'From 2019.3 [latest update: #2019.3] on 18 September 2019 at 1:10:18 am'!!DAVInspector methodsFor: 'as yet unclassified' stamp: 'crl 7/13/2017 10:50'!renameInstanceFile: aDAVResource to: destinationPathString	"Rename an instance. Answer whether I was successful."	| newName rootResource |	rootResource _ self rootResource.	newName _ (destinationPathString reversed readStream upTo: $/) reversed.	(newName allSatisfy: [:character | character isDigit])		ifTrue: [			"Numeric names are reserved by the system."			^false]		ifFalse: [			"We only support renaming the instance, not changing its class."			| destinationPathStream selection |			destinationPathStream _ destinationPathString reversed readStream.			selection _ aDAVResource container.			destinationPathStream upTo: $/.			[selection == rootResource] whileFalse: [				(selection name = ((destinationPathStream upTo: $/) reversed))					ifTrue: [						selection _ selection container yourselfUnlessNil: [selection parent]]					ifFalse: [^false]].			"Change the name of aDAVResource and add it to the resource tree."			aDAVResource name: newName.			aDAVResource container addFile: aDAVResource.			^true]! !!DAVInspector class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!MIDIPort methodsFor: 'as yet unclassified' stamp: 'crl 12/31/2007 11:19'!close	scheduling terminate.	super close! !!MIDIPort methodsFor: 'as yet unclassified' stamp: 'crl 12/30/2007 21:11'!close: theHandle	"Close the port corresponding to theHandle."	<primitive: 'closeMIDIPortWithHandle' module: 'Flow'>	self primitiveFailed! !!MIDIPort methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2008 22:12'!consumingNetworkName: name	consumingNetworkName _ name! !!MIDIPort methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2017 14:50'!currentTime	"Answer the current MIDI time."	^self class currentTime! !!MIDIPort methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2008 00:26'!dataAvailable	^self dataAvailableForMIDIPort: handle! !!MIDIPort methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2008 00:31'!dataAvailableForMIDIPort: midiPortHandle	<primitive: 'midiPortDataAvailable' module: 'Flow'>	self primitiveFailed! !!MIDIPort methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 20:13'!enable: ignored at: anArray	3 halt.	self		outputPortIndex: anArray first		inputPortIndex: (			anArray size = 1				ifTrue: [-1]				ifFalse: [anArray second]).					output := output counterpart.	input := input counterpart! !!MIDIPort methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 01:41'!initialize	"MIDIStream shutDown: false; startUp: false"		newEventPending := Semaphore new.	pendingEvents := OrderedCollection new.	scheduling := (		[			[				newEventPending wait.				pendingEvents do: [:event |					output						send: event statusByte						with: event dataBytes						with: event timestamp].				pendingEvents removeAll			]				repeat		]			forkAt: Processor highIOPriority)! !!MIDIPort methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 00:16'!input	^input! !!MIDIPort methodsFor: 'as yet unclassified' stamp: 'crl 9/6/2008 13:39'!networkName	^consumingNetworkName! !!MIDIPort methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2008 00:12'!networkName: aString	"Set my supplying and consuming network names to aString."	supplyingNetworkName _ consumingNetworkName _ aString! !!MIDIPort methodsFor: 'as yet unclassified' stamp: 'crl 12/30/2007 20:45'!newResourceHandleInto: theHandle	"Write a new resource handle into theHandle."	<primitive: 'newMIDIPortHandleInto' module: 'Flow'>	self primitiveFailed! !!MIDIPort methodsFor: 'as yet unclassified' stamp: 'crl 9/4/2008 16:38'!nextAvailableFrom: midiPortHandle into: aByteArray	<primitive: 'nextAvailableMIDIDataFromInto' module: 'Flow'>	self primitiveFailed! !!MIDIPort methodsFor: 'as yet unclassified' stamp: 'crl 9/4/2008 16:39'!nextAvailableInto: aByteArray	^self nextAvailableFrom: handle into: aByteArray! !!MIDIPort methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 00:16'!output	^output! !!MIDIPort methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 00:34'!outputPortIndex: outputPortIndex inputPortIndex: inputPortIndex	<primitive: 'outputPortIndexInputPortIndex' module: 'Flow'>	self primitiveFailed! !!MIDIPort methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2008 17:46'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: ' connected to "';		nextPutAll: supplyingNetworkName;		nextPut: $".	consumingNetworkName = supplyingNetworkName ifFalse: [		aStream			nextPutAll: ' (input), and "';			nextPutAll: consumingNetworkName;			nextPutAll: '" (output)']! !!MIDIPort methodsFor: 'as yet unclassified' stamp: 'crl 8/20/2017 12:43'!registerScribingSemaphores	"I don't use scribing semaphores."! !!MIDIPort methodsFor: 'as yet unclassified' stamp: 'crl 11/3/2016 22:44'!schedule: aMusicalEvent forNowPlus: numberOfMilliseconds	aMusicalEvent timestamp: self currentTime + numberOfMilliseconds.	pendingEvents add: aMusicalEvent.	newEventPending signal.	^(aMusicalEvent packets)		inject: 0		into: [:subtotal :packet | subtotal + ((packet log: 2) ceiling / 8) ceiling]! !!MIDIPort methodsFor: 'as yet unclassified' stamp: 'crl 9/6/2008 13:12'!schedule: messages inQuantity: size on: theHandle	"Schedule the MIDI data in messages for rendering on the given MIDI port."	<primitive: 'scheduleMIDIMessagesInQuantityOn' module: 'Flow'>	self primitiveFailed! !!MIDIPort methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2008 22:12'!supplyingNetworkName: name	supplyingNetworkName _ name! !!MIDIPort class methodsFor: 'as yet unclassified' stamp: 'crl 9/14/2019 19:27'!allPortNames	^(1 to: self numberOfPorts) collect: [:index | self nameOfPortAt: index - 1]! !!MIDIPort class methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2017 14:50'!currentTime	"Answer the current MIDI time."	<primitive: 'MIDIClockValue' module: 'Flow'>	self primitiveFailed! !!MIDIPort class methodsFor: 'as yet unclassified' stamp: 'crl 9/4/2008 16:33'!nameOfPortAt: portIndex	"Answer the name of the MIDI port at portIndex."	<primitive: 'nameOfMIDIPortAt' module: 'Flow'>	self primitiveFailed! !!MIDIPort class methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 20:05'!named: networkName	"Answer a new instance of myself for communicating with the MIDI network named networkName."	| pattern portIndices |	pattern := '*', networkName.		"Output, then input. MacOS enumerates the inputs first."	portIndices := ((0 to: (self numberOfPorts - 1)) select: [:portIndex | pattern match: (self nameOfPortAt: portIndex)]) reverse.	^(portIndices isEmpty)		ifTrue: [self error: 'There''s no local MIDI network called ', networkName]		ifFalse: [			(self at: portIndices) networkName: (				(self nameOfPortAt: portIndices first)					copyReplaceAll: 'Out '					with: '')]! !!MIDIPort class methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2008 00:01'!numberOfPorts	<primitive: 'numberOfMIDIPorts' module: 'Flow'>	self primitiveFailed! !!Semaphore methodsFor: 'as yet unclassified' stamp: 'crl 5/20/2018 23:24'!storeOnTether: tether
	nil storeOnTether: tether! !!Semaphore methodsFor: 'as yet unclassified' stamp: 'crl 8/20/2017 10:14'!waitTimeoutMSecs: anInteger	"Wait on this semaphore for up to the given number of milliseconds, then timeout. 	Return true if the deadline expired, false otherwise."	^anInteger		ifNil: [			"Wait indefinitely."			self wait.			false]		ifNotNil: [			| d |			d := DelayWaitTimeout new setDelay: (anInteger max: 0) forSemaphore: self.			d wait]! !!HTMLSmalltalkInspector methodsFor: 'as yet unclassified' stamp: 'crl 3/28/2019 18:07'!connect	super connect.	slots := self descendantAt: 'slots'.	value := self descendantAt: 'value'.	self connectToTextArea: slots.	slots onChange: [		(self clearText: value) ifTrue: [			| selectedOption |						selectedOption := slots selectedOptions first value.						value value: (				(					(selectedOption = 'self')						ifTrue: [subject]						ifFalse: [subject instVarNamed: selectedOption]				)					asString)]]! !!HTMLSmalltalkInspector methodsFor: 'as yet unclassified' stamp: 'crl 8/23/2018 14:16'!evaluate: expression	^Compiler evaluate: expression for: subject! !!HTMLSmalltalkInspector methodsFor: 'as yet unclassified' stamp: 'crl 3/28/2019 18:07'!subject: object	subject := object.	((self descendantAt: 'title') children last)		at: #innerHTML		put: '<i><b>', subject asString, '</b></i>'.			slots setOptions: (		(OrderedCollection with: #self)			addAll: object class allInstVarNames;			asArray)! !!CallExpression methodsFor: 'as yet unclassified' stamp: 'crl 5/6/2017 23:58'!printSmalltalkOn: stream	callee printSmalltalkOn: stream withArguments: arguments! !!CallExpression class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!MessageExchange methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2016 01:14'!id	^id! !!MessageExchange methodsFor: 'as yet unclassified' stamp: 'crl 10/4/2016 15:08'!id: uuid	id := uuid! !!MessageExchange methodsFor: 'as yet unclassified' stamp: 'crl 10/4/2016 14:30'!process	^process! !!MessageExchange methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2016 01:14'!terminate	process terminate! !!MessageExchange class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!RaisedBorder class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!ClassDescription methodsFor: 'as yet unclassified' stamp: 'crl 3/17/2019 00:10'!baseID	^baseID! !!ClassDescription methodsFor: 'as yet unclassified' stamp: 'crl 3/17/2019 00:10'!baseID: aUUID	baseID := aUUID! !!ClassDescription methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 23:20'!compile: text classified: category withStamp: changeStamp notifying: requestor logSource: logSource 	| methodAndNode selector |	methodAndNode := self		compile: text asString		notifying: requestor		trailer: (self defaultMethodTrailerIfLogSource: logSource)		ifFail: [ ^ nil ].	selector := methodAndNode selector.	logSource ifTrue:		[ self			logMethodSource: text			forMethodWithNode: methodAndNode			inCategory: category			withStamp: changeStamp			notifying: requestor.		RecentMessages default			recordSelector: selector			forClass: methodAndNode method methodClass			inEnvironment: nil].	self		addAndClassifySelector: selector		withMethod: methodAndNode method		inProtocol: category		notifying: requestor.	self instanceSide		noteCompilationOf: selector		meta: self isClassSide.	^ selector! !!ClassDescription methodsFor: 'as yet unclassified' stamp: 'crl 3/19/2019 05:00'!edition	^EditHistory activeEditionForClassWithBaseID: self baseID! !!ClassDescription methodsFor: 'as yet unclassified' stamp: 'crl 9/18/2019 01:10'!fileOutChangedMessages: aSet on: aFileStream moveSource: moveSource toFile: fileIndex 	"File a description of the messages of this class that have been 	changed (i.e., are entered into the argument, aSet) onto aFileStream.  If 	moveSource, is true, then set the method source pointer to the new file position.	Note when this method is called with moveSource=true, it is condensing the	.changes file, and should only write a preamble for every method."	| org |	(org := self organization) categories do: 		[:cat |  | sels |		sels := (org listAtCategoryNamed: cat) select: [:sel | aSet includes: sel].		(moveSource == #historically		 or: [moveSource and: [(cat beginsWith: '*') and: [cat endsWith: '-override']]])			ifTrue: "when condensing sources/changes, preserve overridden methods"				[sels do:					[:sel |					self printMethodChunkHistorically: sel on: aFileStream						moveSource: moveSource ~~ false toFile: fileIndex]]			ifFalse:				[sels do:					[:sel |						((self compiledMethodAt: sel) == Behavior reloadingMethod)							ifTrue: [								(self == Behavior class)									ifTrue: [										self											printMethodChunk: sel											withPreamble: true											on: aFileStream											moveSource: moveSource											toFile: fileIndex]]							ifFalse: [										self											printMethodChunk: sel											withPreamble: true											on: aFileStream											moveSource: moveSource											toFile: fileIndex]]]]! !!ClassDescription methodsFor: 'as yet unclassified' stamp: 'crl 9/18/2019 00:58'!moveChangesTo: newFile 	"Used in the process of condensing changes, this message requests that 	the source code of all methods of the receiver that have been changed 	should be moved to newFile."	| changes |	changes := self methodDict keys select: [:sel |		(self compiledMethodAt: sel) fileIndex > 1].	self		fileOutChangedMessages: changes		on: newFile		moveSource: true		toFile: 2! !!ClassDescription methodsFor: 'as yet unclassified' stamp: 'crl 3/17/2019 00:04'!organization	"Answer the instance of ClassOrganizer that represents the organization 	of the messages of the receiver."	| org |		org := ClassOrganizer organizerAt: self.		org ifNil: [		self organization: (ClassOrganizer defaultList: self methodDict keys sort) ].	org := ClassOrganizer organizerAt: self.	(org isMemberOf: Array) ifTrue: [		self recoverFromMDFaultWithTrace ].		^org! !!ClassDescription methodsFor: 'as yet unclassified' stamp: 'crl 3/17/2019 00:04'!organization: aClassOrg	"Install an instance of ClassOrganizer that represents the organization of the messages of the receiver."	aClassOrg ifNotNil: [aClassOrg setSubject: self].	ClassOrganizer organizerAt: self put: aClassOrg! !!ClassDescription methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 17:33'!remember	"Assume that there's no need to check whether my superclass is remembered, or to react to my superclass not being remembered, because the object memory is released with every class remembered."	EditHistory rememberActiveClass: self! !!ClassDescription methodsFor: 'as yet unclassified' stamp: 'crl 3/17/2019 00:10'!superclass: aClass methodDictionary: mDict format: fmt	"Basic initialization of the receiver"	super superclass: aClass methodDictionary: mDict format: fmt.	instanceVariables := nil.	self organization: nil.	baseID := UUID new! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'crl 9/18/2019 00:59'!printMethodChunkHistorically: selector on: outStream moveSource: moveSource toFile: fileIndex	"Copy all source codes historically for the method associated with selector onto the 	 fileStream.  If moveSource is true, then also set the source code pointer of the method.	 N.B. fileIndex is interpreted as follows, 0 => just a fileOut; 1 => condensing sources;	 2 => condensing changes; therefore only changes on the chnages file before the last	 version in the sources file are recorded."	| preamble method newPos category changeList priorPos index |	category := self organization categoryOfElement: selector.	preamble := self name , ' methodsFor: ', category asString printString.	method := self methodDict at: selector.	method == Behavior reloadingMethod ifTrue: [		(self == Behavior class and: [selector == #swapInThisMethod]) ifFalse: [3 halt. ^outStream]].	(method filePosition = 0	 or: [method fileIndex = 0	 or: [(SourceFiles at: method fileIndex) isNil]])		ifTrue: "no source; must decompile"			[outStream cr; nextPut: $!!; nextChunkPut: preamble; cr.			outStream nextChunkPut: method decompileString.			outStream nextChunkPut: ' '; cr]		ifFalse:			[changeList := ChangeSet directAncestryOfVersions: (ChangeSet																	scanVersionsOf: method 																	class: self 																	meta: self isMeta																	category: category 																	selector: selector).			newPos := priorPos := nil.			(fileIndex = 2 "condensing changes; select changes file code and find last sources file change"			 and: [(index := changeList findFirst: [:chgRec| chgRec fileIndex = 1]) > 0]) ifTrue:				[priorPos := SourceFiles 								sourcePointerFromFileIndex: 1								andPosition: (changeList at: index) position.				 changeList := changeList copyFrom: 1 to: index - 1].			changeList reverseDo:				[:chgRec|				chgRec file closed ifTrue:					[chgRec file reopen; setToEnd].				outStream copyPreamble: preamble from: chgRec file at: chgRec position.				priorPos ifNotNil:					[outStream						position: outStream position - 2;						nextPutAll: ' prior: '; print: priorPos; nextPut: $!!; cr].				"Copy the method chunk"				newPos := outStream position.				outStream copyMethodChunkFrom: chgRec file at: chgRec position.				chgRec file skipSeparators.      "The following chunk may have ]style["				chgRec file peek == $] ifTrue:					[outStream cr; copyMethodChunkFrom: chgRec file].				outStream nextChunkPut: ' '; cr.				chgRec position: newPos.				priorPos := SourceFiles 								sourcePointerFromFileIndex: fileIndex								andPosition: newPos].			moveSource ifTrue:				[method setSourcePosition: newPos inFile: fileIndex]].	^outStream! !!MessageNode methodsFor: 'as yet unclassified' stamp: 'crl 4/29/2017 19:35'!javaScriptMacroPrinter	special > 0 ifTrue: [^JavaScriptMacroPrinters at: special].	^nil! !!MessageNode methodsFor: 'as yet unclassified' stamp: 'crl 9/1/2018 03:38'!printJavaScriptCaseOn: aStream indent: level 	"receiver caseOf: {[key]->[value]. ...} otherwise: [otherwise]"	| braceNode otherwise extra |	braceNode := arguments first.	otherwise := arguments last.	(arguments size = 1 or: [otherwise isJustCaseError]) ifTrue:		[otherwise := nil].	aStream nextPutAll: 'switch ('.	receiver		printJavaScriptOn: aStream		indent: level		precedence: 3.	aStream nextPutAll: ') {'.	braceNode isVariableReference		ifTrue: [braceNode printJavaScriptOn: aStream indent: level]		ifFalse: 			[aStream crtab: level + 1.			 braceNode casesForwardDo:				[:keyNode :valueNode :last | 				aStream nextPutAll: 'case '.				keyNode printJavaScriptOn: aStream indent: level + 1.				aStream nextPutAll: ': '.				valueNode isComplex					ifTrue: 						[aStream crtab: level + 2.						extra := 1]					ifFalse: [extra := 0].				valueNode printJavaScriptOn: aStream indent: level + 1 + extra.				last ifFalse: [aStream nextPutAll: 'break.';							 crtab: level + 1]]].	otherwise notNil ifTrue:		[aStream crtab: level + 1; nextPutAll: ' default: '.		 extra := otherwise isComplex					ifTrue: 						[aStream crtab: level + 2.						 1]					ifFalse: [0].		 otherwise printJavaScriptOn: aStream indent: level + 1 + extra]! !!MessageNode methodsFor: 'as yet unclassified' stamp: 'crl 9/1/2018 03:42'!printJavaScriptIfNil: aStream indent: level	self printJavaScriptReceiver: receiver on: aStream indent: level.	^self printJavaScriptKeywords: selector key		arguments: (Array with: arguments first)		on: aStream indent: level! !!MessageNode methodsFor: 'as yet unclassified' stamp: 'crl 9/1/2018 03:39'!printJavaScriptIfNilNotNil: aStream indent: level	self printJavaScriptReceiver: receiver ifNilReceiver on: aStream indent: level.	(arguments first isJust: NodeNil) ifTrue:		[^ self printJavaScriptKeywords: #ifNotNil:				arguments: { arguments second }				on: aStream indent: level].	(arguments second isJust: NodeNil) ifTrue:		[^ self printJavaScriptKeywords: #ifNil:				arguments: { arguments first }				on: aStream indent: level].	^ self printJavaScriptKeywords: #ifNil:ifNotNil:			arguments: arguments			on: aStream indent: level! !!MessageNode methodsFor: 'as yet unclassified' stamp: 'crl 9/1/2018 10:24'!printJavaScriptIfOn: aStream indent: level	receiver ifNil: [3 halt].	(arguments last isJust: NodeNil) ifTrue:		[3 halt. ^self printJavaScriptKeywords: #ifTrue: arguments: (Array with: arguments first)					on: aStream indent: level].	(arguments last isJust: NodeFalse) ifTrue:		[3 halt. ^self printJavaScriptKeywords: #and: arguments: (Array with: arguments first)					on: aStream indent: level].	(arguments first isJust: NodeNil) ifTrue:		[aStream nextPutAll: 'if (!!('.		receiver printJavaScriptOn: aStream indent: level + 1 precedence: precedence.		aStream nextPutAll: ')) {('.		arguments last printJavaScriptOn: aStream indent: level.		aStream nextPutAll: ')()}'.		^self].	(arguments first isJust: NodeTrue) ifTrue:		[3 halt. ^self printJavaScriptKeywords: #or: arguments: (Array with: arguments last)					on: aStream indent: level].					aStream nextPutAll: 'if ('.		receiver printJavaScriptOn: aStream indent: level + 1 precedence: precedence.		aStream nextPutAll: ') {'.		arguments nextToLast printJavaScriptOn: aStream indent: level.		aStream nextPutAll: '} else {'.		arguments last printJavaScriptOn: aStream indent: level.		aStream nextPut: $}! !!MessageNode methodsFor: 'as yet unclassified' stamp: 'crl 9/1/2018 04:10'!printJavaScriptKeywords: key arguments: arguments on: stream indent: level	(arguments isEmpty)		ifTrue: [			key isInfix ifTrue: [3 halt].						stream				nextPutAll: key;				nextPutAll: '()']		ifFalse: [			| doCrTab |			key isInfix ifFalse: [stream nextPut: $.].			(key = #at:put:)				ifTrue: [					(arguments first class == LiteralNode)						ifTrue: [							stream								nextPutAll: arguments first key;								nextPutAll: ' = '.															arguments second printJavaScriptOn: stream indent: level]						ifFalse: [self noJavaScriptSupport]]				ifFalse: [						stream nextPutAll: (key keywords first readStream upTo: $:).					key isInfix ifFalse: [stream nextPut: $(].					doCrTab := (						(arguments size > 2) or: [							({receiver}, arguments) anySatisfy: [:argument |								argument notNil and: [									argument isBlockNode or: [										argument isMessageNode and: [argument precedence >= 3]]]]]).					arguments						do: [:argument |							| indent |														doCrTab								ifTrue: [									"newline after big arguments"									stream crtab: level + 1.									indent := 1]								ifFalse: [indent := 0].														key isInfix ifTrue: [stream space].														argument								printJavaScriptOn: stream								indent: level + 1 + indent								precedence: (									(precedence = 2)										ifTrue: [1]										ifFalse: [precedence])]						separatedBy: [stream nextPutAll: ', '].											key isInfix ifFalse: [stream nextPut: $)]]]! !!MessageNode methodsFor: 'as yet unclassified' stamp: 'crl 9/1/2018 03:11'!printJavaScriptOn: stream indent: level	"may not need this check anymore - may be fixed by the #receiver: change"	special ifNil: [^self noJavaScriptSupport].	(special > 0)		ifTrue: [			self				perform: self javaScriptMacroPrinter				with: stream				with: level]		ifFalse: [			self printJavaScriptReceiver: receiver on: stream indent: level.			selector isForFFICall				ifTrue: [self noJavaScriptSupport]				ifFalse: [					(selector key isInfix)						ifTrue: [stream space]						ifFalse: [stream nextPut: $..].											self						printJavaScriptKeywords: selector key						arguments: arguments						on: stream						indent: level]]! !!MessageNode methodsFor: 'as yet unclassified' stamp: 'crl 4/30/2017 18:33'!printJavaScriptOn: strm indent: level precedence: outerPrecedence	| parenthesize |	parenthesize := precedence > outerPrecedence		or: [outerPrecedence = 3 and: [precedence = 3 "both keywords"]].	parenthesize		ifTrue: [strm nextPutAll: '('.				self printJavaScriptOn: strm indent: level.				strm nextPutAll: ')']		ifFalse: [self printJavaScriptOn: strm indent: level]! !!MessageNode methodsFor: 'as yet unclassified' stamp: 'crl 4/30/2017 21:10'!printJavaScriptReceiver: rcvr on: aStream indent: level						rcvr ifNil: [^ self].	"Force parens around keyword receiver of kwd message"	rcvr printJavaScriptOn: aStream indent: level precedence: precedence! !!MessageNode methodsFor: 'as yet unclassified' stamp: 'crl 9/1/2018 03:40'!printJavaScriptRepeatOn: aStream indent: level	self printJavaScriptReceiver: receiver on: aStream indent: level.	^self printJavaScriptKeywords: selector key		arguments: (Array new)		on: aStream indent: level! !!MessageNode methodsFor: 'as yet unclassified' stamp: 'crl 9/1/2018 03:42'!printJavaScriptToDoOn: aStream indent: level	| limitNode |	self printJavaScriptReceiver: receiver on: aStream indent: level.	(arguments last == nil or: [(arguments last isMemberOf: AssignmentNode) not])		ifTrue: [limitNode := arguments first]		ifFalse: [limitNode := arguments last value].	(selector key = #to:by:do:	 and: [(arguments at: 2) isConstantNumber	 and: [(arguments at: 2) key = 1]])		ifTrue: [self printJavaScriptKeywords: #to:do:					arguments: (Array with: limitNode with: (arguments at: 3))					on: aStream indent: level]		ifFalse: [self printJavaScriptKeywords: selector key					arguments: (Array with: limitNode) , arguments allButFirst					on: aStream indent: level]! !!MessageNode methodsFor: 'as yet unclassified' stamp: 'crl 9/1/2018 03:41'!printJavaScriptWhileOn: aStream indent: level	self printJavaScriptReceiver: receiver on: aStream indent: level.	self		printJavaScriptKeywords: originalSelector		arguments: originalArguments		on: aStream indent: level! !!MessageNode class methodsFor: 'as yet unclassified' stamp: 'crl 4/29/2017 19:35'!initialize	"MessageNode initialize"	MacroSelectors := 		#(	ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:			and: or:			whileFalse: whileTrue: whileFalse whileTrue			to:do: to:by:do:			caseOf: caseOf:otherwise:			ifNil: ifNotNil:  ifNil:ifNotNil: ifNotNil:ifNil:			repeat ).	MacroTransformers := 		#(	transformIfTrue: transformIfFalse: transformIfTrueIfFalse: transformIfFalseIfTrue:			transformAnd: transformOr:			transformWhile: transformWhile: transformWhile: transformWhile:			transformToDo: transformToDo:			transformCase: transformCase:			transformIfNil: transformIfNil:  transformIfNilIfNotNil: transformIfNotNilIfNil:			transformRepeat: ).	MacroEmitters := 		#(	emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:			emitCodeForWhile:encoder:value: emitCodeForWhile:encoder:value:			emitCodeForWhile:encoder:value: emitCodeForWhile:encoder:value:			emitCodeForToDo:encoder:value: emitCodeForToDo:encoder:value:			emitCodeForCase:encoder:value: emitCodeForCase:encoder:value:			emitCodeForIfNil:encoder:value: emitCodeForIfNil:encoder:value:			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:			emitCodeForRepeat:encoder:value:).	MacroSizers := 		#(	sizeCodeForIf:value: sizeCodeForIf:value: sizeCodeForIf:value: sizeCodeForIf:value:			sizeCodeForIf:value: sizeCodeForIf:value:			sizeCodeForWhile:value: sizeCodeForWhile:value: sizeCodeForWhile:value: sizeCodeForWhile:value:			sizeCodeForToDo:value: sizeCodeForToDo:value:			sizeCodeForCase:value: sizeCodeForCase:value:			sizeCodeForIfNil:value: sizeCodeForIfNil:value: sizeCodeForIf:value: sizeCodeForIf:value:			sizeCodeForRepeat:value:).	MacroPrinters := 		#(	printIfOn:indent: printIfOn:indent: printIfOn:indent: printIfOn:indent:			printIfOn:indent: printIfOn:indent:			printWhileOn:indent: printWhileOn:indent: printWhileOn:indent: printWhileOn:indent:			printToDoOn:indent: printToDoOn:indent:			printCaseOn:indent: printCaseOn:indent:			printIfNil:indent: printIfNil:indent: printIfNilNotNil:indent: printIfNilNotNil:indent:			printRepeatOn:indent:).	JavaScriptMacroPrinters := 		#(	printJavaScriptIfOn:indent: printJavaScriptIfOn:indent: printJavaScriptIfOn:indent: printJavaScriptIfOn:indent:			printJavaScriptIfOn:indent: printJavaScriptIfOn:indent:			printJavaScriptWhileOn:indent: printJavaScriptWhileOn:indent: printJavaScriptWhileOn:indent: printJavaScriptWhileOn:indent:			printJavaScriptToDoOn:indent: printJavaScriptToDoOn:indent:			printJavaScriptCaseOn:indent: printJavaScriptCaseOn:indent:			printJavaScriptIfNil:indent: printJavaScriptIfNil:indent: printJavaScriptIfNilNotNil:indent: printJavaScriptIfNilNotNil:indent:			printJavaScriptRepeatOn:indent:)! !!NewArrayNode class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!CustomElementRegistry methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!CustomElementRegistry class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!WeakKeyDictionary class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!JSPushButtonMorph methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSPushButtonMorph class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!DSCPostscriptCanvas class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:55'!foo! !!InsetBorder class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!SpecialLiteralNode class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!ActionSequence class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!MorphicEventDispatcher class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!BalloonEdgeData class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!JSMp methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSMp class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!PluggableCompositeSpec class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!ZipEncoder class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!WritableStream methodsFor: 'as yet unclassified' stamp: 'crl 1/21/2003 10:59'!, anObject	"Write anObject to myself; answer myself."	self nextPut: anObject! !!WritableStream methodsFor: 'as yet unclassified' stamp: 'crl 1/20/2011 02:58'!braceArray	"This method is used in compilation of brace constructs.	It MUST NOT be deleted or altered."	^ collection! !!WritableStream methodsFor: 'as yet unclassified' stamp: 'crl 1/20/2011 02:58'!braceArray: anArray	"This method is used in compilation of brace constructs.	It MUST NOT be deleted or altered."	collection _ anArray.	position _ 0.	readLimit _ 0.	writeLimit _ anArray size.! !!WritableStream methodsFor: 'as yet unclassified'!contents	"Answer all of my readable elements."	"Recompute my size to account for recently-written elements."	self size.	^super contents! !!WritableStream methodsFor: 'as yet unclassified'!copyFrom: aStream	"Copy the remaining elements from aStream."	[aStream atEnd] whileFalse: [self nextPut: aStream next]! !!WritableStream methodsFor: 'as yet unclassified' stamp: 'crl 7/30/2002 16:33'!cr	"Write a carriage-return."	self nextPut: Character cr! !!WritableStream methodsFor: 'as yet unclassified' stamp: 'crl 4/18/2004 18:53'!cr: anInteger	"Write anInteger carriage-returns."	anInteger timesRepeat: [self cr]! !!WritableStream methodsFor: 'as yet unclassified' stamp: 'crl 8/3/2002 01:52'!crlf	"Write a 'carriage-return' and a 'linefeed'."	"NOTE:  The system line-end convention is CR, so you should only need to use crlf when transfering ascii code out of the system to a platform that uses crlf as its line end convention."	self		cr;		nextPut: Character lf! !!WritableStream methodsFor: 'as yet unclassified'!crtab	"Write a carriage-return and a tab."	self cr; tab! !!WritableStream methodsFor: 'as yet unclassified'!crtab: anInteger	"Write a carriage-return and anInteger tabs."	self cr.	anInteger timesRepeat: [self tab]! !!WritableStream methodsFor: 'as yet unclassified' stamp: 'crl 6/26/2001 16:45'!dialect	"Used for printing parse nodes."	^#ST80! !!WritableStream methodsFor: 'as yet unclassified'!emphasis: ignored	"For compatibility with streams which carry emphasis."! !!WritableStream methodsFor: 'as yet unclassified' stamp: 'il prior: 34831690!!!!!!!!!!!!!!!!'!emptyCollection: aCollection 	super emptyCollection: aCollection.	writeLimit _ collection size! !!WritableStream methodsFor: 'as yet unclassified'!fileOutChanges	"Append to the receiver a description of all class changes."	Cursor write showWhile:		[self timeStamp.		Smalltalk changes fileOutOn: self.		self shorten; close]! !!WritableStream methodsFor: 'as yet unclassified'!flush	self needsWork! !!WritableStream methodsFor: 'as yet unclassified' stamp: 'crl 5/24/2001 23:20'!increaseAvailableWritingCapacity	"Increase my available writing capacity."	"Fix the collection-growth framework and use it here."	self needsWork.	collection _ collection, (collection class new: self writingCapacityIncreaseAmount).	writeLimit _ collection size! !!WritableStream methodsFor: 'as yet unclassified'!isEmpty	"Answer whether I have no elements available to read."	self size.	^super isEmpty! !!WritableStream methodsFor: 'as yet unclassified' stamp: 'crl 9/23/2012 13:37'!lf	"Write a linefeed."	self nextPut: Character lf! !!WritableStream methodsFor: 'as yet unclassified'!nextChunkPut: aString	"Append the argument, aString, to the receiver, doubling embedded terminators."	| i remainder terminator |	terminator _ $!!.	remainder _ aString.	[(i _ remainder indexOf: terminator) = 0] whileFalse:		[self nextPutAll: (remainder copyFrom: 1 to: i).		self nextPut: terminator.  "double imbedded terminators"		remainder _ remainder copyFrom: i+1 to: remainder size].	self nextPutAll: remainder; nextPut: terminator! !!WritableStream methodsFor: 'as yet unclassified' stamp: 'crl 6/25/2001 20:25'!nextPastEndPut: anObject	"Refresh my collection and write anObject."	^self		increaseAvailableWritingCapacity;		nextPut: anObject! !!WritableStream methodsFor: 'as yet unclassified' stamp: 'crl 6/25/2001 20:40'!nextPut: anObject	"Put anObject at the next position and answer it."	"The implementation of this message is optimized by default (via a primitive), for the common case in which no special processing of anObject need occur. Subclasses may choose to do otherwise. Primitive failure occurs if my collection is not an Array or String, if I'm positioned at the end, if my position is somehow out of the bounds of my collection, or if anObject is not of a format compatible with that of my collection."	<primitive: 66>	^position = writeLimit		ifTrue: [			"Attempt to increase my available writing capacity and retry."			self nextPastEndPut: anObject]		ifFalse: [			position _ position + 1.			collection at: position put: anObject]! !!WritableStream methodsFor: 'as yet unclassified' stamp: 'crl 6/8/2001 00:37'!nextPutAll: aSequenceableCollection	"Put each of the elements of aSequenceableCollection from the next position. Answer aSequenceableCollection."	"There is no optimization by default, since subclasses may perform special processing on an element-by-element basis (in >>nextPut:). Likewise, subclasses may choose to optimize here."	aSequenceableCollection do: [:element | self nextPut: element].	^aSequenceableCollection! !!WritableStream methodsFor: 'as yet unclassified'!nextPutAllText: aText	"For compatibility with TextStream."	^self nextPutAll: aText! !!WritableStream methodsFor: 'as yet unclassified' stamp: 'crl 4/24/2001 12:58'!nextPutFrom: aSequenceableCollection startingAt: startIndex	"Put each of the elements in aSequenceableCollection, starting at startIndex, from my next position. Answer aSequenceableCollection (alternate proposals entertained, but note that this message was motivated by a desire to minimize copying)."	^self		nextPutFrom: aSequenceableCollection		startingAt: startIndex		endingAt: aSequenceableCollection size! !!WritableStream methodsFor: 'as yet unclassified' stamp: 'crl 4/24/2001 12:56'!nextPutFrom: aSequenceableCollection startingAt: startIndex endingAt: endIndex	"Put each of the elements in aSequenceableCollection, starting at startIndex and ending at endIndex, from my next position. Answer aSequenceableCollection (alternate proposals entertained, but note that this message was motivated by a desire to minimize copying)."	"There is no optimization by default, since subclasses may perform special processing on an element-by-element basis (in >>nextPut:). Likewise, subclasses may choose to optimize here."	| sourceIndex |	sourceIndex _ startIndex.	[sourceIndex <= endIndex] whileTrue: [		self nextPut: (aSequenceableCollection at: sourceIndex).		sourceIndex _ sourceIndex + 1].	^aSequenceableCollection! !!WritableStream methodsFor: 'as yet unclassified'!position: anInteger	"Set my position to anInteger."	"Update my readLimit first."	self size.	super position: anInteger! !!WritableStream methodsFor: 'as yet unclassified' stamp: 'crl 1/5/2005 18:44'!previousTake	"Take back and answer the last written element."	^(self previousTake: 1) at: 1! !!WritableStream methodsFor: 'as yet unclassified'!previousTake: anInteger	"Take back the last anInteger written elements, and answer them (in the order in which they were written)."	"Note this implementation is only correct for internal, positionable streams."	| elements |	readLimit _ position.	position _ position - anInteger.	elements _ collection copyFrom: position + 1 to: readLimit.	readLimit _ position.	^elements! !!WritableStream methodsFor: 'as yet unclassified'!print: anObject	"Print anObject on myself."	anObject printOn: self! !!WritableStream methodsFor: 'as yet unclassified'!printVerbosely: anObject	"Verbosely print anObject on myself."	anObject printVerboselyOn: self! !!WritableStream methodsFor: 'as yet unclassified'!reset	"Reset my position to the beginning."	self resetAndBeEmpty! !!WritableStream methodsFor: 'as yet unclassified'!resetAndBeEmpty	"Reset, and have no readable elements."	position _ readLimit _ 0! !!WritableStream methodsFor: 'as yet unclassified'!resetAndRetainContents	"Reset my position to the beginning, and retain my contents (normally resetting a writable stream causes it to be empty)."	self size.	position _ 0! !!WritableStream methodsFor: 'as yet unclassified'!retract	"Retract the last-written element."	self retract: 1! !!WritableStream methodsFor: 'as yet unclassified'!retract: anInteger	"Retract anInteger elements."	self		skip: anInteger negated;		size.	readLimit _ readLimit - anInteger! !!WritableStream methodsFor: 'as yet unclassified'!setFrom: newStart to: newStop	"Set my readLimit to newStop and position myself just before newStart."	"This is a backward-compatability method used by ParagraphEditor. It should be removed."	position _ newStart - 1.	readLimit _ newStop! !!WritableStream methodsFor: 'as yet unclassified' stamp: 'crl 10/14/2003 04:57'!setInitialReadLimit	"Set my initial readLimit."	"By default, my collection is empty, or rather, unwritten."	readLimit _ 0! !!WritableStream methodsFor: 'as yet unclassified'!setToEnd	"Position myself after the last readable element."	self size.	^super setToEnd! !!WritableStream methodsFor: 'as yet unclassified'!shrink	"Use a new collection with no unused slots."	self collection: (collection copyTo: position)! !!WritableStream methodsFor: 'as yet unclassified'!size	"Answer the number of readable elements I have."	"Update my readLimit first to account for recently-written elements."	^readLimit _ readLimit max: position! !!WritableStream methodsFor: 'as yet unclassified' stamp: 'crl 7/30/2002 16:35'!space	"Write a space."	self nextPut: Character space! !!WritableStream methodsFor: 'as yet unclassified' stamp: 'crl 11/23/2004 16:17'!space: anInteger	"Write anInteger spaces."	anInteger timesRepeat: [self space]! !!WritableStream methodsFor: 'as yet unclassified'!store: anObject	"Store anObject on myself in such a way that an equivalent object may be read later."	anObject storeOn: self! !!WritableStream methodsFor: 'as yet unclassified' stamp: 'crl 7/30/2002 16:33'!tab	"Write a tab."	self nextPut: Character tab! !!WritableStream methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2004 23:29'!tab: numberOfTabs	numberOfTabs timesRepeat: [self tab]! !!WritableStream methodsFor: 'as yet unclassified' stamp: 'crl 12/6/2000 15:48'!timeStamp	"Append the current time to the receiver."	| aStream |	aStream _ (String new: 16) emptyWritableStream.	Smalltalk timeStamp: aStream.	self nextChunkPut: aStream contents printString.	"double quotes and !!s"	self cr; cr! !!WritableStream methodsFor: 'as yet unclassified'!withAttribute: att do: strmBlock	^strmBlock value! !!WritableStream methodsFor: 'as yet unclassified'!writableStream	"Used by various random abusers. This should be removed."	^self! !!WritableStream methodsFor: 'as yet unclassified' stamp: 'crl 6/11/2001 16:49'!writingCapacityIncreaseAmount	"Answer the amount by which I should increase my writing capacity."	^(collection size min: 100000) max: 8! !!WritableStream methodsFor: 'as yet unclassified' stamp: 'crl 12/2/2000 21:44'!writingPosition	"Answer my writing position."	^self position! !!WritableStream class methodsFor: 'as yet unclassified' stamp: 'crl 10/14/2003 05:02'!atTheEndOn: aCollection	"Answer an instance of myself on aCollection, positioned to write at the end."	^self		on: aCollection		to: aCollection size		setPositionBefore: aCollection size + 1! !!WritableStream class methodsFor: 'as yet unclassified'!on: aCollection	"Answer a new instance of myself on aCollection."	^self emptyOn: aCollection! !!WritableStream class methodsFor: 'as yet unclassified'!onLongString	"Answer a new instance of myself on a long String."	^self on: (String new: 64)! !!WritableStream class methodsFor: 'as yet unclassified'!onMediumString	"Answer a new instance of myself on a medium String."	^self on: (String new: 32)! !!WritableStream class methodsFor: 'as yet unclassified'!onShortString	"Answer a new instance of myself on a short String."	^self on: (String new: 16)! !!WritableStream class methodsFor: 'as yet unclassified'!with: aCollection	"Answer an instance of myself on aCollection, positioned to write at the end."	"This method is marked 'backward compatability' because its selector doesn't make clear the fact that writing will initially take place at the end."	^self atTheEndOn: aCollection! !!ThreeJS methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!ThreeJS class methodsFor: 'as yet unclassified' stamp: 'crl 6/18/2017 20:14'!BoxGeometry	^globalObject proxy at: #BoxGeometry! !!ThreeJS class methodsFor: 'as yet unclassified' stamp: 'crl 6/18/2017 20:14'!Mesh	^globalObject proxy at: #Mesh! !!ThreeJS class methodsFor: 'as yet unclassified' stamp: 'crl 6/18/2017 20:14'!MeshBasicMaterial	^globalObject proxy at: #MeshBasicMaterial! !!ThreeJS class methodsFor: 'as yet unclassified' stamp: 'crl 6/8/2017 21:38'!camera	^camera! !!ThreeJS class methodsFor: 'as yet unclassified' stamp: 'crl 4/2/2019 12:06'!initialize	self load.	canvas ifNotNil: [		[canvas window remove] on: Error do: [:exception | ].		canvas := renderer := camera := scene := nil].	renderer := self newRenderer.	renderer setSize: 1000 with: 400.	canvas := renderer domElement counterpart.	(canvas style)		at: #border put: '2px inset black';		at: #borderRadius put: '10px'.	Webpage current createWorldOfKind: 'ThreeJS' withCanvas: canvas.	(Webpage current)		windowizeElement: canvas window		closingWith: [self stopRendering].	(canvas window)		beVisible;		beOpaque;		dragWith: canvas window tray.			scene := self newScene.	camera := self newCamera.		(JS top)		at: #renderer		put: renderer;		at: #scene		put: scene;		at: #camera		put: camera;		at: #render		put: (			(JS top at: #Function) new: '				requestAnimationFrame(render);				renderer.render(scene, camera);').						(JS top at: #render) call! !!ThreeJS class methodsFor: 'as yet unclassified' stamp: 'crl 6/22/2017 23:30'!isRendering	^(JS top at: #render) notNil! !!ThreeJS class methodsFor: 'as yet unclassified' stamp: 'crl 6/23/2017 00:14'!load	Webpage current loadScriptFrom: 'https://threejs.org/build/three.js'.	(Delay forMilliseconds: 800) wait.	globalObject := (JS top at: #THREE) counterpart! !!ThreeJS class methodsFor: 'as yet unclassified' stamp: 'crl 6/18/2017 20:00'!newCamera	^(		(globalObject proxy at: #PerspectiveCamera) newWithParameters: {			75.			1000 / 400.			0.1.			1000}	)		counterpart ! !!ThreeJS class methodsFor: 'as yet unclassified' stamp: 'crl 6/18/2017 19:58'!newRenderer	^(globalObject proxy at: #WebGLRenderer) new counterpart ! !!ThreeJS class methodsFor: 'as yet unclassified' stamp: 'crl 6/18/2017 19:58'!newScene	^(globalObject proxy at: #Scene) new counterpart ! !!ThreeJS class methodsFor: 'as yet unclassified' stamp: 'crl 6/8/2017 21:37'!scene	^scene! !!ThreeJS class methodsFor: 'as yet unclassified' stamp: 'crl 6/19/2017 10:44'!stopRendering	JS top at: #render put: nil! !!CSSStyleDeclaration methodsFor: 'as yet unclassified' stamp: 'crl 6/17/2017 13:52'!bottom	^self integerInPixelString: proxy bottom asString! !!CSSStyleDeclaration methodsFor: 'as yet unclassified' stamp: 'crl 8/18/2017 14:31'!integerInPixelString: string	^(string isEmpty)		ifTrue: [0]		ifFalse: [(string copyWithoutAll: 'px') asNumber]! !!CSSStyleDeclaration methodsFor: 'as yet unclassified' stamp: 'crl 6/17/2017 13:52'!left	^self integerInPixelString: proxy left asString! !!CSSStyleDeclaration methodsFor: 'as yet unclassified' stamp: 'crl 6/17/2017 13:52'!right	^self integerInPixelString: proxy right asString! !!CSSStyleDeclaration methodsFor: 'as yet unclassified' stamp: 'crl 6/17/2017 13:51'!top	^self integerInPixelString: proxy top asString! !!CSSStyleDeclaration class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!KedamaFloatArray class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!LinkedList class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!QueueSound class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!Euler methodsFor: 'as yet unclassified' stamp: 'crl 6/19/2017 10:31'!x	^self at: #x! !!Euler methodsFor: 'as yet unclassified' stamp: 'crl 6/19/2017 10:30'!x: number	self at: #x put: number! !!Euler methodsFor: 'as yet unclassified' stamp: 'crl 6/19/2017 10:31'!y	^self at: #y! !!Euler methodsFor: 'as yet unclassified' stamp: 'crl 6/19/2017 10:30'!y: number	self at: #y put: number! !!Euler class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!SegmentScanner class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!PluggableTreeSpec class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!Number methodsFor: 'as yet unclassified'!* aNumber 	"Answer the result of multiplying the receiver by aNumber."	self subclassResponsibility! !!Number methodsFor: 'as yet unclassified'!+ aNumber 	"Answer the sum of the receiver and aNumber."	self subclassResponsibility! !!Number methodsFor: 'as yet unclassified'!- aNumber 	"Answer the difference between the receiver and aNumber."	self subclassResponsibility! !!Number methodsFor: 'as yet unclassified'!/ aNumber 	"Answer the result of dividing the receiver by aNumber."	self subclassResponsibility! !!Number methodsFor: 'as yet unclassified'!// aNumber 	"Integer quotient defined by division with truncation toward negative 	infinity. 9//4 = 2, -9//4 = -3. -0.9//0.4 = -3. \\ answers the remainder 	from this division."	^(self / aNumber) floor! !!Number methodsFor: 'as yet unclassified'!@ y 	"Primitive. Answer a Point whose x value is the receiver and whose y 	value is the argument. Optional. No Lookup. See Object documentation 	whatIsAPrimitive."	<primitive: 18>	^Point x: self y: y! !!Number methodsFor: 'as yet unclassified'!\\ aNumber 	"modulo. Remainder defined in terms of //. Answer a Number with the 	same sign as aNumber. e.g. 9\\4 = 1, -9\\4 = 3, 9\\-4 = -3, 0.9\\0.4 = 0.1."	^self - (self // aNumber * aNumber)! !!Number methodsFor: 'as yet unclassified'!abs	"Answer a Number that is the absolute value (positive magnitude) of the 	receiver."	self < 0		ifTrue: [^self negated]		ifFalse: [^self]! !!Number methodsFor: 'as yet unclassified' stamp: 'di 11/6/1998 13:43'!adaptToCollection: rcvr andSend: selector	"If I am involved in arithmetic with a Collection, return a Collection of	the results of each element combined with me in that expression."	^ rcvr collect: [:element | element perform: selector with: self]! !!Number methodsFor: 'as yet unclassified' stamp: 'nice 10/13/2011 23:55'!adaptToComplex: rcvr andSend: selector	"If I am involved in arithmetic with a Complex number, convert me to a Complex number."	^ rcvr perform: selector with: self asComplex! !!Number methodsFor: 'as yet unclassified' stamp: 'nice 5/21/2014 01:50'!adaptToFloat: rcvr andCompare: selector 	"If I am involved in comparison with a Float, convert rcvr to a	Fraction. This way, no bit is lost and comparison is exact."		rcvr isFinite		ifFalse: [			selector == #= ifTrue: [^false].			selector == #~= ifTrue: [^true].			rcvr isNaN ifTrue: [^ false].			(selector = #< or: [selector = #'<='])				ifTrue: [^ rcvr positive not].			(selector = #> or: [selector = #'>='])				ifTrue: [^ rcvr positive].			^self error: 'unknow comparison selector'].	"Try to avoid asTrueFraction because it can cost"	self isAnExactFloat ifTrue: [^rcvr perform: selector with: self asExactFloat].	selector == #= ifTrue: [^false].	selector == #~= ifTrue: [^true].	^ rcvr asTrueFraction perform: selector with: self! !!Number methodsFor: 'as yet unclassified' stamp: 'di 11/6/1998 13:21'!adaptToFloat: rcvr andSend: selector 	"If I am involved in arithmetic with a Float, convert me to a Float."	^ rcvr perform: selector with: self asFloat! !!Number methodsFor: 'as yet unclassified' stamp: 'di 11/6/1998 13:44'!adaptToFraction: rcvr andSend: selector	"If I am involved in arithmetic with a Fraction, convert us and evaluate exprBlock."	^ self subclassResponsibility! !!Number methodsFor: 'as yet unclassified' stamp: 'di 11/6/1998 13:44'!adaptToInteger: rcvr andSend: selector	"If I am involved in arithmetic with a Integer, convert us and evaluate exprBlock."	^ self subclassResponsibility! !!Number methodsFor: 'as yet unclassified' stamp: 'di 11/6/1998 13:44'!adaptToPoint: rcvr andSend: selector	"If I am involved in arithmetic with a Point, convert me to a Point."	^ rcvr perform: selector with: self@self! !!Number methodsFor: 'as yet unclassified' stamp: 'RAH 4/25/2000 19:49'!adaptToScaledDecimal: receiverScaledDecimal andSend: arithmeticOpSelector 	"Do any required conversion and then the arithmetic. 	receiverScaledDecimal arithmeticOpSelector self."	#Numeric.	"add 200/01/19 For ScaledDecimal support."	^ self subclassResponsibility! !!Number methodsFor: 'as yet unclassified' stamp: 'di 11/6/1998 13:45'!adaptToString: rcvr andSend: selector	"If I am involved in arithmetic with a String, convert it to a Number."	^ rcvr asNumber perform: selector with: self! !!Number methodsFor: 'as yet unclassified' stamp: 'nice 4/23/2011 02:10'!arCosh	"Answer receiver's area hyperbolic cosine.	That is the inverse function of cosh."	^self asFloat arCosh! !!Number methodsFor: 'as yet unclassified' stamp: 'nice 4/23/2011 02:10'!arSinh	"Answer receiver's area hyperbolic sine.	That is the inverse function of sinh."	^self asFloat arSinh! !!Number methodsFor: 'as yet unclassified' stamp: 'nice 4/23/2011 02:09'!arTanh	"Answer receiver's area hyperbolic tangent.	That is the inverse function of tanh."	^self asFloat arTanh! !!Number methodsFor: 'as yet unclassified'!arcCos 	"The receiver is the cosine of an angle. Answer the angle measured in 	radians."	^self asFloat arcCos! !!Number methodsFor: 'as yet unclassified'!arcSin	"The receiver is the sine of an angle. Answer the angle measured in 	radians."	^self asFloat arcSin! !!Number methodsFor: 'as yet unclassified'!arcTan	"The receiver is the tangent of an angle. Answer the angle measured in 	radians."	^self asFloat arcTan! !!Number methodsFor: 'as yet unclassified' stamp: 'jsp 2/24/1999 15:20'!arcTan: denominator	"The receiver is the tangent of an angle. Answer the angle measured in 	radians."	^(self asFloat) arcTan: denominator.! !!Number methodsFor: 'as yet unclassified' stamp: 'mk 10/27/2003 21:00'!arg	"Answer the argument of the receiver (see Complex | arg)."		self isZero ifTrue: [self error: 'Zero (0 + 0 i) does not have an argument.'].	0 < self		ifTrue: [^ 0]		ifFalse: [^ Float pi]! !!Number methodsFor: 'as yet unclassified' stamp: 'ar 5/20/2001 01:40'!asB3DVector3	^self@self@self! !!Number methodsFor: 'as yet unclassified' stamp: 'nice 10/13/2011 23:53'!asComplex	"Answer a Complex number that represents value of the the receiver."	^ Complex real: self imaginary: 0! !!Number methodsFor: 'as yet unclassified' stamp: 'brp 5/13/2003 10:13'!asDuration	^ Duration nanoSeconds: self asInteger! !!Number methodsFor: 'as yet unclassified' stamp: 'nice 5/21/2014 02:36'!asExactFloat	"Convert this number asFloat with a priori knowledge that it is an exact Float.	Some subclass might exploit this knowledge for a faster implementation.	Only send this if self isAnExactFloat."	^self asFloat! !!Number methodsFor: 'as yet unclassified' stamp: 'RAH 4/25/2000 19:49'!asFloatD	"Answer a d precision floating-point number approximating the receiver."	#Numeric.	"add 200/01/19 For ANSI <number> protocol."	^ self asFloat! !!Number methodsFor: 'as yet unclassified' stamp: 'RAH 4/25/2000 19:49'!asFloatE	"Answer a floating-point number approximating the receiver."	#Numeric.	"add 200/01/19 For ANSI <number> protocol."	^ self asFloat! !!Number methodsFor: 'as yet unclassified' stamp: 'RAH 4/25/2000 19:49'!asFloatQ	"Answer a floating-point number approximating the receiver."	#Numeric.	"add 200/01/19 For ANSI <number> protocol."	^ self asFloat! !!Number methodsFor: 'as yet unclassified'!asInteger	"Answer an Integer nearest the receiver toward zero."	^self truncated! !!Number methodsFor: 'as yet unclassified' stamp: 'wiz 5/29/2011 18:34'!asNonFraction		"Answer a number equivalent to the receiver that is not a fraction. See Fraction for active method."	^self ! !!Number methodsFor: 'as yet unclassified' stamp: 'sw 2/16/1999 18:15'!asNumber	^ self! !!Number methodsFor: 'as yet unclassified'!asPoint	"Answer a Point with the receiver as both coordinates; often used to 	supply the same value in two dimensions, as with symmetrical gridding 	or scaling."	^self @ self! !!Number methodsFor: 'as yet unclassified' stamp: 'dtl 9/25/2004 11:47'!asScaledDecimal	"Answer a scaled decimal number approximating the receiver."	#Numeric.	^ self asScaledDecimal: 8! !!Number methodsFor: 'as yet unclassified' stamp: 'RAH 4/25/2000 19:49'!asScaledDecimal: scale 	"Answer a scaled decimal number, with a fractional precision of scale, 	approximating the receiver."	#Numeric.	"add 200/01/19 For number protocol."	^ ScaledDecimal newFromNumber: self scale: scale! !!Number methodsFor: 'as yet unclassified' stamp: 'sw 9/8/97 16:30'!asSmallAngleDegrees	"Return the receiver normalized to lie within the range (-180, 180)"	| pos |	pos := self \\ 360.	pos > 180 ifTrue: [pos := pos - 360].	^ pos"#(-500 -300 -150 -5 0 5 150 300 500 1200) collect: [:n | n asSmallAngleDegrees]"! !!Number methodsFor: 'as yet unclassified' stamp: 'nice 10/5/2009 21:28'!asSmallPositiveDegrees	"Return the receiver normalized to lie within the range (0, 360)"	^self \\ 360! !!Number methodsFor: 'as yet unclassified' stamp: 'sw 9/27/2001 17:26'!basicType	"Answer a symbol representing the inherent type of the receiver"	^ #Number! !!Number methodsFor: 'as yet unclassified' stamp: 'MPW 1/1/1901 00:07'!byteEncode:aStream	^aStream writeNumber:self.! !!Number methodsFor: 'as yet unclassified'!canonicalArgumentName	^ 'Number'! !!Number methodsFor: 'as yet unclassified' stamp: 'wiz 5/29/2011 17:54'!ceiling	"Answer the integer nearest the receiver toward  infinity."	| truncation |	truncation := self truncated.	self <= 0 ifTrue: [^truncation].	self = truncation		ifTrue: [^truncation]		ifFalse: [^truncation + 1]! !!Number methodsFor: 'as yet unclassified' stamp: 'nice 12/26/2009 18:46'!closeTo: num	"are these two numbers close?"	num isFloat ifTrue: [^ num closeTo: self asFloat].	^[self = num] ifError: [false]! !!Number methodsFor: 'as yet unclassified' stamp: 'cmm 9/7/2013 12:09'!compareSafely: aNumber 	^ aNumber isNumber		ifTrue: [ self < aNumber ]		ifFalse: [ super compareSafely: aNumber ]! !!Number methodsFor: 'as yet unclassified' stamp: 'nice 4/23/2011 02:26'!copySignTo: aNumber	"Return a number with same magnitude as aNumber and same sign as self."	^ self positive		ifTrue: [aNumber abs]		ifFalse: [aNumber withNegativeSign].! !!Number methodsFor: 'as yet unclassified'!cos	"The receiver represents an angle measured in radians. Answer its cosine."	^self asFloat cos! !!Number methodsFor: 'as yet unclassified' stamp: 'nice 4/23/2011 00:54'!cosh	"Answer receivers hyperbolic cosine."		^self asFloat cosh! !!Number methodsFor: 'as yet unclassified' stamp: 'brp 1/9/2004 06:12'!day	^ self sign days! !!Number methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2005 18:32'!days	"Answer myself as a duration."	^AbsoluteDuration fromSeconds: self * 86400! !!Number methodsFor: 'as yet unclassified'!defaultLabelForInspector	"Answer the default label to be used for an Inspector window on the receiver."	^ super defaultLabelForInspector, ': ', self printString! !!Number methodsFor: 'as yet unclassified' stamp: 'nice 10/31/2010 22:03'!degreeCos	"Answer the cosine of the receiver taken as an angle in degrees."		^ (90 - (180 + self \\ 360 - 180) abs) degreesToRadians sin! !!Number methodsFor: 'as yet unclassified' stamp: 'nice 10/31/2010 22:01'!degreeSin	"Answer the sine of the receiver taken as an angle in degrees."		^(90 - self) degreeCos! !!Number methodsFor: 'as yet unclassified'!degreesToRadians	"The receiver is assumed to represent degrees. Answer the conversion to 	radians."	^self asFloat degreesToRadians! !!Number methodsFor: 'as yet unclassified' stamp: 'di 2/19/98 21:58'!detentBy: detent atMultiplesOf: grid snap: snap	"Map all values that are within detent/2 of any multiple of grid to that multiple.  Otherwise, if snap is true, return self, meaning that the values in the dead zone will never be returned.  If snap is false, then expand the range between dead zones so that it covers the range between multiples of the grid, and scale the value by that factor."	| r1 r2 |	r1 := self roundTo: grid.  "Nearest multiple of grid"	(self roundTo: detent) = r1 ifTrue: [^ r1].  "Snap to that multiple..."	snap ifTrue: [^ self].  "...or return self"	r2 := self < r1  "Nearest end of dead zone"		ifTrue: [r1 - (detent asFloat/2)]		ifFalse: [r1 + (detent asFloat/2)].	"Scale values between dead zones to fill range between multiples"	^ r1 + ((self - r2) * grid asFloat / (grid - detent))"	(170 to: 190 by: 2) collect: [:a | a detentBy: 10 atMultiplesOf: 90 snap: true] 	(170 to: 190 by: 2) collect: [:a | a detentBy: 10 atMultiplesOf: 90 snap: false]	(3.9 to: 4.1 by: 0.02) collect: [:a | a detentBy: 0.1 atMultiplesOf: 1.0 snap: true] 	(-3.9 to: -4.1 by: -0.02) collect: [:a | a detentBy: 0.1 atMultiplesOf: 1.0 snap: false]"! !!Number methodsFor: 'as yet unclassified'!even	"Answer whether the receiver is an even number."	^self \\ 2 = 0! !!Number methodsFor: 'as yet unclassified'!exp	"Answer the exponential of the receiver as a floating point number."	^self asFloat exp! !!Number methodsFor: 'as yet unclassified'!floor	"Answer the integer nearest the receiver toward negative infinity."	| truncation |	truncation := self truncated.	self >= 0 ifTrue: [^truncation].	self = truncation		ifTrue: [^truncation]		ifFalse: [^truncation - 1]! !!Number methodsFor: 'as yet unclassified' stamp: 'nice 12/11/2012 19:18'!floorLog: radix	"Answer the floor of the log base radix of the receiver."	^(self log: radix) floor! !!Number methodsFor: 'as yet unclassified' stamp: 'GabrielOmarCotelli 5/26/2009 21:58'!fractionPart		"Added for ANSI compatibility"		^self - self integerPart! !!Number methodsFor: 'as yet unclassified' stamp: 'brp 1/9/2004 06:28'!hour	^ self sign hours! !!Number methodsFor: 'as yet unclassified' stamp: 'brp 5/16/2003 07:56'!hours	^ Duration hours: self! !!Number methodsFor: 'as yet unclassified' stamp: 'mk 10/27/2003 18:17'!i	^ Complex real: 0 imaginary: self! !!Number methodsFor: 'as yet unclassified' stamp: 'GabrielOmarCotelli 5/26/2009 21:57'!integerPart	"Added for ANSI compatibility"	^self truncated! !!Number methodsFor: 'as yet unclassified' stamp: 'ar 8/31/2000 20:05'!interpolateTo: aNumber at: param	^self + (aNumber - self * param)! !!Number methodsFor: 'as yet unclassified' stamp: 'nice 5/21/2014 02:43'!isAnExactFloat	"Answer true if this Number can be converted exactly to a Float"	^self subclassResponsibility! !!Number methodsFor: 'as yet unclassified' stamp: 'sw 12/30/1998 13:21'!isDivisibleBy: aNumber	aNumber = 0 ifTrue: [^ false].	aNumber isInteger ifFalse: [^ false].	^ (self \\ aNumber) = 0! !!Number methodsFor: 'as yet unclassified' stamp: 'nice 8/9/2009 21:02'!isInf	self deprecated: 'Use #isInfinite instead'.	^self isInfinite! !!Number methodsFor: 'as yet unclassified' stamp: 'tao 4/19/98 23:33'!isInfinite	^ false! !!Number methodsFor: 'as yet unclassified' stamp: 'tao 10/10/97 16:36'!isNaN	^ false! !!Number methodsFor: 'as yet unclassified'!isNumber	^ true! !!Number methodsFor: 'as yet unclassified' stamp: 'sw 6/29/1999 21:10'!isOrAreStringWith: aNoun	| result |	result := self = 1		ifTrue:			[' is one ']		ifFalse:			[self = 0				ifTrue:					[' are no ']				ifFalse:					[' are ', self printString, ' ']].	result := result, aNoun.	self = 1 ifFalse: [result := result, 's'].	^ result"#(0 1 2 98.6) do:	[:num | Transcript cr; show: 'There', (num isOrAreStringWith: 'way'), ' to skin a cat']"! !!Number methodsFor: 'as yet unclassified'!isZero	^self = 0! !!Number methodsFor: 'as yet unclassified'!ln	"Answer the natural log of the receiver."	^self asFloat ln! !!Number methodsFor: 'as yet unclassified' stamp: 'di 9/8/1998 17:10'!log	"Answer the base-10 log of the receiver."	^self asFloat log! !!Number methodsFor: 'as yet unclassified'!log: aNumber 	"Answer the log base aNumber of the receiver."	^self ln / aNumber ln! !!Number methodsFor: 'as yet unclassified' stamp: 'crl 8/8/2017 17:16'!loudness	"Answer an absolute loudness based on myself as a normalized value."		^(self negative or: [self > 1])		ifTrue: [self error: 'I''m not a normalized value (between zero and one, inclusive).']		ifFalse: [AbsoluteLoudness withNormalizedValue: self]! !!Number methodsFor: 'as yet unclassified' stamp: 'brp 1/9/2004 06:26'!milliSecond	^ self sign milliSeconds! !!Number methodsFor: 'as yet unclassified' stamp: 'brp 9/25/2003 13:16'!milliSeconds	^ Duration milliSeconds: self! !!Number methodsFor: 'as yet unclassified' stamp: 'crl 8/8/2017 16:25'!milliseconds	"Answer myself as a duration."	^(self / 1000) seconds! !!Number methodsFor: 'as yet unclassified' stamp: 'brp 1/9/2004 06:16'!minute	^ self sign minutes! !!Number methodsFor: 'as yet unclassified' stamp: 'brp 5/16/2003 07:56'!minutes	^ Duration minutes: self! !!Number methodsFor: 'as yet unclassified' stamp: 'brp 1/9/2004 06:27'!nanoSecond	^ self sign nanoSeconds! !!Number methodsFor: 'as yet unclassified' stamp: 'brp 5/16/2003 08:52'!nanoSeconds	^ Duration nanoSeconds: self.! !!Number methodsFor: 'as yet unclassified'!negated	"Answer a Number that is the negation of the receiver."	^0 - self! !!Number methodsFor: 'as yet unclassified' stamp: 'di 4/23/1998 11:18'!negative	"Answer whether the receiver is mathematically negative."	^ self < 0! !!Number methodsFor: 'as yet unclassified' stamp: 'sw 10/31/97 13:54'!newTileMorphRepresentative	^ TileMorph new addArrows; setLiteral: self; addSuffixIfCan! !!Number methodsFor: 'as yet unclassified' stamp: 'jmv 10/13/2011 08:36'!nthRoot: aPositiveInteger	"Answer the nth root of the receiver."	self subclassResponsibility! !!Number methodsFor: 'as yet unclassified'!odd	"Answer whether the receiver is an odd number."	^self even == false! !!Number methodsFor: 'as yet unclassified' stamp: 'crl 8/8/2017 16:38'!percent	"Answer a ratio between myself and 100."	^self / 100! !!Number methodsFor: 'as yet unclassified' stamp: 'di 4/23/1998 11:17'!positive	"Answer whether the receiver is positive or equal to 0. (ST-80 protocol).	See also strictlyPositive"	^ self >= 0! !!Number methodsFor: 'as yet unclassified' stamp: 'laza 3/29/2004 12:53'!printOn: aStream	self printOn: aStream base: 10! !!Number methodsFor: 'as yet unclassified' stamp: 'nice 9/25/2007 02:36'!printOn: aStream base: base	"This method should print a representation of the number for the given base,	excluding the base prefix (and the letter r for radix)"		^self subclassResponsibility! !!Number methodsFor: 'as yet unclassified' stamp: 'nice 5/15/2012 23:08'!printOn: aStream maxDecimalPlaces: placesDesired	"Print a representation of the receiver on aStream in decimal notation with at most prescribed number of places after decimal separator."	| rounder rounded roundedFractionPart placesRequired shorten |	placesDesired <= 0 ifTrue: [^ self rounded printOn: aStream].	rounder := 10 raisedToInteger: placesDesired.	rounded := self roundTo: rounder reciprocal.	rounded negative ifTrue: [aStream nextPut: $-].	rounded := rounded abs.	rounded integerPart truncated printOn: aStream.	roundedFractionPart := (rounded fractionPart * rounder) truncated.	placesRequired := placesDesired.	[roundedFractionPart = 0 ifTrue: [^self].	(shorten := roundedFractionPart // 10) * 10 = roundedFractionPart]		whileTrue:			[placesRequired := placesRequired - 1.			roundedFractionPart := shorten].	placesRequired > 0		ifTrue:			[aStream nextPut: $..			roundedFractionPart printOn: aStream base: 10 length: placesRequired padded: true]! !!Number methodsFor: 'as yet unclassified' stamp: 'nice 3/29/2011 21:48'!printOn: aStream showingDecimalPlaces: placesDesired	"Print a representation of the receiver on aStream in decimal notation with prescribed number of places after decimal separator."	| rounder rounded roundedFractionPart |	placesDesired <= 0 ifTrue: [^ self rounded printOn: aStream].	rounder := 10 raisedToInteger: placesDesired.	rounded := self roundTo: rounder reciprocal.	rounded negative ifTrue: [aStream nextPut: $-].	rounded := rounded abs.	rounded integerPart truncated printOn: aStream.	aStream nextPut: $..	roundedFractionPart := (rounded fractionPart * rounder) truncated.	roundedFractionPart printOn: aStream base: 10 length: placesDesired padded: true! !!Number methodsFor: 'as yet unclassified' stamp: 'nice 3/29/2011 21:39'!printShowingDecimalPlaces: placesDesired	"Print the receiver showing precisely the given number of places desired.  If placesDesired is positive, a decimal point and that many digits after the decimal point will always be shown.  If placesDesired is zero, a whole number will be shown, without a decimal point."	^String new: placesDesired + 10 streamContents: [:aStream |		self printOn: aStream showingDecimalPlaces: placesDesired]"23 printShowingDecimalPlaces: 223.5698 printShowingDecimalPlaces: 2-234.567 printShowingDecimalPlaces: 523.4567 printShowingDecimalPlaces: 023.5567 printShowingDecimalPlaces: 0-23.4567 printShowingDecimalPlaces: 0-23.5567 printShowingDecimalPlaces: 0100000000 printShowingDecimalPlaces: 10.98 printShowingDecimalPlaces: 5-0.98 printShowingDecimalPlaces: 22.567 printShowingDecimalPlaces: 2-2.567 printShowingDecimalPlaces: 20 printShowingDecimalPlaces: 2"! !!Number methodsFor: 'as yet unclassified' stamp: 'nice 5/15/2012 23:14'!printShowingMaxDecimalPlaces: placesDesired	"Print the receiver showing at most the given number of places desired after the decimal point.	Trailing zeros of decimal part are discarded, so the number of digits after the decimal point may vary.	When placesDesired is zero or negative, or when fraction part vanish, no decimal point is shown."	^String new: placesDesired + 10 streamContents: [:aStream |		self printOn: aStream maxDecimalPlaces: placesDesired]! !!Number methodsFor: 'as yet unclassified' stamp: 'laza 3/30/2004 10:50'!printString	^self printStringBase: 10! !!Number methodsFor: 'as yet unclassified'!printStringBase: base	^ String streamContents:		[:strm | self printOn: strm base: base]! !!Number methodsFor: 'as yet unclassified'!quo: aNumber 	"Integer quotient defined by division with truncation toward zero. -9 quo: 	4 = -2, -0.9 quo: 0.4 = -2. rem: answers the remainder from this division."	^(self / aNumber) truncated! !!Number methodsFor: 'as yet unclassified'!radiansToDegrees	"The receiver is assumed to represent radians. Answer the conversion to 	degrees."	^self asFloat radiansToDegrees! !!Number methodsFor: 'as yet unclassified' stamp: 'jmv 10/13/2011 08:50'!raisedTo: aNumber 	"Answer the receiver raised to aNumber."	aNumber isInteger ifTrue: [		"Do the special case of integer power"		^ self raisedToInteger: aNumber].	aNumber isFraction ifTrue: [		"Special case for fraction power"		^ (self nthRoot: aNumber denominator) raisedToInteger: aNumber numerator ].	self < 0 ifTrue: [		^ ArithmeticError signal: 'Negative numbers can''t be raised to float powers.' ].	0 = aNumber ifTrue: [^ self class one].	"Special case of exponent=0"	1 = aNumber ifTrue: [^ self].	"Special case of exponent=1"	0 = self ifTrue: [				"Special case of self = 0"		aNumber < 0			ifTrue: [^ (ZeroDivide dividend: self) signal]			ifFalse: [^ self]].	^ (aNumber * self ln) exp		"Otherwise use logarithms"! !!Number methodsFor: 'as yet unclassified' stamp: 'GabrielOmarCotelli 5/26/2009 19:49'!raisedToInteger: anInteger	"The 0 raisedToInteger: 0 is an special case. In some contexts must be 1 and in others must	be handled as an indeterminate form.	I take the first context because that's the way that was previously handled.	Maybe further discussion is required on this topic."		|bitProbe result|	anInteger negative ifTrue: [^(self raisedToInteger: anInteger negated) reciprocal].	bitProbe := 1 bitShift: anInteger highBit - 1. 	result := self class one.  	[		(anInteger bitAnd: bitProbe) = 0 ifFalse: [result := result * self].       bitProbe := bitProbe bitShift: -1.		bitProbe > 0 ]	whileTrue: [result := result * result].		^result! !!Number methodsFor: 'as yet unclassified' stamp: 'GabrielOmarCotelli 5/23/2009 20:20'!reciprocal	"Returns the reciprocal of self.	In case self is 0 the / signals ZeroDivide"		^1 / self! !!Number methodsFor: 'as yet unclassified'!reduce    "If self is close to an integer, return that integer"    ^ self! !!Number methodsFor: 'as yet unclassified'!rem: aNumber 	"Remainder defined in terms of quo:. Answer a Number with the same 	sign as self. e.g. 9 rem: 4 = 1, -9 rem: 4 = -1. 0.9 rem: 0.4 = 0.1."	^self - ((self quo: aNumber) * aNumber)! !!Number methodsFor: 'as yet unclassified' stamp: 'cbc 6/7/2011 22:20'!roundDownTo: aNumber 	"Answer the next multiple of aNumber toward negative infinity that is nearest the 	receiver." 	"Examples:		3.1479 roundDownTo: 0.01 -> 3.14		3.1479 roundDownTo: 0.1 -> 3.1		1923 roundDownTo: 10 -> 1920		3.1479 roundDownTo: 0.005 -> 3.145		-3.1479 roundDownTo: 0.01 -> -3.15"			^(self/aNumber) floor * aNumber! !!Number methodsFor: 'as yet unclassified' stamp: 'di 10/4/1999 08:08'!roundTo: quantum 	"Answer the nearest number that is a multiple of quantum."	^(self / quantum) rounded * quantum! !!Number methodsFor: 'as yet unclassified' stamp: 'cbc 6/7/2011 22:21'!roundUpTo: aNumber 	"Answer the next multiple of aNumber toward infinity that is nearest the 	receiver." 	"Examples:		3.1479 roundUpTo: 0.01 -> 3.15		3.1479 roundUpTo: 0.1 -> 3.2		1923 roundUpTo: 10 -> 1930		3.1479 roundUpTo: 0.005 -> 3.15		-3.1479 roundUpTo: 0.01 -> -3.14"	^(self/aNumber) ceiling * aNumber! !!Number methodsFor: 'as yet unclassified'!rounded	"Answer the integer nearest the receiver."	^(self + (self sign / 2)) truncated! !!Number methodsFor: 'as yet unclassified' stamp: 'brp 1/9/2004 06:17'!second	^ self sign seconds! !!Number methodsFor: 'as yet unclassified' stamp: 'crl 8/8/2017 16:28'!seconds	"Answer myself as a duration."	^AbsoluteDuration fromSeconds: self! !!Number methodsFor: 'as yet unclassified'!sign	"Answer 1 if the receiver is greater than 0, -1 if less than 0, else 0."	self > 0 ifTrue: [^1].	self < 0 ifTrue: [^-1].	^0! !!Number methodsFor: 'as yet unclassified' stamp: 'nice 9/21/2010 23:24'!sign: aNumber	"Return a Number with the same sign as aNumber and same magnitude as self."	^ aNumber copySignTo: self! !!Number methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 20:03'!simplifiedForJSON	"Answer a literal populated with my contents, suitable for JSON encoding."	^self! !!Number methodsFor: 'as yet unclassified'!sin	"The receiver represents an angle measured in radians. Answer its sine."	^self asFloat sin! !!Number methodsFor: 'as yet unclassified' stamp: 'nice 4/23/2011 00:54'!sinh	"Answer receivers hyperbolic sine"		^self asFloat sinh! !!Number methodsFor: 'as yet unclassified' stamp: 'jmv 10/11/2011 08:34'!sqrt	"Answer the square root of the receiver."	self subclassResponsibility! !!Number methodsFor: 'as yet unclassified'!squared	"Answer the receiver multipled by itself."	^self * self! !!Number methodsFor: 'as yet unclassified' stamp: 'laza 3/29/2004 12:50'!storeOn: aStream 	self printOn: aStream! !!Number methodsFor: 'as yet unclassified' stamp: 'nice 9/25/2007 02:35'!storeOn: aStream base: base	"This method should print a representation of the number for the given base,	including the base prefix (with letter r for radix)"		^self subclassResponsibility! !!Number methodsFor: 'as yet unclassified'!storeStringBase: base	^ String streamContents: [:strm | self storeOn: strm base: base]! !!Number methodsFor: 'as yet unclassified' stamp: 'di 4/23/1998 11:02'!strictlyPositive	"Answer whether the receiver is mathematically positive."	^ self > 0! !!Number methodsFor: 'as yet unclassified' stamp: 'sw 7/1/1998 12:33'!stringForReadout	^ self rounded printString! !!Number methodsFor: 'as yet unclassified'!tan	"The receiver represents an angle measured in radians. Answer its 	tangent."	^self asFloat tan! !!Number methodsFor: 'as yet unclassified' stamp: 'nice 4/23/2011 00:55'!tanh	"Answer receivers hyperbolic tangent"		^self asFloat tanh! !!Number methodsFor: 'as yet unclassified'!to: stop	"Answer an Interval from the receiver up to the argument, stop, 	incrementing by 1."	^Interval from: self to: stop by: 1! !!Number methodsFor: 'as yet unclassified'!to: stop by: step	"Answer an Interval from the receiver up to the argument, stop, 	incrementing by step."	^Interval from: self to: stop by: step! !!Number methodsFor: 'as yet unclassified' stamp: 'tao 1/30/1999 08:58'!to: stop by: step do: aBlock 	"Normally compiled in-line, and therefore not overridable.	Evaluate aBlock for each element of the interval (self to: stop by: step)."	| nextValue |	nextValue := self.	step = 0 ifTrue: [self error: 'step must be non-zero'].	step < 0		ifTrue: [[stop <= nextValue]				whileTrue: 					[aBlock value: nextValue.					nextValue := nextValue + step]]		ifFalse: [[stop >= nextValue]				whileTrue: 					[aBlock value: nextValue.					nextValue := nextValue + step]]! !!Number methodsFor: 'as yet unclassified'!to: stop do: aBlock 	"Normally compiled in-line, and therefore not overridable.	Evaluate aBlock for each element of the interval (self to: stop by: 1)."	| nextValue |	nextValue := self.	[nextValue <= stop]		whileTrue: 			[aBlock value: nextValue.			nextValue := nextValue + 1]! !!Number methodsFor: 'as yet unclassified' stamp: 'cbc 6/7/2011 22:18'!truncateTo: aNumber 	"Answer the next multiple of aNumber toward zero that is nearest the 	receiver."	"Examples:		3.1479 truncateTo: 0.01 -> 3.14		3.1479 truncateTo: 0.1 -> 3.1		1923 truncateTo: 10 -> 1920		3.1479 truncateTo: 0.005 -> 3.145		-3.1479 truncateTo: 0.01 -> -3.14"	^(self quo: aNumber)		* aNumber! !!Number methodsFor: 'as yet unclassified'!truncated	"Answer an integer nearest the receiver toward zero."	^self quo: 1! !!Number methodsFor: 'as yet unclassified' stamp: 'cmm 11/4/2013 20:51'!veryDeepCopy	"Overridden for performance."	^ self! !!Number methodsFor: 'as yet unclassified' stamp: 'sw 8/3/2001 13:43'!vocabularyDemanded	"Answer the vocabulary normally preferred by this object"	^ Vocabulary numberVocabulary! !!Number methodsFor: 'as yet unclassified' stamp: 'crl 8/8/2017 17:16'!volume	^self loudness! !!Number methodsFor: 'as yet unclassified' stamp: 'brp 1/9/2004 06:19'!week	^ self sign weeks! !!Number methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2005 18:33'!weeks	"Answer myself as a duration."	^AbsoluteDuration fromSeconds: self * 604800! !!Number methodsFor: 'as yet unclassified' stamp: 'nice 4/23/2011 02:25'!withNegativeSign	"Answer a number with same magnitude than receiver and negative sign."	^self abs negated! !!Number class methodsFor: 'as yet unclassified' stamp: 'crl 3/24/2019 23:59'!fromTether: tether	^tether next negated! !!Number class methodsFor: 'as yet unclassified' stamp: 'GabrielOmarCotelli 5/23/2009 20:46'!one	^1! !!Number class methodsFor: 'as yet unclassified' stamp: 'nice 2/22/2010 22:41'!readExactlyFrom: stringOrStream 	"Answer a number as described on aStream. The number may	include a leading radix specification, as in 16rFADE"		self deprecated: 'Use #readFrom: '.	^ self readFrom: stringOrStream ! !!Number class methodsFor: 'as yet unclassified' stamp: 'nice 2/22/2010 21:43'!readFrom: stringOrStream 	"Answer a number as described on aStream.  The number may	be any accepted Smalltalk literal Number format.	It can include a leading radix specification, as in 16rFADE.	It can as well be NaN, Infinity or -Infinity for conveniency.	If stringOrStream does not start with a valid number description, fail."		^(ExtendedNumberParser on: stringOrStream) nextNumber! !!Number class methodsFor: 'as yet unclassified' stamp: 'nice 3/15/2008 00:27'!readFrom: stringOrStream base: base	"Answer a number as described on aStream in the given number base."	^(SqNumberParser on: stringOrStream) nextNumberBase: base! !!Number class methodsFor: 'as yet unclassified' stamp: 'nice 2/22/2010 22:40'!readFrom: stringOrStream ifFail: aBlock	"Answer a number as described on aStream.  The number may	be any accepted Smalltalk literal Number format.	It can include a leading radix specification, as in 16rFADE.	It can as well be NaN, Infinity or -Infinity for conveniency.	If input does not represent a valid number, then execute fail block	and leave the stream positioned before offending character"		^(ExtendedNumberParser on: stringOrStream) failBlock: aBlock; nextNumber! !!Number class methodsFor: 'as yet unclassified' stamp: 'nice 2/22/2010 21:41'!readSmalltalkSyntaxFrom: stringOrStream 	"Answer a number as described on aStream.  The number may	be any accepted Smalltalk literal Number format.	It can include a leading radix specification, as in 16rFADE.	It can as well be NaN, Infinity or -Infinity for conveniency.	If stringOrStream does not start with a valid number description, fail."		^(SqNumberParser on: stringOrStream) nextNumber! !!Number class methodsFor: 'as yet unclassified' stamp: 'fbs 3/30/2013 21:40'!zero	^ 0.! !!ProtoclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/3/2008 16:46'!addCommentEdition: aCommentEdition	activeCommentEdition ifNotNil: [		activeCommentEdition nextEdition: aCommentEdition.		aCommentEdition previousEdition: activeCommentEdition].	activeCommentEdition := aCommentEdition! !!ProtoclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 21:35'!at: key	"Assuming I describe a SharedPool subclass, answer the indicated shared variable value."	^(EditHistory residesLocally)		ifTrue: [nil]		ifFalse: [			(self inheritsFrom: (EditHistory activeEditionForClassWithBaseID: (UUID fromString: '7e97b8cb-f61a-43bd-9640-ae1b61490fbb')))				ifTrue: [self classVariablesPool]				ifFalse: [self error: 'I don''t describe a subclass of SharedPool.']]! !!ProtoclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/12/2016 15:07'!binding	^self nameLiteral! !!ProtoclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/10/2016 00:24'!bindingOf: varName environment: anEnvironment	"Answer the binding of some variable resolved in the scope of the receiver"	| aSymbol binding |	aSymbol := varName asSymbol.	"First look in classVar dictionary."	(self classThatDefinesClassVariable: aSymbol) ifNotNil:		[:x | ^x classPool bindingOf: aSymbol].	"Next look in shared pools."	self sharedPools do:[:pool | 		binding := pool bindingOf: aSymbol.		binding ifNotNil:[^binding].	].	"Next look in declared environment."	binding := anEnvironment bindingOf: aSymbol.	binding ifNotNil:[^binding].	"Finally look higher up the superclass chain and fail at the end."	superclassID == nil		ifTrue: [^ nil]		ifFalse: [^ self superclass bindingOf: aSymbol].! !!ProtoclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 21:59'!classPool	^self classVariablesPool! !!ProtoclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 15:08'!classSide	^counterpartID edition! !!ProtoclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/10/2016 00:25'!classThatDefinesClassVariable: classVarName	"Answer the class that defines the given class variable"	(self classPool includesKey: classVarName asSymbol) ifTrue: [^ self]. 	^self superclass ifNotNil: [self superclass classThatDefinesClassVariable: classVarName]! !!ProtoclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/29/2016 14:10'!classVarNames	"Answer a collection of the names of the class variables defined in the receiver."	^classPoolKeys clone sort! !!ProtoclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 21:59'!classVariablesPool	^Dictionary new	"^self remoteClass classPool"! !!ProtoclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 4/14/2008 16:18'!editionsOfClassesWithName: className	^self editionsOfClassesSuchThat: [:edition | edition name = className]! !!ProtoclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/12/2016 00:23'!holderOfClassVariablePoolAssociation: anAssociation 	| classVariablesPoolHolder |	classVariablesPoolHolder := (		(self isMeta)			ifTrue: [self soleInstance]			ifFalse: [self]).	[classVariablesPoolHolder == nil] whileFalse: [		((classVariablesPoolHolder classPool includesKey: anAssociation key) and: [(classVariablesPoolHolder classPool at: anAssociation key) == anAssociation value]) ifTrue: [^classVariablesPoolHolder].		classVariablesPoolHolder := classVariablesPoolHolder superclass].	^nil! !!ProtoclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 00:48'!install	^self installWithMetaclassEdition: (EditHistory classEditionWithID: counterpartID) temporaryCopy! !!ProtoclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/14/2016 20:35'!installWithMetaclassEdition: aMetaclassEdition	^(self classBaseID = (UUID fromString: '964ee803-aebc-4bda-bb1b-a506ed782ff4'))		ifTrue: [			(Object clone)				instVarAt: 6 put: #();				yourself]		ifFalse: [			| newMetaclass newClass superclass |			newMetaclass := aMetaclassEdition install.			newClass := newMetaclass soleInstance.			newMetaclass instVarAt: 6 put: newClass.			"Missing class pool variables and shared pools are installed, when needed, by the subsequent installation of methods which use them."			superclass := self activeSuperclass.						newClass				baseID: self classBaseID;				superclass: superclass				methodDict: MethodDictionary new				format: self format				name: name				organization: nil				instVarNames: instanceVariableNames				classPool: Dictionary new				sharedPools: OrderedCollection new.			self isTemporary ifFalse: [				superclass addSubclass: newClass.				Smalltalk at: name put: newClass].				newClass]! !!ProtoclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 4/14/2008 15:33'!isMeta	"Answer whether I describe a Metaclass."	^false! !!ProtoclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 8/11/2007 00:24'!name	^name! !!ProtoclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2012 15:01'!name: aSymbol	name := aSymbol! !!ProtoclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/1/2016 01:17'!name: nameString classPoolKeys: classPoolKeysArray receivedPoolIDs: receivedPoolIDsArray publishedPoolIDs: publishedPoolIDsArray	name := nameString.	classPoolKeys := classPoolKeysArray.	receivedPoolIDs := receivedPoolIDsArray.	publishedPoolIDs := publishedPoolIDsArray! !!ProtoclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/12/2016 00:33'!nameLiteral	^name -> self! !!ProtoclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 15:16'!printComponentNameOn: aStream withOuterAuthor: anAuthorEdition	aStream		nextPutAll: 'class ';		nextPutAll: name;		nextPutAll: ', version ';		print: self version.	self printAuthorOn: aStream withOuterAuthor: anAuthorEdition! !!ProtoclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 22:00'!sharedPools	^OrderedCollection new! !!ProtoclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/1/2016 22:07'!sharedPoolsString	"Answer a string of my shared pool names separated by spaces."	^String streamContents: [ :stream |		{receivedPoolIDs. publishedPoolIDs} do: [:ids |			ids ifNotNil: [ids do: [:each |				| pool |								pool := each activeClass.				stream nextPutAll: (					pool						ifNil: ['private']						ifNotNil: [pool name])]]]			separatedBy: [stream space ] ]! !!ProtoclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/1/2016 01:18'!storeOnTether: tether	super storeOnTether: tether.	tether		store: name;		store: classPoolKeys;		store: receivedPoolIDs;		store: publishedPoolIDs! !!ProtoclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 16:46'!tag	^ProtoclassEditionTag! !!ProtoclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/29/2016 14:44'!theMetaClass	^counterpartID edition! !!ProtoclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 03:03'!theNonMetaClass	^self! !!ProtoclassEdition class methodsFor: 'as yet unclassified' stamp: 'crl 10/1/2016 01:18'!fromTether: tether	^(super fromTether: tether)		name: tether next		classPoolKeys: tether next		receivedPoolIDs: tether next		publishedPoolIDs: tether next! !!PaintBoxColorPicker class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 21:29'!close	"Close the connection between my system and the remote system."		[websocket close]		on: Error		do: [:exception | ]! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 02:44'!incomingMessage: message	incomingMessage := (		(			JS				ifConnected: [message data counterpart simplestRepresentation]				ifNotConnected: [message]		)			asByteArray readStream)! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 4/2/2019 12:51'!isConnected	"Answer whether my websocket is connected to a remote endpoint."		^JS		ifConnected: [			[websocket readyState = 1]				on: Error				do: [:exception |					websocket := nil.					false]]		ifNotConnected: [websocket isConnected]! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 03:25'!isExit	^self subclassResponsibility! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 02:19'!next16Bits	| bytes |	bytes := self next: 2.	^((bytes at: 1) bitShift: 8) + (bytes at: 2)! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 3/20/2019 16:25'!next16BitsPut: sixteenBits	^self nextPutAll: (		ByteArray			with: (sixteenBits bitShift: -8)			with: (sixteenBits bitAnd: 255))! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 02:58'!next: integer	^incomingMessage next: integer! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 02:20'!nextByte	"Answer the next byte from the current incoming event."		^incomingMessage next! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 02:20'!nextBytes	"Answer the next group of bytes from the current incoming event."		^incomingMessage next: self nextInteger! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 02:20'!nextInteger	"Answer the next integer from the current incoming event."		| integer shift sizeByte negative |	integer := shift := 0.	sizeByte := self nextByte.	negative := (sizeByte >= 2r10000000).	(sizeByte bitAnd: 2r1111111) timesRepeat: [		integer := integer + (self nextByte bitShift: shift).		shift := shift + 8].	^negative		ifTrue: [integer negated]		ifFalse: [integer]! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 3/20/2019 16:24'!nextPut: byte	^outgoingMessage nextPut: byte! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 02:55'!nextPutAll: bytes	^outgoingMessage nextPutAll: bytes! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 4/10/2018 15:42'!nextPutBoolean: boolean	"Write boolean to the current outgoing message."		outgoingMessage nextPutByte: (		boolean			ifTrue: [1]			ifFalse: [0])! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 7/2/2016 01:09'!nextPutByte: byte	"Write byte to the current outgoing message."		outgoingMessage nextPut: byte! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 7/2/2016 01:09'!nextPutBytes: bytes	"Write bytes to the current outgoing message."		self nextPutInteger: bytes size.	bytes do: [:byte | self nextPutByte: byte]! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2016 15:55'!nextPutInteger: integer	"Write integer to the current outgoing message."		| sizeByte remainder negative |	negative := integer negative.	remainder := (		negative			ifTrue: [integer negated]			ifFalse: [integer]).	sizeByte := (remainder highBit / 8) ceiling.	negative ifTrue: [sizeByte := sizeByte bitOr: 2r10000000].	self nextPutByte: sizeByte.	[remainder > 0] whileTrue: [		self nextPutByte: (remainder bitAnd: 16rFF).		remainder := remainder bitShift: -8]! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2016 16:20'!nextPutPoint: point	"Write point to the current outgoing message."		self		nextPutInteger: point x;		nextPutInteger: point y! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 7/13/2016 21:17'!nextPutRectangle: rectangle	"Write rectangle to the current outgoing message."		self		nextPutPoint: rectangle origin;		nextPutPoint: rectangle corner! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 8/1/2016 11:52'!nextPutString: string	"Write string to the current outgoing message."		self nextPutBytes: string! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 02:21'!nextWord	| bytes |	bytes := incomingMessage next: 4.	^((bytes at: 1) bitShift: 24) + ((bytes at: 2) bitShift: 16) + ((bytes at: 3) bitShift: 8) + (bytes at: 4)! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 03:27'!nextWordPut: word	self		nextPutByte: ((word bitShift: -24) bitAnd: 255);		nextPutByte: ((word bitShift: -16) bitAnd: 255);		nextPutByte: ((word bitShift: -8) bitAnd: 255);		nextPutByte: (word bitAnd: 255).	^word! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2016 16:22'!onClose: aBlockClosure	"Install aBlockClosure as a callback that my websocket should trigger when it closes."	self subclassResponsibility! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 7/6/2016 12:02'!onError: aBlockClosure	"Install aBlockClosure as a callback that my websocket should trigger when it encounters an error."	self subclassResponsibility! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2016 16:22'!onMessage: aBlockClosure	"Install aBlockClosure as a callback that my websocket should trigger when it receives a message."	self subclassResponsibility! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2016 16:24'!onOpen: aBlockClosure	"Install aBlockClosure as a callback that my websocket should trigger when it opens."	self subclassResponsibility! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 7/6/2016 17:02'!outgoingPayload	"Answer the payload for the next outgoing message."	^self subclassResponsibility! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 7/6/2016 14:58'!payloadForWebSocketMessage: message	"Answer the payload of message, received by my websocket."	^self subclassResponsibility! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 3/20/2019 16:21'!pendingOutgoingMessage	^outgoingMessage contents! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 14:17'!printOn: stream	"Write a textual description of myself to stream."		super printOn: stream.	websocket isConnected ifFalse: [stream nextPutAll: ' which was'].		stream		nextPutAll: ' connected to port ';		print: websocket port;		nextPutAll: ' at ';		nextPutAll: websocket hostname! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2016 16:25'!readyState	"Answer my websocket's readyState (see the WebSocket RFC)."	^self subclassResponsibility! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 8/2/2016 11:08'!send	"Send the contents of the current outgoing message."	[websocket send: self outgoingPayload]		on: SocketPrimitiveFailed		do: [:exception | ]		on: ConnectionTimedOut		do: [:exception | ]! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 7/4/2016 01:43'!service: object	"Set my service to object."		service := object! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 7/2/2016 01:11'!startInstruction: instruction	"Start writing the indicated instruction to the current outgoing message."		outgoingMessage := (ByteArray new: 1024) writeStream.	self nextPutByte: instruction! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 03:30'!startMessage	outgoingMessage := (ByteArray new: 1024) writeStream! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2016 16:26'!stringForWebSocketMessage: message	"Answer the String payload of message, received by my websocket."	^self subclassResponsibility! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 8/31/2018 17:59'!websocket	^websocket! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 4/2/2019 12:51'!websocket: object	"Set my websocket to object, which is either a local instance of WebSocket or a JSObjectProxy to an external JavaScript WebSocket."	websocket := object! !!Portal class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!Noise methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 14:03'!initialize	proxy := JS top noise! !!Noise methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 14:41'!scale: scale offset: offset	| noise |		noise := JS top at: #noise.		proxy := (		scale			ifNil: [noise call]			ifNotNil: [				offset					ifNil: [noise call: nil with: scale]					ifNotNil: [noise call: nil with: scale with: offset]])! !!Noise class methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 14:33'!new	^self scale: nil offset: nil! !!Noise class methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 14:33'!scale: scale offset: offset	^(super new)		scale: scale offset: offset;		yourself! !!FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 5/15/2017 17:12'!deferUpdates: boolean	Display deferUpdates: boolean! !!FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 8/26/2019 07:00'!extent: point	self setForm: (form class extent: point depth: form depth)! !!FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 5/15/2017 14:45'!forceDamageToScreen: rectangles	Display forceDamageToScreen: rectangles! !!FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 5/15/2017 17:13'!forceDisplayUpdate	Display forceDisplayUpdate! !!FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 2/2/2019 10:43'!height	^form height! !!FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 2/2/2019 10:43'!width	^form width! !!Dictionary methodsFor: 'as yet unclassified' stamp: 'crl 7/7/2017 23:52'!asDictionary	^self! !!Dictionary methodsFor: 'as yet unclassified' stamp: 'bf 11/25/2014 18:12'!asJSArgument	"converted to JS object by plugin"	| assocs i |	assocs := Array new: self size.	i := 0.	self associationsDo: [:a |		assocs at: (i := i + 1) put: a key asJSArgument -> a value asJSArgument].	^ assocs! !!Dictionary methodsFor: 'as yet unclassified' stamp: 'crl 3/24/2019 21:23'!classPool	^self! !!Dictionary methodsFor: 'as yet unclassified' stamp: 'crl 3/25/2019 09:48'!id	"I am a shared pool of some class. Answer the id of that class."		^((Class allSubclasses select: [:class | class soleInstance sharedPools includes: self]) asSortedCollection: [:earlier :later | earlier depth <= later depth]) first id! !!Dictionary methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 20:03'!simplifiedForJSON	"Answer a literal populated with my contents, suitable for JSON encoding."	^self! !!Dictionary methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 03:46'!storeElementsOnTether: tether	self keysAndValuesDo: [:key :value |		tether			store: key;			store: value]! !!Dictionary methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 03:50'!tag	^DictionaryTag! !!Dictionary class methodsFor: 'as yet unclassified'!fromTether: tether	| counterpart |		counterpart := self new.		self		readElementsInQuantity: tether nextWord		into: counterpart		for: tether.			^counterpart! !!HTMLDialog methodsFor: 'as yet unclassified' stamp: 'crl 9/10/2019 15:17'!question: question choices: choices	| dialog buttons answer answerAvailable |		dialog := app children.	buttons := dialog buttons children.	answerAvailable := Semaphore new.	dialog question innerHTML: question.		(buttons true)		innerHTML: choices first;		onClick: [			self remove.			answer := true.			answerAvailable signal].	(buttons false)		innerHTML: choices second;		onClick: [			self remove.			answer := false.			answerAvailable signal].			answerAvailable wait.	^answer! !!HTMLDialog class methodsFor: 'as yet unclassified' stamp: 'crl 8/13/2018 10:54'!confirm: question withChoices: choices	^(self new)		question: question		choices: choices! !!PluggableTextMorph methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2019 13:13'!accept 	"Inform the model of text to be accepted, and return true if OK."	| ok saveSelection saveScrollerOffset |"sps 8/13/2001 22:41: save selection and scroll info"	saveSelection := self selectionInterval copy.	saveScrollerOffset := scroller offset copy.	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not])		ifTrue: [^ self flash].	self hasEditingConflicts ifTrue:		[(self confirm: 'Caution!! This method may have beenchanged elsewhere since you startedediting it here.  Accept anyway?' translated) ifFalse: [^ self flash]].	ok := (self acceptTextInModel) == true.	ok ifTrue:		[self setText: self getText.		self hasUnacceptedEdits: false.		(model dependents detect: [:dep | (dep isKindOf: PluggableTextMorph) and: [dep getTextSelector == #annotation]] ifNone: [nil]) ifNotNil:			[:aPane | model changed: #annotation]].	"sps 8/13/2001 22:41: restore selection and scroll info"	["During the step for the browser, updateCodePaneIfNeeded is called, and 		invariably resets the contents of the codeholding PluggableTextMorph		at that time, resetting the cursor position and scroller in the process.		The following line forces that update without waiting for the step, 		then restores the cursor and scrollbar"	ok ifTrue: "(don't bother if there was an error during compile)"		[(model respondsTo: #updateCodePaneIfNeeded) 			ifTrue: [model updateCodePaneIfNeeded].		WorldState addDeferredUIMessage:			[self currentHand newKeyboardFocus: textMorph.			scroller offset: saveScrollerOffset.			self setScrollDeltas.			selectionInterval := saveSelection. "restore prior selection"			self selectFrom: saveSelection first to: saveSelection last]]]			on: Error do: []! !!PluggableTextMorph methodsFor: 'as yet unclassified' stamp: 'di 5/4/1998 15:55'!editString: aString 	"Jam some text in.  This is treated as clean text by default."	self setText: aString asText! !!CaffeineExtension methodsFor: 'as yet unclassified' stamp: 'crl 5/13/2017 00:16'!attachTo: tabID	^self send: 'attach' toTabWithID: tabID! !!CaffeineExtension methodsFor: 'as yet unclassified' stamp: 'crl 7/24/2017 14:12'!attachToTabWithTitle: title	self attachTo: (self idForTabWithTitle: title)! !!CaffeineExtension methodsFor: 'as yet unclassified' stamp: 'crl 7/22/2017 01:53'!close! !!CaffeineExtension methodsFor: 'as yet unclassified' stamp: 'crl 7/22/2017 15:30'!detachFrom: tabID	tabs removeKey: tabID.	^self send: 'detach' toTabWithID: tabID! !!CaffeineExtension methodsFor: 'as yet unclassified' stamp: 'crl 7/24/2017 14:12'!detachFromTabWithTitle: title	self detachFrom: (self idForTabWithTitle: title)! !!CaffeineExtension methodsFor: 'as yet unclassified' stamp: 'crl 7/21/2017 13:41'!getTabInfo	tabInfo := self send: 'tabs'! !!CaffeineExtension methodsFor: 'as yet unclassified' stamp: 'crl 7/24/2017 14:12'!idForTabWithTitle: title 	^(		tabInfo			detect: [:tab | tab title = title]			ifNone: [^nil]	)		id! !!CaffeineExtension methodsFor: 'as yet unclassified' stamp: 'crl 9/16/2019 17:15'!initialize	"Connect to the Caffeine Helper web browser extension."		tabs := IdentityDictionary new.	promises := IdentityDictionary new.	nextPromiseID := 1.	port := JS chrome runtime connect: 'hmfnphcjichoefnnncadoikiboacckmk'.		port onMessage addListener: [:message |		(message at: 'method')			ifNil: [				"Resolve a promised answer from the extension."								| promise |								promise := promises at: (message at: 'promiseID') ifAbsent: [nil].								promise ifNotNil: [promise resolveWith: (message at: 'result') counterpart simplestRepresentation]]			ifNotNil: [				"Handle a message from the web browser."								| tabID |								tabID := message at: 'tabID'.				(					ChromeMethodInvocation						fromDictionary: message counterpart simplestRepresentation						for: (							tabs								at: tabID								ifAbsent: [									tabs										at: tabID										put: (											(ChromeTab new)												initializeFromTabInfo: (tabInfo detect: [:tab | tab id = tabID]);												transport: self;												yourself)])				)					perform]].			self getTabInfo! !!CaffeineExtension methodsFor: 'as yet unclassified' stamp: 'crl 5/13/2017 00:17'!myID	^self send: 'myID'! !!CaffeineExtension methodsFor: 'as yet unclassified' stamp: 'crl 9/16/2019 22:21'!pauseTabWithID: tabID	^self		send: 'Debugger.pause'		toTabWithID: tabID! !!CaffeineExtension methodsFor: 'as yet unclassified' stamp: 'crl 5/13/2017 00:17'!removeBreakpointWithID: breakpointID inTabWithID: tabID	^self		send: 'Debugger.removeBreakpoint'		withParameters: {#breakpointId -> breakpointID}		toTabWithID: tabID! !!CaffeineExtension methodsFor: 'as yet unclassified' stamp: 'crl 5/13/2017 12:35'!resumeTabWithID: tabID	^self		send: 'Debugger.resume'		toTabWithID: tabID! !!CaffeineExtension methodsFor: 'as yet unclassified' stamp: 'crl 5/13/2017 00:15'!send: selector	^self send: selector toTabWithID: nil! !!CaffeineExtension methodsFor: 'as yet unclassified' stamp: 'crl 5/13/2017 12:33'!send: selector toTabWithID: tabID	^self		send: selector		withParameters: JS Object new		toTabWithID: tabID! !!CaffeineExtension methodsFor: 'as yet unclassified' stamp: 'crl 5/13/2017 00:14'!send: selector withParameters: parameters toTabWithID: tabID	| promise |		promise := promises at: nextPromiseID put: Promise new.			port postMessage: {		'promiseID' -> nextPromiseID.		'selector' -> selector.		'parameters' -> {tabID. parameters}}.			nextPromiseID := nextPromiseID + 1.	^promise		wait;		value! !!CaffeineExtension methodsFor: 'as yet unclassified' stamp: 'crl 5/13/2017 00:18'!setBreakpointByURL: url atLine: line andColumn: column inTabWithID: tabID	^self		send: 'Debugger.setBreakpointByUrl'		withParameters: {			#lineNumber -> line.			#url -> url}		toTabWithID: tabID! !!CaffeineExtension methodsFor: 'as yet unclassified' stamp: 'crl 7/21/2017 13:40'!tabs	^tabInfo := self send: 'tabs'! !!ChromeDebuggingObject methodsFor: 'as yet unclassified' stamp: 'crl 5/11/2017 22:48'!initializeFrom: dictionary	self class allInstVarNames do: [:instanceVariableName |		self			instVarNamed: instanceVariableName			put: (dictionary at: instanceVariableName ifAbsent: [nil])]! !!ChromeDebuggingObject class methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 19:46'!fromDictionary: dictionary	^self new initializeFrom: dictionary! !!DAVQuery methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!DAVQuery class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!DebuggerMethodMapForClosureCompiledMethods class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!StringHolder methodsFor: 'as yet unclassified' stamp: 'crl 8/18/2017 17:28'!openLabel: aString 	"Create a standard system view of the model, me, a StringHolder and open it.  If in mvc, terminate the active controller so that the new window will immediately be activated."	^self openLabel: aString world: ActiveWorld! !!StringHolder methodsFor: 'as yet unclassified' stamp: 'crl 6/13/2017 19:03'!openLabel: aString world: world	"Create a standard system view of the model, me, a StringHolder and open it.  If in mvc, terminate the active controller so that the new window will immediately be activated."	^ToolBuilder open: self label: aString world: world! !!StringHolder class methodsFor: 'as yet unclassified' stamp: 'crl 8/18/2017 17:54'!label	^'workspace'! !!StringHolder class methodsFor: 'as yet unclassified' stamp: 'crl 8/18/2017 17:27'!open	^self openInWorld: ActiveWorld! !!StringHolder class methodsFor: 'as yet unclassified' stamp: 'crl 8/18/2017 17:54'!openInWorld: world 	^self new openLabel: self label world: world! !!GrafPort class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!VueComponent methodsFor: 'as yet unclassified' stamp: 'crl 8/23/2018 13:52'!activeElement	^JS top document activeElement counterpart! !!VueComponent methodsFor: 'as yet unclassified' stamp: 'crl 9/10/2019 15:19'!app	^app! !!VueComponent methodsFor: 'as yet unclassified' stamp: 'crl 9/10/2019 15:17'!asJSArgument	^app proxy! !!VueComponent methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 17:10'!connect	"Establish event handlers for the components in my app."		[		(Delay forSeconds: 2) wait.		self windowize	]		fork! !!VueComponent methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2019 22:23'!descendantAt: id	^webpage document getElementById: id! !!VueComponent methodsFor: 'as yet unclassified' stamp: 'crl 9/10/2019 15:17'!doesNotUnderstand: message	^message sendTo: app! !!VueComponent methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 14:35'!initialize	webpage := Webpage current.	tag := self class tag.	appID := tag, '-app-', (String randomOfLength: 5).	mounted := Semaphore new! !!VueComponent methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 15:35'!loadScript	"If I haven't already, load a script which uses Vue to register my component. Answer whether a loaded a script."		| element |	Vue ensureLoadedInto: webpage.			(JS window top)		at: #mountedFunction		put: [mounted signal].	element := (		(webpage createDiv)			id: appID;			innerHTML: '<', tag, '></', tag, '>';			yourself).						script := (		(webpage createScript)			id: appID;			innerText: (				(WriteStream on: (String new: 64))					nextPutAll: '						new Vue({							el: "#';					nextPutAll: appID;					nextPutAll: '",							components: {								"';					nextPutAll: tag;					nextPutAll: '": httpVueLoader("';					nextPutAll: url;					nextPutAll: '")},							mounted: function () {window.top.mountedFunction();}})';					contents);			yourself).			(webpage body)		appendChild: element;		appendChild: script.			mounted wait! !!VueComponent methodsFor: 'as yet unclassified' stamp: 'crl 3/28/2019 13:44'!printOn: stream	stream		nextPutAll: tag article;		nextPutAll: ' <';		nextPutAll: tag;		nextPutAll: '> from ';		nextPutAll: url! !!VueComponent methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2019 19:47'!remove	app remove.	script remove! !!VueComponent methodsFor: 'as yet unclassified' stamp: 'crl 8/13/2018 11:29'!selectedElementIn: listbox	^listbox selectedOptions first value! !!VueComponent methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 16:36'!title	^self subclassResponsibility! !!VueComponent methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 15:35'!url: theURL	url := theURL.	self loadScript.	app := webpage elementAt: appID.	self connect.	app beVisible! !!VueComponent methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 17:49'!windowize	webpage		shortWindowizeElement: app children first		closingWith: [self remove]! !!VueComponent class methodsFor: 'as yet unclassified' stamp: 'crl 3/28/2019 11:34'!appID	^nil! !!VueComponent class methodsFor: 'as yet unclassified' stamp: 'crl 3/28/2019 12:30'!fromURL: url	"Answer an element from the document at url."		^(self new)		url: url;		yourself! !!VueComponent class methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 20:59'!initialize	"Initialize the custom HTML tags and component file locations that my concrete subclasses use."		(Dictionary new)		at: HTMLSmalltalkClassesBrowser		put: #(			'smalltalk-classes-browser'			'vue/devtools/smalltalk-classes-browser.vue');		at: HTMLSmalltalkInspector		put: #(			'smalltalk-inspector'			'vue/devtools/smalltalk-inspector.vue');		at: HTMLSmalltalkWorkspace		put: #(			'smalltalk-workspace'			'vue/devtools/smalltalk-workspace.vue');		at: HTMLPopupMenu		put: #(			'popup-menu'			'vue/popup-menu.vue');		at: HTMLDialog		put: #(			'dialog'			'vue/dialog.vue');		keysAndValuesDo: [:key :value |			key				tag: value first				location: value second]! !!VueComponent class methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2019 21:17'!open	"Open an instance of myself on the current webpage."		^self fromURL: location! !!VueComponent class methodsFor: 'as yet unclassified' stamp: 'crl 3/28/2019 13:06'!tag	^tag! !!VueComponent class methodsFor: 'as yet unclassified' stamp: 'crl 3/28/2019 13:05'!tag: string	tag := string! !!VueComponent class methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2019 17:49'!tag: theTag location: theLocation	tag := theTag.	location := theLocation! !!InvalidUTF8 class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!Compiler methodsFor: 'as yet unclassified' stamp: 'crl 4/29/2017 00:44'!javaScriptFor: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock	"Compiles textOrStream into a parse tree, then generates code into a JavaScript source string, and answers it.  If receiver is not nil, then the text can refer to instance variables of that receiver (the Inspector uses this). If aContext is not nil, the text can refer to temporaries in that context (the Debugger uses this). If aRequestor is not nil, then it will receive a notify:at: message before the attempt to evaluate is aborted."	^(		self			compileNoPattern: textOrStream			in: ((aContext == nil ifTrue: [receiver] ifFalse: [aContext receiver]) class)			context: aContext			notifying: aRequestor			ifFail: [^failBlock value]	)		javaScript! !!Compiler class methodsFor: 'as yet unclassified' stamp: 'crl 4/28/2017 17:25'!javaScriptFor: smalltalkSourceString	^self		javaScriptFor: smalltalkSourceString		in: nil		to: nil		notifying: nil		ifFail: []! !!Compiler class methodsFor: 'as yet unclassified' stamp: 'crl 4/28/2017 17:25'!javaScriptFor: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock	^(self new)		javaScriptFor: textOrStream		in: aContext		to: receiver		notifying: aRequestor		ifFail: failBlock! !!Win32 methodsFor: 'as yet unclassified' stamp: 'crl 1/15/2015 00:07'!defaultProcessorNameTail	^'spoon.exe'! !!Win32 methodsFor: 'as yet unclassified' stamp: 'crl 10/24/2016 20:33'!isAbsolutePathname: string	^string size > 2 and: [(string copyFrom: 2 to: 3) = ':\']! !!Win32 methodsFor: 'as yet unclassified' stamp: 'crl 6/12/2001 18:47'!pathFor: aFilename	"Answer the path for aFilename, using my separator conventions."	^((super pathFor: aFilename) copyFrom: 2)		replaceAll: $/		with: self separator! !!Win32 methodsFor: 'as yet unclassified' stamp: 'crl 1/15/2015 00:11'!processorFolderName	^'win32'! !!Win32 methodsFor: 'as yet unclassified' stamp: 'crl 6/12/2001 18:45'!separator	"Answer my filename segment separator."	^$\! !!Win32 class methodsFor: 'as yet unclassified' stamp: 'crl 10/25/2016 22:30'!installerLocatorString	^'http://blackpagedigital.com/context/installers/windows/squeak.exe'! !!Win32 class methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2016 12:00'!userAgentPlatformTagPatterns	^#('Win*')! !!DirectoryEntryFile class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!HostPlatform methodsFor: 'as yet unclassified' stamp: 'crl 1/15/2015 00:05'!defaultProcessorNameTail	^self subclassResponsibility! !!HostPlatform methodsFor: 'as yet unclassified' stamp: 'crl 1/17/2015 17:06'!handleFor: anExternalResource	^anExternalResource cHandle! !!HostPlatform methodsFor: 'as yet unclassified' stamp: 'crl 10/25/2016 16:50'!isAbsolutePathname: string	^string first = self separator! !!HostPlatform methodsFor: 'as yet unclassified' stamp: 'crl 6/12/2001 18:37'!pathFor: aFilename	"Answer the path for aFilename, using my separator conventions."	| stream |	stream := (String new: 16) writeStream.	aFilename printPathOn: stream.	^stream contents! !!HostPlatform methodsFor: 'as yet unclassified' stamp: 'crl 9/12/2012 06:03'!portFromSocketAddressBytes: bytes	^((bytes at: 5) bitShift: 8) + (bytes at: 6)! !!HostPlatform methodsFor: 'as yet unclassified' stamp: 'crl 8/16/2012 12:43'!printOn: aStream	aStream		nextPutAll: 'the ';		print: self class;		nextPutAll: ' platform'! !!HostPlatform methodsFor: 'as yet unclassified' stamp: 'crl 1/14/2015 16:06'!processorFolderName	^self subclassResponsibility! !!HostPlatform methodsFor: 'as yet unclassified' stamp: 'crl 9/7/2016 14:48'!resumeMemory: aMemoryProfile withProcessorParameter: processorParameter andMemoryParameter: memoryParameter	aMemoryProfile		resumeOnPlatform: self		withProcessorParameter: processorParameter		andMemoryParameter: memoryParameter! !!HostPlatform methodsFor: 'as yet unclassified' stamp: 'crl 1/15/2015 04:05'!separator	"Answer my filename segment separator."	^$/! !!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 6/12/2001 18:15'!current	"Answer the current host platform."	^Current! !!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 9/3/2016 23:12'!flow	<primitive: 'greetings' module: 'Flow'>	self primitiveFailed! !!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 10/24/2016 20:22'!initialize	"Initialize myself."	"I don't recall exactly what the platform system attributes are on the non-win32 platforms."	Platforms := (		(Dictionary new)			at: 'Win32' put: Win32;			at: 'Mac OS' put: Macintosh;			at: 'unix' put: Unix;			at: 'Web' put: Web;			yourself).	Smalltalk addToStartUpList: self after: Delay	"Interpreter afterResumingNotify: self"! !!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 10/25/2016 22:29'!installerLocatorString	^self subclassResponsibility! !!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 9/12/2012 06:02'!portFromSocketAddressBytes: bytes	^Current portFromSocketAddressBytes: bytes! !!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2016 12:00'!provides: userAgentPlatformTag	^self userAgentPlatformTagPatterns anySatisfy: [:pattern | pattern match: userAgentPlatformTag]! !!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 9/4/2019 18:35'!resume	"Note the current host platform."	Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.	"Filename resume"! !!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 21:08'!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2016 11:52'!userAgentPlatformTagPatterns	^self subclassResponsibility! !!HTMLPopupMenu methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 14:07'!selectFromBlocks: blocks for: activeElement at: point	| answer answerAvailable |		answerAvailable := Semaphore new.		blocks keysAndValuesDo: [:label :block |		app appendChild: (			((JS top document createElement: 'div') counterpart)				at: #class put: 'menu-item';				innerHTML: label;				onClick: [					self remove.					answer := block value.					answerAvailable signal];				styleAt: #fontSize put: '18px';				at: #onmouseenter put: [:event | event target style at: #backgroundColor put: 'white'];				at: #onmouseleave put: [:event | event target style at: #backgroundColor put: ''];				yourself)].				app		styleAt: #top put: point x printString, 'px';		styleAt: #left put: point y printString, 'px'.	activeElement styleAt: #pointerEvents put: 'none'.	activeElement parentNode parentNode appendChild: app.		answerAvailable wait.	activeElement styleAt: #pointerEvents put: ''.	^answer! !!HTMLPopupMenu class methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 21:01'!selectFromBlocks: blocks for: activeElement at: point	^self open selectFromBlocks: blocks for: activeElement at: point! !!RemoteServiceInstructions methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!RemoteServiceInstructions class methodsFor: 'as yet unclassified' stamp: 'crl 7/20/2018 14:31'!dispatch: instruction in: stream for: service	"Perform service's method corresponding to instruction."	service perform: (classPool keyAtValue: instruction) with: stream! !!RemoteServiceInstructions class methodsFor: 'as yet unclassified' stamp: 'crl 8/29/2016 21:45'!initializeInstructions: instructions	instructions		inject: self instructionsBase		into: [:runningValue :next | 			classPool at: next put: runningValue.			runningValue + 1]! !!RemoteServiceInstructions class methodsFor: 'as yet unclassified' stamp: 'crl 8/29/2016 21:46'!instructionsBase	^1! !!GlobalJSObject methodsFor: 'as yet unclassified' stamp: 'crl 4/27/2017 01:24'!printOn: stream	stream		nextPutAll: 'the ';		print: self class;		nextPutAll: ' global object'! !!GlobalJSObject class methodsFor: 'as yet unclassified' stamp: 'crl 4/27/2017 17:01'!doesNotUnderstand: aMessage	^(aMessage lookupClass: nil; yourself) sentTo: globalObject ! !!GlobalJSObject class methodsFor: 'as yet unclassified' stamp: 'crl 4/27/2017 16:43'!globalObject	^globalObject! !!GlobalJSObject class methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2017 18:33'!ifConnected: block	globalObject ifNotNil: [block value]! !!GlobalJSObject class methodsFor: 'as yet unclassified' stamp: 'crl 4/28/2017 17:13'!initialize	globalObject := (		JS			ifConnected: [self forProxy: (JS perform: name)]			ifNotConnected: [nil])! !!GlobalJSObject class methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2017 18:35'!startUp: resuming	resuming ifTrue: [globalObject := nil]! !!Editor methodsFor: 'as yet unclassified' stamp: 'crl 6/18/2018 15:34'!moveCursor: directionBlock forward: forward event: aKeyboardEvent specialBlock: specialBlock 	"Private - Move cursor.	directionBlock is a one argument Block that computes the new Position from a given one.	specialBlock is a one argumentBlock that computes the new position from a given one under the alternate semantics.	Note that directionBlock always is evaluated first."	| indices newPosition shouldSelect |	shouldSelect := aKeyboardEvent shiftPressed.	indices := self setIndices: shouldSelect forward: forward.	newPosition := directionBlock value: (indices at: #moving).	(aKeyboardEvent commandKeyPressed)		ifTrue: [newPosition := specialBlock value: newPosition].	shouldSelect		ifTrue: [self selectMark: (indices at: #fixed) point: newPosition - 1]		ifFalse: [self selectAt: newPosition]! !!BorderGripMorph class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!Esprima methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!Esprima class methodsFor: 'as yet unclassified' stamp: 'crl 7/23/2017 22:21'!load	Webpage current loadScriptFrom: 'https://unpkg.com/esprima@~3.1/dist/esprima.js'.	globalObject := (JS top at: #esprima) counterpart! !!Esprima class methodsFor: 'as yet unclassified' stamp: 'crl 6/19/2017 12:46'!parse: string	^globalObject parse: string! !!Esprima class methodsFor: 'as yet unclassified' stamp: 'crl 6/19/2017 12:52'!smalltalkFor: javaScriptSource	^(self parse: javaScriptSource) smalltalk! !!JSArray methodsFor: 'as yet unclassified' stamp: 'crl 5/5/2017 16:55'!asArray	| array |		array := Array new: self size.		1		to: self size		do: [:index |			array				at: index				put: (self at: index)].			^array! !!JSArray methodsFor: 'as yet unclassified' stamp: 'crl 5/5/2017 15:36'!at: index	^(proxy at: index - 1) counterpart! !!JSArray methodsFor: 'as yet unclassified' stamp: 'crl 5/6/2017 15:49'!simplestRepresentation	^self asArray! !!JSArray methodsFor: 'as yet unclassified' stamp: 'crl 5/5/2017 16:38'!size	^proxy length! !!JSArray class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!DiffElement methodsFor: 'as yet unclassified' stamp: 'ul 12/26/2009 01:47'!= anObject	^anObject class == self class and: [		anObject hash = hash and: [			anObject string = string ] ]! !!DiffElement methodsFor: 'as yet unclassified' stamp: 'klub 12/27/2009 01:56'!hasMatch	^match notNil! !!DiffElement methodsFor: 'as yet unclassified' stamp: 'ul 12/26/2009 01:10'!hash	^hash! !!DiffElement methodsFor: 'as yet unclassified' stamp: 'ul 12/26/2009 04:38'!match	^match! !!DiffElement methodsFor: 'as yet unclassified' stamp: 'klub 12/27/2009 01:20'!match: aDiffMatch	match := aDiffMatch	! !!DiffElement methodsFor: 'as yet unclassified' stamp: 'klub 12/27/2009 01:20'!matches: aDiffMatch	match := aDiffMatch.	aDiffMatch match: self! !!DiffElement methodsFor: 'as yet unclassified' stamp: 'klub 12/27/2009 01:52'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		print: hash;		nextPutAll: ', ';		print: string;		nextPutAll: ', ';		print: (match class == self class);		nextPut: $)! !!DiffElement methodsFor: 'as yet unclassified' stamp: 'ul 12/26/2009 01:48'!string	^string! !!DiffElement methodsFor: 'as yet unclassified' stamp: 'ul 11/6/2010 02:23'!string: aString	string := aString.	hash := string hash! !!DiffElement class methodsFor: 'as yet unclassified' stamp: 'klub 12/27/2009 01:51'!string: aString	^self new		string: aString;		yourself! !!NotImplemented methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!NotImplemented class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!HTMLLIElement methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!HTMLLIElement class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!StaticMemberExpression methodsFor: 'as yet unclassified' stamp: 'crl 5/7/2017 14:09'!accesses	^true! !!StaticMemberExpression methodsFor: 'as yet unclassified' stamp: 'crl 5/7/2017 14:20'!printSmalltalkAtPutOn: stream	object printSmalltalkOn: stream.	stream nextPutAll: ' at: '.	property printSmalltalkOn: stream.	stream nextPutAll: ' put: '	! !!StaticMemberExpression methodsFor: 'as yet unclassified' stamp: 'crl 5/7/2017 00:30'!printSmalltalkOn: stream	self printSmalltalkOn: stream withArguments: #()! !!StaticMemberExpression methodsFor: 'as yet unclassified' stamp: 'crl 5/7/2017 14:26'!printSmalltalkOn: stream withArguments: arguments	stream nextPut: $(.	object printSmalltalkOn: stream.	stream space.	property printSmalltalkOn: stream.	arguments ifNotEmpty: [		stream nextPutAll: ': '.		arguments first printSmalltalkOn: stream.		2			to: arguments size			do: [:index |				stream nextPutAll: ' with: '.				(arguments at: index) printSmalltalkOn: stream]].	stream nextPut: $)! !!StaticMemberExpression class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!MixedSound class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!ZipReadStream methodsFor: 'as yet unclassified' stamp: 'nk 3/7/2004 18:55'!expectedCrc: aNumberOrNil	"If expectedCrc is set, it will be compared against the calculated CRC32 in verifyCrc.	This number should be the number read from the Zip header (which is the bitwise complement of my crc if all is working correctly)"	expectedCrc := aNumberOrNil! !!ZipReadStream methodsFor: 'as yet unclassified' stamp: 'nk 3/7/2004 15:31'!on: aCollection from: firstIndex to: lastIndex	super on: aCollection from: firstIndex to: lastIndex.	crc := 16rFFFFFFFF.	expectedCrc := nil.! !!ZipReadStream methodsFor: 'as yet unclassified' stamp: 'nk 3/7/2004 15:32'!updateCrc: oldCrc from: start to: stop in: aCollection	^ZipWriteStream updateCrc: oldCrc from: start to: stop in: aCollection! !!ZipReadStream methodsFor: 'as yet unclassified' stamp: 'BG 3/16/2005 08:28'!verifyCrc	"Verify the CRC-32 checksum calculated from the input against the expected CRC-32, if any.	Answer the calculated CRC-32 in any case.	Note that the CRC-32 used in Zip files is actually the bit inverse of the calculated value, so that is what is returned."	| invertedCrc |	invertedCrc := crc bitXor: 16rFFFFFFFF.	(expectedCrc notNil and: [ expectedCrc ~= invertedCrc ])		ifTrue: [ ^ self crcError: ('Wrong CRC-32 (expected {1} got {2}) (proceed to ignore)' translated format: { expectedCrc printStringHex. invertedCrc printStringHex }) ].	^invertedCrc! !!Inspector methodsFor: 'as yet unclassified' stamp: 'crl 9/13/2019 23:35'!printStringErrorText	| nm |	nm := self selectionIndex < 3		ifTrue: ['self']		ifFalse: [self selectedSlotName].	^ (nm		ifNil: ['no selection']		ifNotNil:			[nm first isDigit				ifTrue: ['<error in printString: evaluate "(self at: ' , nm , ') printString" to debug>']				ifFalse: ['<error in printString: evaluate "' , nm , ' printString" to debug>'] ]) asText! !!Inspector methodsFor: 'as yet unclassified' stamp: 'crl 9/13/2019 23:35'!selectionPrintString	| text |	selectionUpdateTime := [text := [self selection isInteger										ifTrue: [self selection storeStringBase: self defaultIntegerBase]										ifFalse: [self selection printString]]						on: Error						do: [text := self printStringErrorText.							text								addAttribute: TextColor red								from: 1								to: text size.							text]] timeToRun.	^ text! !!Inspector class methodsFor: 'as yet unclassified' stamp: 'crl 9/10/2017 20:46'!openOn: anObject	"Create and schedule an instance of me on the model, anInspector. "	^self openOn: anObject inWorld: ActiveWorld! !!Inspector class methodsFor: 'as yet unclassified' stamp: 'crl 9/10/2017 21:24'!openOn: anObject inWorld: world	^self		openOn: anObject		withExpression: ''		inWorld: world! !!Inspector class methodsFor: 'as yet unclassified' stamp: 'crl 9/10/2017 21:24'!openOn: anObject withExpression: expression inWorld: world	^self		openOn: anObject		withExpression: expression		withLabel: anObject defaultLabelForInspector		inWorld: world! !!Inspector class methodsFor: 'as yet unclassified' stamp: 'crl 9/10/2017 21:22'!openOn: anObject withExpression: expression withLabel: label inWorld: world	| inspector |	inspector := self inspect: anObject.		inspector setExpression: expression.		ToolBuilder		open: inspector		label: label		world: world.			^inspector! !!Inspector class methodsFor: 'as yet unclassified' stamp: 'crl 4/2/2019 16:06'!openOn: anObject withLabel: ignored	"Create and schedule an instance of me on the model, anInspector. "	^self openOn: anObject! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 2/28/2006 16:06'!<= aNote	^(pitch == nil)		ifTrue: [degree <= aNote degree]		ifFalse: [pitch <= aNote pitch]! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 8/22/2017 11:16'!= aNote	"Answer whether I am equivalent to aNote."	^super = aNote and: [		pitch = aNote pitch and: [self loudness = aNote loudness]]! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2005 19:47'!addUninitializedAspectsTo: aspects	self hasIndefinitePitch ifTrue: [aspects add: 'pitch']! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2004 01:28'!appliedTo: anObject	"Answer the application of myself to anObject."	^anObject applyNote: self! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 12/4/2007 23:48'!applyInteger: anInteger	"Set my volume from anInteger, and answer myself."	self applyFraction: (anInteger min: 1)! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 8/28/2017 12:55'!applyNote: note	"Answer a sequence of myself followed by note."	note completeFrom: self.	self completeFrom: note.	^Sequence withAll: {		self.		note}! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 8/29/2017 19:32'!applyPitch: aPitch	^pitch		ifNil: [			"If I don't have a pitch yet, set it."			pitch _ aPitch.			self]		ifNotNil: [			"If I already have a pitch, answer a sequence."			Sequence withAll: {				self.				Note withPitch: aPitch}]! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 2/28/2006 17:21'!applyPitchSet: aPitchSet	(degree == nil)		ifTrue: [			(self hasIndefinitePitch)				ifTrue: [self error: 'I have no degree or pitch to map.']				ifFalse: [degree _ pitch in: aPitchSet]]		ifFalse: [pitch _ degree in: aPitchSet]! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2005 17:14'!applyScaleDegree: aScaleDegree	degree _ aScaleDegree! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 1/24/2003 04:12'!applyVelocity: aMIDIVelocity	"Set my volume from aMIDIVelocity, and answer myself."	self applyInteger: aMIDIVelocity index! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2005 21:38'!asRoot	"Answer myself as a RootNote."	^RootNote new completeFrom: self! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 8/28/2017 13:43'!completeFrom: note	"Set my uninitialized parameters from note."	super completeFrom: note.	degree == nil ifTrue: [degree _ note degree].	self hasIndefinitePitch ifTrue: [pitch _ note pitch]! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 01:41'!dataBytes	^{		pitch midiNoteNumber.		(self loudness * 127) asInteger}! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2005 20:16'!degree	^degree! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 9/17/2005 02:02'!degree: aScaleDegree	degree _ aScaleDegree! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2005 16:57'!delayInMilliseconds	^delayInMilliseconds! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2005 19:49'!down	self hasIndefinitePitch ifFalse: [pitch down].	degree == nil ifFalse: [degree down]! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2005 19:49'!flat	self hasIndefinitePitch ifFalse: [pitch flat].	degree == nil ifFalse: [degree flat]! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2005 19:46'!hasIndefinitePitch	^pitch == Pitch indefinite! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 10/5/2004 11:19'!hasNoAbsoluteDuration	^false! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 8/22/2017 11:17'!hash	"Answer a hash which all objects equivalent to me share."	^super hash + pitch hash + absoluteLoudness hash + relativeLoudness hash! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 9/6/2008 13:05'!initialize	"Initialize myself."	super initialize.	pitch _ Pitch indefinite! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 8/23/2017 15:30'!initializeFrom: aMIDIStream	pitch := (aMIDIStream next)th key.	self applyAbsoluteLoudness: (AbsoluteLoudness withNormalizedValue: aMIDIStream next / 127)! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2005 19:48'!isPlayable	^super isPlayable and: [self hasIndefinitePitch not]! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 8/22/2017 11:17'!isSilent	^self loudness = 0! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 8/22/2017 11:18'!packet	^super packet + (pitch midiNoteNumber bitShift: 8) + ((self loudness * 127) asInteger bitShift: 16)! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 1/24/2003 04:29'!pitch	"Answer my pitch."	^pitch! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 1/19/2003 16:42'!pitch: aPitch	"Set my pitch to aPitch."	pitch _ aPitch! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2005 19:48'!postCopy	self hasIndefinitePitch ifFalse: [pitch _ pitch copy]! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 01:25'!printBytesOn: stream	super printBytesOn: stream.	stream		nextPut: pitch midiNoteNumber;		nextPut: (self loudness * 127) asInteger! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 8/24/2017 12:48'!printOn: aStream	"Print a textual representation of myself on aStream."	(self hasIndefinitePitch and: [degree == nil])		ifTrue: [aStream nextPutAll: 'no particular pitch']		ifFalse: [			(self hasIndefinitePitch)				ifTrue: [aStream print: degree]				ifFalse: [					aStream print: pitch.					degree == nil ifFalse: [						aStream							nextPutAll: ' (';							print: degree;							nextPut: $)]]].	aStream		nextPutAll: ', at ';		print: absoluteLoudness.	super printOn: aStream! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 1/31/2005 22:14'!processPlayingRandomlyWithin: minimumMillisecondDuration and: maximumMillisecondDuration	"Answer a Process which randomly plays me at random intervals, between minimumMillisecondDuration and maximumMillisecondDuration."	| randomNumberStream |	randomNumberStream _ Random new.	^[		[			self, (randomNumberStream nextIntegerBetween: minimumMillisecondDuration and: maximumMillisecondDuration) milliseconds.			self play		]			repeat	]		newProcess! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2005 19:48'!sharp	self hasIndefinitePitch ifFalse: [pitch sharp].	degree == nil ifFalse: [degree sharp]! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 1/22/2003 03:23'!statusMask	"Answer the eight-bit value which serves as the message-type indicator in my MIDI status byte."	^noteOn! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 8/22/2017 11:18'!storeOn: aStream	"Store on aStream a Smalltalk expression which, when evaluated, will yield an object equivalent to me."	aStream		nextPut: $(;		nextPutAll: self class name;		nextPutAll: ' withPitch: ';		store: pitch;		nextPutAll: '), ';		print: self loudness numerator;		nextPutAll: ' percent volume'.	super storeOn: aStream! !!Note methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2005 19:48'!up	self hasIndefinitePitch ifFalse: [pitch up].	degree == nil ifFalse: [degree up]! !!Note class methodsFor: 'as yet unclassified' stamp: 'crl 12/28/2004 01:20'!activeNotes	"Answer the ActiveNotes."	^ActiveNotes! !!Note class methodsFor: 'as yet unclassified' stamp: 'crl 1/31/2005 22:17'!chineseCymbal	^(GeneralMIDIPitch chineseCymbal name: 'chinese cymbal'), 10th channel! !!Note class methodsFor: 'as yet unclassified' stamp: 'crl 1/31/2005 22:51'!claves	^(GeneralMIDIPitch claves name: 'claves'), 10th channel! !!Note class methodsFor: 'as yet unclassified' stamp: 'crl 1/24/2005 18:41'!closedHiHat	^(GeneralMIDIPitch hiHatClosed name: 'closed hihat'), 10th channel! !!Note class methodsFor: 'as yet unclassified' stamp: 'crl 2/17/2006 14:58'!initialize	"Initialize myself."	tagMinimum _ 16r80.	tagMaximum _ 16r9F.	ActiveNotes _ IdentitySet new! !!Note class methodsFor: 'as yet unclassified' stamp: 'crl 2/17/2006 17:45'!isConcreteClassForTag: tag	^(tag >= tagMinimum) and: [tag <= tagMaximum]! !!Note class methodsFor: 'as yet unclassified' stamp: 'crl 1/24/2005 18:42'!kick	^self kickdrum! !!Note class methodsFor: 'as yet unclassified' stamp: 'crl 1/24/2005 18:41'!kickdrum	^(GeneralMIDIPitch bassDrumH name: 'kick drum'), 10th channel! !!Note class methodsFor: 'as yet unclassified' stamp: 'crl 2/1/2005 01:49'!rest	^(GeneralMIDIPitch rest name: 'rest'), 10th channel! !!Note class methodsFor: 'as yet unclassified' stamp: 'crl 1/24/2005 18:43'!snare	^(GeneralMIDIPitch snareM name: 'snare'), 10th channel! !!Note class methodsFor: 'as yet unclassified' stamp: 'crl 9/17/2005 02:01'!withDegree: aScaleDegree	"Answer a new instance of myself which conveys aScaleDegree when played."	^self new degree: aScaleDegree! !!Note class methodsFor: 'as yet unclassified' stamp: 'crl 1/19/2003 16:42'!withPitch: aPitch	"Answer a new instance of myself which conveys aPitch when played."	^self new pitch: aPitch! !!InstanceVariableNode class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!Macintosh methodsFor: 'as yet unclassified' stamp: 'crl 1/15/2015 00:06'!defaultProcessorNameTail	^'Spoon VM Opt'! !!Macintosh methodsFor: 'as yet unclassified' stamp: 'crl 9/12/2012 06:03'!portFromSocketAddressBytes: bytes	^((bytes at: 6) bitShift: 8) + (bytes at: 5)! !!Macintosh methodsFor: 'as yet unclassified' stamp: 'crl 1/15/2015 00:11'!processorFolderName	^'MacOS'! !!Macintosh class methodsFor: 'as yet unclassified' stamp: 'crl 10/25/2016 22:29'!installerLocatorString	^'http://blackpagedigital.com/context/installers/macos/Squeak.pkg'! !!Macintosh class methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2016 11:53'!userAgentPlatformTagPatterns	^#('Mac*')! !!DecompilerConstructorForClosures class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!TextDomainManager methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!TextDomainManager class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 21:42'!updateDomainOfMethod: aCompiledMethod 	"First it looks for the package of the method reference (using	the PackageOrganizer: deadly slow). If the method doesn't	belong to any package it uses the default domain. Finally it	stores the text domain of the method using a method	property, this way we gain performance the next time we	translate the same method because we avoid the use of	PackageOrganizer. Have I mentioned it is really slow? :)"	^ aCompiledMethod		propertyValueAt: self textDomainProperty		put: TextDomainManager defaultDomain! !!WeakActionSequence class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!ObjectFinalizerCollection class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!TTCompositeGlyph class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!JSdp methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSdp class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!InMidstOfFileinNotification class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!CanvasRenderingContext2D methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!CanvasRenderingContext2D class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!OutOfScopeNotification class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!KSX1001 methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!TestFailure class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!Other methodsFor: 'as yet unclassified' stamp: 'crl 10/25/2016 22:36'!doesNotUnderstand: message	^OutgoingMessageExchange		forward: message		for: remoteIdentity		over: tether! !!Other methodsFor: 'as yet unclassified' stamp: 'crl 10/25/2016 22:36'!forward: message	^OutgoingMessageExchange		forward: message		for: remoteIdentity		over: tether! !!Other methodsFor: 'as yet unclassified' stamp: 'crl 3/20/2019 14:32'!printOn: stream	^self forward: (Message selector: #printOn: argument: stream)! !!Other methodsFor: 'as yet unclassified' stamp: 'crl 3/20/2019 14:31'!printString	^self forward: (Message selector: #printString)! !!Other methodsFor: 'as yet unclassified' stamp: 'crl 10/7/2016 02:53'!recyclingHash	"Answer a hash for the purpose of deciding whether or not I should be recycled."	^(		(remoteIdentity == nil)			ifTrue: [0]			ifFalse: [remoteIdentity]	)		+ tether hash! !!Other methodsFor: 'as yet unclassified' stamp: 'crl 10/4/2016 17:44'!remoteIdentity: aSmallInteger tether: aTether 	remoteIdentity := aSmallInteger.	tether := aTether! !!Other methodsFor: 'as yet unclassified' stamp: 'crl 5/20/2018 23:24'!storeOnTether: aTether
	(aTether == tether)
		ifTrue: [tether nextWordPut: remoteIdentity]
		ifFalse: [
			aTether store: (
				OtherMarker new exposureHash: (
					aTether
						expose: self
						as: self recyclingHash))]! !!Other methodsFor: 'as yet unclassified' stamp: 'crl 10/5/2016 02:05'!tether	^tether! !!Other class methodsFor: 'as yet unclassified' stamp: 'crl 8/29/2016 21:31'!firstInstanceSuchThat: testBlock ifNone: failureBlock	"Answer the first of my instances for which aBlockClosure evaluates to true. If there aren't any, answer the result of evaluating failureBlock."	self allInstancesDo: [:instance | (testBlock value: instance) ifTrue: [^instance]].	^failureBlock value! !!Other class methodsFor: 'as yet unclassified' stamp: 'crl 9/1/2016 17:49'!fromTether: tether	^self		withRemoteIdentity: (tether nextWord - OtherMarkerTagBase)		andTether: tether! !!Other class methodsFor: 'as yet unclassified' stamp: 'crl 10/20/2016 17:02'!initialize	Smalltalk addToStartUpList: self after: Delay! !!Other class methodsFor: 'as yet unclassified' stamp: 'crl 10/5/2016 02:12'!new	^self basicNew! !!Other class methodsFor: 'as yet unclassified' stamp: 'crl 10/20/2016 16:58'!reset	| proxy thisProxy |	proxy := self someInstance.	[proxy isNil] whileFalse: [		thisProxy := proxy.		proxy := proxy nextInstance.		(Array with: thisProxy) elementsExchangeIdentityWith: (Array with: (Array with: thisProxy recyclingHash))].	Smalltalk garbageCollect! !!Other class methodsFor: 'as yet unclassified' stamp: 'crl 10/20/2016 16:58'!startUp: resuming	resuming ifTrue: [self reset]! !!Other class methodsFor: 'as yet unclassified' stamp: 'crl 10/4/2016 17:44'!withRemoteIdentity: aSmallInteger andTether: tether	"Answer a new instance of myself which which corresponds to the remote object with identity aSmallInteger, reachable via tether's network connections."	| recyclingHashValue |	recyclingHashValue := aSmallInteger + tether hash.	^self		firstInstanceSuchThat: [:other | other recyclingHash = recyclingHashValue]		ifNone: [			(self new)				remoteIdentity: aSmallInteger				tether: tether]! !!Symbol methodsFor: 'as yet unclassified' stamp: 'crl 5/29/2017 17:54'!storeJavaScriptOn: stream	self asString storeJavaScriptOn: stream! !!Symbol methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 03:50'!tag	"Answer my proxy tag."	^SymbolTag! !!Symbol methodsFor: 'as yet unclassified' stamp: 'cmm 8/13/2013 15:02'!veryDeepCopy	"Overridden for performance."	^ self! !!Symbol class methodsFor: 'as yet unclassified'!fromTether: tether	^(super fromTether: tether) asSymbol! !!Mesh methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!Mesh class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!Operations methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!Operations class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!Operations class methodsFor: 'as yet unclassified' stamp: 'crl 9/14/2019 00:00'!initialize	connect := 0.	accept := 1.	read := 2.	write := 3! !!ChannelVoiceMessage methodsFor: 'as yet unclassified' stamp: 'crl 2/17/2006 13:46'!= aChannelVoiceMessage	"Answer whether I am equivalent to aChannelVoiceMessage."	^self class = aChannelVoiceMessage class and: [channel = aChannelVoiceMessage channel]! !!ChannelVoiceMessage methodsFor: 'as yet unclassified' stamp: 'crl 2/17/2006 13:46'!completeFrom: aChannelVoiceMessage	"Set my uninitialized parameters from aChannelVoiceMessage."	channel == nil ifTrue: [channel _ aChannelVoiceMessage channel]! !!ChannelVoiceMessage methodsFor: 'as yet unclassified' stamp: 'crl 2/17/2006 13:46'!hash	"Answer a hash which all objects equivalent to me share."	^super hash + channel hash! !!ChannelVoiceMessage methodsFor: 'as yet unclassified' stamp: 'crl 2/17/2006 13:46'!isPlayable	^super isPlayable and: [channel notNil]! !!ChannelVoiceMessage methodsFor: 'as yet unclassified' stamp: 'crl 2/17/2006 13:46'!statusByte	"Answer the first byte of my MIDI scheduling data."	^self statusMask + channel index - 1! !!ChannelVoiceMessage methodsFor: 'as yet unclassified' stamp: 'crl 2/17/2006 13:46'!storeOn: aStream	channel == nil ifFalse: [		aStream			nextPutAll: ', ';			store: channel]! !!ChannelVoiceMessage class methodsFor: 'as yet unclassified' stamp: 'crl 9/7/2008 22:31'!initialize	"Initialize myself."	tagMinimum _ 16r80.	tagMaximum _ 16rEF! !!PublishedVariableDictionaryLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2012 14:57'!literal	^self activeClass publishedPools associationAt: name! !!PublishedVariableDictionaryLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 6/23/2011 00:28'!name: aSymbol	name _ aSymbol! !!PublishedVariableDictionaryLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 6/24/2011 02:23'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: ' and name ';		nextPutAll: name! !!PublishedVariableDictionaryLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2016 15:16'!storeOnTether: tether	"Store a copy of myself on tether, suitable for re-animation in a remote system."	super storeOnTether: tether.	name storeOnTether: tether! !!PublishedVariableDictionaryLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 16:46'!tag	^PublishedVariableDictionaryLiteralMarkerTag! !!PublishedVariableDictionaryLiteralMarker class methodsFor: 'as yet unclassified' stamp: 'crl 10/1/2016 01:24'!canRepresent: literal inMethod: aCompiledMethod of: aClass	(aClass isMeta and: [literal isKindOf: Association]) ifTrue: [		| givenPool pools |		pools := aClass soleInstance sharedPools.		givenPool := literal value.		pools isEmpty ifFalse: [			pools do: [:pool |				(pool == givenPool) ifTrue: [^true]]]].	^false! !!PublishedVariableDictionaryLiteralMarker class methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2012 20:14'!forLiteral: literal inMethod: aCompiledMethod ofClass: aMetaclass	"Answer an instance representing literal when transferring aCompiledMethod from aMetaclass."	^(self forLiteralDefinedByClass: (Object allSubclasses detect: [:subclass | subclass isMeta not and: [subclass publishedPools notNil and: [subclass publishedPools includesAssociation: literal]]]))		name: literal key;		yourself! !!PublishedVariableDictionaryLiteralMarker class methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 18:52'!fromTether: tether	"Answer an instance of myself composed from bytes supplied by aStream, and objects supplied by anObjectTransferCorrespondent."	^(super fromTether: tether) name: tether next! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 7/28/2016 16:10'!apiAt: apiName	^apis at: apiName! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 8/8/2016 21:29'!callFunction: function on: reference	^self		callFunction: function		on: reference		with: #()! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 8/8/2016 21:27'!callFunction: function on: reference returnByValue: returnByValue	^self		callFunction: function		on: reference		with: #()		returnByValue: returnByValue! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 8/8/2016 21:28'!callFunction: function on: reference with: parameters	^self		callFunction: function		on: reference		with: parameters		returnByValue: false! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 8/8/2016 21:22'!callFunction: function on: reference with: parameters returnByValue: returnByValue	^runtime resultOf: [		runtime callFunctionOn: {			'objectId' -> reference.			'functionDeclaration' -> function.			'arguments' -> parameters.			'returnByValue' -> returnByValue}]! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 7/21/2017 17:30'!close	transport ifNotNil: [transport close].	outstandingMessages := IdentityDictionary new.	nextPacketID := 1.	apis do: [:api | api initialize].	messages := OrderedCollection new! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 7/21/2017 17:30'!debug	(transport notNil and: [transport readyState = 1]) ifTrue: [		"I'm already debugging."		^false].	self close.	webSocketDebuggerUrl ifNil: [3 halt].	transport := (		(JS WebSocket new: webSocketDebuggerUrl printString)			onopen: [:event |				console enable.				page enable; getResourceTree.				runtime enable.				debugger					enable;					setPauseOnExceptions: {'state' -> 'none'};					setAsyncCallStackDepth: {'maxDepth' -> 0}.				dom enable.				css enable.				worker					setWaitForDebuggerOnStart: {'value' -> true};					enable.				profiler					enable;					setSamplingInterval: {'interval' -> 100}.				serviceWorker enable.				page setAutoAttachToCreatedPages: {'autoAttach' -> false}.				emulation setScriptExecutionDisabled: {'value' -> false}.				rendering setShowViewportSizeOnResize: {'show' -> true}.				runtime run.				inspector enable];			onmessage: [:dictionary |				| message |								message := (					ChromeDebuggingMessage						fromDictionary: (WebUtils jsonDecode: dictionary data asString readStream)						for: self).										messages add: message.				(message invokes)					ifTrue: [message perform]					ifFalse: [(outstandingMessages removeKey: message id) deliver: message result]];			yourself).				^true! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 5/12/2017 16:43'!debugger	^debugger! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 7/22/2017 00:27'!dom	^dom! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 7/23/2017 23:16'!evaluate: expression	| result |		result := (		self			send: 'Runtime.evaluate'			withParameters: {				#expression -> expression.				#includeCommandLineAPI -> true}).					(result properties includes: #exceptionDetails)		ifTrue: [self error: result exceptionDetails exception description]		ifFalse: [result := result result].	^(result properties includes: #objectId)		ifTrue: [			ChromeRemoteObject				withID: result objectId				andTab: self]		ifFalse: [result proxy at: #value]! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 8/9/2016 20:37'!fieldsOf: reference	| names objects |		names := (		(			self				callFunction: 'function () {return Object.keys(this)}'				on: reference				returnByValue: true		)			result at: #value).	objects := Dictionary new.	names do: [:name |		| type |				type := (			(				self					callFunction: ('function () {return typeof this.', name, '}')					on: reference					returnByValue: true			)				result at: 'value').		objects			at: name			put: (				(type = 'object')					ifTrue: [						| object |												object := (							(								self									callFunction: ('function () {return this.', name, '}')									on: reference							)								result).														(object includesKey: 'value')							ifTrue: [object at: 'value']							ifFalse: [object objectId]]					ifFalse: [type])].			^objects! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 7/24/2017 15:41'!find: searchString	| results |		self send: 'DOM.enable'.		results := (		self			send: 'DOM.performSearch'			withParameters: {#query -> searchString}).					results resultCount = 0 ifTrue: [^nil].		^(		self			send: 'DOM.getSearchResults'			withParameters: {				#searchId -> results searchId.				#fromIndex -> 0.				#toIndex -> results resultCount}	)		nodeIds collect: [:nodeID |			ChromeRemoteObject				withID: (					(						self							send: 'DOM.resolveNode'							withParameters: {#nodeId -> nodeID}					)						object objectId)				andTab: self]! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 8/22/2016 01:34'!html	^page html! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 8/1/2016 23:56'!id	^id! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 5/13/2017 12:43'!id: integer	id := integer! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 8/3/2016 15:48'!initializeFrom: dictionary	id := UUID fromString: (dictionary at: 'id').	description := dictionary at: 'description'.	(dictionary includesKey: 'faviconUrl') ifTrue: [faviconUrl := Url absoluteFromText: (dictionary at: 'faviconUrl')].	type := dictionary at: 'type'.	url := Url absoluteFromText: (dictionary at: 'url').	title := dictionary at: 'title'.	(dictionary includesKey: 'webSocketDebuggerUrl') ifTrue: [webSocketDebuggerUrl := Url absoluteFromText: (dictionary at: 'webSocketDebuggerUrl')].	(dictionary includesKey: 'devtoolsFrontendUrl') ifTrue: [devtoolsFrontendUrl := Url absoluteFromText: (dictionary at: 'devtoolsFrontendUrl')]! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 9/16/2019 18:22'!initializeFromTabInfo: tabInfo	id := tabInfo id.	faviconUrl := tabInfo at: #favIconUrl ifAbsent: [nil].	url := Url absoluteFromText: tabInfo url.	title := tabInfo title! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 7/21/2017 17:31'!invokeSelector: selector withParameters: parameters ofAPI: api	| packet |		packet := (		ChromeMethodInvocation			invokingSelector: selector			withParameters: parameters			ofAPI: api).	packet id: nextPacketID.	nextPacketID := nextPacketID + 1.		outstandingMessages		at: packet id		put: packet.			packet sendTo: transport! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 7/24/2017 15:17'!loadJQueryRotatable	JQuery loadRotatableInto: self! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 8/18/2016 21:48'!outerHTML	^self evaluate: 'top.document.body.outerHTML'! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 8/22/2016 03:23'!outerHTML: string	page html: string! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 9/16/2019 22:21'!pause	transport pauseTabWithID: id! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 7/27/2016 23:31'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: ' entitled ''';		nextPutAll: title;		nextPut: $'! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 8/11/2016 10:23'!resourceTree	page getResourceTree.	[page resourceTree isNil or: [page resourceTree isEmpty]] whileTrue: [(Delay forMilliseconds: 300) wait].	^page resourceTree! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 5/13/2017 12:35'!resume	transport resumeTabWithID: id! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 7/24/2017 14:27'!root	^dom root! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 8/5/2016 21:23'!scriptURLs	^debugger scriptURLs! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 7/22/2017 01:29'!send: selector	^self send: selector withParameters: {}! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 7/21/2017 23:40'!send: selector withParameters: parameters	^transport		send: selector		withParameters: parameters		toTabWithID: id! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 8/15/2016 23:09'!setFieldNamed: fieldName ofObjectWithReference: reference from: valueString	self		callFunction: ('function () {this.', fieldName, ' = ', valueString, '}')		on: reference! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 8/1/2016 11:53'!title	^title! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 8/8/2016 21:55'!topObjects	^self fieldsOf: (self evaluate: '(document.getElementById("snowglobe")).contentWindow') result objectId! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 7/21/2017 17:35'!transport	^transport! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 7/22/2017 01:04'!transport: websocketOrExtension	transport := websocketOrExtension.	apis := (		(Dictionary new)			at: #Console put: (console := ChromeConsoleAPI for: self);			at: #Network put: (network := ChromeNetworkAPI for: self);			at: #Page put: (page := ChromePageAPI for: self);			at: #Runtime put: (runtime := ChromeRuntimeAPI for: self);			at: #Debugger put: (debugger := ChromeDebuggerAPI for: self);			at: #DOM put: (dom := ChromeDOMAPI for: self);			at: #CSS put: (css := ChromeCSSAPI for: self);			at: #Worker put: (worker := ChromeWorkerAPI for: self);			at: #Profiler put: (profiler := ChromeProfilerAPI for: self);			at: #ServiceWorker put: (serviceWorker := ChromeServiceWorkerAPI for: self);			at: #Emulation put: (emulation := ChromeEmulationAPI for: self);			at: #Rendering put: (rendering := ChromeRenderingAPI for: self);			at: #Inspector put: (inspector := ChromeInspectorAPI for: self);			at: #Security put: (security := ChromeSecurityAPI for: self);			yourself).				self close	! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 8/9/2016 17:47'!typeof: reference	^self		callFunction: 'function () {return typeof this}'		on: reference		returnByValue: true! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 8/3/2016 13:10'!url	^url! !!ChromeTab methodsFor: 'as yet unclassified' stamp: 'crl 8/9/2016 21:46'!valueOfField: fieldName of: reference	^(		self			callFunction: ('function () {return this.', fieldName, '}')			on: reference			returnByValue: true	)		result at: 'value'! !!ChromeTab class methodsFor: 'as yet unclassified' stamp: 'crl 7/27/2017 16:34'!appID	^'915989b9-cf0d-43d6-bf78-a23dc0063d71'! !!ChromeTab class methodsFor: 'as yet unclassified' stamp: 'crl 7/22/2017 01:03'!forTransport: transport	^self new transport: transport! !!ChromeTab class methodsFor: 'as yet unclassified' stamp: 'crl 7/27/2016 22:43'!fromDictionary: dictionary	^self new initializeFrom: dictionary! !!FileWriteError methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!FileWriteError class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!ReadStream methodsFor: 'as yet unclassified' stamp: 'crl 7/20/2018 14:43'!nextBitmap	"Answer the next Bitmap from the current incoming event."		| bitmapType bytes |	bitmapType := self nextByte.	bytes := self nextBytes.	^(bitmapType = 1)		ifTrue: [			"Squeak"			Bitmap decompressFromByteArray: bytes]		ifFalse: [			"VisualWorks"			bytes := bytes unzipped.			(Bitmap new: (bytes size / 4) ceiling) decompressFromVisualWorksByteArray: bytes]! !!ReadStream methodsFor: 'as yet unclassified' stamp: 'crl 7/20/2018 14:48'!nextBoolean	"Answer the next boolean from the current incoming event."		^self nextByte = 1! !!ReadStream methodsFor: 'as yet unclassified' stamp: 'crl 7/20/2018 14:39'!nextByte	"Answer the next byte from the current incoming event."		^self next yourselfUnlessNil: [World halt: 'end of stream']! !!ReadStream methodsFor: 'as yet unclassified' stamp: 'crl 7/20/2018 14:40'!nextBytes	"Answer the next group of bytes from the current incoming event."		^self next: self nextInteger! !!ReadStream methodsFor: 'as yet unclassified' stamp: 'crl 7/20/2018 14:48'!nextInteger	"Answer the next integer from the current incoming event."		| integer shift sizeByte negative |	integer := shift := 0.	sizeByte := self nextByte.	negative := (sizeByte >= 2r10000000).	(sizeByte bitAnd: 2r1111111) timesRepeat: [		integer := integer + (self nextByte bitShift: shift).		shift := shift + 8].	^negative		ifTrue: [integer negated]		ifFalse: [integer]! !!ReadStream methodsFor: 'as yet unclassified' stamp: 'crl 7/20/2018 14:48'!nextPoint	"Answer the next Point from the current incoming event."		^self nextInteger @ self nextInteger! !!ReadStream methodsFor: 'as yet unclassified' stamp: 'crl 7/20/2018 14:49'!nextRectangle	"Answer the next Rectangle from the current incoming event."		^self nextPoint corner: self nextPoint! !!ReadStream methodsFor: 'as yet unclassified' stamp: 'crl 7/20/2018 14:49'!nextString	"Answer the next String from the current incoming event."		^String fromByteArray: self nextBytes! !!ReadStream methodsFor: 'as yet unclassified' stamp: 'crl 7/20/2018 14:49'!nextSymbol	"Answer the next Symbol from the current incoming event."		^self nextString asSymbol! !!ReadStream methodsFor: 'as yet unclassified' stamp: 'crl 7/20/2018 14:49'!nextUUID	"Answer the next UUID from the current incoming event."		^UUID withAll: self nextBytes! !!ReadStream methodsFor: 'as yet unclassified' stamp: 'crl 7/20/2018 14:40'!nextWord	| bytes |	bytes := self next: 4.	^((bytes at: 1) bitShift: 24) + ((bytes at: 2) bitShift: 16) + ((bytes at: 3) bitShift: 8) + (bytes at: 4)! !!ToolBuilderSpec class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!ProvideAnswerNotification methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!ProvideAnswerNotification class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!ProcessorScheduler class methodsFor: 'as yet unclassified' stamp: 'ul 6/17/2011 12:41'!idleProcess	"A default background process which is invisible."	[self relinquishProcessorForMicroseconds: 1000] repeat! !!XMLInvalidException methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!XMLInvalidException class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!BlockStartLocator class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!BalloonEngineConstants methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!SAXParseException methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!SAXParseException class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!EncodedCharSet methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!ToolSet methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!TagsEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2008 20:22'!addTags: anArray	tags add: anArray! !!TagsEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/9/2011 22:01'!component	^taggedEdition! !!TagsEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2008 21:41'!includesTags: anArray	^tags includes: anArray! !!TagsEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/6/2008 12:03'!initialize	super initialize.	self tags: Set new! !!TagsEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 16:44'!printComponentNameOn: aStream withOuterAuthor: anAuthorEdition	(tags isEmpty)		ifTrue: [aStream nextPutAll: 'an empty tag set']		ifFalse: [			aStream nextPutAll: 'the tags '.			tags printVerboselyOn: aStream].		aStream			nextPutAll: ' for ';			print: taggedEdition.		('* by *' match: aStream contents) ifFalse: [			aStream nextPut: $,.			self printAuthorOn: aStream withOuterAuthor: anAuthorEdition]! !!TagsEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 15:50'!storeOnTether: tether	super storeOnTether: tether.	tether store: tags asArray! !!TagsEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 16:45'!tag	^TagsEditionTag! !!TagsEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2008 20:19'!taggedEdition: aTaggedEdition	taggedEdition := aTaggedEdition! !!TagsEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/10/2011 12:13'!tags	| allTags |	allTags := Set new.	tags do: [:set | allTags addAll: set].	^allTags! !!TagsEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/6/2008 12:03'!tags: aSet	tags := aSet! !!TagsEdition class methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2008 20:20'!about: aTaggedEdition	^self new taggedEdition: aTaggedEdition! !!TagsEdition class methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 18:52'!fromTether: tether	^(super fromTether: tether) tags: (Set withAll: tether next)! !!CommentedEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2008 21:44'!activeCommentEdition	^activeCommentEdition! !!CommentedEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/6/2008 11:51'!activeCommentEdition: aCommentEdition	activeCommentEdition := aCommentEdition! !!CommentedEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2008 19:59'!applyComment: aString	| newCommentEdition |	newCommentEdition := CommentEdition forComment: aString about: self.	activeCommentEdition ifNotNil: [		activeCommentEdition nextEdition: newCommentEdition.		newCommentEdition previousEdition: activeCommentEdition].	activeCommentEdition := newCommentEdition! !!CommentedEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/10/2011 13:26'!comment	^activeCommentEdition comment! !!CommentedEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2008 21:43'!previousEdition: anEdition	super previousEdition: anEdition.	activeCommentEdition := previousEdition activeCommentEdition! !!CommentedEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 15:46'!storeOnTether: tether	super storeOnTether: tether.	tether store: activeCommentEdition! !!CommentedEdition class methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 18:50'!fromTether: tether	| commentedEdition commentEdition |	commentedEdition := super fromTether: tether.	commentEdition := tether next.	commentedEdition activeCommentEdition: commentEdition.	commentEdition ifNotNil: [commentEdition commentedEdition: commentedEdition].	^commentedEdition! !!Latin1 methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!TransferMorph methodsFor: 'as yet unclassified' stamp: 'nk 6/16/2003 16:51'!aboutToBeGrabbedBy: aHand 	"The receiver is being grabbed by a hand.                           	Perform necessary adjustments (if any) and return the actual morph    	     that should be added to the hand."	"Since this morph has been initialized automatically with bounds origin   	     0@0, we have to move it to aHand position."	super aboutToBeGrabbedBy: aHand.	self draggedMorph.	self align: self bottomLeft with: aHand position.	aHand newKeyboardFocus: self.! !!TransferMorph methodsFor: 'as yet unclassified' stamp: 'sr 6/6/2000 07:19'!animationForMoveSuccess: success 	| start stop slideForm |	success		ifTrue: [^ self]		ifFalse: 			[start := self fullBounds origin.			stop := self source bounds origin].	start = stop ifTrue: [^ self].	slideForm := self imageFormForRectangle: ((self fullBounds origin corner: self fullBounds corner + self activeHand shadowOffset)					merge: self activeHand bounds).	slideForm offset: 0 @ 0.	slideForm		slideWithFirstFrom: start		to: stop		nSteps: 12		delay: 20! !!TransferMorph methodsFor: 'as yet unclassified' stamp: 'dgd 3/7/2003 15:00'!defaultColor"answer the default color/fill style for the receiver"	^ Color blue alpha: 0.4! !!TransferMorph methodsFor: 'as yet unclassified' stamp: 'cmm 8/3/2004 11:05'!delete	"See also >>justDroppedInto:event:."	self changed: #deleted.	self breakDependents.	super delete! !!TransferMorph methodsFor: 'as yet unclassified' stamp: 'panda 4/28/2000 16:11'!dragTransferType	^transferType! !!TransferMorph methodsFor: 'as yet unclassified' stamp: 'panda 4/28/2000 16:11'!dragTransferType: aSymbol	transferType := aSymbol! !!TransferMorph methodsFor: 'as yet unclassified' stamp: 'mir 5/5/2000 17:34'!draggedMorph	draggedMorph ifNil: [self initDraggedMorph].	^draggedMorph! !!TransferMorph methodsFor: 'as yet unclassified' stamp: 'panda 4/25/2000 16:31'!draggedMorph: aMorph	draggedMorph := aMorph! !!TransferMorph methodsFor: 'as yet unclassified' stamp: 'nk 6/16/2003 16:49'!initDraggedMorph	draggedMorph ifNotNil: [^self].	draggedMorph := self passenger asDraggableMorph.	self addMorphBack: draggedMorph.	self updateCopyIcon.	self changed; fullBounds! !!TransferMorph methodsFor: 'as yet unclassified' stamp: 'cmm 8/3/2004 11:05'!initialize	"initialize the state of the receiver"	super initialize.	self layoutPolicy: TableLayout new.	self listDirection: #leftToRight;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		layoutInset: 3;		wrapCentering: #center;		cellPositioning: #leftCenter.	copy := false.	self on: #keyStroke send: #keyStroke: to: self! !!TransferMorph methodsFor: 'as yet unclassified' stamp: 'cmm 3/11/2010 22:59'!justDroppedInto: targetMorph event: anEvent 	"If only world wants this TransferMorph, treat it as unaccepted (see also >>delete)."	super		justDroppedInto: targetMorph		event: anEvent.	self animationForMoveSuccess: true.	self delete! !!TransferMorph methodsFor: 'as yet unclassified' stamp: 'nk 6/16/2003 16:51'!keyStroke: evt	"Abort the drag on an escape"	evt keyCharacter ~= Character escape ifTrue: [ ^self ].	self delete.! !!TransferMorph methodsFor: 'as yet unclassified' stamp: 'cmm 3/11/2010 22:10'!morphToDropInPasteUp: aPasteUpMorph	^ aPasteUpMorph morphToDropForTransferMorph: self! !!TransferMorph methodsFor: 'as yet unclassified' stamp: 'mir 5/5/2000 14:39'!move	copy := false! !!TransferMorph methodsFor: 'as yet unclassified' stamp: 'sr 4/16/2000 18:52'!passenger	^passenger! !!TransferMorph methodsFor: 'as yet unclassified' stamp: 'sr 4/16/2000 18:53'!passenger: anObject	passenger := anObject! !!TransferMorph methodsFor: 'as yet unclassified' stamp: 'mir 5/14/2000 00:11'!privateFullMoveBy: delta 	super privateFullMoveBy: delta.	self changed: #position! !!TransferMorph methodsFor: 'as yet unclassified' stamp: 'mir 5/5/2000 14:39'!shouldCopy	^copy! !!TransferMorph methodsFor: 'as yet unclassified' stamp: 'nk 6/16/2003 16:29'!shouldCopy: aBoolean	copy := aBoolean.! !!TransferMorph methodsFor: 'as yet unclassified' stamp: 'sr 4/16/2000 11:55'!source	^source! !!TransferMorph methodsFor: 'as yet unclassified' stamp: 'sr 4/16/2000 18:53'!source: anObject	source := anObject! !!TransferMorph methodsFor: 'as yet unclassified' stamp: 'bf 11/14/2011 16:46'!step	self shouldCopy: self primaryHand lastEvent shiftPressed.	self updateCopyIcon! !!TransferMorph methodsFor: 'as yet unclassified' stamp: 'nk 6/16/2003 16:42'!stepTime	^100! !!TransferMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/6/2000 17:30'!undoGrabCommand	^nil! !!TransferMorph methodsFor: 'as yet unclassified' stamp: 'nk 6/16/2003 16:34'!updateCopyIcon	| copyIcon |	copyIcon := self submorphWithProperty: #tmCopyIcon.	(self shouldCopy and: [ copyIcon isNil ]) ifTrue: [		^self addMorphFront: ((ImageMorph new image: CopyPlusIcon) setProperty: #tmCopyIcon toValue: true)	].	(self shouldCopy not and: [ copyIcon notNil ]) ifTrue: [		copyIcon delete	]! !!TransferMorph methodsFor: 'as yet unclassified' stamp: 'cmm 3/11/2010 22:49'!wantsToBeDroppedInto: aMorph	^ aMorph isWorldMorph		ifTrue: [ aMorph hasTransferMorphConverter ]		ifFalse: [ super wantsToBeDroppedInto: aMorph ]! !!TransferMorph class methodsFor: 'as yet unclassified' stamp: 'mir 5/5/2000 14:49'!initIcons	"TransferMorph initIcons"	CopyPlusIcon := Form		extent: 16@16		depth: 8		fromArray: #( 0 0 65535 0 0 0 16768220 4278190080 0 0 16768220 4278190080 0 255 4294958300 4294967040 0 65500 3705461980 3705462015 0 65500 3705461980 3705462015 0 255 4294958300 4294967295 0 0 16768220 4278190080 0 0 16768220 4278190080 0 0 65535 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)		offset: 0@0! !!TransferMorph class methodsFor: 'as yet unclassified' stamp: 'mir 5/5/2000 14:48'!initialize	"TransferMorph initialize"	self initIcons! !!TransferMorph class methodsFor: 'as yet unclassified' stamp: 'sr 4/13/2000 21:52'!withPassenger: anObject 	^ self withPassenger: anObject from: nil! !!TransferMorph class methodsFor: 'as yet unclassified' stamp: 'nk 6/16/2003 16:29'!withPassenger: anObject from: source 	| ddm |	ddm := self new.	ddm passenger: anObject.	ddm source: source.	Sensor shiftPressed ifTrue: [ddm shouldCopy: true].	^ ddm! !!Wiimote class methodsFor: 'as yet unclassified' stamp: 'crl 6/6/2018 11:03'!handlerBlockForKey: code	^[:upDown |		(upDown = 1)			ifTrue: [				(JS window)					setTimeout: [Webpage current evaluate: 'document.getElementById("squeak-plane").dispatchEvent(new CustomEvent("mouseleave"))']					with: 10;					setTimeout: [self dispatchKeyDown: code]					with: 20]			ifFalse: [				(JS window)					setTimeout: [self dispatchKeyUp: code]					with: 10;					setTimeout: [Webpage current evaluate: 'squeakDisplay.vm = SqueakJS.vm']					with: 60]]! !!Wiimote class methodsFor: 'as yet unclassified' stamp: 'crl 6/6/2018 20:27'!initialize	"Add OSC event handlers for my buttons."		OSCEventHandler		at: '/buttons/down'		do: (self handlerBlockForKey: 40);		at: '/buttons/up'		do: (self handlerBlockForKey: 38);		at: '/buttons/left'		do: (self handlerBlockForKey: 37);		at: '/buttons/right'		do: (self handlerBlockForKey: 39);		at: '/buttons/B'		do: [:upDown | upDown = 1 ifTrue: [(JS document getElementById: 'home') onclick]];		at: '/buttons/A'		do: [:upDown |			| cursor |						cursor := (				[(JS document getElementById: 'camera') childNodes at: 0]					on: Error					do: [:exception | nil]).			cursor ifNotNil: [				cursor := cursor components at: #cursor.				JS window at: #cursor put: cursor.				(JS window)					setTimeout: (						JS Function new: (							(upDown = 1)								ifTrue: ['window.cursor.onCursorDown()']								ifFalse: ['window.cursor.onCursorUp()']))					with: 20]]! !!InvalidSocketStatusException methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!InvalidSocketStatusException class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!ProcessLocalVariable class methodsFor: 'as yet unclassified' stamp: 'ul 9/17/2011 17:41'!value: anObject		^Processor activeProcess environmentAt: self put: anObject! !!ExpressionStatement methodsFor: 'as yet unclassified' stamp: 'crl 5/6/2017 23:43'!printSmalltalkOn: stream	expression printSmalltalkOn: stream! !!ExpressionStatement class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!ModuleID methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!ModuleID class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!LayoutPolicy class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!HTMLUListElement methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!HTMLUListElement class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSTriggerMorph methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSTriggerMorph class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!Window methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!Window class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!SpaceTally methodsFor: 'as yet unclassified' stamp: 'nice 10/20/2009 23:55'!compareTallyIn: beforeFileName to: afterFileName	"SpaceTally new compareTallyIn: 'tally' to: 'tally2'"	| answer s beforeDict a afterDict allKeys |	beforeDict := Dictionary new.	s := FileDirectory default fileNamed: beforeFileName.	[s atEnd] whileFalse: [		a := Array readFrom: s nextLine.		beforeDict at: a first put: a allButFirst.	].	s close.	afterDict := Dictionary new.	s := FileDirectory default fileNamed: afterFileName.	[s atEnd] whileFalse: [		a := Array readFrom: s nextLine.		afterDict at: a first put: a allButFirst.	].	s close.	answer := WriteStream on: String new.	allKeys := (Set new addAll: beforeDict keys; addAll: afterDict keys; yourself) asSortedCollection.	allKeys do: [ :each |		| before after diff |		before := beforeDict at: each ifAbsent: [#(0 0 0)].		after := afterDict at: each ifAbsent: [#(0 0 0)].		diff := before with: after collect: [ :vBefore :vAfter | vAfter - vBefore].		diff = #(0 0 0) ifFalse: [			answer nextPutAll: each,'  ',diff printString; cr.		].	].	StringHolder new contents: answer contents; openLabel: 'space diffs'.	! !!SpaceTally methodsFor: 'as yet unclassified' stamp: 'ul 4/1/2013 13:01'!computeSpaceUsage	results		do: [ :entry |			| class instanceSpaceAndCount |			class := self class environment at: entry analyzedClassName.			Smalltalk garbageCollectMost.			instanceSpaceAndCount := self spaceForInstancesOf: class.			entry 				codeSize: class spaceUsed;				instanceCount: instanceSpaceAndCount second;				spaceForInstances: instanceSpaceAndCount first ]		displayingProgress: 'Taking statistics...'! !!SpaceTally methodsFor: 'as yet unclassified' stamp: 'sd 6/20/2003 22:54'!preAllocateResultsFor: classes	results := OrderedCollection new: classes size.	classes do: [:cl | results add: (SpaceTallyItem analyzedClassName: cl name)].	results := results asArray.! !!SpaceTally methodsFor: 'as yet unclassified' stamp: 'ar 2/26/2010 18:02'!printSpaceAnalysis		"SpaceTally new printSpaceAnalysis"	^ self printSpaceAnalysis: 1 on: 'STspace.text'! !!SpaceTally methodsFor: 'as yet unclassified' stamp: 'ul 3/26/2013 09:47'!printSpaceAnalysis: threshold on: fileName	"SpaceTally new printSpaceAnalysis: 1000 on: 'STspace.text1'"	"sd-This method should be rewrote to be more coherent within the rest of the class 	ie using preAllocate and spaceForInstanceOf:"	"If threshold > 0, then only those classes with more than that number	of instances will be shown, and they will be sorted by total instance space.	If threshold = 0, then all classes will appear, sorted by name."	FileStream newFileNamed: fileName do: [ :file |		self printSpaceAnalysis: threshold onStream: file ]! !!SpaceTally methodsFor: 'as yet unclassified' stamp: 'cmm 1/7/2014 10:48'!printSpaceAnalysis: threshold onStream: stream	"If threshold > 0, then only those classes with more than that number	of instances will be shown, and they will be sorted by total instance space.	If threshold = 0, then all classes will appear, sorted by name."	| totalCodeSpace totalInstCount totalInstSpace totalPercent classNameLength printRow |	self systemWideSpaceTally.	totalCodeSpace := totalInstCount := totalInstSpace := 0.	classNameLength := 1.	results do: [ :each |		classNameLength := classNameLength max: each analyzedClassName size.		totalCodeSpace := totalCodeSpace + each codeSize.		totalInstCount := totalInstCount + each instanceCount.		totalInstSpace := totalInstSpace + each spaceForInstances ].	totalPercent := 0.0.	printRow := [ :class :codeSpace :instanceCount :instanceSpace :percent |		stream			nextPutAll: (class padded: #right to: classNameLength + 1 with: $ );			nextPutAll: (codeSpace padded: #left to: 12 with: $ );			nextPutAll: (instanceCount padded: #left to: 12 with: $ );			nextPutAll: (instanceSpace padded: #left to: 14 with: $ );			nextPutAll: (percent padded: #left to: 8 with: $ );			cr ].	stream timeStamp.	printRow valueWithArguments: { 'Class'. 'code space'. '# instances'. 'inst space'. 'percent' }.	threshold > 0 ifTrue: [		"If inst count threshold > 0, then sort by space"		results := results select: [ :s |			s instanceCount >= threshold or: [				s spaceForInstances > (totalInstSpace // 500) ] ].		results sort: [ :s :s2 | s spaceForInstances > s2 spaceForInstances ] ].	results do: [ :s |		| percent | 		percent := s spaceForInstances * 100.0 / totalInstSpace.		totalPercent := totalPercent + percent.		printRow valueWithArguments: {			s analyzedClassName.			s codeSize printString.			s instanceCount printString.			s spaceForInstances asBytesDescription.			percent printShowingDecimalPlaces: 1 } ].	stream cr.	printRow valueWithArguments: {		'Total'.		totalCodeSpace printString.		totalInstCount printString.		totalInstSpace printString.		totalPercent printShowingDecimalPlaces: 1 }! !!SpaceTally methodsFor: 'as yet unclassified' stamp: 'nice 6/11/2010 21:28'!printSpaceDifferenceFrom: fileName1 to: fileName2	"For differential results, run printSpaceAnalysis twice with different fileNames,	then run this method...		SpaceTally new printSpaceAnalysis: 0 on: 'STspace.text1'.			--- do something that uses space here ---		SpaceTally new printSpaceAnalysis: 0 on: 'STspace.text2'.		SpaceTally new printSpaceDifferenceFrom: 'STspace.text1' to: 'STspace.text2'"	| f coll1 coll2 item |	f := FileStream readOnlyFileNamed: fileName1.	coll1 := OrderedCollection new.	[f atEnd] whileFalse: [coll1 add: f nextLine].	f close.	f := FileStream readOnlyFileNamed: fileName2.	coll2 := OrderedCollection new.	[f atEnd] whileFalse:		[item := f nextLine.		((coll1 includes: item) and: [(item endsWith: 'percent') not])			ifTrue: [coll1 remove: item]			ifFalse: [coll2 add: item]].	f close.	(StringHolder new contents: (String streamContents: 			[:s | 			s nextPutAll: fileName1; cr.			coll1 do: [:x | s nextPutAll: x; cr].			s cr; cr.			s nextPutAll: fileName2; cr.			coll2 do: [:x | s nextPutAll: x; cr]]))		openLabel: 'Differential Space Analysis'.! !!SpaceTally methodsFor: 'as yet unclassified' stamp: 'sd 6/20/2003 22:31'!results	^ results! !!SpaceTally methodsFor: 'as yet unclassified' stamp: 'sd 6/20/2003 22:59'!saveTo: aFileName	"| st |	st := SpaceTally new.	st spaceTally: (Array with: TextMorph with: Point).	st saveTo: 'spaceTally2'"	| s |	(FileDirectory default fileExists: aFileName) ifTrue: [		FileDirectory default deleteFileNamed: aFileName].	s := FileDirectory default fileNamed: aFileName.	results do: [:each | s nextPutAll: each analyzedClassName asString ; 						nextPutAll: ' '; nextPutAll: each codeSize printString; 						nextPutAll: ' '; nextPutAll: each instanceCount printString; 						nextPutAll: ' '; nextPutAll: each spaceForInstances printString; cr].	s close! !!SpaceTally methodsFor: 'as yet unclassified' stamp: 'dtl 2/15/2014 21:47'!spaceForInstancesOf: aClass	"Answer the number of bytes consumed by all instances of the given class, including their object headers and the number of instances."	| smallHeaderSize instVarBytes isVariable bytesPerElement  total lastInstance instance instanceCount |	instance := aClass someInstance ifNil: [ ^#(0 0) ].		smallHeaderSize := aClass isCompact ifTrue: [ 4 ] ifFalse: [ 8 ].	instVarBytes := aClass instSize * 4.	isVariable := aClass isVariable.	bytesPerElement := isVariable		ifFalse: [ 0 ]		ifTrue: [ aClass isBytes ifTrue: [ 1 ] ifFalse: [ 4 ] ].	total := 0.	instanceCount := 0.	"A modified version of #allInstancesDo: is inlined here. It avoids an infinite loop when another process is creating new instances of aClass."	self flag: #allInstancesDo:.	lastInstance :=		aClass == CompiledMethod "CompiledMethod has special format, see its class comment"			ifTrue: [aClass new]			ifFalse: [aClass basicNew].	[ instance == lastInstance ] whileFalse: [		| contentBytes headerBytes |		contentBytes := instVarBytes + (isVariable			ifFalse: [ 0 ]			ifTrue: [ instance basicSize * bytesPerElement ]).		headerBytes := contentBytes > 255			ifTrue: [ 12 ]			ifFalse: [ smallHeaderSize ].		total := total + headerBytes + (contentBytes roundUpTo: 4).		instanceCount := instanceCount + 1.		instance := instance nextInstance ].	^{ total. instanceCount }! !!SpaceTally methodsFor: 'as yet unclassified' stamp: 'cmm 9/5/2012 10:30'!spaceTally: classes 	"Answer a collection of SpaceTallyItems representing the memory space (in bytes) consumed 	by the code and instances of each class in the system. Note that code sizes do not currently 	report memory consumed by class variables. "	"((SpaceTally new spaceTally: (Array with: TextMorph with: Point)) asSortedCollection: [:a :b | a spaceForInstances > b spaceForInstances]) asArray"	self preAllocateResultsFor: classes.	Smalltalk garbageCollect.	self computeSpaceUsage.	^ results		 sort: [ : a : b | a spaceForInstances > b spaceForInstances ] ;		 yourself! !!SpaceTally methodsFor: 'as yet unclassified' stamp: 'efc 7/6/2004 00:25'!systemWideSpaceTally	"Answer a collection of SpaceTallyItems representing the memory space (in bytes) consumed 	by the code and instances of each class in the system. Note that code sizes do not currently 	report memory consumed by class variables. "	"(SpaceTally new systemWideSpaceTally asSortedCollection: [:a :b | a spaceForInstances > b spaceForInstances]) asArray"	^self spaceTally: Smalltalk allClasses.! !!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'crl 5/20/2018 23:24'!storeOnTether: tether
	(self otherVia: tether) storeOnTether: tether! !!SystemDictionary class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!XMLNode class methodsFor: 'as yet unclassified' stamp: 'crl 6/2/2011 14:07'!new	^super new initialize! !!UndeclaredVariableNode class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!BlockStatement methodsFor: 'as yet unclassified' stamp: 'crl 5/7/2017 14:04'!printSmalltalkOn: stream	| declarations statements |		declarations := OrderedCollection new.	statements := OrderedCollection new.		body do: [:declarationOrStatement |		(declarationOrStatement declares)			ifTrue: [declarations addAll: declarationOrStatement declarators]			ifFalse: [statements add: declarationOrStatement]].			declarations ifNotEmpty: [		stream			crtab;			nextPutAll: '| '.					declarations do: [:declaration | declaration printSmalltalkOn: stream].		stream			nextPutAll: ' |';			cr].			statements do: [:statement |		stream crtab.		statement printSmalltalkOn: stream.		stream nextPut: $.]! !!BlockStatement class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!ExceptionAboutToReturn methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!ExceptionAboutToReturn class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!ChromeScript methodsFor: 'as yet unclassified' stamp: 'crl 5/12/2017 16:45'!printOn: stream	super printOn: stream.	stream		nextPutAll: ' from ';		nextPutAll: url! !!ChromeScript methodsFor: 'as yet unclassified' stamp: 'crl 8/5/2016 20:47'!url	^url! !!Abort class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!DirectoryEntryDirectory class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!DAVSessionSnapshot methodsFor: 'as yet unclassified' stamp: 'crl 1/12/2015 00:16'!initialName	^'snapshot'! !!DAVSessionSnapshot class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!MethodDictionary methodsFor: 'as yet unclassified' stamp: 'crl 5/20/2018 23:23'!storeOnTether: tether
	(self otherVia: tether) storeOnTether: tether! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!InstructionClient class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!DeepCopier methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 22:55'!checkBasicClasses	"Check that no indexes of instance vars have changed in certain classes.  If you get an error in this method, an implementation of veryDeepCopyWith: needs to be updated.  The idea is to catch a change while it is still in the system of the programmer who made it.  	DeepCopier new checkVariables	"	| str str2 objCls morphCls |	str := '|veryDeepCopyWith: or veryDeepInner: is out of date.'.	(objCls := self objInMemory: #Object) ifNotNil: [		objCls instSize = 0 ifFalse: [self error: 			'Many implementers of veryDeepCopyWith: are out of date']].	(morphCls := self objInMemory: #Morph) ifNotNil: [		morphCls superclass == Object ifFalse: [self error: 'Morph', str].		(morphCls instVarNames copyFrom: 1 to: 6) = #('bounds' 'owner' 'submorphs' 				'fullBounds' 'color' 'extension') 			ifFalse: [self error: 'Morph', str]].	"added ones are OK"	str2 := 'Player|copyUniClassWith: and DeepCopier|mapUniClasses are out of date'.! !!DeepCopier methodsFor: 'as yet unclassified' stamp: 'tk 3/7/2001 15:42'!checkClass: aClass	| meth |	"Check that no indexes of instance vars have changed in certain classes.  If you get an error in this method, an implementation of veryDeepCopyWith: needs to be updated.  The idea is to catch a change while it is still in the system of the programmer who made it."	self checkBasicClasses.	"Unlikely, but important to catch when it does happen."	"Every class that implements veryDeepInner: must copy all its inst vars.  Danger is that a user will add a new instance variable and forget to copy it.  So check that the last one is mentioned in the copy method."	(aClass includesSelector: #veryDeepInner:) ifTrue: [ 		((aClass compiledMethodAt: #veryDeepInner:) writesField: aClass instSize) ifFalse: [			aClass instSize > 0 ifTrue: [				self warnIverNotCopiedIn: aClass sel: #veryDeepInner:]]].	(aClass includesSelector: #veryDeepCopyWith:) ifTrue: [		meth := aClass compiledMethodAt: #veryDeepCopyWith:.		(meth size > 20) & (meth literals includes: #veryDeepCopyWith:) not ifTrue: [			(meth writesField: aClass instSize) ifFalse: [				self warnIverNotCopiedIn: aClass sel: #veryDeepCopyWith:]]].! !!DeepCopier methodsFor: 'as yet unclassified' stamp: 'nice 12/26/2009 01:30'!checkDeep	"Write exceptions in the Transcript.  Every class that implements veryDeepInner: must copy all its inst vars.  Danger is that a user will add a new instance variable and forget to copy it.  This check is only run by hand once in a while to make sure nothing was forgotten.  (Please do not remove this method.)	DeepCopier new checkDeep 	"	Transcript		cr;		show: 'Instance variables shared with the original object when it is copied'.	(self systemNavigation allClassesImplementing: #veryDeepInner:) do: 			[:aClass | 			| mm |			(mm := aClass instVarNames size) > 0 				ifTrue: 					[aClass instSize - mm + 1 to: aClass instSize						do: 							[:index | 							((aClass compiledMethodAt: #veryDeepInner:) writesField: index) 								ifFalse: 									[Transcript										cr;										show: aClass name;										space;										show: (aClass allInstVarNames at: index)]]]]! !!DeepCopier methodsFor: 'as yet unclassified' stamp: 'nice 12/26/2009 01:30'!checkVariables	"Check that no indexes of instance vars have changed in certain classes.  If you get an error in this method, an implementation of veryDeepCopyWith: needs to be updated.  The idea is to catch a change while it is still in the system of the programmer who made it.  	DeepCopier new checkVariables	"	self checkBasicClasses.	"Every class that implements veryDeepInner: must copy all its inst vars.  Danger is that a user will add a new instance variable and forget to copy it.  So check that the last one is mentioned in the copy method."	(self systemNavigation allClassesImplementing: #veryDeepInner:) do: 			[:aClass | 			((aClass compiledMethodAt: #veryDeepInner:) writesField: aClass instSize) 				ifFalse: 					[aClass instSize > 0 						ifTrue: [self warnIverNotCopiedIn: aClass sel: #veryDeepInner:]]].	(self systemNavigation allClassesImplementing: #veryDeepCopyWith:) do: 			[:aClass | 			| meth |			meth := aClass compiledMethodAt: #veryDeepCopyWith:.			meth size > 20 & (meth literals includes: #veryDeepCopyWith:) not 				ifTrue: 					[(meth writesField: aClass instSize) 						ifFalse: [self warnIverNotCopiedIn: aClass sel: #veryDeepCopyWith:]]]! !!DeepCopier methodsFor: 'as yet unclassified' stamp: 'nice 12/26/2009 01:31'!fixDependents	"They are not used much, but need to be right"	DependentsFields associationsDo: [:pair |		pair value do: [:dep | 			| newDep newModel |			newDep := references at: dep ifAbsent: [nil].			newDep ifNotNil: [				newModel := references at: pair key ifAbsent: [pair key].				newModel addDependent: newDep]]].! !!DeepCopier methodsFor: 'as yet unclassified' stamp: 'hg 11/23/1999 13:36'!initialize	self initialize: 4096.! !!DeepCopier methodsFor: 'as yet unclassified' stamp: 'tk 3/4/2003 19:40'!initialize: size	references := IdentityDictionary new: size.	uniClasses := IdentityDictionary new.	"UniClass -> new UniClass"	"self isItTimeToCheckVariables ifTrue: [self checkVariables]."		"no more checking at runtime"	newUniClasses := true.! !!DeepCopier methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 22:55'!mapUniClasses	"For new Uniclasses, map their class vars to the new objects.  And their additional class instance vars.  (scripts slotInfo) and cross references like (player321)."	"Players also refer to each other using associations in the References dictionary.  Search the methods of our Players for those.  Make new entries in References and point to them."! !!DeepCopier methodsFor: 'as yet unclassified' stamp: 'tk 3/11/2003 14:13'!newUniClasses	"If false, all new Players are merely siblings of the old players"	^ newUniClasses! !!DeepCopier methodsFor: 'as yet unclassified' stamp: 'tk 3/4/2003 19:44'!newUniClasses: newVal	"If false, all new players are merely siblings of the old players"	newUniClasses := newVal! !!DeepCopier methodsFor: 'as yet unclassified' stamp: 'tk 3/7/2001 15:29'!objInMemory: ClassSymbol	| cls |	"Test if this global is in memory and return it if so."	cls := Smalltalk at: ClassSymbol ifAbsent: [^ nil].	^ cls isInMemory ifTrue: [cls] ifFalse: [nil].! !!DeepCopier methodsFor: 'as yet unclassified' stamp: 'tk 8/20/1998 22:13'!references	^ references! !!DeepCopier methodsFor: 'as yet unclassified' stamp: 'tk 8/19/1998 15:48'!uniClasses	^uniClasses! !!DeepCopier methodsFor: 'as yet unclassified' stamp: 'ar 9/27/2005 20:27'!warnIverNotCopiedIn: aClass sel: sel	"Warn the user to update veryDeepCopyWith: or veryDeepInner:"	self inform: ('An instance variable was added to to class ', aClass name, ',\and it is not copied in the method ', sel, '.\Please rewrite it to handle all instance variables.\See DeepCopier class comment.') withCRs.	ToolSet browse: aClass selector: sel! !!JSFunction methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSFunction class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSFunction class methodsFor: 'as yet unclassified' stamp: 'crl 9/16/2019 00:02'!new: source	^((JS at: #Function) new: 'return ', source) call counterpart! !!EventTarget methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2017 10:03'!onChange: block	self at: #onchange put: [[block value] fork]! !!EventTarget methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2019 21:42'!onInput: block	self at: #oninput put: [:event | [block value: event] fork]! !!EventTarget class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!HTMLHeadElement methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!HTMLHeadElement class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!C methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!C class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!RadialEntity methodsFor: 'as yet unclassified' stamp: 'crl 8/19/2017 14:21'!add	super add.	self		setAttribute: 'radius'		with: 2! !!RadialEntity methodsFor: 'as yet unclassified' stamp: 'crl 8/19/2017 14:20'!literalAttributesToSet	^super literalAttributesToSet, #(radius)! !!RadialEntity class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!Collection methodsFor: 'as yet unclassified' stamp: 'crl 7/23/2017 19:54'!asChromeRemoteCallArgument	| array i |	array := Array new: self size.	i := 0.	self do: [:each | array at: (i := i + 1) put: each asChromeRemoteCallArgument].	^ array! !!Collection methodsFor: 'as yet unclassified' stamp: 'crl 7/3/2017 00:46'!asDictionary	| dictionary |		dictionary := Dictionary new.		self do: [:association |		dictionary			at: association key			put: (				(association value class == Array and: [association value size > 1 and: [association value first class == Association]])					ifTrue: [association value asDictionary]					ifFalse: [association value])].					^dictionary! !!Collection methodsFor: 'as yet unclassified' stamp: 'bf 11/25/2014 18:12'!asJSArgument	"converted to JS array by plugin"	| array i |	array := Array new: self size.	i := 0.	self do: [:each | array at: (i := i + 1) put: each asJSArgument].	^ array! !!Collection methodsFor: 'as yet unclassified' stamp: 'crl 8/6/2019 16:00'!elect: aBlockClosure	"Answer any element which emerges victorious against the others in the test posed by aBlockClosure."	^(self isEmpty)		ifTrue: [self error: 'I have no elements to compare.']		ifFalse: [			self				inject: self anyOne				into: [:winner :next |					(aBlockClosure value: winner value: next)						ifTrue: [winner]						ifFalse: [next]]]! !!Collection methodsFor: 'as yet unclassified' stamp: 'crl 7/23/2017 14:21'!onlyOne	^(self size = 1)		ifTrue: [self anyOne]		ifFalse: [self error: 'I have a size other than one.']! !!Collection methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 03:28'!recyclingHash	^(self inject: 0 into: [:subtotal :next | subtotal + next recyclingHash]) negated! !!Collection methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 20:02'!simplifiedForJSON	"Answer a literal populated with my contents, suitable for JSON encoding."	^self asArray! !!Collection methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 03:46'!storeElementsOnTether: tether	self do: [:element | element storeOnTether: tether]! !!Collection methodsFor: 'as yet unclassified' stamp: 'crl 5/20/2018 23:22'!storeOnTether: tether
	tether
		nextWordPut: self tag;
		nextWordPut: self transmissionSize.
	self storeElementsOnTether: tether! !!Collection methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 03:40'!transmissionSize	^self size! !!Collection class methodsFor: 'as yet unclassified'!fromTether: tether 	| counterpart |	counterpart := self transmissionNew: tether nextWord.	self		readElementsInto: counterpart		fromTether: tether.	^counterpart! !!Collection class methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 10:57'!readElementsInto: counterpart fromTether: tether	1		to: counterpart size		do: [:index |			counterpart				at: index				put: tether next]! !!Collection class methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 10:56'!transmissionNew: anInteger	^self new: anInteger! !!Worker methodsFor: 'as yet unclassified' stamp: 'crl 9/4/2018 09:50'!onMessage: oneParameterBlock	self at: #onmessage put: oneParameterBlock! !!Worker class methodsFor: 'as yet unclassified' stamp: 'crl 1/14/2019 21:49'!executing: string	^(		Genesis			call: nil			with: '				self.addEventListener(					"message",					(', string, '),					false)'	)		counterpart! !!Worker class methodsFor: 'as yet unclassified' stamp: 'crl 1/14/2019 21:50'!executing: string onMessage: oneParameterBlock	^(self executing: string)		onMessage: oneParameterBlock;		yourself! !!Worker class methodsFor: 'as yet unclassified' stamp: 'crl 1/8/2019 11:30'!genesisFunction	"Answer the 'genesis function' which, given source code, creates a new worker."		^Genesis! !!Worker class methodsFor: 'as yet unclassified' stamp: 'crl 9/7/2018 02:07'!initialize	Smalltalk addToStartUpList: self before: Webpage.	self startUp: true! !!Worker class methodsFor: 'as yet unclassified' stamp: 'crl 9/4/2018 17:14'!initializeGenesisFunction	Genesis := (		(JS Function)			new: 'script'			with: '				var URL = window.URL || window.webkitURL				var Blob = window.Blob				var Worker = window.Worker				if (!!URL || !!Blob || !!Worker || !!script) {					return null}				else {					return new Worker(URL.createObjectURL(new Blob([script])))}')! !!Worker class methodsFor: 'as yet unclassified' stamp: 'crl 10/16/2018 17:43'!startUp: resuming	(resuming and: [JS isConnected]) ifTrue: [self initializeGenesisFunction]! !!SystemWindow methodsFor: 'as yet unclassified' stamp: 'crl 6/18/2017 14:02'!doFastFrameDrag: grabPoint	"Do fast frame dragging from the given point"	| offset newBounds outerWorldBounds |	self world class = HTML5PasteUpMorph ifTrue: [^self].	outerWorldBounds := self boundsIn: nil.	offset := outerWorldBounds origin - grabPoint.	newBounds := outerWorldBounds newRectFrom: [:f | 		Sensor cursorPoint + offset extent: outerWorldBounds extent].	self position: (self globalPointToLocal: newBounds topLeft); comeToFront! !!SystemWindow methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2019 13:18'!initialExtent	"Ask the model for it's initial extent."		^model initialExtent! !!SystemWindow methodsFor: 'as yet unclassified' stamp: 'kfr 4/19/2015 08:19'!openInWorldExtent: extent	"This msg and its callees result in the window being activeOnlyOnTop"	^ self openInWorld: self currentWorld extent: extent! !!RealEstateAgent methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'kfr 7/21/2014 15:56'!assignCollapseFrameFor: aSSView 	"Offer up a location along the left edge of the screen for a collapsed SSView. Make sure it doesn't overlap any other collapsed frames."	| grid otherFrames topLeft viewBox collapsedFrame extent newFrame verticalBorderDistance top |	grid := 8.	verticalBorderDistance := 8.	aSSView isMorph		ifTrue: [otherFrames := (SystemWindow windowsIn: aSSView world satisfying: [:w | w ~= aSSView])						collect: [:w | w collapsedFrame]						thenSelect: [:rect | rect notNil].				viewBox := self maximumUsableAreaInWorld: aSSView world]		ifFalse: [otherFrames := ScheduledControllers scheduledWindowControllers						collect: [:aController | aController view ~= aSSView ifTrue: [aController view collapsedFrame]]						thenSelect: [:rect | rect notNil].				viewBox := Display boundingBox].	collapsedFrame := aSSView collapsedFrame.	extent := collapsedFrame notNil				ifTrue: [collapsedFrame extent]				ifFalse: [aSSView isMorph					ifTrue: [aSSView getRawLabel width + aSSView labelWidgetAllowance @ (aSSView labelHeight + 2)]					ifFalse: [(aSSView labelText extent x + 70) @ aSSView labelHeight							min: aSSView labelDisplayBox extent]].	collapsedFrame notNil		ifTrue: [(otherFrames anySatisfy: [:f | collapsedFrame intersects: f])				ifFalse: ["non overlapping"					^ collapsedFrame]].	top := viewBox top + verticalBorderDistance.	[topLeft := viewBox left @ top.	newFrame := topLeft extent: extent.	newFrame bottom <= (viewBox height - verticalBorderDistance)]		whileTrue: 			[(otherFrames anySatisfy: [:w | newFrame intersects: w])				ifFalse: ["no overlap"					^ newFrame].			top := top + grid].	"If all else fails... (really to many wins here)"	aSSView isMorph		ifTrue:[ Project current showWorldMainDockingBar ifTrue:[^ (0 @ Project current world mainDockingBars first height) extent: extent]].	^ 0 @ 0 extent: extent! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'crl 5/29/2017 18:06'!normalInitialFrameFor: aView initialExtent: initialExtent world: aWorld	"Find a plausible initial screen area for the supplied view, which should be a StandardSystemView, taking into account the 'reverseWindowStagger' Preference, the size needed, and other windows currently on the screen."	| candidate displayBounds |	displayBounds := Display bounds.		^(		SystemWindow topWindow notNil and: [			| candidateTopRightCorner newRightmostMorph oldRightmostMorph translationIncrement | 			translationIncrement := 40@40.			oldRightmostMorph := SystemWindow topWindow.			candidateTopRightCorner := oldRightmostMorph bounds topRight translateBy: translationIncrement.			[				(displayBounds containsPoint: candidateTopRightCorner) and: [					newRightmostMorph := (						(World submorphs)							detect: [:morph | morph bounds containsPoint: (candidateTopRightCorner translateBy: (-5 @ 5))]							ifNone: [nil]).					newRightmostMorph notNil]			]				whileTrue: [					oldRightmostMorph := newRightmostMorph.					candidateTopRightCorner := candidateTopRightCorner translateBy: translationIncrement].			(displayBounds containsPoint: candidateTopRightCorner) and: [				oldRightmostMorph notNil and: [					candidate := ((oldRightmostMorph bounds translateBy: translationIncrement) topLeft corner: (candidateTopRightCorner x @ (candidateTopRightCorner y + initialExtent y))) intersect: displayBounds.					candidate area between: (initialExtent area * 0.8) and: (initialExtent area * 1.2)]]]	)		ifTrue: [candidate]		ifFalse: [			candidate := 0@0 corner: ((initialExtent x min: (Display extent x - 50)) @ (initialExtent y min: (Display extent y - 50))).			candidate translateBy: Display bounds center - (candidate extent / 2)]! !!JSToggleMorph methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSToggleMorph class methodsFor: 'as yet unclassified' stamp: 'crl 5/31/2017 13:09'!style: style target: target action: action label: label query: query	^self		style: style		target: target		action: action		label: label		query: query		environment: nil		hint: nil		template: nil		element: nil		builder: nil! !!JSToggleMorph class methodsFor: 'as yet unclassified' stamp: 'crl 5/31/2017 17:27'!style: style target: target action: action label: label query: query element: element	^self		style: style		target: target		action: action		label: label		query: query		environment: nil		hint: nil		template: nil		element: element		builder: nil! !!JSToggleMorph class methodsFor: 'as yet unclassified' stamp: 'crl 5/30/2017 11:59'!style: style target: target action: action label: label query: query environment: environment hint: hint template: template element: element builder: builder	^(self new)		init: style		with: target		with: action		with: label		with: query		with: environment		with: hint		with: template		with: element		with: builder;		yourself! !!HTTPProgress class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!FastInflateStream methodsFor: 'as yet unclassified' stamp: 'eem 5/6/2014 14:54'!decompressBlock: llTable with: dTable	"Process the compressed data in the block.	llTable is the huffman table for literal/length codes	and dTable is the huffman table for distance codes."	| value extra length distance oldPos oldBits oldBitPos |	<primitive: 'primitiveInflateDecompressBlock' module: 'ZipPlugin'>	[readLimit < collection size and:[sourcePos <= sourceLimit]] whileTrue:[		"Back up stuff if we're running out of space"		oldBits := bitBuf.		oldBitPos := bitPos.		oldPos := sourcePos.		value := self decodeValueFrom: llTable.		value < 256 ifTrue:[ "A literal"			collection byteAt: (readLimit := readLimit + 1) put: value.		] ifFalse:["length/distance or end of block"			value = 256 ifTrue:["End of block"				state := state bitAnd: StateNoMoreData.				^self].			"Compute the actual length value (including possible extra bits)"			extra := (value bitShift: -16) - 1.			length := value bitAnd: 16rFFFF.			extra > 0 ifTrue:[length := length + (self nextBits: extra)].			"Compute the distance value"			value := self decodeValueFrom: dTable.			extra := (value bitShift: -16).			distance := value bitAnd: 16rFFFF.			extra > 0 ifTrue:[distance := distance + (self nextBits: extra)].			(readLimit + length >= collection size) ifTrue:[				bitBuf := oldBits.				bitPos := oldBitPos.				sourcePos := oldPos.				^self].			collection 					replaceFrom: readLimit+1 					to: readLimit + length					with: collection 					startingAt: readLimit - distance + 1.			readLimit := readLimit + length.		].	].! !!FastInflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/4/1998 02:26'!distanceMap	^DistanceMap! !!FastInflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/4/1998 01:48'!increment: value bits: nBits	"Increment value in reverse bit order, e.g. 	for a 3 bit value count as follows:		000 / 100 / 010 / 110		001 / 101 / 011 / 111	See the class comment why we need this."	| result bit |	result := value.	"Test the lowest bit first"	bit := 1 << (nBits - 1).	"If the currently tested bit is set then we need to	turn this bit off and test the next bit right to it"	[(result bitAnd: bit) = 0] whileFalse:[ 		"Turn off current bit"		result := result bitXor: bit.		"And continue testing the next bit"		bit := bit bitShift: -1].	"Turn on the right-most bit that we haven't touched in the loop above"	^result bitXor: bit! !!FastInflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/4/1998 02:26'!literalLengthMap	^LiteralLengthMap! !!FastInflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/4/1998 02:02'!nextSingleBits: n	"Fetch the bits all at once"	^self nextBits: n.! !!FastInflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/4/1998 19:15'!processFixedBlock	litTable := FixedLitTable.	distTable := FixedDistTable.	state := state bitOr: BlockProceedBit.	self proceedFixedBlock.! !!FastInflateStream class methodsFor: 'as yet unclassified' stamp: 'ar 12/21/1999 23:00'!initialize	"FastInflateStream initialize"	| low high |	"Init literal/length map"	low := #(3 4 5 6 7 8 9 10 11 13 15 17 19 23 27 31 35 43 51 59 67 83 99 115 131 163 195 227 258 ).	high := #(0 0 0 0 0 0 0 0 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 0 0).	LiteralLengthMap := WordArray new: 256 + 32.	1 to: 257 do:[:i| LiteralLengthMap at: i put: i-1].	1 to: 29 do:[:i| LiteralLengthMap at: 257+i put: (low at:i) + ( (high at: i) + 1 << 16)].	"Init distance map"	high := #(0 0 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 11 11 12 12 13 13).	low := #(1 2 3 4 5 7 9 13 17 25 33 49 65 97 129 193 257 385 513 769			1025 1537 2049 3073 4097 6145 8193 12289 16385 24577).	DistanceMap := WordArray new: 32.	1 to: 30 do:[:i| DistanceMap at: i put: (low at: i) + ( (high at: i) << 16)].	"Init fixed block huffman tables"	FixedLitTable := self basicNew				huffmanTableFrom: FixedLitCodes				mappedBy: LiteralLengthMap.	FixedDistTable := self basicNew				huffmanTableFrom: FixedDistCodes				mappedBy: DistanceMap.! !!Array methodsFor: 'as yet unclassified' stamp: 'crl 7/23/2017 20:10'!asChromeRemoteCallArgument	^{#unserializableValue -> self}! !!Array methodsFor: 'as yet unclassified' stamp: 'crl 2/15/2019 11:37'!asJSArgument	^self! !!Array methodsFor: 'as yet unclassified' stamp: 'crl 6/18/2017 20:07'!asJSObject	| jsObject|		jsObject := JS Object new.		self do: [:association | jsObject at: association key put: association value].	^jsObject! !!Array methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 20:02'!simplifiedForJSON	"Answer a literal populated with my contents, suitable for JSON encoding."	^self! !!Array methodsFor: 'as yet unclassified' stamp: 'crl 5/29/2017 17:48'!storeJavaScriptOn: aStream 	"Use the literal form if possible."	self shouldBePrintedAsLiteral		ifTrue: 			[aStream nextPut: $[.			self do: 				[:element | 				element storeJavaScriptOn: aStream]			separatedBy: [aStream nextPutAll: ', '].			aStream nextPut: $]]		ifFalse: [super storeJavaScriptOn: aStream]! !!Array methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 03:50'!tag	^ArrayTag! !!TextReadWriter methodsFor: 'as yet unclassified' stamp: 'mt 5/3/2015 16:17'!nextPutText: aText	"Encoding aText on stream."		self subclassResponsibility.! !!TextReadWriter methodsFor: 'as yet unclassified' stamp: 'mt 5/3/2015 16:16'!nextText	"Decoding a text object on stream and answer that text object."		^ self subclassResponsibility.! !!TextReadWriter methodsFor: 'as yet unclassified' stamp: 'mt 5/3/2015 17:34'!on: aStream	stream := aStream.! !!TextReadWriter class methodsFor: 'as yet unclassified' stamp: 'mt 5/3/2015 17:46'!on: stream	^ self new on: stream! !!ConnectionClosed methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!ConnectionClosed class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!JSMenuMorph methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSMenuMorph class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSColor methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSColor class methodsFor: 'as yet unclassified' stamp: 'crl 6/5/2017 15:26'!black	^self		r: 0		g: 0		b: 0! !!JSColor class methodsFor: 'as yet unclassified' stamp: 'crl 6/5/2017 18:12'!blue	^self		r: 0		g: 0		b: 255! !!JSColor class methodsFor: 'as yet unclassified' stamp: 'crl 6/5/2017 18:11'!green	^self		r: 0		g: 255		b: 0! !!JSColor class methodsFor: 'as yet unclassified' stamp: 'crl 6/5/2017 15:25'!r: red g: green b: blue	^self		r: red		g: green		b: blue		a: 1! !!JSColor class methodsFor: 'as yet unclassified' stamp: 'crl 6/5/2017 15:24'!r: red g: green b: blue a: alpha	^self newWithParameters: {red. green. blue. alpha}! !!JSColor class methodsFor: 'as yet unclassified' stamp: 'crl 6/5/2017 18:11'!red	^self		r: 255		g: 0		b: 0! !!JSColor class methodsFor: 'as yet unclassified' stamp: 'crl 6/5/2017 18:11'!white	^self		r: 255		g: 255		b: 255! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/27/1999 13:43'!atEnd	"Note: It is possible that we have a few bits left,	representing just the EOB marker. To check for	this we must force decompression of the next	block if at end of data."	super atEnd ifFalse:[^false]. "Primitive test"	(position >= readLimit and:[state = StateNoMoreData]) ifTrue:[^true].	"Force decompression, by calling #next. Since #moveContentsToFront	will never move data to the beginning of the buffer it is safe to	skip back the read position afterwards"	self next == nil ifTrue:[^true].	position := position - 1.	^false! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/27/1999 13:47'!bitPosition	"Return the current bit position of the source"	sourceStream == nil		ifTrue:[^sourcePos * 8 + bitPos]		ifFalse:[^sourceStream position + sourcePos * 8 + bitPos]! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/23/1999 15:31'!close	sourceStream ifNotNil:[sourceStream close].! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/21/1999 22:59'!computeHuffmanValues: aCollection counts: counts from: minBits to: maxBits	"Assign numerical values to all codes.	Note: The values are stored according to the bit length"	| offsets values baseOffset codeLength |	offsets := Array new: maxBits.	offsets atAllPut: 0.	baseOffset := 1.	minBits to: maxBits do:[:bits|		offsets at: bits put: baseOffset.		baseOffset := baseOffset + (counts at: bits+1)].	values := WordArray new: aCollection size.	1 to: aCollection size do:[:i|		codeLength := aCollection at: i.		codeLength > 0 ifTrue:[			baseOffset := offsets at: codeLength.			values at: baseOffset put: i-1.			offsets at: codeLength put: baseOffset + 1]].	^values! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'tk 2/4/2000 10:26'!contents	^ self upToEnd! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 2/29/2004 04:04'!crcError: aString	^CRCError signal: aString! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'sma 5/12/2000 10:49'!createHuffmanTables: values counts: counts from: minBits to: maxBits	"Create the actual tables"	| table tableStart tableSize tableEnd 	valueIndex tableStack numValues deltaBits maxEntries	lastTable lastTableStart tableIndex lastTableIndex |	table := WordArray new: ((4 bitShift: minBits) max: 16).	"Create the first entry - this is a dummy.	It gives us information about how many bits to fetch initially."	table at: 1 put: (minBits bitShift: 24) + 2. "First actual table starts at index 2"	"Create the first table from scratch."	tableStart := 2. "See above"	tableSize := 1 bitShift: minBits.	tableEnd := tableStart + tableSize.	"Store the terminal symbols"	valueIndex := (counts at: minBits+1).	tableIndex := 0.	1 to: valueIndex do:[:i|		table at: tableStart + tableIndex put: (values at: i).		tableIndex := self increment: tableIndex bits: minBits].	"Fill up remaining entries with invalid entries"	tableStack := OrderedCollection new: 10. "Should be more than enough"	tableStack addLast: 		(Array 			with: minBits	"Number of bits (e.g., depth) for this table"			with: tableStart	"Start of table"			with: tableIndex "Next index in table"			with: minBits	"Number of delta bits encoded in table"			with: tableSize - valueIndex "Entries remaining in table").	"Go to next value index"	valueIndex := valueIndex + 1.	"Walk over remaining bit lengths and create new subtables"	minBits+1 to: maxBits do:[:bits|		numValues := counts at: bits+1.		[numValues > 0] whileTrue:["Create a new subtable"			lastTable := tableStack last.			lastTableStart := lastTable at: 2.			lastTableIndex := lastTable at: 3.			deltaBits := bits - (lastTable at: 1).			"Make up a table of deltaBits size"			tableSize := 1 bitShift: deltaBits.			tableStart := tableEnd.			tableEnd := tableEnd + tableSize.			[tableEnd > table size ]				whileTrue:[table := self growHuffmanTable: table].			"Connect to last table"			self assert:[(table at: lastTableStart + lastTableIndex) = 0]."Entry must be unused"			table at: lastTableStart + lastTableIndex put: (deltaBits bitShift: 24) + tableStart.			lastTable at: 3 put: (self increment: lastTableIndex bits: (lastTable at: 4)).			lastTable at: 5 put: (lastTable at: 5) - 1.			self assert:[(lastTable at: 5) >= 0]. "Don't exceed tableSize"			"Store terminal values"			maxEntries := numValues min: tableSize.			tableIndex := 0.			1 to: maxEntries do:[:i|				table at: tableStart + tableIndex put: (values at: valueIndex).				valueIndex := valueIndex + 1.				numValues := numValues - 1.				tableIndex := self increment: tableIndex bits: deltaBits].			"Check if we have filled up the current table completely"			maxEntries = tableSize ifTrue:[				"Table has been filled. Back up to the last table with space left."				[tableStack isEmpty not and:[(tableStack last at: 5) = 0]]						whileTrue:[tableStack removeLast].			] ifFalse:[				"Table not yet filled. Put it back on the stack."				tableStack addLast:					(Array						with: bits		"Nr. of bits in this table"						with: tableStart	"Start of table"						with: tableIndex "Index in table"						with: deltaBits	"delta bits of table"						with: tableSize - maxEntries "Unused entries in table").			].		].	].	 ^table copyFrom: 1 to: tableEnd-1! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/4/1998 02:25'!decodeDynamicTable: nItems from: aHuffmanTable	"Decode the code length of the literal/length and distance table	in a block compressed with dynamic huffman trees"	| values index value repCount theValue |	values := Array new: nItems.	index := 1.	theValue := 0.	[index <= nItems] whileTrue:[		value := self decodeValueFrom: aHuffmanTable.		value < 16 ifTrue:[			"Immediate values"			theValue := value.			values at: index put: value.			index := index+1.		] ifFalse:[			"Repeated values"			value = 16 ifTrue:[				"Repeat last value"				repCount := (self nextBits: 2) + 3.			] ifFalse:[				"Repeat zero value"				theValue := 0.				value = 17 					ifTrue:[repCount := (self nextBits: 3) + 3]					ifFalse:[value = 18 								ifTrue:[repCount := (self nextBits: 7) + 11]								ifFalse:[^self error:'Invalid bits tree value']]].			0 to: repCount-1 do:[:i| values at: index+i put: theValue].			index := index + repCount].	].	^values! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/4/1998 02:24'!decodeValueFrom: table	"Decode the next value in the receiver using the given huffman table."	| bits bitsNeeded tableIndex value |	bitsNeeded := (table at: 1) bitShift: -24.	"Initial bits needed"	tableIndex := 2.							"First real table"	[bits := self nextSingleBits: bitsNeeded.	"Get bits"	value := table at: (tableIndex + bits).		"Lookup entry in table"	(value bitAnd: 16r3F000000) = 0] 			"Check if it is a non-leaf node"		whileFalse:["Fetch sub table"			tableIndex := value bitAnd: 16rFFFF.	"Table offset in low 16 bit"			bitsNeeded := (value bitShift: -24) bitAnd: 255. "Additional bits in high 8 bit"			bitsNeeded > MaxBits ifTrue:[^self error:'Invalid huffman table entry']].	^value! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/4/1998 02:03'!decompressAll	"Profile the decompression speed"	[self atEnd] whileFalse:[		position := readLimit.		self next "Provokes decompression"	].! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'eem 5/6/2014 14:54'!decompressBlock: llTable with: dTable	"Process the compressed data in the block.	llTable is the huffman table for literal/length codes	and dTable is the huffman table for distance codes."	| value extra length distance oldPos oldBits oldBitPos |	[readLimit < collection size and:[sourcePos <= sourceLimit]] whileTrue:[		"Back up stuff if we're running out of space"		oldBits := bitBuf.		oldBitPos := bitPos.		oldPos := sourcePos.		value := self decodeValueFrom: llTable.		value < 256 ifTrue:[ "A literal"			collection byteAt: (readLimit := readLimit + 1) put: value.		] ifFalse:["length/distance or end of block"			value = 256 ifTrue:["End of block"				state := state bitAnd: StateNoMoreData.				^self].			"Compute the actual length value (including possible extra bits)"			extra := #(0 0 0 0 0 0 0 0 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 0) at: value - 256.			length := #(3 4 5 6 7 8 9 10 11 13 15 17 19 23 27 31 35 43 51 59 67 83 99 115 131 163 195 227 258) at: value - 256.			extra > 0 ifTrue:[length := length + (self nextBits: extra)].			"Compute the distance value"			value := self decodeValueFrom: dTable.			extra := #(0 0 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 11 11 12 12 13 13) at: value+1.			distance := #(1 2 3 4 5 7 9 13 17 25 33 49 65 97 129 193 257 385 513 769						1025 1537 2049 3073 4097 6145 8193 12289 16385 24577) at: value+1.			extra > 0 ifTrue:[distance := distance + (self nextBits: extra)].			(readLimit + length >= collection size) ifTrue:[				bitBuf := oldBits.				bitPos := oldBitPos.				sourcePos := oldPos.				^self].			collection 					replaceFrom: readLimit+1 					to: readLimit + length					with: collection 					startingAt: readLimit - distance + 1.			readLimit := readLimit + length.		].	].! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/4/1998 01:51'!distanceMap	"This is used by the fast decompressor"	^nil! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/23/1999 15:15'!getFirstBuffer	"Get the first source buffer after initialization has been done"	sourceStream == nil ifTrue:[^self].	source := sourceStream next: 1 << 16. "This is more than enough..."	sourceLimit := source size.! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/3/1998 17:32'!getNextBlock	^self nextBits: 3! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/3/1998 13:16'!growHuffmanTable: table	| newTable |	newTable := table species new: table size * 2.	newTable replaceFrom: 1 to: table size with: table startingAt: 1.	^newTable! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/4/1998 02:27'!huffmanTableFrom: aCollection mappedBy: valueMap	"Create a new huffman table from the given code lengths.	Map the actual values by valueMap if it is given.	See the class comment for a documentation of the huffman	tables used in this decompressor."	| counts  values table minBits maxBits |	minBits := MaxBits + 1.	maxBits := 0.	"Count the occurences of each code length and compute minBits and maxBits"	counts := Array new: MaxBits+1.	counts atAllPut: 0.	aCollection do:[:length| 		length > 0 ifTrue:[			length < minBits ifTrue:[minBits := length].			length > maxBits ifTrue:[maxBits := length].			counts at: length+1 put: (counts at: length+1)+1]].	maxBits = 0 ifTrue:[^nil]. "Empty huffman table"	"Assign numerical values to all codes."	values := self computeHuffmanValues: aCollection counts: counts from: minBits to: maxBits.	"Map the values if requested"	self mapValues: values by: valueMap.	"Create the actual tables"	table := self createHuffmanTables: values counts: counts from: minBits to: maxBits.	^table! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/4/1998 01:48'!increment: value bits: nBits	"Increment a value of nBits length.	The fast decompressor will do this differently"	^value+1! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/4/1998 01:50'!literalLengthMap	"This is used by the fast decompressor"	^nil! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/4/1998 02:28'!mapValues: values by: valueMap	| oldValue |	valueMap ifNil:[^values].	1 to: values size do:[:i|		oldValue := values at: i.		"Note: there may be nil values if not all values are used"		oldValue isNil			ifTrue:[^values]			ifFalse:[values at: i put: (valueMap at: oldValue+1)]].! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/23/1999 15:17'!moveContentsToFront	"Move the decoded contents of the receiver to the front so that we have enough space for decoding more data."	| delta |	readLimit > 32768 ifTrue:[		delta := readLimit - 32767.		collection 			replaceFrom: 1 			to: collection size - delta + 1 			with: collection 			startingAt: delta.		position := position - delta + 1.		readLimit := readLimit - delta + 1].! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/23/1999 15:27'!moveSourceToFront	"Move the encoded contents of the receiver to the front so that we have enough space for decoding more data."	(sourceStream == nil or:[sourceStream atEnd]) ifTrue:[^self].	sourcePos > 10000 ifTrue:[		source 			replaceFrom: 1 			to: source size - sourcePos			with: source 			startingAt: sourcePos + 1.		source := sourceStream 			next: sourcePos 			into: source 			startingAt: source size - sourcePos + 1.		sourcePos := 0.		sourceLimit := source size].! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/22/1999 01:29'!next	"Answer the next decompressed object in the Stream represented by the	receiver."	<primitive: 65>	position >= readLimit		ifTrue: [^self pastEndRead]		ifFalse: [^collection at: (position := position + 1)]! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'nk 3/7/2004 18:45'!next: anInteger 	"Answer the next anInteger elements of my collection.  overriden for simplicity"	| newArray |	"try to do it the fast way"	position + anInteger < readLimit ifTrue: [		newArray := collection copyFrom: position + 1 to: position + anInteger.		position := position + anInteger.		^newArray	].	"oh, well..."	newArray := collection species new: anInteger.	1 to: anInteger do: [:index | newArray at: index put: (self next ifNil: [ ^newArray copyFrom: 1 to: index - 1]) ].	^newArray! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ul 12/6/2011 11:47'!next: n into: buffer startingAt: startIndex	"Read n objects into the given collection. 	Return aCollection or a partial copy if less than	n elements have been read."	| c numRead count |	n = 0 ifTrue: [ ^buffer ].	numRead := 0.	["Force decompression if necessary"	(c := self next) == nil 		ifTrue:[^buffer copyFrom: 1 to: startIndex+numRead-1].	"Store the first value which provoked decompression"	buffer at: startIndex + numRead put: c.	numRead := numRead + 1.	"After collection has been filled copy as many objects as possible"	count := (readLimit - position) min: (n - numRead).	buffer 		replaceFrom: startIndex + numRead 		to: startIndex + numRead + count - 1 		with: collection 		startingAt: position+1.	position := position + count.	numRead := numRead + count.	numRead = n] whileFalse.	^buffer! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/4/1998 02:00'!nextBits: n	| bits |	[bitPos < n] whileTrue:[		bitBuf := bitBuf + (self nextByte bitShift: bitPos).		bitPos := bitPos + 8].	bits := bitBuf bitAnd: (1 bitShift: n)-1.	bitBuf := bitBuf bitShift: 0 - n.	bitPos := bitPos - n.	^bits! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/5/1998 14:54'!nextByte	^source byteAt: (sourcePos := sourcePos + 1)! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/4/1998 02:01'!nextSingleBits: n	| out |	out := 0.	1 to: n do:[:i| out := (out bitShift: 1) + (self nextBits: 1)].	^out! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ls 1/2/2001 11:44'!on: aCollectionOrStream	aCollectionOrStream isStream 		ifTrue:[	aCollectionOrStream binary.				sourceStream := aCollectionOrStream.				self getFirstBuffer]		ifFalse:[source := aCollectionOrStream].	^self on: source from: 1 to: source size.! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/23/1999 15:35'!on: aCollection from: firstIndex to: lastIndex	bitBuf := bitPos := 0.	"The decompression buffer has a size of at 64k,	since we may have distances up to 32k back and	repetitions of at most 32k length forward"	collection := aCollection species new: 1 << 16.	readLimit := 0. "Not yet initialized"	position := 0.	source := aCollection.	sourceLimit := lastIndex.	sourcePos := firstIndex-1.	state := StateNewBlock.! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 2/29/2004 04:18'!pastEndRead	"A client has attempted to read beyond the read limit.	Check in what state we currently are and perform	the appropriate action"	| blockType bp oldLimit |	state = StateNoMoreData ifTrue:[^nil]. "Get out early if possible"	"Check if we can move decoded data to front"	self moveContentsToFront.	"Check if we can fetch more source data"	self moveSourceToFront.	state = StateNewBlock ifTrue:[state := self getNextBlock].	blockType := state bitShift: -1.	bp := self bitPosition.	oldLimit := readLimit.	self perform: (BlockTypes at: blockType+1).	"Note: if bit position hasn't advanced then nothing has been decoded."	bp = self bitPosition 		ifTrue:[^self primitiveFailed].	"Update crc for the decoded contents"	readLimit > oldLimit 		ifTrue:[crc := self updateCrc: crc from: oldLimit+1 to: readLimit in: collection].	state = StateNoMoreData ifTrue:[self verifyCrc].	^self next! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/3/1998 20:49'!proceedDynamicBlock	self decompressBlock: litTable with: distTable! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/3/1998 20:49'!proceedFixedBlock	self decompressBlock: litTable with: distTable! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/27/1999 13:49'!proceedStoredBlock	"Proceed decompressing a stored (e.g., uncompressed) block"	| length decoded |	"Literal table must be nil for a stored block"	litTable == nil ifFalse:[^self error:'Bad state'].	length := distTable.	[length > 0 and:[readLimit < collection size and:[sourcePos < sourceLimit]]] 		whileTrue:[			collection at: (readLimit := readLimit + 1) put: 				(source at: (sourcePos := sourcePos + 1)).			length := length - 1].	length = 0 ifTrue:[state := state bitAnd: StateNoMoreData].	decoded := length - distTable.	distTable := length.	^decoded! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/4/1998 01:46'!processDynamicBlock	| nLit nDist nLen codeLength lengthTable bits |	nLit := (self nextBits: 5) + 257.	nDist := (self nextBits: 5) + 1.	nLen := (self nextBits: 4) + 4.	codeLength := Array new: 19.	codeLength atAllPut: 0.	1 to: nLen do:[:i|		bits := #(16 17 18 0 8 7 9 6 10 5 11 4 12 3 13 2 14 1 15) at: i.		codeLength at: bits+1 put: (self nextBits: 3).	].	lengthTable := self huffmanTableFrom: codeLength mappedBy: nil.	"RFC 1951: In other words, all code lengths form a single sequence..."	codeLength := self decodeDynamicTable: nLit+nDist from: lengthTable.	litTable := self 				huffmanTableFrom: (codeLength copyFrom: 1 to: nLit)				mappedBy: self literalLengthMap.	distTable := self 				huffmanTableFrom: (codeLength copyFrom: nLit+1 to: codeLength size)				mappedBy: self distanceMap.	state := state bitOr: BlockProceedBit.	self proceedDynamicBlock.! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/4/1998 19:13'!processFixedBlock	litTable := self 				huffmanTableFrom: FixedLitCodes				mappedBy: self literalLengthMap.	distTable := self 				huffmanTableFrom: FixedDistCodes				mappedBy: self distanceMap.	state := state bitOr: BlockProceedBit.	self proceedFixedBlock.! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/27/1999 13:49'!processStoredBlock	| chkSum length |	"Skip to byte boundary"	self nextBits: (bitPos bitAnd: 7).	length := self nextBits: 16.	chkSum := self nextBits: 16.	(chkSum bitXor: 16rFFFF) = length		ifFalse:[^self error:'Bad block length'].	litTable := nil.	distTable := length.	state := state bitOr: BlockProceedBit.	^self proceedStoredBlock! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/4/1998 02:03'!profile	"Profile the decompression speed"	MessageTally spyOn:[self decompressAll].! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ul 12/6/2011 12:16'!readInto: buffer startingAt: startIndex count: n	"Read n objects into the given collection. 	Return number of elements that have been read."	| c numRead count |	n = 0 ifTrue: [ ^n ].	numRead := 0.	["Force decompression if necessary"	(c := self next) == nil 		ifTrue: [^numRead].	"Store the first value which provoked decompression"	buffer at: startIndex + numRead put: c.	numRead := numRead + 1.	"After collection has been filled copy as many objects as possible"	count := (readLimit - position) min: (n - numRead).	buffer 		replaceFrom: startIndex + numRead 		to: startIndex + numRead + count - 1 		with: collection 		startingAt: position+1.	position := position + count.	numRead := numRead + count.	numRead = n] whileFalse.	^n! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/3/1998 16:32'!reset	"Position zero - nothing decoded yet"	position := readLimit := 0.	sourcePos := 0.	bitBuf := bitPos := 0.	state := 0.! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/3/1998 16:19'!size	"This is a compressed stream - we don't know the size beforehand"	^self shouldNotImplement! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/21/1999 23:54'!sourceLimit	^sourceLimit! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/21/1999 23:52'!sourcePosition	^sourcePos! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/23/1999 15:31'!sourceStream	^sourceStream! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/3/1998 16:19'!upTo: anObject 	"Answer a subcollection from the current access position to the 	occurrence (if any, but not inclusive) of anObject in the receiver. If 	anObject is not in the collection, answer the entire rest of the receiver."	| newStream element |	newStream := WriteStream on: (collection species new: 100).	[self atEnd or: [(element := self next) = anObject]]		whileFalse: [newStream nextPut: element].	^newStream contents! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'nice 12/8/2009 15:10'!upToAnyOf: subcollection do: aBlock	"re-implement super super again...	This is a strong indicator that ReadStream SHOULD be abstract"		^self collectionSpecies new: 1000 streamContents: [ :stream |		| ch |		[ self atEnd or: [ (subcollection includes: (ch := self next)) and: [aBlock value: ch. true] ] ] 			whileFalse: [ stream nextPut: ch ] ]! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 12/22/1999 02:04'!upToEnd	"Answer a subcollection from the current access position through the last element of the receiver."	| newStream buffer |	buffer := collection species new: 1000.	newStream := WriteStream on: (collection species new: 100).	[self atEnd] whileFalse: [newStream nextPutAll: (self nextInto: buffer)].	^ newStream contents! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 2/29/2004 03:49'!updateCrc: oldCrc from: start to: stop in: aCollection	"Answer an updated CRC for the range of bytes in aCollection.	Subclasses can implement the appropriate means for the check sum they wish to use."	^oldCrc! !!InflateStream methodsFor: 'as yet unclassified' stamp: 'ar 2/29/2004 04:22'!verifyCrc	"Verify the crc checksum in the input"! !!InflateStream class methodsFor: 'as yet unclassified' stamp: 'ar 12/4/1998 19:12'!initialize	"InflateStream initialize"	MaxBits := 16.	StateNewBlock := 0.	StateNoMoreData := 1.	BlockProceedBit := 8.	BlockTypes := #(	processStoredBlock	"New block in stored format"					processFixedBlock	"New block with fixed huffman tables"					processDynamicBlock	"New block with dynamic huffman tables"					errorBadBlock		"Bad block format"					proceedStoredBlock	"Continue block in stored format"					proceedFixedBlock	"Continue block in fixed format"					proceedDynamicBlock	"Continue block in dynamic format"					errorBadBlock		"Bad block format").	"Initialize fixed block values"	FixedLitCodes := 	((1 to: 144) collect:[:i| 8]),					((145 to: 256) collect:[:i| 9]),					((257 to: 280) collect:[:i| 7]),					((281 to: 288) collect:[:i| 8]).	FixedDistCodes := ((1 to: 32) collect:[:i| 5]).! !!DAVSessionState methodsFor: 'as yet unclassified' stamp: 'crl 1/12/2015 00:10'!initialName	^'state'! !!DAVSessionState methodsFor: 'as yet unclassified' stamp: 'crl 7/14/2017 00:04'!responsePayload	| memory stream connected |	stream _ (String new: 1024) writeStream.	memory _ session memory.	connected _ memory isConnected.	stream		nextPutAll: '# Context object memory ';		nextPutAll: memory name.	(memory names size > 1) ifTrue: [		stream nextPutAll: '# # Also known as ';		printVerbosely: ((memory names copyWithout: memory name) collect: [:string | '''', string, '''']);		nextPut: $.].	stream nextPutAll: '# # This memory is'.	connected ifFalse: [stream nextPutAll: ' not'].	stream nextPutAll: ' running. You can send it'.	connected ifTrue: [stream nextPutAll: ' one of'].	stream nextPutAll: ' the following command'.	connected ifTrue: [stream nextPut: $s].	stream		nextPutAll: ': ';		nextPutAll: '# # ';		nextPutAll: (			connected				ifTrue: ['- snapshot# - suspend# - stop']				ifFalse: ['- resume']);		nextPutAll: '# # To do so, write this file with the desired command uncommented.# # '.	connected ifTrue: [		stream nextPutAll: 'Subsequent comments below give other information about this memory,# like host resource usage and virtual machine plugins loaded.# # '].	stream		nextPutAll: 'There''s also an HTML control interface, at# http://localhost:';		print: FrontendWebserver activePeer port;		nextPutAll: '/README.html# # '.	connected ifTrue: [		stream nextPutAll: '# host resource usage## bytes available: ';			print: Smalltalk garbageCollect";			nextPutAll: '# virtual machine plugins loaded# '.		memory loadedPlugins do: [:plugin |			stream				cr;				nextPutAll: '# ';				print: plugin]"].	^stream contents! !!DAVSessionState methodsFor: 'as yet unclassified' stamp: 'crl 1/12/2015 03:33'!sideEffect	self shouldNotImplement! !!DAVSessionState class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 6/5/2001 17:09'!beBinary	"Treat my contents as binary data."	binary _ true.	collection _ self encode: collection! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 8/26/2005 13:10'!beBinaryWhile: aBlockClosure	"Be in binary mode while evaluating aBlockClosure."	| wasBinary |	wasBinary _ binary.	self beBinary.	aBlockClosure ensure: [		wasBinary ifFalse: [self beTextual]]! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 8/26/2005 13:09'!beTextual	"Treat my contents textually."	binary _ false.	collection _ self encode: collection! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 8/26/2005 13:10'!beTextualWhile: aBlockClosure	"Be in textual mode while evaluating aBlockClosure."	| wasBinary |	wasBinary _ binary.	self beTextual.	aBlockClosure ensure: [		wasBinary ifTrue: [self beBinary]]! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 2/7/2003 04:15'!bufferSize	"Answer my bufferSize."	^collection size! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 4/16/2001 15:32'!bufferSize: bufferSize	"Initialize buffering for future reading and writing operations."	"By default, use my collection as a single logical buffer for both reading and writing."	self emptyCollection: (String new: bufferSize)! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 5/7/2001 19:02'!bufferingWrittenElements	"Answer whether I'm buffering written elements."	"By default, I am."	^true! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 5/29/2011 20:16'!close	"Close my resource."	resource close! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 12/19/2000 21:58'!commit	"Commit any buffered data externally."	"There is a semantic difference between 'flush' and 'commit'. 'Flush' sends buffered data from object memory to the virtual machine, while 'commit' flushes buffered data and subsequently ensures that the data is actually sent to the appropriate external resource. This provides for portable buffering in object memory, while allowing for additional buffering optimization by the virtual machine and host environment (if any). If there is no such additional buffering, then 'flush' and 'commit' are equivalent."	self flush.	resource commit! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 5/25/2001 00:31'!cr	"Write a 'carriage-return'."	binary		ifTrue: [EncodingMismatch signal]		ifFalse: [super cr]! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 5/25/2001 00:31'!crlf	"Write a 'carriage-return' and a 'linefeed'."	binary		ifTrue: [EncodingMismatch signal]		ifFalse: [super crlf]! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 11/28/2000 17:35'!dataAvailable	"Answer whether there is data available for reading."	^resource dataAvailable! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 5/7/2001 16:57'!encode: aSequenceableCollection	"Answer a suitably encoded version of aSequenceableCollection (e.g., characters or bytes)."	^binary		ifTrue: [aSequenceableCollection asByteArray]		ifFalse: [aSequenceableCollection asString]! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 5/7/2001 19:10'!encodeSingleElement: eightBitValue	"Answer a suitably-encoded version of eightBitValue (e.g., as a byte or a character)."	^binary		ifTrue: [eightBitValue asInteger]		ifFalse: [eightBitValue asCharacter]! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 2/21/2006 11:53'!flush	"Flush any unwritten elements."	"There is a semantic difference between 'flush' and 'commit'. 'Flush' sends buffered data from object memory to the virtual machine, while 'commit' flushes buffered data and subsequently ensures that the data is actually sent to the appropriate external resource. This provides for portable buffering in object memory, while allowing for additional buffering optimization by the virtual machine and host environment (if any). If there is no such additional buffering, then 'flush' and 'commit' are equivalent."	self isDirty ifTrue: [		self			open;			flushWritingBuffer.		indexOfLastDirtyElement _ 0]! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 8/3/2002 02:03'!flushWritingBuffer	"Send unsent writing buffer elements to the virtual machine."	"Assume my resource is active (e.g., the sending context is >>flush)."	self subclassResponsibility! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 12/14/2000 18:55'!increaseAvailableReadingCapacity	"Increase my available reading capacity."	"Fetch additional elements from my resource."	self subclassResponsibility! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 12/14/2000 16:55'!indexOfFirstWritableField	"Answer the index of the first writable field."	^self subclassResponsibility! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 12/12/2000 11:04'!indexOfLastDirtyElement	"Answer the index of the last dirty element."	^self subclassResponsibility! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 11/28/2000 17:35'!isActive	"Answer whether I'm active."	^resource isActive! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 12/12/2007 22:00'!isBinary	^binary! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 12/15/2000 00:35'!isDirty	"Answer whether my writing buffer contains elements which ought to be committed."	^indexOfLastDirtyElement > 0! !!ExternalStream methodsFor: 'as yet unclassified'!isExternal	^true! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 11/28/2000 17:34'!isOpen	"Answer whether I'm open."	^resource isOpen! !!ExternalStream methodsFor: 'as yet unclassified'!next16Bits	| bytes |	bytes _ self next: 2.	^((bytes at: 1) bitShift: 8) + (bytes at: 2)! !!ExternalStream methodsFor: 'as yet unclassified'!next16BitsPut: sixteenBits	self nextPutAll: (		ByteArray			with: (sixteenBits bitShift: -8)			with: (sixteenBits bitAnd: 255)).	^sixteenBits! !!ExternalStream methodsFor: 'as yet unclassified'!nextByte	^ self next asInteger! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 5/7/2001 17:48'!nextBytePut: eightBitValue	"Write eightBitValue at the next writing position in my writing buffer."	self beBinaryWhile: [self nextPut: eightBitValue]! !!ExternalStream methodsFor: 'as yet unclassified'!nextInt32	"Read a 32-bit signed integer from the next 4 bytes"	| s |	s _ 0.	1 to: 4 do: [:i | s _ (s bitShift: 8) + self next].	(s bitAnd: 16r80000000) = 0		ifTrue: [^ s]		ifFalse: [^ -1 - s bitInvert32]! !!ExternalStream methodsFor: 'as yet unclassified'!nextInt32Put: int32	"Write a signed integer to the next 4 bytes"	| pos |	pos _ int32 < 0		ifTrue: [(0-int32) bitInvert32 + 1]		ifFalse: [int32].	1 to: 4 do: [:i | self nextPut: (pos digitAt: 5-i)].	^ int32! !!ExternalStream methodsFor: 'as yet unclassified'!nextLittleEndianNumber: n 	"Answer the next n bytes as a positive Integer or LargePositiveInteger, where the bytes are ordered from least significant to most significant."	| s bytes |	bytes _ self next: n.	s _ 0.	n to: 1 by: -1 do: [: i | s _ (s bitShift: 8) bitOr: (bytes at: i)].	^ s! !!ExternalStream methodsFor: 'as yet unclassified'!nextLittleEndianNumber: n put: integer	"Put the next n bytes as a positive integer where the bytes are ordered from least significant to most significant."	1 to: n do: [: i | self nextPut: (integer digitAt: i)]! !!ExternalStream methodsFor: 'as yet unclassified'!nextNumber: n 	"Answer the next n bytes as a positive Integer or LargePositiveInteger."	| s |	s _ 0.	1 to: n do: 		[:i | s _ (s bitShift: 8) bitOr: self next].	^ s normalize! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 6/9/2011 19:45'!nextPut: anObject	"Put anObject at the next position and answer it."	self nextPutAll: (collection species with: anObject).	^anObject! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 5/29/2011 01:23'!nextPut: numberOfElementsToWrite from: eightBitValues startingAt: startIndex	"Write numberOfElementsToWrite elements from eightBitValues, starting at startIndex."	numberOfElementsToWrite <= 0 ifFalse: [		| numberOfAvailableSlots numberOfElementsToPut relativeWritingPosition |		relativeWritingPosition _ self relativeWritingPosition.		numberOfAvailableSlots _ writeLimit - relativeWritingPosition.		numberOfElementsToPut _ numberOfAvailableSlots min: eightBitValues size - startIndex + 1.		collection			replaceFrom: relativeWritingPosition + 1			to: relativeWritingPosition + numberOfElementsToPut			with: eightBitValues			startingAt: startIndex.		indexOfLastDirtyElement _ relativeWritingPosition + numberOfElementsToPut.		self relativeWritingPosition: indexOfLastDirtyElement.		indexOfLastDirtyElement = writeLimit ifTrue: [self increaseAvailableWritingCapacity].		self			nextPut: numberOfElementsToWrite - numberOfElementsToPut			from: eightBitValues			startingAt: startIndex + numberOfElementsToPut]! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 5/29/2011 01:13'!nextPutAll: eightBitValues 	(		(self bufferingWrittenElements)			ifTrue: [self]			ifFalse: [resource]	)		nextPut: eightBitValues basicSize		from: eightBitValues		startingAt: 1.	^eightBitValues! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'il prior: 37037765!!!!!!!!!!!!!!!!'!nextWord	| bytes |	bytes _ self next: 4.	^((bytes at: 1) bitShift: 24) + ((bytes at: 2) bitShift: 16) + ((bytes at: 3) bitShift: 8) + (bytes at: 4)! !!ExternalStream methodsFor: 'as yet unclassified'!nextWord16   "For compatibility with old systems only"	"Answer the next two bytes from the receiver as an Integer."	| high low str |	true ifTrue:		["Slower code works while file next fails on non-ascii data"		str _ self next: 2.		high _ str at: 1.		low _ str at: 2]	ifFalse:		[high _ self next.		low _ self next].	^(high asInteger bitShift: 8) + low asInteger! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 6/23/2011 15:07'!nextWordPut: aWord 	"Append to the receiver an Integer as the next four bytes."	self nextPut: ((aWord bitShift: -24) bitAnd: 255).	self nextPut: ((aWord bitShift: -16) bitAnd: 255).	self nextPut: ((aWord bitShift: -8) bitAnd: 255).	self nextPut: (aWord bitAnd: 255).	^ aWord! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 2/21/2006 11:48'!open	"Ensure that I am open. Answer whether I was closed before."	^resource open! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 5/31/2011 01:01'!peek: anInteger	"Answer the next anInteger elements without consuming them."	anInteger > self readingBufferCapacity		ifTrue: [			self				readingBufferCapacity: 64;				peek: anInteger]		ifFalse: [collection copyTo: anInteger]! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 11/28/2000 17:34'!peerClosed	"Answer whether my peer closed its side of the connection."	^resource peerClosed! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 5/7/2001 17:54'!pendingIncomingElements	"Answer the contents of my reading buffer."	^collection! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 12/15/2000 00:56'!pendingOutgoingElements	"Answer the contents of my writing buffer."	^(self isDirty)		ifTrue: [			collection				copyFrom: self indexOfFirstWritableField				to: indexOfLastDirtyElement]		ifFalse: ['']! !!ExternalStream methodsFor: 'as yet unclassified'!postCopy	"Finish copying myself."	resource _ resource copy! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 11/3/1999 03:45'!printInactivityExplanationOn: aStream	"Print an inactivity explanation on aStream."	aStream		nextPutAll: ', until a ';		nextPutAll: (			resource peerClosed				ifTrue: ['remote']				ifFalse: ['local']);		nextPutAll: ' disconnection occurred'! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 5/7/2001 17:50'!printOn: aStream	"Print a character-based description of myself on aStream."	aStream nextPutAll: 'a '.	binary ifFalse: [aStream nextPutAll: 'non-'].	aStream		nextPutAll: 'binary ';		print: self class;		nextPutAll: ' on ';		print: resource! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 1/30/2004 17:25'!readingBufferCapacity	"Answer my reading buffer capacity."	^self bufferSize! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 2/7/2003 04:16'!readingBufferSize	"Answer my readingBufferSize."	^self bufferSize! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 5/7/2001 17:16'!readingBufferSize: readingBufferSize	"Initialize buffering for future reading and writing operations."	"By default, use my collection as a single logical buffer for both reading and writing."	self bufferSize: readingBufferSize! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 12/14/2000 16:25'!relativeWritingPosition	"Answer my writing position, relative to the beginning of my buffering sequence (as opposed to the beginning of some externally-held sequence)."	"By default, my relative reading and writing positions are the same."	^position! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 12/14/2000 16:25'!relativeWritingPosition: anInteger	"Set my writing position, relative to the beginning of my buffering sequence (as opposed to the beginning of some externally-held sequence)."	"By default, my relative reading and writing positions are the same."	position _ anInteger! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 2/21/2006 12:23'!reopen	self close; open! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 9/6/2008 00:46'!resource	^resource! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 8/29/2005 18:37'!resource: anExternalResource 	resource _ anExternalResource.	self emptyCollection: ''.	writeLimit _ 0.	indexOfLastDirtyElement _ 0.	binary _ true.	singletonToWrite _ ByteArray new: 1! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 4/24/2001 19:51'!skip: anInteger	"Skip anInteger elements."	"The superclass implementation is inappropriate for each of my direct subclasses."	self subclassResponsibility! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 7/19/2005 20:37'!skipWord	self skip: 4! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 5/25/2001 00:31'!space	"Write a space."	binary		ifTrue: [EncodingMismatch signal]		ifFalse: [super space]! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 5/25/2001 00:31'!tab	"Write a tab."	binary		ifTrue: [EncodingMismatch signal]		ifFalse: [super tab]! !!ExternalStream methodsFor: 'as yet unclassified' stamp: 'crl 5/30/2011 21:53'!upToAll: pattern	"Answer the next elements up to but not including those in pattern."	| elementStream elementPattern elementPatternSize |	elementStream _ (collection species new: 128) writableStream.	elementPattern _ self encode: pattern.	elementPatternSize _ pattern size.	[(elementStream size >= elementPatternSize) and: [(elementStream last: elementPatternSize) = elementPattern]] whileFalse: [elementStream nextPut: self next].	^elementStream allButLast: elementPatternSize! !!ExternalStream class methodsFor: 'as yet unclassified' stamp: 'crl 6/16/2001 23:50'!on: anExternalResource	"Answer an instance of myself on anExternalResource."	^self basicNew resource: anExternalResource! !!HTMLCanvasElement methodsFor: 'as yet unclassified' stamp: 'crl 4/18/2018 17:55'!displayForm: form at: origin	self		primitiveShowTop: 0		left: 0		bottom: form height		right: form width		inForm: form		at: origin		onContext: context! !!HTMLCanvasElement methodsFor: 'as yet unclassified' stamp: 'crl 4/2/2019 11:33'!extent	^self width @ self height! !!HTMLCanvasElement methodsFor: 'as yet unclassified' stamp: 'crl 4/18/2018 17:54'!initialize	context := proxy getContext: '2d'! !!HTMLCanvasElement methodsFor: 'as yet unclassified' stamp: 'crl 6/21/2017 01:12'!position: point	self		styleAt: #position put: 'absolute';		styleAt: #top put: point y;		styleAt: #left put: point x! !!HTMLCanvasElement methodsFor: 'as yet unclassified' stamp: 'crl 6/21/2017 01:09'!primitiveShowTop: top left: left bottom: bottom right: right inForm: form at: origin onContext: context	<primitive: 247>	self error: 'oops'! !!HTMLCanvasElement methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2017 20:05'!world	| identityHash |		identityHash := proxy world.	^HTML5PasteUpMorph allInstances detect: [:world | world identityHash = identityHash] ifNone: [nil]! !!HTMLCanvasElement class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!RemoteDebugger methodsFor: 'as yet unclassified' stamp: 'crl 10/10/2016 21:06'!contents: aText notifying: aController	"The retrieved information has changed and its source must now be updated.	 In this case, the retrieved information is the method of the selected context."	| result selector classOfMethod category h ctxt newMethodEdition temporaryClass |	contextStackIndex = 0 ifTrue:		[^false].	self selectedContext isExecutingBlock ifTrue:		[h := self selectedContext activeHome.		 h ifNil:			[self inform: 'Method for block not found on stack, can''t edit and continue'.			 ^false].		 (self confirm: 'I will have to revert to the method from\which this block originated.  Is that OK?' withCRs) ifFalse:			[^false].		self resetContext: h changeContents: false.		"N.B. Only reset the contents if the compilation succeeds.  If contents are reset		 when compilation fails both compiler error message and modifications are lost."		(result := self contents: aText notifying: aController) ifTrue:			[self contentsChanged].		^result].	classOfMethod := self selectedClass.	category := self selectedMessageCategoryName.	selector := self selectedClass newParser parseSelector: aText.	(selector == self selectedMessageName	 or: [(self selectedMessageName beginsWith: 'DoIt')		and: [selector numArgs = self selectedMessageName numArgs]]) ifFalse:		[self inform: 'can''t change selector'.		 ^false].	temporaryClass := classOfMethod temporaryCopy install.	selector := temporaryClass				compile: aText				classified: category				notifying: aController.	selector ifNil: [^false]. "compile cancelled"	contents := aText.	newMethodEdition := (		temporaryClass			newEditionForMethod: (temporaryClass compiledMethodAt: selector)			at: selector			withSource: aText asString).	EditHistory activateMethodEdition: newMethodEdition.	MemoryProfile current peer installMethodEdition: newMethodEdition.	newMethodEdition isQuick ifTrue:		[self down.		 self selectedContext jump: (self selectedContext previousPc - self selectedContext pc)].	ctxt := interruptedProcess popTo: self selectedContext.	ctxt == self selectedContext		ifFalse:			[self inform: 'Method saved, but current context unchanged\because of unwind error. Click OK to see error' withCRs]		ifTrue:			[newMethodEdition isQuick ifFalse:				[interruptedProcess					restartTopWith: newMethodEdition;				 	stepToSendOrReturn].			contextVariablesInspector object: nil].	self resetContext: ctxt.	Smalltalk isMorphic ifTrue:		[World			addAlarm: #changed:			withArguments: #(contentsSelection)			for: self			at: (Time millisecondClockValue + 200)].	^true! !!RemoteDebugger methodsFor: 'as yet unclassified' stamp: 'crl 10/10/2016 02:21'!contextStackIndex: anInteger oldContextWas: oldContext 	"Change the context stack index to anInteger, perhaps in response to user selection."	| isNewMethod selectedContextSlotName index |	contextStackIndex := anInteger.	anInteger = 0 ifTrue:		[currentCompiledMethod := contents := nil.		 self changed: #contextStackIndex.		 self decorateButtons.		 self contentsChanged.		 contextVariablesInspector object: nil.		 receiverInspector object: self receiver.		 ^self].	selectedContextSlotName := contextVariablesInspector selectedSlotName.	isNewMethod := oldContext == nil					or: [oldContext method ~= (currentCompiledMethod := self selectedContext method)].	isNewMethod ifTrue:		[contents := self selectedMessage.		 self contentsChanged.		 self pcRange].	self changed: #contextStackIndex.	self decorateButtons.	contextVariablesInspector object: self selectedContext.	((index := contextVariablesInspector fieldList indexOf: selectedContextSlotName) ~= 0	 and: [index ~= contextVariablesInspector selectionIndex]) ifTrue:		[contextVariablesInspector toggleIndex: index].	receiverInspector object: self receiver.	isNewMethod ifFalse:		[self changed: #contentsSelection]! !!RemoteDebugger methodsFor: 'as yet unclassified' stamp: 'crl 10/9/2016 16:53'!isModeStyleable	^false! !!RemoteDebugger methodsFor: 'as yet unclassified' stamp: 'crl 10/13/2016 16:18'!morphicResumeProcess: aTopView	| processToResume |	bridgeContext swapSender: originalBridgeContextSender.	processToResume := interruptedProcess.	interruptedProcess := nil. "Before delete, so release doesn't terminate it"	aTopView delete.	World displayWorld. "We have to redraw *before* resuming the old process."	Smalltalk installLowSpaceWatcher. "restart low space handler"	savedCursor		ifNotNil: [Cursor currentCursor: savedCursor].	processToResume isTerminated ifFalse: [		errorWasInUIProcess					ifTrue: [Project resumeProcess: processToResume]					ifFalse: [processToResume resumeRemotely]].	"if old process was terminated, just terminate current one"	errorWasInUIProcess == false		ifFalse: [Processor terminateActive].	localProcess resume! !!RemoteDebugger methodsFor: 'as yet unclassified' stamp: 'crl 10/9/2016 23:23'!pcRange	"Answer the indices in the source code for the method corresponding to 	the selected context's program counter value."	| context |		(selectingPC and: [contextStackIndex ~= 0]) ifFalse:		[^1 to: 0].	self selectedContext isDead ifTrue:		[^1 to: 0].		context := self selectedContext.	^(		(			(context recyclingHash = 0)				ifTrue: [context]				ifFalse: [context id edition]		)			debuggerMap	)		rangeForPC: self selectedContext pc		contextIsActiveContext: contextStackIndex = 1! !!RemoteDebugger methodsFor: 'as yet unclassified' stamp: 'crl 10/14/2016 23:29'!remoteProcess: aProcess localProcess: anotherProcess controller: aController context: aContext bridgeContext: anotherContext originalBridgeContextSender: yetAnotherContext	self		process: aProcess		controller: nil		context: aContext.	bridgeContext := anotherContext.	originalBridgeContextSender := yetAnotherContext.	"localDebugger := (		(Debugger new)			process: anotherProcess			controller: aController			context: thisContext sender sender)"	localProcess := anotherProcess! !!RemoteDebugger methodsFor: 'as yet unclassified' stamp: 'crl 10/10/2016 15:33'!selectedClass	"Answer the class in which the currently selected context's method was 	found."	^self selectedContext id edition classEdition! !!RemoteDebugger methodsFor: 'as yet unclassified' stamp: 'crl 10/10/2016 00:21'!selectedMessage	"Answer the source code of the currently selected context."	^contents := self selectedContext source asText makeSelectorBoldIn: Object! !!RemoteDebugger methodsFor: 'as yet unclassified' stamp: 'crl 10/13/2016 16:18'!windowIsClosing	bridgeContext sender recyclingHash = 0 ifTrue: [		bridgeContext swapSender: originalBridgeContextSender.		localProcess terminate].	super windowIsClosing! !!RemoteDebugger class methodsFor: 'as yet unclassified' stamp: 'crl 10/14/2016 16:50'!openContext: aContext inRemoteProcess: remoteProcess bridgeContext: anotherContext originalBridgeContextSender: yetAnotherContext label: aString contents: contentsString 
	"Send a marker telling the remote sender that something has gone wrong. This is the remote system's cue to open a debugger on the context conveyed by the marker. We'll also suspend this very process, so that it doesn't interfere with this system's answers to messages from the remote system (in particular, the ones sent by the remote debugger)."

	<primitive: 19>
	ErrorRecursion ifTrue: [
		ErrorRecursion := false.
		self primitiveError: aString].
	ErrorRecursion := true.
	(
		(self new)
			remoteProcess: remoteProcess
			localProcess: Processor activeProcess
			controller: (
				(Smalltalk isMorphic)
					ifTrue: [nil]
					ifFalse: [ScheduledControllers activeController])
			context: aContext
			bridgeContext: anotherContext
			originalBridgeContextSender: yetAnotherContext
	)
		openNotifierContents: contentsString
		label: aString.
	ErrorRecursion := false.
	Project current spawnNewProcessAndTerminateOld: false! !!NodeList methodsFor: 'as yet unclassified' stamp: 'crl 4/1/2019 01:11'!at: index	^proxy at: index printString! !!NodeList methodsFor: 'as yet unclassified' stamp: 'crl 4/1/2019 01:11'!at: index put: value	^proxy		at: index printString		put: value! !!NodeList class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSAlignmentMorph methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSAlignmentMorph class methodsFor: 'as yet unclassified' stamp: 'crl 5/29/2017 22:37'!orientation: orientation	^self orientation: orientation padding: 2! !!JSAlignmentMorph class methodsFor: 'as yet unclassified' stamp: 'crl 5/29/2017 22:36'!orientation: orientation padding: padding	^self newWithParameters: {orientation. padding}! !!ChromeMethodInvocation methodsFor: 'as yet unclassified' stamp: 'crl 7/31/2016 13:12'!api	^api! !!ChromeMethodInvocation methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 12:20'!api: theAPI selector: theSelector parameters: theParameters	api := theAPI.	selector := theSelector.	parameters := theParameters! !!ChromeMethodInvocation methodsFor: 'as yet unclassified' stamp: 'crl 8/7/2016 15:47'!deliver: result	api deliver: (		api			perform: (selector, ':with:') asSymbol			with: parameters			with: result)! !!ChromeMethodInvocation methodsFor: 'as yet unclassified' stamp: 'crl 7/28/2016 16:26'!id	^id! !!ChromeMethodInvocation methodsFor: 'as yet unclassified' stamp: 'crl 7/28/2016 20:42'!id: anInteger	id := anInteger! !!ChromeMethodInvocation methodsFor: 'as yet unclassified' stamp: 'crl 7/30/2016 00:43'!invokes	^true! !!ChromeMethodInvocation methodsFor: 'as yet unclassified' stamp: 'crl 7/30/2016 23:51'!perform	api		perform: (selector, ':') asSymbol		withArguments: parameters! !!ChromeMethodInvocation methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 20:25'!printOn: aStream	aStream		nextPutAll: api domain;		nextPut: $.;		nextPutAll: selector! !!ChromeMethodInvocation methodsFor: 'as yet unclassified' stamp: 'crl 8/6/2016 17:46'!sendTo: websocket	| dictionary |		dictionary := IdentityDictionary new.		dictionary		at: #id put: id;		at: #method put: (api domain, '.', selector).			parameters isEmpty ifFalse: [		dictionary			at: #params			put: (Dictionary withAll: parameters)].	websocket send: (WebUtils jsonEncode: dictionary)! !!ChromeMethodInvocation class methodsFor: 'as yet unclassified' stamp: 'crl 7/24/2017 14:53'!fromDictionary: dictionary for: tab	| method api selector |		method := (dictionary at: 'method') readStream.	api := tab apiAt: (method upTo: $.).	selector := method upToEnd asSymbol.		^self		invokingSelector: selector		withParameters: (			{api				perform: (					(						(							(api class)								compiledMethodAt: (selector, ':') asSymbol								ifAbsent: [self error: 'Chrome API pragma missing']						)							pragmaAt: #parseParameters:					)						arguments onlyOne)				withArguments: {dictionary at: 'params'}})		ofAPI: api! !!ChromeMethodInvocation class methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 12:21'!invokingSelector: selector withParameters: parameters ofAPI: api	^(self new)		api: api		selector: selector		parameters: parameters! !!TheWorldMainDockingBar methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 22:32'!toolsMenuOn: aDockingBar 	aDockingBar addItem: [ :item |		item			contents: 'Tools' translated;			addSubMenu: [ :menu | 				self					browserMenuItemOn: menu;					workspaceMenuItemOn: menu;					transcriptMenuItemOn: menu;					testRunnerMenuItemOn: menu;					methodFinderMenuItemOn: menu.				menu addLine.				self 					simpleChangeSorterMenuItemOn: menu;					dualChangeSorterMenuItemOn: menu.				menu addLine.				self					processBrowserMenuItemOn: menu;					preferenceBrowserMenuItemOn: menu;					fileListMenuItemOn: menu.			] ]! !!MaybeContextInstanceVariableNode class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!ISO88597TextConverter methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:55'!foo! !!WebGLRenderingContext methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!WebGLRenderingContext class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!TraitComposition class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!Form methodsFor: 'as yet unclassified' stamp: 'crl 6/23/2016 17:33'!bounds	^self boundingBox translateBy: offset! !!Form methodsFor: 'as yet unclassified' stamp: 'crl 6/22/2016 15:34'!copyInto: newForm at: origin 	"Return a new form which derives from the portion of the original form delineated by aRect."	^ newForm copyBits: self boundingBox from: self at: origin		clippingBox: newForm boundingBox rule: Form over fillColor: nil! !!Promise methodsFor: 'as yet unclassified' stamp: 'fbs 5/17/2013 18:42'!error	^ error.! !!Promise methodsFor: 'as yet unclassified' stamp: 'fbs 5/20/2013 09:41'!evaluateRejecter: rejecterBlock	^ rejecterBlock cull: error.! !!Promise methodsFor: 'as yet unclassified' stamp: 'fbs 5/20/2013 09:29'!evaluateResolver: resolverBlock	^ resolverBlock cull: value.! !!Promise methodsFor: 'as yet unclassified' stamp: 'fbs 5/26/2013 14:17'!ifRejected: errBlock	^ self then: [:ignored | "Do nothing"] ifRejected: errBlock.! !!Promise methodsFor: 'as yet unclassified' stamp: 'fbs 5/26/2013 14:19'!initialize	state := #pending.	resolvers := #().	rejecters := #().	mutex := Mutex new.! !!Promise methodsFor: 'as yet unclassified' stamp: 'fbs 5/20/2013 20:37'!initializeWithIfRejected: aBlock	self initialize.	rejecters := {aBlock}.! !!Promise methodsFor: 'as yet unclassified' stamp: 'fbs 5/15/2013 17:37'!initializeWithResolvedValue: anObject	self initialize.	self resolveWith: anObject.! !!Promise methodsFor: 'as yet unclassified' stamp: 'fbs 5/20/2013 09:48'!isPromise	^ true.! !!Promise methodsFor: 'as yet unclassified' stamp: 'fbs 5/20/2013 09:32'!isRejected	^ state == #rejected.! !!Promise methodsFor: 'as yet unclassified' stamp: 'fbs 5/17/2013 18:33'!isResolved	^ state == #fulfilled.! !!Promise methodsFor: 'as yet unclassified' stamp: 'fbs 5/20/2013 20:42'!printOn: aStream	aStream nextPutAll: 'a Promise'.	self isResolved ifTrue: [		aStream			nextPutAll: '(resolved: ';			nextPutAll: value printString;			nextPutAll: ')'].	self isRejected ifTrue: [		aStream			nextPutAll: '(rejected: ';			nextPutAll: error printString;			nextPutAll: ')'].! !!Promise methodsFor: 'as yet unclassified' stamp: 'fbs 5/20/2013 09:45'!rejectWith: anObject	"Reject this promise."	mutex critical: [		(state == #fulfilled) ifTrue: [self error: 'Promise was already resolved'].		(state == #rejected) ifTrue: [self error: 'Promise was already rejected'].		error := anObject.		state := #rejected.		rejecters do: [:r | self evaluateRejecter: r]].! !!Promise methodsFor: 'as yet unclassified' stamp: 'fbs 5/23/2013 17:38'!resolveWith: arg	"Resolve this promise"	mutex critical: [		(state == #fulfilled) ifTrue: [self error: 'Promise was already resolved'].		(state == #rejected) ifTrue: [self error: 'Promise was already resolved'].		value := arg.		state := #fulfilled.		resolvers do: [:r |			self evaluateResolver: r]].! !!Promise methodsFor: 'as yet unclassified' stamp: 'fbs 5/20/2013 20:37'!then: resolvedBlock	^ self then: resolvedBlock ifRejected: [:ignored | "Do nothing"].! !!Promise methodsFor: 'as yet unclassified' stamp: 'fbs 5/23/2013 20:26'!then: resolvedBlock ifRejected: errBlock	"Return a Promise that, if it resolves, runs the resolvedBlock. If resolution throws an Exception, it runs the errBlock."	| p |	p := Promise new.	self whenResolved: [:v |		[p resolveWith: (resolvedBlock value: v)]			on: Error do: [:e | p rejectWith: e]].	self whenRejected: [:e | p rejectWith: (errBlock value: e)].	^ p.! !!Promise methodsFor: 'as yet unclassified' stamp: 'fbs 5/26/2013 14:40'!unsynchronized	"This is useful for tests, because it's quite easy otherwise to deadlock your image. It is a DISASTER to use this in production code!!"	mutex := NullMutex new.! !!Promise methodsFor: 'as yet unclassified' stamp: 'jcg 12/17/2009 01:03'!value	^value! !!Promise methodsFor: 'as yet unclassified' stamp: 'jcg 12/17/2009 01:09'!wait	"Wait unconditionally for this promise to resolve."	| sema |	sema := Semaphore new.	self whenResolved:[sema signal].	sema wait.	^value! !!Promise methodsFor: 'as yet unclassified' stamp: 'fbs 5/17/2013 18:35'!waitTimeoutMSecs: msecs	"Wait for at most the given number of milliseconds for this promise to resolve. Answer true if it is resolved, false otherwise."	| sema delay |	sema := Semaphore new.	self whenResolved: [sema signal].	delay := Delay timeoutSemaphore: sema afterMSecs: msecs.	[sema wait] ensure: [delay unschedule].	^ self isResolved.! !!Promise methodsFor: 'as yet unclassified' stamp: 'jcg 12/17/2009 01:11'!waitTimeoutSeconds: seconds	"Wait for at most the given number of seconds for this promise to resolve. Answer true if it is resolved, false otherwise."	^self waitTimeoutMSecs: seconds*1000! !!Promise methodsFor: 'as yet unclassified' stamp: 'fbs 5/20/2013 20:34'!whenRejected: aBlock	"Evaluate aBlock when I am rejected"	aBlock numArgs <= 1 ifFalse: [self error: 'Must be 0- or 1-argument block'].	^ mutex critical: [		rejecters := rejecters copyWith: aBlock.		self isRejected ifTrue:[self evaluateRejecter: aBlock].	]! !!Promise methodsFor: 'as yet unclassified' stamp: 'fbs 5/20/2013 20:34'!whenResolved: aBlock	"Evaluate aBlock when I am resolved"	aBlock numArgs <= 1 ifFalse:[self error: 'Must be 0- or 1-argument block'].	^ mutex critical: [		resolvers := resolvers copyWith: aBlock.		self isResolved ifTrue:[self evaluateResolver: aBlock].	]! !!Promise class methodsFor: 'as yet unclassified' stamp: 'fbs 5/20/2013 20:37'!ifRejected: aBlock	^ Promise basicNew initializeWithIfRejected: aBlock.! !!Promise class methodsFor: 'as yet unclassified' stamp: 'fbs 5/17/2013 08:23'!unit: anObject	"Return a resolved Promise. #new is the other half of Promise's unit function; #new returns an unresolved Promise."	^ Promise basicNew initializeWithResolvedValue: anObject.! !!ProportionalLayout class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!ToolBuilder methodsFor: 'as yet unclassified' stamp: 'crl 6/13/2017 19:09'!open: anObject inWorld: world	"Build and open the object. Answer the widget opened."	| morph |	anObject isMorph 		ifTrue:[morph := anObject]		ifFalse:[morph := self build: anObject].	(morph isKindOf: MenuMorph)		ifTrue:[morph popUpInWorld: world].	(morph isKindOf: SystemWindow)		ifFalse:[morph openInWorld: world]		ifTrue:[			morph := morph openInWorld: world extent: morph extent.			(self class openToolsAttachedToMouseCursor				and: [self currentEvent isMouse  and: [self currentEvent isMouseUp]])					ifTrue: [						morph setProperty: #initialDrop toValue: true.						morph hasDropShadow: false.						self currentHand attachMorph: morph]].	^morph! !!ToolBuilder methodsFor: 'as yet unclassified' stamp: 'crl 6/13/2017 19:09'!open: anObject label: aString world: world	"Build an open the object, labeling it appropriately.  Answer the widget opened."	| window |	window := self open: anObject inWorld: world.	window setLabel: aString.	^window! !!ToolBuilder class methodsFor: 'as yet unclassified' stamp: 'crl 8/18/2017 17:30'!open: aClass label: aString	^self		open: aClass		label: aString		world: ActiveWorld! !!ToolBuilder class methodsFor: 'as yet unclassified' stamp: 'crl 6/13/2017 20:00'!open: aClass label: aString world: world	^self default open: aClass label: aString world: world! !!TopLeftGripMorph class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!WeakKeyToCollectionDictionary class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!WideSymbol methodsFor: 'as yet unclassified' stamp: 'crl 5/20/2018 23:24'!storeOnTether: tether
	tether
		nextWordPut: WideSymbolTag;
		store: self asWideString! !!WideSymbol class methodsFor: 'as yet unclassified'!fromTether: tether	^tether next asSymbol! !!DOMNode methodsFor: 'as yet unclassified' stamp: 'crl 3/28/2019 18:07'!descendantAt: id	| children |		children := self children.		^children		detect: [:child | child id = id]		ifNone: [			children do: [:child |				| hit |										hit := child descendantAt: id.								hit ifNotNil: [^hit]].						nil]! !!DOMNode methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2019 22:35'!removeChildren	(JS Function new: 'while (this.hasChildNodes()) {this.removeChild(this.lastChild)}') call: proxy! !!DOMNode class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!HTML5ToolBuilder methodsFor: 'as yet unclassified' stamp: 'crl 9/18/2017 15:52'!buildPluggableWindow: aSpec	| widget |	aSpec layout == #proportional ifFalse:[		"This needs to be implemented - probably by adding a single pane and then the rest"		^self error: 'Not implemented'.	].	widget := (self windowClassFor: aSpec) new.	self register: widget id: aSpec name.		widget model: aSpec model.	"Set child dependent layout properties."	widget wantsPaneSplitters: (aSpec wantsResizeHandles ifNil: [true]).	self setLayoutHintsFor: widget spec: aSpec.	widget layoutInset: (aSpec padding ifNil: [ProportionalSplitterMorph gripThickness]).	widget cellInset: (aSpec spacing ifNil: [ProportionalSplitterMorph gripThickness]).		"Now create the children."	panes := OrderedCollection new.	aSpec children isSymbol		ifTrue: [			widget getChildrenSelector: aSpec children.			widget update: aSpec children]		ifFalse: [			self buildAll: aSpec children in: widget].	widget setUpdatablePanesFrom: panes.		aSpec label ifNotNil: [:label|		label isSymbol 			ifTrue:[widget getLabelSelector: label]			ifFalse:[widget setLabel: label]].	aSpec multiWindowStyle notNil ifTrue:		[widget savedMultiWindowState: (SavedMultiWindowState on: aSpec model)].	widget closeWindowSelector: aSpec closeAction.	self buildHelpFor: widget spec: aSpec. 	widget bounds: (RealEstateAgent 		initialFrameFor: widget 		initialExtent: (aSpec extent ifNil:[widget initialExtent])		world: self currentWorld).	^ widget! !!HTML5ToolBuilder methodsFor: 'as yet unclassified' stamp: 'crl 9/18/2017 16:32'!register: widget id: id	id ifNil:[^self].	widgets ifNil:[widgets := Dictionary new].	widgets at: id put: widget.	widget setNameTo: id! !!HTML5ToolBuilder methodsFor: 'as yet unclassified' stamp: 'crl 9/18/2017 16:30'!windowClassFor: spec	^HTMLDivElement! !!HTML5ToolBuilder class methodsFor: 'as yet unclassified' stamp: 'crl 9/18/2017 15:45'!open: aClass label: aString world: world	^self new open: aClass label: aString world: world! !!Halt class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!ReadWriteStream class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!Morph methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2019 01:46'!balloonHelpTextForHandle: aHandle 	"Answer a string providing balloon help for the	given halo handle"	| itsSelector |	itsSelector := aHandle eventHandler firstMouseSelector.	itsSelector == #doRecolor:with:		ifTrue: [^ Preferences propertySheetFromHalo				ifTrue: ['Open a property sheet.']				ifFalse: ['Change color']].	itsSelector == #mouseDownInDimissHandle:with:		ifTrue: [^'Remove from screen'].	#(#(#addFullHandles 'More halo handles') #(#addSimpleHandles 'Fewer halo handles') #(#chooseEmphasisOrAlignment 'Emphasis & alignment') #(#chooseFont 'Change font') #(#chooseNewGraphicFromHalo 'Choose a new graphic') #(#chooseStyle 'Change style') #(#dismiss 'Remove') #(#doDebug:with: 'Debug') #(#doDirection:with: 'Choose forward direction') #(#doDup:with: 'Duplicate') #(#doMakeSibling:with: 'Make a sibling') #(#doMenu:with: 'Menu') #(#doGrab:with: 'Pick up') #(#editButtonsScript 'See the script for this button') #(#editDrawing 'Repaint') #(#doDupOrMakeSibling:with: 'Duplicate (press shift to make a sibling)') #(#doMakeSiblingOrDup:with: 'Make a sibling (press shift to make simple duplicate)') #(#makeNascentScript 'Make a scratch script') #(#makeNewDrawingWithin 'Paint new object') #(#mouseDownInCollapseHandle:with: 'Collapse') #(#mouseDownOnHelpHandle: 'Help') #(#openViewerForArgument 'Open a Viewer for me. Press shift for a snapshot.') #(#openViewerForTarget:with: 'Open a Viewer for me. Press shift for a snapshot.') #(#paintBackground 'Paint background') #(#prepareToTrackCenterOfRotation:with: 'Move object or set center of rotation') #(#presentViewMenu 'Present the Viewing menu') #(#startDrag:with: 'Move') #(#startGrow:with: 'Change size') #(#startRot:with: 'Rotate') #(#startScale:with: 'Change scale') #(#tearOffTile 'Make a tile representing this object') #(#tearOffTileForTarget:with: 'Make a tile representing this object') #(#trackCenterOfRotation:with: 'Set center of rotation') )		do: [:pair | itsSelector == pair first				ifTrue: [^ pair last]].	^ 'unknown halo handle'translated! !!Morph methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2019 01:48'!dismissViaHalo	"The user has clicked in the delete halo-handle.  This provides a hook in case some concomitant action should be taken, or if the particular morph is not one which should be put in the trash can, for example."	| cmd |	self setProperty: #lastPosition toValue: self positionInWorld.	self dismissMorph.	cmd := Command new cmdWording: 'dismiss ' translated, self externalName.	cmd undoTarget: ActiveWorld selector: #reintroduceIntoWorld: argument: self.	cmd redoTarget: ActiveWorld selector: #onceAgainDismiss: argument: self.	ActiveWorld rememberCommand: cmd! !!Morph methodsFor: 'as yet unclassified' stamp: 'crl 6/13/2017 11:17'!drawErrorOn: aCanvas	"The morph (or one of its submorphs) had an error in its drawing method."	| saneBounds |	3 haltOnce.	saneBounds := bounds rounded.	aCanvas		frameAndFillRectangle: saneBounds		fillColor: Color red		borderWidth: 1		borderColor: Color yellow.	aCanvas line: saneBounds topLeft to: saneBounds bottomRight width: 1 color: Color yellow.	aCanvas line: saneBounds topRight to: saneBounds bottomLeft width: 1 color: Color yellow.! !!BlockCannotReturn class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!GraphicSymbol class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!PluggableTreeItemNode class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!MethodID methodsFor: 'as yet unclassified' stamp: 'crl 3/3/2008 17:50'!<= aMethodID	(self activeClass theNonMetaClass name < aMethodID activeClass theNonMetaClass name) ifTrue: [^true].	(self activeClass theNonMetaClass name > aMethodID activeClass theNonMetaClass name) ifTrue: [^false].	(self isMeta = aMethodID isMeta) ifFalse: [^self isMeta not].	^self selector <= aMethodID selector! !!MethodID methodsFor: 'as yet unclassified' stamp: 'crl 6/12/2007 15:39'!author	^self methodAuthor! !!MethodID methodsFor: 'as yet unclassified' stamp: 'crl 6/12/2007 15:37'!authorID	^self methodAuthorID! !!MethodID methodsFor: 'as yet unclassified' stamp: 'crl 7/6/2008 17:55'!authorID: aUUID	self methodAuthorID: aUUID! !!MethodID methodsFor: 'as yet unclassified' stamp: 'crl 3/3/2008 16:52'!classID	"Answer my class ID part."	^ClassID withAll: (self copyTo: ClassID instanceSize)! !!MethodID methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2011 15:38'!classID: aClassID	self		replaceFrom: 1		to: ClassID instanceSize		with: aClassID! !!MethodID methodsFor: 'as yet unclassified' stamp: 'crl 3/9/2008 19:41'!covers: aMethodID	"Answer whether the method I identify satisfies a request for aMethodID."	^((self classBaseID = aMethodID classBaseID) or: [aMethodID activeClass inheritsFrom: self activeClass]) and: [		self selector == aMethodID selector and: [			(aMethodID version = 0) or: [				(self authorID = aMethodID authorID) and: [self version = aMethodID version]]]]! !!MethodID methodsFor: 'as yet unclassified' stamp: 'crl 9/3/2012 17:07'!edition	^EditHistory activeMethodEditionWithID: self! !!MethodID methodsFor: 'as yet unclassified' stamp: 'crl 9/1/2012 00:55'!impromptuEdition	| class |	class := Object subclassWithBaseID: self classBaseID.	^class			newEditionForMethod: (class compiledMethodAt: self selector)			at: self selector			withSource: (class sourceCodeAt: self selector)! !!MethodID methodsFor: 'as yet unclassified' stamp: 'crl 9/1/2012 00:56'!installVia: remoteModule	"Install, in remoteModule's system, the method I describe."	remoteModule installMethodEdition: self impromptuEdition	"(EditHistory activeMethodEditionWithID: self)"! !!MethodID methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2011 16:11'!method	^self activeClass compiledMethodAt: self selector ifAbsent: [nil]! !!MethodID methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2016 18:17'!methodAuthor	"Answer the local Author of the method I describe, or nil if the system doesn't know about that author."	^EditHistory knownAuthorWithID: self methodAuthorID! !!MethodID methodsFor: 'as yet unclassified' stamp: 'crl 6/12/2007 15:36'!methodAuthorID	"Answer my method author ID part."	^UUID withAll: (		self			copyFrom: 35			to: 50)! !!MethodID methodsFor: 'as yet unclassified' stamp: 'crl 6/12/2007 15:38'!methodAuthorID: aUUID	"Set my method author ID part to the bytes of aUUID."	self		replaceFrom: 35		to: 50		with: aUUID! !!MethodID methodsFor: 'as yet unclassified' stamp: 'crl 6/12/2007 15:35'!methodVersion	^((self at: 51) bitShift: 8) + (self at: 52)! !!MethodID methodsFor: 'as yet unclassified' stamp: 'crl 3/31/2008 12:55'!methodVersion: sixteenBits	self		at: 51		put: (sixteenBits bitShift: -8);		at: 52		put: (sixteenBits bitAnd: 2r11111111).	^sixteenBits! !!MethodID methodsFor: 'as yet unclassified' stamp: 'crl 7/15/2011 22:01'!pattern	^MethodIDPattern reference: self! !!MethodID methodsFor: 'as yet unclassified' stamp: 'crl 2/3/2006 17:58'!printComponentNameOn: aStream	super printComponentNameOn: aStream.	aStream		nextPutAll: '>>';		nextPutAll: self selector! !!MethodID methodsFor: 'as yet unclassified' stamp: 'crl 1/15/2015 15:02'!reference	^(MethodReference new)		setStandardClass: self activeClass		methodSymbol: self selector! !!MethodID methodsFor: 'as yet unclassified' stamp: 'crl 7/27/2007 16:43'!selector	"Answer my selector part."	^(String withAll: (self copyFrom: 53 to: self size)) asSymbol! !!MethodID methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2011 16:14'!sentSelectors	^(self activeClass == Object and: [#(~~ isNil == pointsTo: identityHash nextInstance become:) includes: self selector])		ifTrue: [(ProtoObject compiledMethodAt: self selector) messages]		ifFalse: [			| method |			method := self method.			(method isNil)				ifTrue: [#()]				ifFalse: [method messages]]! !!MethodID methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 16:46'!tag	"Answer my transfer tag."	^MethodIDTag! !!MethodID methodsFor: 'as yet unclassified' stamp: 'crl 5/25/2007 15:12'!version	^self methodVersion! !!MethodID class methodsFor: 'as yet unclassified' stamp: 'crl 3/3/2008 17:19'!forActiveClass: aClass	^self shouldNotImplement! !!MethodID class methodsFor: 'as yet unclassified' stamp: 'crl 6/17/2008 21:38'!forMethodAt: selector inActiveClass: class	^self		forVersion: (class compiledMethodAt: selector) version		ofMethodAt: selector		inActiveClass: class! !!MethodID class methodsFor: 'as yet unclassified' stamp: 'crl 9/30/2016 12:02'!forVersion: version ofMethodAt: selector inActiveClass: class	^self		forVersion: version		ofMethodAt: selector		inClassWithID: (super forActiveClass: class)! !!MethodID class methodsFor: 'as yet unclassified' stamp: 'crl 9/30/2016 12:01'!forVersion: version ofMethodAt: selector inClassWithID: classID	^(WriteStream with: (self withAll: classID))		nextPutAll: Author current id;		next16BitsPut: version;		nextPutAll: selector asByteArray;		contents! !!MethodID class methodsFor: 'as yet unclassified' stamp: 'crl 7/31/2007 18:16'!instanceSize	"Answer the size of each of my instances."	"My instances vary in size, depending upon the selector with which they are associated."	^self shouldNotImplement! !!BottomLeftGripMorph class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!UnhandledError methodsFor: 'as yet unclassified' stamp: 'crl 3/27/2019 11:22'!defaultAction	"The current computation is terminated. The cause of the error should be logged or reported to the user. If the program is operating in an interactive debugging environment the computation should be suspended and the debugger activated."	^ToolSet debugError: exception.	"JS break: exception printString"! !!Message methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 03:36'!storeOnTether: tether
	tether nextWordPut: MessageTag.
	selector storeOnTether: tether.
	args storeOnTether: tether! !!ConnectionTimedOut methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!ConnectionTimedOut class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!Identifier methodsFor: 'as yet unclassified' stamp: 'crl 5/6/2017 16:25'!name	^name! !!Identifier methodsFor: 'as yet unclassified' stamp: 'crl 5/6/2017 22:40'!printOn: stream	super printOn: stream.	stream		nextPutAll: ' for ''';		nextPutAll: name;		nextPut: $'! !!Identifier methodsFor: 'as yet unclassified' stamp: 'crl 5/6/2017 16:11'!printSmalltalkOn: stream	stream nextPutAll: name! !!Identifier class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!OtherMarker methodsFor: 'as yet unclassified' stamp: 'crl 8/29/2016 17:59'!exposureHash: aSmallInteger	exposureHash := aSmallInteger! !!OtherMarker methodsFor: 'as yet unclassified' stamp: 'crl 5/20/2018 23:24'!storeOnTether: tether
	tether nextWordPut: exposureHash + OtherMarkerTagBase! !!OtherMarker class methodsFor: 'as yet unclassified' stamp: 'crl 8/29/2016 18:11'!exposing: object via: tether	"Answer a new instance of myself which represents a remote reference to the given local object, reachable via tether."	^self new exposureHash: (tether expose: object)! !!MorphicEvent methodsFor: 'as yet unclassified' stamp: 'crl 6/5/2018 14:45'!handle	World activeHand handleEvent: self! !!HTMLOptionElement methodsFor: 'as yet unclassified' stamp: 'crl 9/18/2017 12:32'!value	^self at: #value! !!HTMLOptionElement class methodsFor: 'as yet unclassified' stamp: 'crl 9/18/2017 13:32'!withValue: value andInnerHTML: innerHTML	^(Webpage current createElement: 'option')		at: #value put: value;		at: #innerHTML put: innerHTML;		yourself! !!ZipConstants methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!InstVarRefLocator class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!RootNote methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2005 21:43'!appliedTo: anObject	"Answer the application of myself to anObject."	^anObject applyRootNote: self! !!RootNote methodsFor: 'as yet unclassified' stamp: 'crl 3/2/2006 11:58'!applyNote: aNote	"Answer a Chord with myself as the root, and containing aNote."	^self chord, aNote! !!RootNote methodsFor: 'as yet unclassified' stamp: 'crl 3/2/2006 11:58'!applyPitch: aPitch	"Answer a Chord with myself as the root, and containing aPitch."	^self chord, aPitch! !!RootNote methodsFor: 'as yet unclassified' stamp: 'crl 3/2/2006 11:58'!applyScaleDegree: aDegree	"Answer a Chord with myself as the root, and containing aDegree."	^self chord, aDegree! !!RootNote methodsFor: 'as yet unclassified' stamp: 'crl 8/26/2017 22:03'!chord	^(Chord new), self! !!Parser methodsFor: 'as yet unclassified' stamp: 'lw 5/26/2011 21:24'!method: doit context: ctxt 	" pattern [ | temporaries ] block => MethodNode."	| sap blk prim temps messageComment methodNode |	sap := self pattern: doit inContext: ctxt.	"sap={selector, arguments, precedence}"	self properties selector: (sap at: 1).	encoder selector: (sap at: 1).	(sap at: 2) do: [:argNode | argNode beMethodArg].	doit ifFalse: [self pragmaSequence].	temps := self temporaries.	messageComment := currentComment.	currentComment := nil.	doit ifFalse: [self pragmaSequence].	prim := self pragmaPrimitives.	self statements: #() innerBlock: doit.	blk := parseNode.	doit ifTrue: [blk returnLast]		ifFalse: [blk returnSelfIfNoOther: encoder].	hereType == #doIt ifFalse: [^self expected: 'Nothing more'].	methodNode := self newMethodNode comment: messageComment.	methodNode		selector: (sap at: 1)		arguments: (sap at: 2)		precedence: (sap at: 3)		temporaries: temps		block: blk		encoder: encoder		primitive: prim		properties: properties.	self interactive ifTrue:		[self declareUndeclaredTemps: methodNode.		 self removeUnusedTemps: methodNode].	^methodNode! !!PluggableInputFieldSpec class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!LimitedWriteStream class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!BoxGeometry methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!BoxGeometry class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!UpdatingStringMorph methodsFor: 'as yet unclassified'!acceptContents	self informTarget.! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'tk 8/14/2000 23:11'!acceptValue: aValue	self updateContentsFrom: (self acceptValueFromTarget: aValue).! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'sw 3/10/2005 01:53'!acceptValueFromTarget: v	"Accept a value from the target"	lastValue := v.	self format == #string ifTrue: [^ v asString].	self format == #symbol ifTrue: [^ v asString translated].	(format == #default and: [v isNumber]) ifTrue:		[^ self stringForNumericValue: v].	^ v printString translated! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'dgd 8/30/2003 22:21'!addCustomMenuItems: menu hand: aHandMorph 	| prefix |	super addCustomMenuItems: menu hand: aHandMorph.	prefix := (self growable				ifTrue: ['stop being growable']				ifFalse: ['start being growable']) translated.	menu add: prefix action: #toggleGrowability.	menu add: 'decimal places...' translated action: #setPrecision.	menu add: 'font size...' translated action: #setFontSize.	menu add: 'font style...' translated action: #setFontStyle! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'sw 9/9/1999 16:47'!autoAcceptOnFocusLoss	^ autoAcceptOnFocusLoss ~~ false! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'sw 9/8/1999 10:45'!autoAcceptOnFocusLoss: aBoolean	autoAcceptOnFocusLoss := aBoolean! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'yo 6/7/2004 21:35'!checkTarget	""	getSelector ifNil: [^ true].	^ getSelector numArgs = 0.! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'aoy 2/17/2003 01:15'!contents: newContents 	"This is the original StringMorph implementation of #contents:, restored down in UpdatingStringMorph because a recent 'optimization' of the StringMorph version of this method broke UpdatingStringMorphs."	contents := newContents isText 				ifTrue:  					[emphasis := newContents emphasisAt: 1.					newContents string]				ifFalse: 					[contents = newContents ifTrue: [^self].	"no substantive change"					newContents].	self fitContents.	self changed! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'tk 9/26/2001 06:04'!couldHoldSeparateDataForEachInstance	"Answer whether this type of morph is inherently capable of holding separate data for each instance ('card data')"	^ true! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'tk 9/26/2001 06:06'!currentDataValue	"Answer the current data value held by the receiver"	^ self valueFromContents! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'sw 9/13/2002 17:55'!decimalPlaces	"Answer the number of decimal places to show."	| places |	(places := self valueOfProperty: #decimalPlaces) ifNotNil: [^ places].	self setProperty: #decimalPlaces toValue: (places := Utilities decimalPlacesForFloatPrecision: self floatPrecision).	^ places! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'ar 1/3/2010 19:57'!decimalPlaces: aNumber	"Set the receiver's number of decimal places to be shown.  If my target is a morph or a player, tell it about the change, in case it wants to remember it."	| constrained |	self setProperty: #decimalPlaces toValue: (constrained := aNumber min: 11).	self pvtFloatPrecision: (Utilities floatPrecisionForDecimalPlaces: constrained).	(target isMorph or:[target isPlayer]) ifTrue:		[target noteDecimalPlaces: constrained forGetter: getSelector]! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'nk 1/11/2004 15:29'!doneWithEdits	"If in a SyntaxMorph, shrink min width after editing"	| editor |	super doneWithEdits.	(owner respondsTo: #parseNode) ifTrue: [minimumWidth := 8].	editor := (submorphs detect: [ :sm | sm isKindOf: StringMorphEditor ] ifNone: [ ^self ]).	editor delete.! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'ar 12/30/2001 20:48'!fitContents	| newExtent f |	f := self fontToUse.	newExtent := (((f widthOfString: contents) max: self minimumWidth) min: self maximumWidth)  @ f height.	(self extent = newExtent) ifFalse:		[self extent: newExtent.		self changed]! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'sw 7/27/2001 18:20'!floatPrecision	"Answer the floatPrecision to use:		1.0 ->	show whole number		0.1	->	show one digit of precision		.01 ->	show two digits of precision		etc.	Initialize the floatPrecision to 1 if it is not already defined"	floatPrecision isNumber ifFalse:		[self target: target].  "Fixes up errant cases from earlier bug"	^ floatPrecision! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'sw 9/13/2002 17:57'!floatPrecision: aPrecision	"Set the receiver's number of decimal places to correspond with the given precision.  The preferred protocol here is #decimalPlaces:, which conforms to the UI for this, but #floatPrecision: is retained for backward compatibility."	self decimalPlaces: (Utilities decimalPlacesForFloatPrecision: aPrecision)! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'sw 9/11/2002 14:44'!format	"Answer the receiver's format: #default or #string"	^ format ifNil: [format := #default]! !!UpdatingStringMorph methodsFor: 'as yet unclassified'!getSelector	^ getSelector! !!UpdatingStringMorph methodsFor: 'as yet unclassified'!getSelector: aSymbol	getSelector := aSymbol.! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'jm 5/26/1999 16:21'!growable	^ growable ~~ false! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'jm 5/26/1999 16:22'!growable: aBoolean	growable := aBoolean.! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'sw 11/15/2001 18:17'!handlerForMouseDown: evt	"Answer an object to field the mouseDown event provided, or nil if none"	| aHandler |	aHandler := super handlerForMouseDown: evt.	aHandler == self ifTrue:	[^ self]. "I would get it anyways"	"Note: This is a hack to allow value editing in viewers"	((owner wantsKeyboardFocusFor: self) and:		[self userEditsAllowed]) ifTrue: [^ self].	^ aHandler! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/6/2000 00:17'!handlesMouseDown: evt	(owner wantsKeyboardFocusFor: self)		ifTrue:[^true].	^ super handlesMouseDown: evt! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'sw 3/7/2004 15:49'!hasStructureOfComplexWatcher	"Answer whether the receiver has precisely the structure of a so-called complex watcher, as used in the etoy system."	| top |	top := (self owner ifNil: [^ false]) owner.	^ ((((top isMemberOf: AlignmentMorph)		and: [top submorphs size = 4])			and: [top submorphs first isMemberOf: TileMorph])				and: [top submorphs third isMemberOf: AlignmentMorph])! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'dgd 2/22/2003 19:01'!informTarget	"Obtain a value from my contents, and tell my target about it.  The putSelector can take one argument (traditional) or two (as used by Croquet)"	| newValue typeIn |	(target notNil and: [putSelector notNil]) 		ifTrue: 			[typeIn := contents.			(newValue := self valueFromContents) ifNotNil: 					[self checkTarget.					putSelector numArgs = 1 						ifTrue: [target perform: putSelector with: newValue].					putSelector numArgs = 2 						ifTrue: 							[target 								perform: putSelector								with: newValue								with: self].					target isMorph ifTrue: [target changed]].			self fitContents.			(format == #default and: [newValue isNumber]) 				ifTrue: [self setDecimalPlacesFromTypeIn: typeIn]]! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'dgd 2/14/2003 20:44'!initialize	"Initialie the receiver to have default values in its instance 	variables "	super initialize.""	format := #default.	"formats: #string, #default"	target := getSelector := putSelector := nil.	floatPrecision := 1.	growable := true.	stepTime := 50.	autoAcceptOnFocusLoss := true.	minimumWidth := 8.	maximumWidth := 300! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'sw 1/6/2005 01:27'!isEtoyReadout	"Answer whether the receiver can serve as an etoy readout"	^ true! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'tk 11/29/2000 13:54'!lostFocusWithoutAccepting	"The message is sent when the user, having been in an editing episode on the receiver, changes the keyboard focus -- typically by clicking on some editable text somewhere else -- without having accepted the current edits."	self autoAcceptOnFocusLoss ifTrue: [self doneWithEdits; acceptContents]! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'sw 9/10/1999 10:07'!maximumWidth	"Answer the maximum width that the receiver can have.   A nil value means no maximum, and for practical purposes results in a value of 99999 here temporarily, for help in future debugging"	^ maximumWidth ifNil: [99999]! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'sw 9/10/1999 09:59'!minimumWidth	"Answer the minimum width that the receiver can have.  A nonzero value here keeps the receiver from degenerating into something that cannot ever be seen or touched again!!  Obeyed by fitContents."	^ minimumWidth ifNil: [minimumWidth := 8]! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'tk 12/1/2000 15:08'!minimumWidth: aWidth	"Set the minimum width that the receiver can have.  A nonzero value here keeps the receiver from degenerating into something that cannot ever be seen or touched again!!  Obeyed by fitContents."	minimumWidth := aWidth! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'sw 11/15/2001 10:15'!mouseDown: evt	"The mouse went down over the receiver.  If appropriate, launch a mini-editor so that the user can commence text-editing here"	(owner wantsKeyboardFocusFor: self) ifTrue:		[self userEditsAllowed ifTrue:			[(owner respondsTo: #parseNode)					ifTrue: 	"leave space for editing"						[minimumWidth := (49 max: minimumWidth)].			self launchMiniEditor: evt]]! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'tk 9/26/2001 06:08'!putOnBackground	"Place the receiver, formerly private to its card, onto the shared background.  If the receiver needs data carried on its behalf by the card, such data will be represented on every card."	"If I seem to have per-card data, then set that up."	target class superclass == CardPlayer ifTrue: [		(self hasOwner: target costume) ifTrue: [				self setProperty: #holdsSeparateDataForEachInstance toValue: true]].	super putOnBackground.! !!UpdatingStringMorph methodsFor: 'as yet unclassified'!putSelector	^ putSelector! !!UpdatingStringMorph methodsFor: 'as yet unclassified'!putSelector: aSymbol	putSelector := aSymbol.! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'sw 9/13/2002 17:58'!pvtFloatPrecision: aNumber	"Private - Set the floatPrecision instance variable to the given number"	floatPrecision := aNumber! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'yo 6/9/2004 07:09'!readFromTarget	"Update my readout from my target"	| v ret |	(target isNil or: [getSelector isNil]) ifTrue: [^contents].	ret := self checkTarget.	ret ifFalse: [^ '0'].	v := target perform: getSelector.	"scriptPerformer"	(v isKindOf: Text) ifTrue: [v := v asString].	^self acceptValueFromTarget: v! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'sw 9/11/2002 09:57'!setDecimalPlaces: places	"Set the number of decimal places, and update the display."	self decimalPlaces: places.	self acceptValueFromTarget: lastValue! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'sw 3/3/2005 02:55'!setDecimalPlacesFromTypeIn: typeIn	"The user has typed in a number as the new value of the receiver.  Glean off decimal-places-preference from the type-in"	| decimalPointPosition tail places |	(typeIn includes: $e) ifTrue: [^ self].	decimalPointPosition := typeIn indexOf: $. ifAbsent: [nil].	places := 0.	decimalPointPosition		ifNotNil:			[tail := typeIn copyFrom: decimalPointPosition + 1 to: typeIn size.			[places < tail size and: [(tail at: (places + 1)) isDigit]]				whileTrue:					[places := places + 1]].			self decimalPlaces: places! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/6/2009 19:18'!setFontSize	| sizes reply family |	family := font ifNil: [TextStyle default] ifNotNil: [font textStyle].	family ifNil: [family := TextStyle default].  "safety net -- this line SHOULD be unnecessary now"	sizes := 	family fontNamesWithPointSizes.	reply := UIManager default chooseFrom: sizes values: sizes.	reply ifNotNil:		[self font: (family fontAt: (sizes indexOf: reply))]! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'nice 10/21/2009 00:16'!setFontStyle	| aList reply style |	aList := (TextConstants select: [:anItem | anItem isKindOf: TextStyle]) 				keys asArray.	reply := UIManager default chooseFrom: aList values: aList.	reply notNil 		ifTrue: 			[(style := TextStyle named: reply) ifNil: 					[Beeper beep.					^true].			self font: style defaultFont]! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'tk 9/25/2001 11:43'!setNewContentsFrom: stringOrNumberOrNil	self acceptValue: stringOrNumberOrNil! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'dgd 10/17/2003 22:50'!setPrecision	"Allow the user to specify a number of decimal places.  This UI is invoked from a menu.  Nowadays the precision can be set by simple type-in, making this menu approach mostly obsolete.  However, it's still useful for read-only readouts, where type-in is not allowed."	| aMenu |	aMenu := MenuMorph new.	aMenu addTitle: ('How many decimal places? (currently {1})' translated format: {self decimalPlaces}).	0 to: 5 do:		[:places |			aMenu add: places asString target: self selector: #setDecimalPlaces: argument: places].	aMenu popUpInWorld! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'sw 11/15/2001 20:20'!setToAllowTextEdit	"Set up the receiver so that it will be receptive to text editing, even if there is no putSelector provided"	self setProperty: #okToTextEdit toValue: true! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'sw 7/15/1999 07:28'!step	| s |	super step.	hasFocus ifFalse:		["update contents, but only if user isn't editing this string"		s := self readFromTarget.		s = contents ifFalse:			[self updateContentsFrom: s]]! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'jm 5/26/1999 16:17'!stepTime	^ stepTime ifNil: [50]! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'jm 5/26/1999 16:23'!stepTime: mSecsPerStep	stepTime := mSecsPerStep truncated.! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'sw 3/3/2005 02:53'!stringForNumericValue: aValue	"Answer a suitably-formatted string representing the value."	| barePrintString |	((barePrintString := aValue printString) includes: $e)  ifTrue: [^ barePrintString].	^ aValue printShowingDecimalPlaces: self decimalPlaces! !!UpdatingStringMorph methodsFor: 'as yet unclassified'!target	^ target! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'sw 3/11/2000 20:05'!target: anObject	target := anObject.	getSelector ifNotNil: [floatPrecision := anObject defaultFloatPrecisionFor: getSelector]! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'sw 6/26/1998 07:47'!toggleGrowability	growable := self growable not.	self updateContentsFrom: self readFromTarget.	growable ifTrue: [self fitContents]! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'sw 6/26/1998 07:31'!updateContentsFrom: aValue	self growable		ifTrue:			[self contents: aValue]		ifFalse:			[self contentsClipped: aValue]! !!UpdatingStringMorph methodsFor: 'as yet unclassified'!useDefaultFormat	"Use the object's own printString format."	format := #default.! !!UpdatingStringMorph methodsFor: 'as yet unclassified'!useStringFormat	format := #string.! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'yo 1/12/2005 14:28'!useSymbolFormat	format := #symbol.! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'sw 11/15/2001 09:43'!userEditsAllowed	"Answer whether user-edits are allowed to this field"	^ putSelector notNil or: [self hasProperty: #okToTextEdit]! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'ar 1/3/2010 16:08'!valueFromContents	"Return a new value from the current contents string.""	| expression tilePadMorphOrNil asNumberBlock |	asNumberBlock := [:string | [string asNumber]				on: Error				do: []].	format = #string		ifTrue: [^ contents].	(format = #default			and: [self owner isKindOf: NumericReadoutTile])		ifTrue: [^ asNumberBlock value: contents].	tilePadMorphOrNil := self ownerThatIsA: TilePadMorph.	(tilePadMorphOrNil notNil			and: [tilePadMorphOrNil type = #Number])		ifTrue: [^ asNumberBlock value: contents].	expression := Vocabulary eToyVocabulary translationKeyFor: contents.	expression isNil		ifTrue: [expression := contents].	^ Compiler evaluate: expression"	format = #symbol ifTrue: [^ lastValue].	format = #string ifTrue: [^ contents].	(owner notNil and: [owner isNumericReadoutTile]) ifTrue: [		^ Number readFrom: contents	].	target ifNotNil: [target owner ifNotNil: [		((target owner isTilePadMorph) and: [target owner type = #Number])			ifTrue: [^ Number readFrom: contents]]].	^ Compiler evaluate: contents! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'tk 9/26/2001 06:10'!variableDocks	"Answer a list of VariableDock objects for docking up my data with an instance held in my containing playfield.  For a numeric-readout tile."	"Is CardPlayer class holding my variableDock, or should I be using the caching mechanism in Morph>>variableDocks?"	^ Array with: (VariableDock new 			variableName: (getSelector allButFirst: 3) withFirstCharacterDownshifted 			type: #number 			definingMorph: self 			morphGetSelector: #valueFromContents 			morphPutSelector: #acceptValue:)! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'tk 1/7/1999 15:37'!veryDeepFixupWith: deepCopier	"If target field is weakly copied, fix it here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.target := deepCopier references at: target ifAbsent: [target].! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'tk 9/26/2001 05:09'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared."	super veryDeepInner: deepCopier.	format := format veryDeepCopyWith: deepCopier.	target := target.					"Weakly copied"	lastValue := lastValue veryDeepCopyWith: deepCopier.	getSelector := getSelector.			"Symbol"	putSelector := putSelector.		"Symbol"	floatPrecision := floatPrecision veryDeepCopyWith: deepCopier.	growable := growable veryDeepCopyWith: deepCopier.	stepTime := stepTime veryDeepCopyWith: deepCopier.	autoAcceptOnFocusLoss := autoAcceptOnFocusLoss veryDeepCopyWith: deepCopier.	minimumWidth := minimumWidth veryDeepCopyWith: deepCopier.	maximumWidth := maximumWidth veryDeepCopyWith: deepCopier.! !!UpdatingStringMorph methodsFor: 'as yet unclassified' stamp: 'sw 5/6/1998 12:59'!wouldAcceptKeyboardFocus	^ (self hasProperty: #okToTextEdit) or: [super wouldAcceptKeyboardFocus]! !!UpdatingStringMorph class methodsFor: 'as yet unclassified' stamp: 'sw 3/10/2000 17:27'!on: targetObject selector: aSymbol	^ self new		getSelector: aSymbol;		target: targetObject! !!JSPromise methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSPromise class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!DAVSession methodsFor: 'as yet unclassified' stamp: 'crl 7/13/2017 10:51'!at: resourceNameStream put: request	| tail response |	tail _ resourceNameStream upToEnd.	response _ request request.	(tail = 'state')		ifTrue: [			(request contents size = 0)				ifTrue: [					self initializeState.					response created]				ifFalse: [					| stream cr command |					state touch.					response ok.					stream _ request contents readStream.					cr _ Character cr.					command _ (String new: 8) writeStream.					[						(stream upTo: cr; peek) = $#					]						whileTrue.					stream throughAll: '- '.					stream atEnd ifFalse: [						[stream peek isSeparator] whileFalse: [command nextPut: stream next].						response addSideEffect: [(Commands at: command contents) value: memory]]]]			ifFalse: [				self addFileNamed: tail.				response created]! !!DAVSession methodsFor: 'as yet unclassified' stamp: 'crl 1/11/2015 02:46'!createFileNamed: resourceNameStream	(resourceNameStream upToEnd = 'state') ifTrue: [self initializeState]! !!DAVSession methodsFor: 'as yet unclassified' stamp: 'crl 1/12/2015 01:22'!initialize	super initialize.	self name: 'session'.	{		DAVSessionResume.		DAVSessionSnapshot.		DAVSessionSuspend.		DAVSessionStop	}		do: [:class | self addFile: (class withSession: self)]! !!DAVSession methodsFor: 'as yet unclassified' stamp: 'crl 1/12/2015 00:43'!initializeState	state _ self addFile: (DAVSessionState withSession: self)! !!DAVSession methodsFor: 'as yet unclassified' stamp: 'crl 1/11/2015 02:49'!memory	^memory! !!DAVSession methodsFor: 'as yet unclassified' stamp: 'crl 1/11/2015 02:46'!memory: aDAVMemory	memory _ aDAVMemory.	self initializeState! !!DAVSession methodsFor: 'as yet unclassified' stamp: 'crl 1/12/2015 01:27'!resume	memory resume! !!DAVSession methodsFor: 'as yet unclassified' stamp: 'crl 1/12/2015 03:38'!stop	memory stop! !!DAVSession class methodsFor: 'as yet unclassified' stamp: 'crl 1/10/2015 19:48'!initialize	Commands _ (		(Dictionary new)			at: 'resume' put: [:memory | memory resume];			at: 'snapshot' put: [:memory | memory snapshot];			at: 'stop' put: [:memory | memory stop];			at: 'suspend' put: [:memory | memory suspend];			yourself)! !!DAVSession class methodsFor: 'as yet unclassified' stamp: 'crl 1/3/2015 13:50'!withMemory: aDAVMemory	^self new memory: aDAVMemory! !!MIDIOutputMap methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!MIDIOutputMap class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!CommentEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!CommentEdition class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!HTMLHtmlElement methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!HTMLHtmlElement class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!Model methodsFor: 'as yet unclassified' stamp: 'crl 9/4/2019 18:30'!buildMenu: aMenu withBuilders: builders shifted: aBoolean	" We let every builder modify the menu.	The builder should indicate whether to abort by returning nil."	| menu |	menu := aMenu.	builders do: [:builder |		menu := self perform: builder method selector withEnoughArguments: { menu . aBoolean }.		menu ifNil: [^ aMenu]].	^ menu! !!Model methodsFor: 'as yet unclassified' stamp: 'crl 9/4/2019 18:28'!menu: aMenu for: aMenuSymbolOrCollection shifted: aBoolean	| builders |	builders := self menuBuildersFor: aMenuSymbolOrCollection in: self class shifted: aBoolean.	builders := self sortMenuBuilders: builders.	^ self buildMenu: aMenu withBuilders: builders shifted: aBoolean! !!Model methodsFor: 'as yet unclassified' stamp: 'crl 9/4/2019 18:29'!menuBuildersFor: someMenus in: aClass shifted: aBoolean	"Find all builders but reject the ones not matching the shift state "	| pragmas |	pragmas := (self menuPragmasFor: someMenus in: aClass) .	^ aBoolean 		ifTrue:  [pragmas reject: [:builder | builder arguments = #(false)]]		ifFalse: [pragmas reject: [:builder | builder arguments = #(true)]].! !!Model methodsFor: 'as yet unclassified' stamp: 'crl 9/4/2019 18:29'!menuPragmasFor: aMenuSymbolOrCollection in: aClass		^ aMenuSymbolOrCollection isCollection		ifTrue: [aMenuSymbolOrCollection gather: [:aMenuSymbol |				Pragma allNamed: aMenuSymbol from: aClass to: Object]]		ifFalse: [Pragma allNamed: aMenuSymbolOrCollection from: aClass to: Object]! !!Model methodsFor: 'as yet unclassified' stamp: 'crl 9/4/2019 18:29'!sortMenuBuilders: builders 	" Sort them by		1. Priority (default 500)		2. selector name	"	^  builders sorted: [:a :b | 		| ma mb pa pb |		ma := a method.		mb := b method.		pa := self methodMenuPriority: ma.		pb := self methodMenuPriority: mb.		pa < pb or: [pa = pb and: [ma selector <= mb selector]]]! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 10:08'!helpMenu        "Build the help menu for the world."        |  menu |  	menu := self menu: 'help...'.        self fillIn: menu from:        {                {'about this system...'. {Smalltalk. #aboutThisSystem}. 'current version information.'}.                {'preferences...'. {self. #openPreferencesBrowser}. 'view and change various options.'}.			 {'set language...' . {Project. #chooseNaturalLanguage}. 'choose the language in which tiles should be displayed.'} .                nil.               {'command-key help'. { Utilities . #openCommandKeyHelp}. 'summary of keyboard shortcuts.'}	}.	self addGestureHelpItemsTo: menu.	self fillIn: menu from:	{                {'world menu help'. { self . #worldMenuHelp}. 'helps find menu items buried in submenus.'}.                        "{'info about flaps' . { Utilities . #explainFlaps}. 'describes how to enable and use flaps.'}."                {'font size summary' . { TextStyle . #fontSizeSummary}.  'summary of names and sizes of available fonts.'}.                {'useful expressions' . { Utilities . #openStandardWorkspace}. 'a window full of useful expressions.'}.			 {'annotation setup...' . { Preferences . #editAnnotations}. 'Click here to get a little window that will allow you to specify which types of annotations, in which order, you wish to see in the annotation panes of browsers and other tools'}.			nil.                {'standard graphics library' . { ScriptingSystem . #inspectFormDictionary}.  'lets you view and change the system''s standard library of graphics.'}.                nil.                {'telemorphic...' . {self. #remoteDo}.  'commands for doing multi-machine "telemorphic" experiments'}.                {#soundEnablingString . { SoundService . #toggleSoundEnabled}. 'turning sound off will completely disable Squeak''s use of sound.'}.                nil.                {'set author initials...' . { Utilities . #setAuthorInitials }. 'supply initials to be used to identify the author of code and other content.'}.                {'vm statistics' . { self . #vmStatistics}.  'obtain some intriguing data about the vm.'}.			  nil.			  {'purge undo records' . { CommandHistory . #resetAllHistory }. 'save space by removing all the undo information remembered in all projects.'}.                {'space left' . { self . #garbageCollect}. 'perform a full garbage-collection and report how many bytes of space remain in the image.'}.        }.	^menu! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'crl 6/13/2017 18:58'!makeConvenient: menu	self		fillIn: menu		from: {			{ 'Browser'. { StandardToolSet. #openClassBrowser }. 'open a browser' }.			{ 'Workspace'. { #myWorld. #openWorkspace }. 'open a workspace' }.			{ 'Transcript'. { Transcript. #open }. 'open a transcript' }.			Smalltalk at: #TestRunner ifPresent:[:aClass|				{ 'Test Runner'. { aClass. #open }. 'open a test runner' }.			].			nil		}! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 21:01'!projectMenu	"Build the project menu for the world."	| menu |	self flag: #bob0302.	menu := self menu: 'projects...'.	self fillIn: menu from: { 		{ 'save on server (also makes a local copy)' . { #myProject  } }.		{ 'save project on local file only' . { #myWorld . #saveOnFile } }.		{ 'see if server version is more recent...' . { #myProject . #loadFromServer } }.		{ 'load project from file...' . { self . #loadProject } }.		nil.	}.	self mvcProjectsAllowed ifTrue: [		self fillIn: menu from: {			{ 'create new mvc project'. { self . #openMVCProject } }.		}	].	self fillIn: menu from: { 		{ 'create new morphic project' . { self . #openMorphicProject } }.	}.	Smalltalk at: #SMxMorphicProject ifPresent: [:p |		self fillIn: menu from: { 			{ 'create new simple morphic project' . { self . #openSMxMorphicProject } }.		}	].	self fillIn: menu from: { 		nil.		{ 'go to previous project' . { Project . #returnToPreviousProject } }.		{ 'go to next project' . { Project . #advanceToNextProject } }.		{ 'jump to project...' . { #myWorld . #jumpToProject } }.	}.	Preferences simpleMenus ifFalse: [		self fillIn: menu from: { 			nil.			{ 'save for future revert' . { #myProject . #saveForRevert } }.			{ 'revert to saved copy' . { #myProject . #revert } }.		}.	].	^ menu! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 22:58'!scriptingMenu	"Build the authoring-tools menu for the world."	^ self fillIn: (self menu: 'authoring tools...') from: { 		{ 'objects (o)' . { #myWorld . #activateObjectsTool }. 'A searchable source of new objects.'}.		nil.  "----------" 		{ 'view trash contents' . { #myWorld . #openScrapsBook:}. 'The place where all your trashed morphs go.'}.		nil.  "----------"			{ 'new scripting area' . { #myWorld . #detachableScriptingSpace}. 'A window set up for simple scripting.'}.		nil.  "----------"					{ 'status of scripts' . {#myWorld . #showStatusOfAllScripts}. 'Lets you view the status of all the scripts belonging to all the scripted objects of the project.'}.		{ 'summary of scripts' . {#myWorld . #printScriptSummary}. 'Produces a summary of scripted objects in the project, and all of their scripts.'}.		{ 'browser for scripts' . {#myWorld . #browseAllScriptsTextually}. 'Allows you to view all the scripts in the project in a traditional programmers'' "browser" format'}.		nil.		{ 'gallery of players' . {#myWorld . #galleryOfPlayers}. 'A tool that lets you find out about all the players used in this project'}."		{ 'gallery of scripts' . {#myWorld . #galleryOfScripts}. 'Allows you to view all the scripts in the project'}."		{ 'etoy vocabulary summary' . {#myWorld . #printVocabularySummary }. 'Displays a summary of all the pre-defined commands and properties in the pre-defined EToy vocabulary.'}.		{ 'remove all viewers' . {#myWorld . #removeAllViewers}. 'Remove all the Viewers from this project.'}.		{ 'refer to masters' . {#myWorld . #makeAllScriptEditorsReferToMasters }. 'Ensure that all script editors are referring to the first (alphabetically by external name) Player of their type' }.		nil.  "----------" 		{ 'unlock locked objects' . { #myWorld . #unlockContents}. 'If any items on the world desktop are currently locked, unlock them.'}.		{ 'unhide hidden objects' . { #myWorld . #showHiders}. 'If any items on the world desktop are currently hidden, make them visible.'}.        }! !!JSPoint methodsFor: 'as yet unclassified' stamp: 'crl 1/31/2019 15:08'!asPoint	^self x @ self y! !!JSPoint class methodsFor: 'as yet unclassified' stamp: 'crl 5/30/2017 14:27'!fromPoint: point	^self newWithParameters: {point x. point y}! !!UTF8ClipboardInterpreter class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!ExternalResourceError methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!ExternalResourceError class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!ParseNodeVisitor class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!TextMorphCommandHistory class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!SharedVariableLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 5/23/2007 19:39'!key: aSymbol	"Set my key to aSymbol."	key _ aSymbol! !!SharedVariableLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 7/8/2011 16:28'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: ' and key ';		print: key! !!SharedVariableLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2016 15:16'!storeOnTether: tether	"Store a copy of myself on tether, suitable for re-animation in a remote system."	super storeOnTether: tether.	key storeOnTether: tether! !!SharedVariableLiteralMarker class methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 18:52'!fromTether: tether	"Answer an instance of myself composed from bytes supplied by aStream, and objects supplied by anObjectTransferCorrespondent."	^(super fromTether: tether) key: tether next! !!Selection methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!Selection class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!ChromeNetworkAPI class methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 12:40'!domain	^'Network'! !!ProjectViewMorph methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 21:00'!showMenuForProjectView	| menu |	(menu := MenuMorph new)		add: 'enter this project' translated		action: [^ self enter];				add: 'see if server version is more recent' translated		action: [^ self checkForNewerVersionAndLoad];		addLine;		add: 'expunge this project' translated		action: [^ self expungeProject].	menu title: ('Project Named \"{1}"' translated withCRs format: {project name}).	menu invokeModal.! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'dgd 8/30/2003 21:17'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	deleteOnMouseUp		ifTrue: [aCustomMenu add: 'stay up' translated action: #toggleDeleteOnMouseUp]		ifFalse: [aCustomMenu add: 'do not stay up' translated action: #toggleDeleteOnMouseUp].	updateContinuously		ifTrue: [aCustomMenu add: 'update only at end' translated action: #toggleUpdateContinuously]		ifFalse: [aCustomMenu add: 'update continuously' translated action: #toggleUpdateContinuously].! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'di 11/27/1999 09:12'!addToWorld: world near: box	| goodLocation |	goodLocation := self bestPositionNear: box inWorld: world.	world allMorphsDo:		[:p | (p isMemberOf: ColorPickerMorph) ifTrue:		[(p ~~ self and: [p owner notNil and: [p target == target]]) ifTrue:			[(p selector == selector and: [p argument == argument])				ifTrue: [^ p comeToFront  "uncover existing picker"]				ifFalse: ["place second picker relative to first"						goodLocation := self bestPositionNear: p bounds inWorld: world]]]].	self position: goodLocation.	world addMorphFront: self.	self changed! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'di 9/27/2000 10:36'!anchorAndRunModeless: aHand	"If user clicks on the drag-dot of a modal picker,	anchor it, and change to modeless operation."	aHand showTemporaryCursor: nil.  "revert to normal cursor"	self initializeModal: false; originalColor: originalColor.  "reset as modeless"	aHand flushEvents.  "Drop any events gathered during modal loop"	aHand position: Sensor cursorPoint; grabMorph: self.  "Slip into drag operation"! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'ar 6/25/1999 11:33'!argument	^argument! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'ar 6/25/1999 11:33'!argument: anObject	argument := anObject! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'ar 7/19/2003 20:40'!argumentsWith: aColor	"Return an argument array appropriate to this action selector"	| nArgs |	nArgs := selector ifNil:[0] ifNotNil:[selector numArgs].	nArgs = 0 ifTrue:[^#()].	nArgs = 1 ifTrue:[^ {aColor}].	nArgs = 2 ifTrue:[^ {aColor. sourceHand}].	nArgs = 3 ifTrue:[^ {aColor. argument. sourceHand}].! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'di 11/27/1999 08:51'!bestPositionNear: box inWorld: world	| points b |	points := #(topCenter rightCenter bottomCenter leftCenter).  "possible anchors"	1 to: 4 do:		[:i |  "Try the four obvious anchor points"		b := self bounds align: (self bounds perform: (points at: i))					with: (box perform: (points atWrap: i + 2)).		(world viewBox containsRect: b) ifTrue:			[^ b topLeft"  Yes, it fits"]].	^ 20@20  "when all else fails"! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'di 9/28/2000 12:05'!buildChartForm	| chartForm |	chartForm := ColorChart deepCopy asFormOfDepth: Display depth.	chartForm fill: ((TransparentBox left + 9)@0 extent: 1@9) fillColor: Color lightGray.	chartForm fill: ((TransparentBox right - 10)@0 extent: 1@9) fillColor: Color lightGray.	TransText displayOn: chartForm at: 62@0.	Display depth = 32 ifTrue:		["Set opaque bits for 32-bit display"		chartForm fill: chartForm boundingBox rule: Form under				fillColor: (Color r: 0.0 g: 0.0 b: 0.0 alpha: 1.0)].	chartForm borderWidth: 1.	self form: chartForm.	selectedColor ifNotNil: [self updateAlpha: selectedColor alpha].	self updateSelectorDisplay.! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'sw 9/8/2000 18:14'!choseModalityFromPreference	"Decide whether to be modal or not by consulting the prevailing preference"	self initializeModal: Preferences modalColorPickers! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'LC 2/2/2000 04:28'!containsPoint: aPoint 	^ (super containsPoint: aPoint)		or: [RevertBox containsPoint: aPoint - self topLeft]! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'nk 4/17/2004 19:34'!delete	"The moment of departure has come.	If the receiver has an affiliated command, finalize it and have the system remember it.	In any case, delete the receiver"	(selector isNil or: [ target isNil ]) ifFalse: [		self rememberCommand: 			(Command new				cmdWording: 'color change' translated;				undoTarget: target selector: selector arguments: (self argumentsWith: originalColor);				redoTarget: target selector: selector arguments: (self argumentsWith: selectedColor)).	].	super delete! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'di 9/27/2000 12:55'!deleteAllBalloons	self submorphsDo: [:m | m deleteBalloon].! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'jm 11/4/97 07:15'!deleteOnMouseUp	^ deleteOnMouseUp! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'jm 11/4/97 07:15'!deleteOnMouseUp: aBoolean	deleteOnMouseUp := aBoolean.! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'di 9/3/1999 13:34'!drawOn: aCanvas	aCanvas depth = 1 ifTrue: [aCanvas fillRectangle: self bounds color: Color white].	Display depth = originalForm depth ifFalse: [self buildChartForm].	super drawOn: aCanvas! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'ar 1/3/2010 18:52'!getColorFromKedamaWorldIfPossible: aGlobalPoint	self world submorphs do: [:sub |		 (sub isKedamaMorph) ifTrue: [			sub morphsAt: aGlobalPoint unlocked: false do: [:e |				^ e colorAt: (aGlobalPoint - e topLeft).			].		].	].	^ nil.! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'jm 11/4/97 07:15'!handlesMouseDown: evt	^ true! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'di 9/25/2000 15:38'!indicateColorUnderMouse	"Track the mouse with the special eyedropper cursor, and accept whatever color is under the mouse as the currently-chosen color; reflect that choice in the feedback box, and return that color."	| pt |	self pickColorAt: (pt := Sensor cursorPoint).	isModal ifTrue:		[self activeHand position: pt.		self world displayWorldSafely; runStepMethods].	^ selectedColor	! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 2/19/2001 13:16'!inhibitDragging	^self hasProperty: #noDraggingThisPicker! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'ar 9/4/2001 13:26'!initialize	"Initialize the receiver.  Obey the modalColorPickers preference when deciding how to configure myself.  This is not quite satisfactory -- we'd like to have explicit calls tell us things like whether whether to be modal, whether to allow transparency, but for the moment, in grand Morphic fashion, this is rather inflexibly all housed right here"	super initialize.	self clipSubmorphs: true.	self buildChartForm.		selectedColor := Color white.	sourceHand := nil.	deleteOnMouseUp := false.	clickedTranslucency := false.	updateContinuously := true.	selector := nil.	target := nil! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'yo 2/23/2005 17:17'!initializeForPropertiesPanel	"Initialize the receiver.  If beModal is true, it will be a modal color picker, else not"	isModal := false.	self removeAllMorphs.	self setProperty: #noDraggingThisPicker toValue: true.	self addMorph: ((Morph newBounds: (RevertBox translateBy: self topLeft))			color: Color transparent; setCenteredBalloonText: 'restore original color' translated).	self addMorph: ((Morph newBounds: (FeedbackBox translateBy: self topLeft))			color: Color transparent; setCenteredBalloonText: 'shows selected color' translated).	self addMorph: ((Morph newBounds: (TransparentBox translateBy: self topLeft))			color: Color transparent; setCenteredBalloonText: 'adjust translucency' translated).	self buildChartForm.		selectedColor ifNil: [selectedColor := Color white].	sourceHand := nil.	deleteOnMouseUp := false.	updateContinuously := true.! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'yo 2/23/2005 17:13'!initializeModal: beModal	"Initialize the receiver.  If beModal is true, it will be a modal color picker, else not"	isModal := beModal.	self removeAllMorphs.	isModal ifFalse:		[theSelectorDisplayMorph := AlignmentMorph newRow			color: Color white;			borderWidth: 1;			borderColor: Color red;			hResizing: #shrinkWrap;			vResizing: #shrinkWrap;			addMorph: (StringMorph contents: 'theSelector' translated).		self addMorph: theSelectorDisplayMorph.		self addMorph: (SimpleButtonMorph new borderWidth: 0;			label: 'x' font: nil; color: Color transparent;			actionSelector: #delete; target: self; useSquareCorners;			position: self topLeft - (0@3); extent: 10@12;			setCenteredBalloonText: 'dismiss color picker' translated)].	self addMorph: ((Morph newBounds: (DragBox translateBy: self topLeft))			color: Color transparent; setCenteredBalloonText: 'put me somewhere' translated).	self addMorph: ((Morph newBounds: (RevertBox translateBy: self topLeft))			color: Color transparent; setCenteredBalloonText: 'restore original color' translated).	self addMorph: ((Morph newBounds: (FeedbackBox translateBy: self topLeft))			color: Color transparent; setCenteredBalloonText: 'shows selected color' translated).	self addMorph: ((Morph newBounds: (TransparentBox translateBy: self topLeft))			color: Color transparent; setCenteredBalloonText: 'adjust translucency' translated).	self buildChartForm.		selectedColor ifNil: [selectedColor := Color white].	sourceHand := nil.	deleteOnMouseUp := false.	updateContinuously := true.! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'sw 7/6/1999 09:00'!isCandidateForAutomaticViewing	^ false! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'sw 7/6/1999 09:07'!isLikelyRecipientForMouseOverHalos	^ false! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:11'!locationIndicator		^self valueOfProperty: #locationIndicator ifAbsent:[ | loc |		loc := EllipseMorph new.		loc color: Color transparent; 			borderWidth: 1; 			borderColor: Color red; 			extent: 6@6.		self setProperty: #locationIndicator toValue: loc.		self addMorphFront: loc.		loc]! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'dgd 2/21/2003 22:59'!modalBalloonHelpAtPoint: cursorPoint 	self flag: #arNote.	"Throw this away. There needs to be another way."	self submorphsDo: 			[:m | 			m wantsBalloon 				ifTrue: 					[(m valueOfProperty: #balloon) isNil						ifTrue: 							[(m containsPoint: cursorPoint) ifTrue: [m showBalloon: m balloonText]]						ifFalse: [(m containsPoint: cursorPoint) ifFalse: [m deleteBalloon]]]]! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 2/19/2001 13:17'!mouseDown: evt	| localPt |	localPt := evt cursorPoint - self topLeft.	self deleteAllBalloons.	clickedTranslucency := TransparentBox containsPoint: localPt.	self inhibitDragging ifFalse: [		(DragBox containsPoint: localPt)			ifTrue: [^ evt hand grabMorph: self].	].	(RevertBox containsPoint: localPt)		ifTrue: [^ self updateColor: originalColor feedbackColor: originalColor].	self inhibitDragging ifFalse: [self comeToFront].	sourceHand := evt hand.	self startStepping.! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'yo 9/29/2004 10:24'!mouseUp: evt	| c |	self stopStepping.	sourceHand := nil.	deleteOnMouseUp ifTrue: [self delete].	c := self getColorFromKedamaWorldIfPossible: evt cursorPoint.	c ifNotNil: [selectedColor := c].	self updateTargetColor.! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'KR 12/9/2005 22:51'!originalColor: colorOrSymbol 	"Set the receiver's original color.  It is at this point that a command is launched to represent the action of the picker, in support of Undo."	originalColor := (colorOrSymbol isColor) 				ifTrue: [colorOrSymbol]				ifFalse: [Color lightGreen].	originalForm fill: RevertBox fillColor: originalColor.	selectedColor := originalColor.	self updateAlpha: originalColor alpha.	self locationIndicator 		center: self topLeft + (self positionOfColor: originalColor)! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'yo 9/29/2004 10:57'!pickColorAt: aGlobalPoint 	| alpha selfRelativePoint pickedColor c |	clickedTranslucency ifNil: [clickedTranslucency := false].	selfRelativePoint := (self globalPointToLocal: aGlobalPoint) - self topLeft.	(FeedbackBox containsPoint: selfRelativePoint) ifTrue: [^ self].	(RevertBox containsPoint: selfRelativePoint)		ifTrue: [^ self updateColor: originalColor feedbackColor: originalColor].	"check for transparent color and update using appropriate feedback color "	(TransparentBox containsPoint: selfRelativePoint) ifTrue:		[clickedTranslucency ifFalse: [^ self].  "Can't wander into translucency control"		alpha := (selfRelativePoint x - TransparentBox left - 10) asFloat /							(TransparentBox width - 20)							min: 1.0 max: 0.0.					"(alpha roundTo: 0.01) printString , '   ' displayAt: 0@0." " -- debug"		self 			updateColor: (selectedColor alpha: alpha)			feedbackColor: (selectedColor alpha: alpha).		^ self].	"pick up color, either inside or outside this world"	clickedTranslucency ifTrue: [^ self].  "Can't wander out of translucency control"	self locationIndicator visible: false. self refreshWorld.	pickedColor := Display colorAt: aGlobalPoint.	c := self getColorFromKedamaWorldIfPossible: aGlobalPoint.	c ifNotNil: [pickedColor := c].	self locationIndicator visible: true. self refreshWorld.	self 		updateColor: (			(selectedColor isColor and: [selectedColor isTranslucentColor])						ifTrue: [pickedColor alpha: selectedColor alpha]						ifFalse: [pickedColor]		)		feedbackColor: pickedColor! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'yo 9/29/2004 10:38'!pickUpColorFor: aMorph	"Show the eyedropper cursor, and modally track the mouse through a mouse-down and mouse-up cycle"      | aHand localPt c |	aHand := aMorph ifNil: [self activeHand] ifNotNil: [aMorph activeHand].	aHand ifNil: [aHand := self currentHand].	self addToWorld: aHand world near: (aMorph ifNil: [aHand world]) fullBounds.	self owner ifNil: [^ self].	aHand showTemporaryCursor: (ScriptingSystem formAtKey: #Eyedropper) 			hotSpotOffset: 6 negated @ 4 negated.    "<<<< the form was changed a bit??"	self updateContinuously: false.	[Sensor anyButtonPressed]		whileFalse: 			 [self trackColorUnderMouse].	self deleteAllBalloons.	localPt := Sensor cursorPoint - self topLeft.	self inhibitDragging ifFalse: [		(DragBox containsPoint: localPt) ifTrue:			["Click or drag the drag-dot means to anchor as a modeless picker"			^ self anchorAndRunModeless: aHand].	].	(clickedTranslucency := TransparentBox containsPoint: localPt)		ifTrue: [selectedColor := originalColor].	self updateContinuously: true.	[Sensor anyButtonPressed]		whileTrue:			 [self updateTargetColorWith: self indicateColorUnderMouse].	c := self getColorFromKedamaWorldIfPossible: Sensor cursorPoint.	c ifNotNil: [selectedColor := c].	aHand newMouseFocus: nil;		showTemporaryCursor: nil;		flushEvents.	self delete.		  ! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'ar 9/4/2001 13:27'!positionOfColor: aColor	"Compute the position of the given color in the color chart form"	| rgbRect x y h s v |	rgbRect := (0@0 extent: originalForm boundingBox extent) insetBy: (1@10 corner: 11@1).	h := aColor hue.	s := aColor saturation.	v := aColor brightness.	h = 0.0 ifTrue:["gray"		^(rgbRect right + 6) @ (rgbRect height * (1.0 - v) + rgbRect top)].	x := (h + 22 \\ 360 / 360.0 * rgbRect width) rounded.	y := 0.5.	s < 1.0 ifTrue:[y := y - (1.0 - s * 0.5)].	v < 1.0 ifTrue:[y := y + (1.0 - v * 0.5)].	y := (y * rgbRect height) rounded.	^x@y + (1@10)! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'ar 12/8/2000 15:32'!putUpFor: aMorph near: aRectangle	"Put the receiver up on the screen.   Note highly variant behavior depending on the setting of the #modalColorPickers preference"	| layerNumber |	aMorph isMorph ifTrue: [		layerNumber := aMorph morphicLayerNumber.		aMorph allOwnersDo:[:m|			layerNumber := layerNumber min: m morphicLayerNumber].		self setProperty: #morphicLayerNumber toValue: layerNumber - 0.1	].	isModal == true "backward compatibility"		ifTrue:			[self pickUpColorFor: aMorph]		ifFalse:			[self addToWorld:				((aMorph notNil and: [aMorph world notNil])					ifTrue:						[aMorph world]					ifFalse:						[self currentWorld])		  		near:					(aRectangle ifNil:						[aMorph ifNil: [100@100 extent: 1@1] ifNotNil: [aMorph fullBoundsInWorld]])]! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'jm 11/4/97 07:15'!selectedColor	^ selectedColor! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'jm 11/4/97 07:15'!selector	^ selector! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'di 8/30/2000 13:40'!selector: aSymbol	"Set the selector to be associated with the receiver.  Store it in the receiver's command, if appropriate"	selector := aSymbol.	self updateSelectorDisplay! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'jm 11/4/97 07:15'!sourceHand	^ sourceHand! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'jm 11/4/97 07:15'!sourceHand: aHand	sourceHand := aHand.! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'jm 11/4/97 07:15'!step	sourceHand ifNotNil:		[self pickColorAt: sourceHand position].! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'jm 11/4/97 07:15'!stepTime	^ 50! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'jm 11/4/97 07:15'!target	^ target! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'aoy 2/15/2003 21:24'!target: anObject 	target := anObject.	selectedColor := (target respondsTo: #color)  				ifTrue: [target color]				ifFalse: [Color white]! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'jm 11/4/97 07:46'!toggleDeleteOnMouseUp	deleteOnMouseUp := deleteOnMouseUp not.! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'jm 11/4/97 07:46'!toggleUpdateContinuously	updateContinuously := updateContinuously not.! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'di 9/30/2000 10:07'!trackColorAt: aGlobalPoint 	"Before the mouse comes down in a modal color picker, track the color under the cursor, and show it in the feedback box, but do not make transparency changes"	| selfRelativePoint pickedColor |	selfRelativePoint := (self globalPointToLocal: aGlobalPoint) - self topLeft.	(FeedbackBox containsPoint: selfRelativePoint) ifTrue: [^ self].	(RevertBox containsPoint: selfRelativePoint)		ifTrue: [^ self updateColor: originalColor feedbackColor: originalColor].	"check for transparent color and update using appropriate feedback color "	(TransparentBox containsPoint: selfRelativePoint) ifTrue: [^ self].	"pick up color, either inside or outside this world"	pickedColor := Display colorAt: aGlobalPoint.	self updateColor: (pickedColor alpha: originalColor alpha)		feedbackColor: pickedColor! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'di 9/27/2000 11:48'!trackColorUnderMouse	"Track the mouse with the special eyedropper cursor, and accept whatever color is under the mouse as the currently-chosen color; reflect that choice in the feedback box, and return that color."	| pt |	selectedColor := originalColor.	self trackColorAt: (pt := Sensor cursorPoint).	isModal ifTrue:		[self activeHand position: pt.		self world displayWorldSafely; runStepMethods.		self modalBalloonHelpAtPoint: pt].	^ selectedColor	! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'di 9/28/2000 11:10'!updateAlpha: alpha	| sliderRect |	sliderRect := (TransparentBox left + 10)@1 corner: (TransparentBox right - 9)@9.	originalForm fill: (sliderRect withRight: sliderRect left + (alpha*sliderRect width))				fillColor: Color lightGray.	originalForm fillWhite: (sliderRect withLeft: sliderRect left + (alpha*sliderRect width)).	originalForm fill: ((TransparentBox right - 9)@1 extent: 8@8)				fillColor: (alpha < 1.0 ifTrue: [Color white] ifFalse: [Color lightGray]).	TransText displayOn: originalForm at: 62@1 rule: Form paint.! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/25/2001 20:50'!updateColor: aColor feedbackColor: feedbackColor	"Set my selected color to the given color if it is different. Give user feedback. Inform the target of the change if the target and selector are not nil." 	selectedColor = aColor ifTrue: [^ self].  "do nothing if color doesn't change"	self updateAlpha: aColor alpha.	originalForm fill: FeedbackBox fillColor: feedbackColor.	self form: originalForm.	selectedColor := aColor.	updateContinuously ifTrue: [self updateTargetColor].	self locationIndicator center: self topLeft + (self positionOfColor: feedbackColor).! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'jm 11/4/97 07:46'!updateContinuously	^ updateContinuously! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'jm 11/4/97 07:46'!updateContinuously: aBoolean	updateContinuously := aBoolean.! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'sma 4/22/2000 19:39'!updateSelectorDisplay	theSelectorDisplayMorph ifNil: [^self].	theSelectorDisplayMorph position: self bottomLeft.	theSelectorDisplayMorph firstSubmorph contents: selector asString , ' ' , selectedColor printString! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'dgd 2/22/2003 18:41'!updateTargetColor	| nArgs |	(target notNil and: [selector notNil]) 		ifTrue: 			[self updateSelectorDisplay.			nArgs := selector numArgs.			nArgs = 1 ifTrue: [^target perform: selector with: selectedColor].			nArgs = 2 				ifTrue: 					[^target 						perform: selector						with: selectedColor						with: sourceHand].			nArgs = 3 				ifTrue: 					[^target 						perform: selector						with: selectedColor						with: argument						with: sourceHand]]! !!ColorPickerMorph methodsFor: 'as yet unclassified' stamp: 'dgd 2/22/2003 18:41'!updateTargetColorWith: aColor 	"Update the target so that it reflects aColor as the color choice"	(target notNil and: [selector notNil]) 		ifTrue: 			[self updateSelectorDisplay.			^target perform: selector withArguments: (self argumentsWith: aColor)]! !!ColorPickerMorph class methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:11'!colorPaletteForDepth: depth extent: chartExtent	"Display a palette of colors sorted horizontally by hue and vertically by lightness. Useful for eyeballing the color gamut of the display, or for choosing a color interactively."	"Note: It is slow to build this palette, so it should be cached for quick access."	"(Color colorPaletteForDepth: 16 extent: 190@60) display"	| startHue palette transHt vSteps transCaption grayWidth hSteps y c x |	palette := Form extent: chartExtent depth: depth.	transCaption := "(DisplayText text: 'no color' asText textStyle: (TextConstants at: #ComicPlain)) form storeString"		(Form extent: 34@9 depth: 1			fromArray: #(0 0 256 0 256 0 3808663859 2147483648 2491688266 2147483648 2491688266 0 2491688266 0 2466486578 0 0 0)			offset: 0@0).	transHt := transCaption height.	palette fillWhite: (0@0 extent: palette width@transHt).	palette fillBlack: (0@transHt extent: palette width@1).	transCaption displayOn: palette at: palette boundingBox topCenter - ((transCaption width // 2)@0).	grayWidth := 10.	startHue := 338.0.	vSteps := palette height - transHt // 2.	hSteps := palette width - grayWidth.	x := 0.	startHue to: startHue + 360.0 by: 360.0/hSteps do: [:h | | basicHue |		basicHue := Color h: h asFloat s: 1.0 v: 1.0.		y := transHt+1.		0 to: vSteps do: [:n | 			c := basicHue mixed: (n asFloat / vSteps asFloat) with: Color white.			palette fill: (x@y extent: 1@1) fillColor: c.			y := y + 1].		1 to: vSteps do: [:n | 			c := Color black mixed: (n asFloat / vSteps asFloat) with: basicHue.			palette fill: (x@y extent: 1@1) fillColor: c.			y := y + 1].		x := x + 1].	y := transHt + 1.	1 to: vSteps * 2 do: [:n | 		c := Color black mixed: (n asFloat / (vSteps*2) asFloat) with: Color white.		palette fill: (x@y extent: 10@1) fillColor: c.		y := y + 1].	^ palette! !!ColorPickerMorph class methodsFor: 'as yet unclassified' stamp: 'ar 7/8/2006 20:33'!initialize	"ColorPickerMorph initialize"	ColorChart := ColorPickerMorph colorPaletteForDepth: 16 extent: 190@60.	DragBox :=  (11@0) extent: 9@8.	RevertBox := (ColorChart width - 20)@1 extent: 9@8.	FeedbackBox := (ColorChart width - 10)@1 extent: 9@8.	TransparentBox := DragBox topRight corner: RevertBox bottomLeft.		ColorChart fillBlack: ((DragBox left - 1)@0 extent: 1@9).		ColorChart fillBlack: ((TransparentBox left)@0 extent: 1@9).		ColorChart fillBlack: ((FeedbackBox left - 1)@0 extent: 1@9).		ColorChart fillBlack: ((RevertBox left - 1)@0 extent: 1@9).		(Form dotOfSize: 5) displayOn: ColorChart at: DragBox center + (0@1).	self localeChanged.! !!ColorPickerMorph class methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2019 01:24'!localeChanged	TransText		ifNil: [TransText := Form						extent: 63 @ 8						depth: 1						fromArray: #(4194306 1024 4194306 1024 15628058 2476592640 4887714 2485462016 1883804850 2486772764 4756618 2485462016 4748474 1939416064 0 0 )						offset: 0 @ 0].	TransText := ColorForm mappingWhiteToTransparentFrom: TransText! !!ColorPickerMorph class methodsFor: 'as yet unclassified' stamp: 'ar 7/8/2006 20:33'!noColorCaption	| formTranslator |	formTranslator := NaturalLanguageFormTranslator localeID: Locale current localeID.	^ (formTranslator translate: 'no color')		ifNil: [Form				extent: 34 @ 9				depth: 1				fromArray: #(0 0 256 0 256 0 3808663859 2147483648 2491688266 2147483648 2491688266 0 2491688266 0 2466486578 0 0 0 )				offset: 0 @ 0]! !!ColorPickerMorph class methodsFor: 'as yet unclassified' stamp: 'sw 10/27/1999 11:40'!perniciousBorderColor	"Answer the color of the border lines of a color picker; this color gets reported as you drag the mouse through from the translucent box to the true color area, for example, and can cause some difficulties in some special cases, so it is faithfully reported here in this hard-coded fashion in order that energetic clients wishing to handle it as special-case it can do so."	^ Color r: 0.0 g: 0.0 b: 0.032! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 1/21/2003 10:37'!, aMagnitude	"Answer myself after applying aMagnitude."	^aMagnitude appliedTo: self! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 1/24/2003 04:25'!= anObject	"Answer whether I am equivalent to anObject."	^self class = anObject class! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 3/6/2006 15:40'!absoluteTimepoint	^absoluteTimepoint! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 1/26/2005 01:16'!addUninitializedAspectsTo: aspects	self subclassResponsibility! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 1/21/2003 10:40'!appliedTo: anObject	"Answer anObject, after applying myself to it."	^self subclassResponsibility! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 3/6/2006 15:41'!applyAbsoluteTimepoint: anAbsoluteTimepoint	absoluteTimepoint _ anAbsoluteTimepoint! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 7/27/2003 11:49'!asMusicalEvent	"Answer myself as a MusicalEvent."	^self! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 8/27/2017 18:08'!asSequence	^Sequence withAll: {self}! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 8/29/2017 12:31'!basicTimestamp: integer	timestamp _ integer asInteger! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 1/24/2005 19:59'!completeFrom: aMusicalEvent	"Set my uninitialized parameters from aMusicalEvent."	self subclassResponsibility! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 01:42'!dataBytes	^self subclassResponsibility! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 10/1/2004 16:30'!doNotRepeat! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 8/28/2017 13:18'!events	^{self}! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 1/26/2005 01:23'!explainUnplayabilityOn: aStream	| definingClass uninitializedAspects |	definingClass _ self class.	uninitializedAspects _ OrderedCollection new.	[definingClass == MusicalEvent] whileFalse: [		self			perform: #addUninitializedAspectsTo:			withArguments: {uninitializedAspects}			inSuperclass: definingClass.		definingClass _ definingClass superclass].	uninitializedAspects isEmpty ifFalse: [		aStream nextPutAll: '"I''m not playable because my '.		uninitializedAspects printVerboselyOn: aStream.		aStream			space;			nextPutAll: (				(uninitializedAspects size = 1)					ifTrue: ['is']					ifFalse: ['are']);			nextPutAll: 'n''t set,']! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 1/24/2003 04:24'!hash	"Answer a hash which all objects equivalent to me share."	^self class hash! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2019 13:14'!swapInThisMethod	"Swap in the corresponding method for this signature from a tethered system."	"When this method is run, the arguments intended by the sender are copied by the virtual machine into the 'arguments' temporary variable."		| arguments selector lookupClass newMethod |		JS isConnected ifFalse: [3 error: 'This feature requires support lacking in the current virtual machine.'].			selector := thisContext sender selectorJustSent.	lookupClass := self class.		[		lookupClass ifNil: [3 halt: 'method ', selector, ' for a ', self class printString, ' not found'].		(lookupClass includesSelector: selector) and: [(lookupClass compiledMethodAt: selector) == SwapInThisMethod]	]		whileFalse: [lookupClass := lookupClass superclass].	EditHistory swapInMethodAt: selector in: lookupClass.		[newMethod isNil and: [lookupClass notNil]] whileTrue: [		newMethod := (			lookupClass				compiledMethodAt: selector				ifAbsent: [					lookupClass := lookupClass superclass.					nil])].				newMethod ifNil: [		JS			alert: 'method not installed';			debugger].			thisContext method flushCache.			^self		perform: selector		withArguments: arguments! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 9/6/2008 12:56'!initializeFrom: aMIDIStream	self subclassResponsibility! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 2/3/2003 22:05'!isControlChange	"Answer whether I'm a MIDI control-change event."	^false! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 2/17/2006 20:03'!isMMC	^false! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 1/24/2005 22:19'!isPlayable	"Answer whether I'm playable."	^true! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 8/28/2017 17:48'!numberOfEvents	^1! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 12/29/2007 19:48'!packet	"Answer the bytes of a MIDI message representing me, packed into a SmallInteger."	^self statusByte! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 8/29/2017 11:55'!packets	^{(timestamp bitShift: 32) + self packet}! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 12/30/2007 16:18'!play	"Schedule myself on the current active synthesizer."	self scheduleOn: MIDIStream default! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 01:23'!printBytesOn: stream	stream nextPut: self statusByte! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 2/21/2006 15:03'!renderOnMIDIRecorder: aMIDIRecorder	"Take appropriate action for aMIDIRecorder."	"By default, do nothing."! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 8/23/2017 18:25'!schedule	"Schedule myself for immediate rendering on the default MIDIStream. Answer how many bytes were processed."	^self scheduleOn: MIDIStream default! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2008 19:42'!scheduleOn: aMIDIStream	"Schedule myself for immediate rendering on aMIDIStream. Answer how many bytes were processed."	^self scheduleOn: aMIDIStream forNowPlus: 0! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2008 19:48'!scheduleOn: aMIDIStream forNowPlus: numberOfMilliseconds	"Schedule myself for immediate rendering on aMIDIStream. Answer how many bytes were processed."	^aMIDIStream schedule: self forNowPlus: numberOfMilliseconds! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2019 13:14'!swapInThisMethod	"Swap in the corresponding method for this signature from a tethered system."	"When this method is run, the arguments intended by the sender are copied by the virtual machine into the 'arguments' temporary variable."		| arguments selector lookupClass newMethod |		JS isConnected ifFalse: [3 error: 'This feature requires support lacking in the current virtual machine.'].			selector := thisContext sender selectorJustSent.	lookupClass := self class.		[		lookupClass ifNil: [3 halt: 'method ', selector, ' for a ', self class printString, ' not found'].		(lookupClass includesSelector: selector) and: [(lookupClass compiledMethodAt: selector) == SwapInThisMethod]	]		whileFalse: [lookupClass := lookupClass superclass].	EditHistory swapInMethodAt: selector in: lookupClass.		[newMethod isNil and: [lookupClass notNil]] whileTrue: [		newMethod := (			lookupClass				compiledMethodAt: selector				ifAbsent: [					lookupClass := lookupClass superclass.					nil])].				newMethod ifNil: [		JS			alert: 'method not installed';			debugger].			thisContext method flushCache.			^self		perform: selector		withArguments: arguments! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 1/22/2003 02:19'!statusByte	"Answer the first byte of my MIDI scheduling data."	^self subclassResponsibility! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 1/22/2003 02:22'!statusMask	"Answer the eight-bit value which serves as the message-type indicator in my MIDI status byte."	^self subclassResponsibility! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 2/17/2006 20:13'!tag	^self class tag! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 12/30/2007 21:02'!timestamp	^timestamp! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 8/29/2017 12:30'!timestamp: integer	self basicTimestamp: integer! !!MusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 8/29/2017 10:31'!twice	^self, self copy! !!MusicalEvent class methodsFor: 'as yet unclassified' stamp: 'crl 2/21/2006 14:54'!announceNoSupportForTag: tag	| stream |	stream _ (String new: 32) writableStream.	stream		nextPutAll: 'There''s no specialization of ';		print: self;		nextPutAll: ' for tag '.	tag printOn: stream base: 16.	stream nextPut: $..	self error: stream contents! !!MusicalEvent class methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2008 01:23'!concreteClassForTag: tag from: aMIDIStream	"Answer the concrete class to use for an event from aMIDIStream which continues with tag (e.g., an event's initial 'status byte')."	^(self isConcreteClassForTag: tag)		ifTrue: [self]		ifFalse: [			(				subclasses					detect: [:subclass | subclass handles: tag]					ifNone: [self announceNoSupportForTag: tag]			)				concreteClassForTag: tag				from: aMIDIStream]! !!MusicalEvent class methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2008 01:43'!from: aMIDIStream	"Answer an instance of the appropriate concrete subclass for the next event from aMIDIStream."	| tag |	tag _ aMIDIStream next.	^(		self			concreteClassForTag: tag			from: aMIDIStream	)		withTag: tag		from: aMIDIStream! !!MusicalEvent class methodsFor: 'as yet unclassified' stamp: 'crl 2/17/2006 13:32'!handles: tag	"Answer whether I handle subsequent byte tag after my superclass has parsed the preceeding bytes from a MIDI stream."	^(tag >= tagMinimum) and: [tag <= tagMaximum]! !!MusicalEvent class methodsFor: 'as yet unclassified' stamp: 'crl 8/29/2017 12:31'!initialize	"Initialize myself."	tagMinimum _ 16r80.	tagMaximum _ 16rFF.	Now _ 0.	StatusMasks		at: #noteOn		put: 16r90;		at: #controlChange		put: 16rB0;		at: #programChange		put: 16rC0;		at: #pitchWheelChange		put: 16rE0;		at: #systemExclusive		put: 16rF0;		at: #systemReset		put: 16rFF! !!MusicalEvent class methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2008 16:41'!isConcreteClassForTag: tag	"If my tag range is not split over subclasses, then answer true."	^(tag = tagMinimum) and: [tagMinimum = tagMaximum]! !!MusicalEvent class methodsFor: 'as yet unclassified' stamp: 'crl 9/6/2008 12:58'!new	^super new initialize! !!MusicalEvent class methodsFor: 'as yet unclassified' stamp: 'crl 2/17/2006 20:14'!tag	^(tagMinimum = tagMaximum)		ifTrue: [tagMinimum]		ifFalse: [self error: 'I can have a range of tags.']! !!MusicalEvent class methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2008 01:21'!withTag: tag from: aMIDIStream	^self from: aMIDIStream! !!MIDIAccess methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!MIDIAccess class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!ClassOrganizer class methodsFor: 'as yet unclassified' stamp: 'crl 4/2/2019 16:34'!captureOrganizers	Class allSubclassesDo: [:metaclass |		Organizers			at: metaclass put: metaclass organization;			at: metaclass soleInstance put: metaclass soleInstance organization]! !!ClassOrganizer class methodsFor: 'as yet unclassified' stamp: 'crl 4/2/2019 16:48'!clearUninstalledBehaviors	self uninstalledBehaviors do: [:behavior | Organizers removeKey: behavior]! !!ClassOrganizer class methodsFor: 'as yet unclassified' stamp: 'crl 3/16/2019 23:35'!initialize	Organizers := IdentityDictionary new! !!ClassOrganizer class methodsFor: 'as yet unclassified' stamp: 'crl 3/16/2019 23:37'!organizerAt: behavior	^Organizers at: behavior ifAbsent: [nil]! !!ClassOrganizer class methodsFor: 'as yet unclassified' stamp: 'crl 3/16/2019 23:37'!organizerAt: behavior put: organizer	^Organizers at: behavior put: organizer! !!ClassOrganizer class methodsFor: 'as yet unclassified' stamp: 'crl 4/2/2019 16:47'!uninstalledBehaviors	| installedMetaclasses uninstalledBehaviors |	installedMetaclasses := Class allSubclasses asIdentitySet.	uninstalledBehaviors := IdentitySet new.	Organizers keysDo: [:behavior |		(			installedMetaclasses includes: (				(behavior isMeta)					ifTrue: [behavior]					ifFalse: [behavior class])		)			ifFalse: [uninstalledBehaviors add: behavior]].			^uninstalledBehaviors! !!Utilities methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!PluggableTextSpec class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!License methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!License class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!HTML5PasteUpMorph class methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2017 19:41'!startUp: resuming	resuming ifTrue: [self allInstancesDo: [:world | world stop]]! !!JSPort methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSPort class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSCircleBoxMorph methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSCircleBoxMorph class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!ProcessSpecificVariable class methodsFor: 'as yet unclassified' stamp: 'mvl 3/13/2007 14:32'!default	"Answer the default value for the variable. The default for the default value is nil."	^nil! !!ProcessSpecificVariable class methodsFor: 'as yet unclassified' stamp: 'ul 8/16/2011 11:22'!hash		^hash ifNil: [ hash := super hash ]! !!ProcessSpecificVariable class methodsFor: 'as yet unclassified' stamp: 'mvl 3/13/2007 14:33'!value	"Answer the current value for this variable in the current context."	^Processor activeProcess environmentAt: self ifAbsent: [self default].! !!UIEvent methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!UIEvent class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!Vector3 methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!Vector3 class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!MorphicUnknownEvent class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!Unicode methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!Mode methodsFor: 'as yet unclassified' stamp: 'crl 7/14/2006 18:01'!name	^(		(self class classVariablesPool)			keyAtValue: self			ifAbsent: [nil]	)		asLowercase! !!Mode methodsFor: 'as yet unclassified' stamp: 'crl 11/22/2004 21:46'!printOn: aStream	"Print a textual representation of myself on aStream."	| name |	name _ self name.	(name == nil)		ifTrue: [			aStream				nextPutAll: self class name article;				space;				print: self class;				nextPutAll: ': '.			super printOn: aStream]		ifFalse: [			aStream				nextPutAll: 'the ';				nextPutAll: name;				nextPutAll: ' mode']! !!Mode class methodsFor: 'as yet unclassified' stamp: 'crl 8/16/2004 18:03'!aeolian	"Answer the aeolian mode."	^Aeolian! !!Mode class methodsFor: 'as yet unclassified' stamp: 'crl 8/16/2004 18:02'!dorian	"Answer the dorian mode."	^Dorian! !!Mode class methodsFor: 'as yet unclassified' stamp: 'crl 8/15/2004 11:24'!initialize	"Initialize myself."	Ionian _ self withAll: #(0 2 4 5 7 9 11).	Dorian _ self withAll: #(0 2 3 5 7 9 10).	Phrygian _ self withAll: #(0 1 3 5 7 8 10).	Lydian _ self withAll: #(0 2 4 6 7 9 11).	Mixolydian _ self withAll: #(0 2 4 5 7 9 10).	Aeolian _ self withAll: #(0 2 3 5 7 8 10).	Locrian _ self withAll: #(0 1 3 5 6 8 10)! !!Mode class methodsFor: 'as yet unclassified' stamp: 'crl 8/16/2004 18:02'!ionian	"Answer the ionian mode."	^Ionian! !!Mode class methodsFor: 'as yet unclassified' stamp: 'crl 8/16/2004 18:03'!locrian	"Answer the locrian mode."	^Locrian! !!Mode class methodsFor: 'as yet unclassified' stamp: 'crl 8/16/2004 18:03'!lydian	"Answer the lydian mode."	^Lydian! !!Mode class methodsFor: 'as yet unclassified' stamp: 'crl 8/16/2004 18:03'!mixolydian	"Answer the mixolydian mode."	^Mixolydian! !!Mode class methodsFor: 'as yet unclassified' stamp: 'crl 8/16/2004 18:03'!phrygian	"Answer the phrygian mode."	^Phrygian! !!AlternatePluggableListMorphOfMany methodsFor: 'as yet unclassified' stamp: 'cmm 1/18/2002 17:49'!changeModelSelection: anInteger	"Change the model's selected item index to be anInteger."	^self		changeModelSelection: anInteger		shifted: Sensor shiftPressed		controlled: Sensor controlKeyPressed! !!AlternatePluggableListMorphOfMany methodsFor: 'as yet unclassified' stamp: 'cmm 1/18/2002 16:50'!changeModelSelection: anInteger shifted: shiftedBoolean controlled: controlledBoolean	"Change the model's selected item index to be anInteger."	setIndexSelector ifNotNil:		[ model 			perform: setIndexSelector 			with: anInteger			with: shiftedBoolean			with: controlledBoolean ]! !!AlternatePluggableListMorphOfMany methodsFor: 'as yet unclassified' stamp: 'cmm 3/2/2004 23:14'!handlesMouseDown: evt	^ true! !!AlternatePluggableListMorphOfMany methodsFor: 'as yet unclassified' stamp: 'bf 7/19/2012 16:18'!itemSelectedAmongMultiple: index	^self listSelectionAt: (self modelIndexFor: index)! !!AlternatePluggableListMorphOfMany methodsFor: 'as yet unclassified' stamp: 'tpr 12/31/2013 16:42'!list: listOfStringsself isThisEverCalled .	scroller removeAllMorphs.	list := listOfStrings ifNil: [Array new].	list isEmpty ifTrue: [^ self selectedMorph: nil].	super list: listOfStrings.	"At this point first morph is sensitized, and all morphs share same handler."	scroller firstSubmorph on: #mouseEnterDragging						send: #mouseEnterDragging:onItem:						to: self.	scroller firstSubmorph on: #mouseUp						send: #mouseUp:onItem:						to: self.	"This should add this behavior to the shared event handler thus affecting all items"! !!AlternatePluggableListMorphOfMany methodsFor: 'as yet unclassified' stamp: 'cmm 1/18/2002 16:08'!listSelectionAt: index	getSelectionListSelector ifNil:[^false].	^model perform: getSelectionListSelector with: index! !!AlternatePluggableListMorphOfMany methodsFor: 'as yet unclassified' stamp: 'cmm 1/18/2002 16:08'!listSelectionAt: index put: value	setSelectionListSelector ifNil:[^false].	^model perform: setSelectionListSelector with: index with: value! !!AlternatePluggableListMorphOfMany methodsFor: 'as yet unclassified' stamp: 'bf 7/19/2012 16:39'!mouseDown: event	| row |	event yellowButtonPressed ifTrue: [^ self yellowButtonActivity: event shiftPressed].	row := self rowAtLocation: event position.		row = 0 ifTrue: [^super mouseDown: event].	model okToChange ifFalse: [^ self].  "No change if model is locked"	"Inform model of selected item and let it toggle."	self		changeModelSelection: (self modelIndexFor: row)		shifted: event shiftPressed		controlled: event controlKeyPressed."	event hand releaseMouseFocus: aMorph.	submorphs do: [ :each | each changed ]"! !!AlternatePluggableListMorphOfMany methodsFor: 'as yet unclassified' stamp: 'bf 7/19/2012 16:40'!mouseMove: event 	"The mouse has moved, as characterized by the event provided.  Adjust the scrollbar, and alter the selection as appropriate"	| oldIndex oldVal row |	event position y < self top 		ifTrue: 			[scrollBar scrollUp: 1.			row := self rowAtLocation: scroller topLeft + (1 @ 1)]		ifFalse: 			[row := event position y > self bottom 				ifTrue: 					[scrollBar scrollDown: 1.					self rowAtLocation: scroller bottomLeft + (1 @ -1)]				ifFalse: [ self rowAtLocation: event position]].	row = 0 ifTrue: [^super mouseDown: event].	model okToChange ifFalse: [^self].	"No change if model is locked"	"Set meaning for subsequent dragging of selection"	oldIndex := self getCurrentSelectionIndex.	oldIndex ~= 0 ifTrue: [oldVal := self listSelectionAt: oldIndex].	"Need to restore the old one, due to how model works, and set new one."	oldIndex ~= 0 ifTrue: [self listSelectionAt: oldIndex put: oldVal].	"Inform model of selected item and let it toggle."	self 		changeModelSelection: (self modelIndexFor: row)		shifted: true		controlled: event controlKeyPressed.	submorphs do: [:each | each changed]! !!AlternatePluggableListMorphOfMany methodsFor: 'as yet unclassified' stamp: 'mt 4/9/2015 13:42'!mouseUp: event		event hand newKeyboardFocus: self. 	hasFocus := true.! !!AlternatePluggableListMorphOfMany methodsFor: 'as yet unclassified' stamp: 'cmm 12/24/2002 15:47'!on: anObject list: listSel primarySelection: getSelectionSel changePrimarySelection: setSelectionSel listSelection: getListSel changeListSelection: setListSel menu: getMenuSel keystroke: keyActionSel 	"setup a whole load of pluggability options"	getSelectionListSelector := getListSel.	setSelectionListSelector := setListSel.	self 		on: anObject		list: listSel		selected: getSelectionSel		changeSelected: setSelectionSel		menu: getMenuSel		keystroke: keyActionSel! !!AlternatePluggableListMorphOfMany methodsFor: 'as yet unclassified' stamp: 'cmm 1/18/2002 16:08'!update: aSymbol 	aSymbol == #allSelections ifTrue:		[self selectionIndex: self getCurrentSelectionIndex.		^ self changed].	^ super update: aSymbol! !!AlternatePluggableListMorphOfMany class methodsFor: 'as yet unclassified' stamp: 'cmm 1/18/2002 16:08'!on: anObject list: listSel primarySelection: getSelectionSel changePrimarySelection: setSelectionSel listSelection: getListSel changeListSelection: setListSel menu: getMenuSel	^ self new		on: anObject		list: listSel		primarySelection: getSelectionSel		changePrimarySelection: setSelectionSel		listSelection: getListSel		changeListSelection: setListSel		menu: getMenuSel		keystroke: #arrowKey:from:		"default"! !!AlternatePluggableListMorphOfMany class methodsFor: 'as yet unclassified' stamp: 'cmm 1/18/2002 16:08'!on: anObject list: listSel primarySelection: getSelectionSel changePrimarySelection: setSelectionSel listSelection: getListSel changeListSelection: setListSel menu: getMenuSel keystroke: keyActionSel 	^ self new		on: anObject		list: listSel		primarySelection: getSelectionSel		changePrimarySelection: setSelectionSel		listSelection: getListSel		changeListSelection: setListSel		menu: getMenuSel		keystroke: keyActionSel! !!Warning class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!Error methodsFor: 'as yet unclassified' stamp: 'crl 4/17/2018 00:58'!defaultAction	"No one has handled this error, but now give them a chance to decide how to debug it.  If none handle this either then open debugger (see UnhandedError-defaultAction)"	ActiveWorld := World. 	UnhandledError signalForException: self! !!Error class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!PositionableEntity methodsFor: 'as yet unclassified' stamp: 'crl 8/18/2017 19:53'!add	super add.	self		setAttribute: 'position'		with: ((webpage elementAt: #camera) object3D localToWorld: (Vector3 newWithParameters: #(0 0 -5)));		setAttribute: #color with: 'red'! !!PositionableEntity methodsFor: 'as yet unclassified' stamp: 'crl 8/18/2017 20:37'!literalAttributesToSet	^super literalAttributesToSet, #(color)! !!PositionableEntity methodsFor: 'as yet unclassified' stamp: 'crl 8/18/2017 20:37'!nonLiteralAttributesToSet	^super nonLiteralAttributesToSet, #(position rotation)! !!PositionableEntity class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!Exception methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 01:25'!tag	"Return an exception's tag value."	^tag == nil		ifTrue: [self messageText]		ifFalse: [tag]! !!MetaclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/11/2016 11:04'!acceptsLoggingOfCompilation	"Answer whether the receiver's method submisions and class defintions should be logged to the changes file and to the current change set.  The metaclass follows the rule of the class itself.  6/18/96 sw"	^ self theNonMetaClass acceptsLoggingOfCompilation! !!MetaclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/12/2016 15:07'!binding	^nil -> self! !!MetaclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/10/2016 00:24'!bindingOf: varName environment: anEnvironment 	^ self theNonMetaClass classBindingOf: varName environment: anEnvironment! !!MetaclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 15:09'!classSide	^self! !!MetaclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/29/2016 14:31'!definition	"Refer to the comment in ClassDescription|definition."	^ String streamContents:[:strm |		self printComponentNameOn: strm withOuterAuthor: author.		self traitComposition isEmpty ifFalse:[			strm crtab; nextPutAll: 'uses: '; nextPutAll: self traitComposition asString.		].		strm			crtab;			nextPutAll: 'instanceVariableNames: ';			store: self instanceVariablesString]! !!MetaclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/24/2019 23:10'!install	^(self classBaseID = (UUID fromString: '84f50d4b-cf55-4462-bb7d-075db57127d9'))		ifTrue: [Object class clone]		ifFalse: [			| newMetaclass superMetaclass |			superMetaclass := self superclass temporaryCopy install.			newMetaclass := Metaclass new.			"Since we're getting all our information from an edition, we don't need to do format checks. We can also assume that the sending system has already defined all the appropriate superclasses."			newMetaclass				baseID: self classBaseID;				superclass: superMetaclass				methodDictionary: MethodDictionary new				format: self format;				setInstVarNames: instanceVariableNames;				instVarAt: 6				put: (					(newMetaclass new)						superclass: newMetaclass superclass soleInstance						methodDict: MethodDictionary new						format: newMetaclass superclass soleInstance format						name: #DummyProtoclass						organization: nil						instVarNames: #()						classPool: Dictionary new						sharedPools: OrderedCollection new);				yourself]! !!MetaclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 4/14/2008 15:33'!isMeta	"Answer whether I describe a Metaclass."	^true! !!MetaclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 01:46'!name	^counterpartID edition name, ' class'! !!MetaclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/11/2016 11:15'!possibleVariablesFor: misspelled continuedFrom: oldResults	^ self theNonMetaClass possibleVariablesFor: misspelled continuedFrom: oldResults! !!MetaclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/30/2008 21:29'!printComponentNameOn: aStream withOuterAuthor: anAuthorEdition	aStream		nextPut: $(;		nextPutAll: (EditHistory classEditionWithID: counterpartID) name;		nextPutAll: ' class), version ';		print: self version.	self printAuthorOn: aStream withOuterAuthor: anAuthorEdition! !!MetaclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 16:45'!tag	^MetaclassEditionTag! !!MetaclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 03:03'!theNonMetaClass	^counterpartID edition! !!MetaclassEdition class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!TimedOut methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!TimedOut class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!NewParagraph methodsFor: 'as yet unclassified' stamp: 'crl 9/2/2019 23:58'!selectionColor	| color |	Display depth = 1 ifTrue: [^ Color veryLightGray].	Display depth = 2 ifTrue: [^ Color gray].	color := Preferences textHighlightColor.	self focused ifFalse: [color := Color gray: 0.7].	^ color! !!NewParagraph class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!Project methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 21:07'!enter: returningFlag revert: revertFlag saveForRevert: saveForRevert	"Install my ChangeSet, Transcript, and scheduled views as current globals. If returningFlag is true, we will return to the project from whence the current project was entered; don't change its previousProject link in this case.	If saveForRevert is true, save the ImageSegment of the project being left.	If revertFlag is true, make stubs for the world of the project being left.	If revertWithoutAsking is true in the project being left, then always revert."	| showZoom recorderOrNil old forceRevert response seg |	self isIncompletelyLoaded ifTrue:		[^self loadFromServer: true	"try to get a fresh copy"].	self isCurrentProject ifTrue: [^ self].	"Check the guards"	guards ifNotNil:		[guards := guards reject: [:obj | obj isNil].		guards do: [:obj | obj okayToEnterProject ifFalse: [^ self]]].	CurrentProject world triggerEvent: #aboutToLeaveWorld.	forceRevert := false.	CurrentProject rawParameters 		ifNil: [revertFlag ifTrue: [^ self inform: 'nothing to revert to' translated]]		ifNotNil: [saveForRevert ifFalse: [				forceRevert := CurrentProject projectParameters 								at: #revertWithoutAsking ifAbsent: [false]]].	forceRevert not & revertFlag ifTrue: [		response := (UIManager default chooseFrom: {			'Revert to saved version' translated.			'Cancel' translated.		} title: 'Are you sure you want to destroy this Project\ and revert to an older version?\\(From the parent project, click on this project''s thumbnail.)' translated withCRs) = 1.		response ifFalse: [^ self]].	revertFlag | forceRevert 		ifTrue: [seg := CurrentProject projectParameters at: #revertToMe ifAbsent: [					^ self inform: 'nothing to revert to' translated]]		ifFalse: [			CurrentProject finalExitActions.			CurrentProject makeThumbnail].	CurrentProject abortResourceLoading.	CurrentProject triggerClosingScripts.	CurrentProject saveProjectPreferences.	"Update the display depth and make a thumbnail of the current project"	CurrentProject displayDepth: Display depth.	old := CurrentProject.		"for later"	"Show the project transition.	Note: The project zoom is run in the context of the old project,		so that eventual errors can be handled accordingly"	displayDepth == nil ifTrue: [displayDepth := Display depth].	self installNewDisplay: Display extent depth: displayDepth.	(showZoom := self showZoom) ifTrue: [		self displayZoom: CurrentProject parent ~~ self].	CurrentProject pauseSoundPlayers.	returningFlag == #specialReturn ifTrue: [		old removeChangeSetIfPossible.	"keep this stuff from accumulating"		nextProject := nil	] ifFalse: [		returningFlag			ifTrue: [nextProject := CurrentProject]			ifFalse: [previousProject := CurrentProject].	].	CurrentProject saveState.	CurrentProject := self.	self installProjectPreferences.	ChangeSet  newChanges: changeSet.	TranscriptStream newTranscript: transcript.	Sensor flushKeyboard.	recorderOrNil := old pauseEventRecorder.	self setWorldForEnterFrom: old recorder: recorderOrNil.	revertFlag | forceRevert ifTrue: [		seg clone revert].	"non-cloned one is for reverting again later"	self removeParameter: #exportState.	"Complete the enter: by launching a new process"	self scheduleProcessForEnter: showZoom! !!Project methodsFor: 'as yet unclassified' stamp: 'crl 7/6/2016 18:05'!fullScreenOff	self fullscreen: false! !!Project methodsFor: 'as yet unclassified' stamp: 'crl 7/6/2016 18:05'!fullScreenOn	self fullscreen: true! !!Project methodsFor: 'as yet unclassified' stamp: 'crl 1/2/2018 21:17'!fullscreen: fullscreen	JS		ifConnected: [Webpage fullscreen: fullscreen]		ifNotConnected: [			LastScreenModeSelected := fullscreen.			Display fullScreenMode: LastScreenModeSelected.			DisplayScreen checkForNewScreenSize.			self restoreDisplay]! !!BlockNode methodsFor: 'as yet unclassified' stamp: 'crl 4/30/2017 21:13'!printJavaScriptArgumentsOn: stream indent: level	arguments ifEmpty: [^self].	arguments		do: [:argument | stream nextPutAll: argument key]		separatedBy: [stream nextPutAll: ', '].		"If >0 args and >1 statement, put all statements on separate lines"	statements size > 1 ifTrue: [stream crtab: level]! !!BlockNode methodsFor: 'as yet unclassified' stamp: 'crl 7/20/2017 09:44'!printJavaScriptOn: stream indent: level	"Print myself as an ES2015 arrow function."		stream nextPut: $(.	self printJavaScriptArgumentsOn: stream indent: level.	stream nextPutAll: ') => {'.	(self printJavaScriptTemporaries: temporaries on: stream doPrior: []) ifTrue: [stream crtab: level].	self printJavaScriptStatementsOn: stream indent: level.	stream nextPut: $}! !!BlockNode methodsFor: 'as yet unclassified' stamp: 'crl 7/20/2017 09:53'!printJavaScriptStatementsOn: stream indent: level	| length shown thisStatement actualLevel |	actualLevel := 1 max: level.	length := shown := statements size.		comment ifNotNil: [		self printJavaScriptCommentOn: stream indent: actualLevel.		stream crtab: actualLevel].		(		(			"top level"			level = 0		)			and: [statements last isReturnSelf]	)		ifTrue: [shown := 1 max: shown - 1]		ifFalse: [			"Should a trailing nil be printed or not? Not if it is an implicit result."			(				(arguments size = 0) and: [					(length >= 1) and: [						((statements at: length) == NodeNil) and: [							(length = 1) or: [								(length > 1) and: [									(statements at: length - 1) isMessageNode and: [(statements at: length - 1) isNilIf]]]]]]			)				ifTrue: [shown := shown - 1]].					1		to: shown - 1		do: [:index | 			thisStatement := statements at: index.			thisStatement printJavaScriptOn: stream indent: actualLevel.			stream				nextPut: $;;				crtab: actualLevel.						(thisStatement comment notNil and: [thisStatement comment size > 0]) ifTrue: [				(index = shown) ifTrue: [stream crtab: actualLevel].				thisStatement printJavaScriptCommentOn: stream indent: actualLevel.				index < shown ifTrue: [stream crtab: actualLevel]]].			thisStatement := statements at: shown.	thisStatement class == ReturnNode ifFalse: [stream nextPutAll: 'return '].	thisStatement printJavaScriptOn: stream indent: actualLevel.	stream		nextPut: $;;				crtab: actualLevel.						(thisStatement comment notNil and: [thisStatement comment size > 0]) ifTrue: [				stream crtab: actualLevel.				thisStatement printJavaScriptCommentOn: stream indent: actualLevel]! !!BlockNode methodsFor: 'as yet unclassified' stamp: 'crl 4/29/2017 11:17'!printJavaScriptTemporaries: tempSequence on: aStream doPrior: aBlock	"Print any in-scope temporaries. If there are any, evaluate aBlock prior to printing. Answer whether any temporaries were printed."		| temps seen |	tempSequence ifNil: [^false].	temps := OrderedCollection new.		"This is for the decompiler, which can't work out the optimized block to which a particular temp is local, and so may produce duplicates, as in: (expr ifTrue: [| aTemp | ...] ifFalse: [| aTemp | ...])"	seen := Set new.	tempSequence do: [:tempNode |		(tempNode isIndirectTempVector)			ifTrue: [				tempNode remoteTemps do: [:tempVariableNode |					 (tempVariableNode scope >= 0 and: [(seen includes: tempNode key) not]) 						ifTrue: [temps add: (seen add: tempVariableNode key)]]]			ifFalse: [				(					tempNode scope >= -1 and: [						"This is for the decompiler, which may create a block arg when converting a 'while' into a 'to:do:', but won't remove it from temporaries."					 	  tempNode isBlockArg not and: [(seen includes: tempNode key) not]]				)					ifTrue: [temps add: (seen add: tempNode key)]]].					temps ifEmpty: [^false].	temps do: [:temp |		aBlock value.		aStream			nextPutAll: 'var ';			nextPutAll: temp;			nextPut: $;].			^true! !!PeerOperations methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!PeerOperations class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!JSRectangle methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSRectangle class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!WeakActionSequenceTrappingErrors class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!ReturnNode methodsFor: 'as yet unclassified' stamp: 'crl 5/6/2017 17:03'!printJavaScriptOn: stream indent: level	stream nextPutAll: 'return '.	expr		printJavaScriptOn: stream indent: level;		printJavaScriptCommentOn: stream indent: level! !!ReturnNode class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!Entrance methodsFor: 'as yet unclassified' stamp: 'crl 1/20/2019 15:09'!connectTo: url	websocket := (		(			WebClient				webSocket07: (url copyReplaceAll: 'ws:' with: 'http:')				protocol: nil		)			fork)! !!Entrance methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 03:25'!isExit	^false! !!Entrance methodsFor: 'as yet unclassified' stamp: 'crl 7/6/2016 17:56'!isOpen	"Answer whether my websocket is open."	^[self readyState = 1] ifError: [false]! !!Entrance methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2016 16:28'!onClose: aBlockClosure	"Install aBlockClosure as a callback that my websocket should trigger when it closes."	websocket onclose: aBlockClosure! !!Entrance methodsFor: 'as yet unclassified' stamp: 'crl 7/6/2016 12:03'!onError: aBlockClosure	"Install aBlockClosure as a callback that my websocket should trigger when it encounters an error."	websocket onerror: aBlockClosure! !!Entrance methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2016 16:29'!onMessage: aBlockClosure	"Install aBlockClosure as a callback that my websocket should trigger when it receives a message."	websocket onmessage: aBlockClosure! !!Entrance methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2016 16:29'!onOpen: aBlockClosure	"Install aBlockClosure as a callback that my websocket should trigger when it opens."	websocket onopen: aBlockClosure! !!Entrance methodsFor: 'as yet unclassified' stamp: 'crl 8/2/2016 20:58'!outgoingPayload	"Answer the payload for the next outgoing message."		^outgoingMessage contents! !!Entrance methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2016 16:30'!readyState	"Answer my websocket's readyState (see the WebSocket RFC)."	^websocket readyState! !!Entrance methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2016 16:30'!stringForWebSocketMessage: message	"Answer the String payload of message, received by my websocket."	^message data asString! !!Entrance class methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 01:18'!to: url	"Answer a new instance of myself which connects to the system indicated by url."	^(		(			JS				ifConnected: [WebEntrance]				ifNotConnected: [self]		)			new	)		connectTo: url! !!Entrance class methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 01:19'!to: url for: service	"Answer a new instance of myself which connects to the service indicated by url."	^(self to: url) service: service! !!UUID methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 03:50'!tag	"Answer my transport tag."	^UUIDTag! !!UUID methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 03:40'!transmissionSize	^16! !!UUID class methodsFor: 'as yet unclassified'!fromTether: tether	^self withAll: (super fromTether: tether)! !!VariableDeclarator methodsFor: 'as yet unclassified' stamp: 'crl 5/6/2017 16:25'!id	^id! !!VariableDeclarator methodsFor: 'as yet unclassified' stamp: 'crl 5/6/2017 16:28'!initializes	^init notNil! !!VariableDeclarator methodsFor: 'as yet unclassified' stamp: 'crl 6/19/2017 12:56'!printSmalltalkOn: stream	id printSmalltalkOn: stream.	init ifNotNil: [		stream nextPutAll: ' := '.		init printSmalltalkOn: stream]! !!VariableDeclarator class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSBlinkerMorph methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSBlinkerMorph class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!WindowEvent class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!Manifest methodsFor: 'as yet unclassified'!at: index	"Answer the 16-bit unsigned value at index."	^((self basicAt: index - 1 * 2 + 1) bitShift: 8) + (self basicAt: index - 1 * 2 + 2)! !!Manifest methodsFor: 'as yet unclassified' stamp: 'crl 9/7/2012 18:08'!at: index put: sixteenBitUnsignedValue	"Put sixteenBitUnsignedValue at index."	self basicAt: (index - 1 * 2 + 1) put: (sixteenBitUnsignedValue bitShift: -8).	self basicAt: (index - 1 * 2 + 2) put: (sixteenBitUnsignedValue bitAnd: 16rFF)! !!Manifest methodsFor: 'as yet unclassified'!completeVia: aBlockClosure	"Complete the list of provisions I represent, by evaluating aBlockClosure with each missing provision's index."	self indicesOfMissingProvisions do: [:index | aBlockClosure value: index]! !!Manifest methodsFor: 'as yet unclassified'!do: aBlockClosure	"Evaluate aBlockClosure with each of my elements in turn."	1		to: self size		do: [:index | aBlockClosure value: (self at: index)]! !!Manifest methodsFor: 'as yet unclassified'!generalDescription	"Answer a general description of myself, in textual form."	^self subclassResponsibility! !!Manifest methodsFor: 'as yet unclassified'!indices	"Answer the indices I record."	^self subclassResponsibility! !!Manifest methodsFor: 'as yet unclassified'!indicesOfMissingProvisions	"Answer the indices of the missing provisions."	^self subclassResponsibility! !!Manifest methodsFor: 'as yet unclassified'!missingItemsFrom: aCollection	"Answer the missing items I represent from aCollection."	^self subclassResponsibility! !!Manifest methodsFor: 'as yet unclassified'!printOn: aStream	"Append a textual representation of myself to aStream."	aStream		nextPutAll: self class name article;		space;		print: self class;		nextPutAll: ' (the ';		nextPutAll: self generalDescription;		nextPutAll: ' of the elements at indices ';		printVerbosely: self indices;		nextPutAll: ' in a collection';		nextPut: $)! !!Manifest methodsFor: 'as yet unclassified'!replaceFrom: start to: stop with: replacement startingAt: repStart 	| index repOff |	repOff := repStart - start.	index := start - 1.	[(index := index + 1) <= stop] whileTrue: [		self			at: index			put: (replacement at: repOff + index)]! !!Manifest methodsFor: 'as yet unclassified'!size	"Answer the number of elements I have."	^super size // 2! !!Manifest methodsFor: 'as yet unclassified'!transmissionSize	^self basicSize! !!Manifest class methodsFor: 'as yet unclassified'!new: anInteger	"Answer a new instance of myself with anInteger elements."	^super new: anInteger * 2! !!Manifest class methodsFor: 'as yet unclassified' stamp: 'crl 9/7/2012 20:37'!readFromProxyStream: aStream for: anObjectTransferCorrespondent	| bytes manifest index |	bytes := (aStream next: aStream next16Bits) stream.	manifest := self transmissionNew: bytes size.	index := 1.	[bytes atEnd] whileFalse: [		manifest			at: index			put: ((bytes next bitShift: 16) + (bytes next)).		index := index + 1].	^manifest! !!Manifest class methodsFor: 'as yet unclassified'!transmissionNew: anInteger	^self basicNew: anInteger! !!NullCanvas class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:55'!foo! !!FloatingPointException methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!FloatingPointException class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!AEntity methodsFor: 'as yet unclassified' stamp: 'crl 8/18/2017 19:50'!add	"Add myself to the scene."		scene appendChild: self! !!AEntity methodsFor: 'as yet unclassified' stamp: 'crl 8/18/2017 19:55'!at: key	^(key == #tag)		ifTrue: [self tag]		ifFalse: [			super				at: key				ifAbsent: [self getAttribute: key]]! !!AEntity methodsFor: 'as yet unclassified' stamp: 'crl 10/22/2017 16:32'!initialize	webpage := Webpage current.	scene := webpage elementAt: #scene.	proxy := (webpage topDocument createElement: self tag) proxy.	proxy		at: #id		put: self tag, '-', (String randomOfLength: 5)! !!AEntity methodsFor: 'as yet unclassified' stamp: 'crl 8/19/2017 13:31'!initializeFrom: dictionary	retained := dictionary.	self propertiesToSet do: [:key | proxy at: key put: (dictionary at: key)].	self add.	self literalAttributesToSet do: [:key | proxy setAttribute: key with: (dictionary at: key)].	self nonLiteralAttributesToSet do: [:key | proxy setAttribute: key with: (JSObject from: (dictionary at: key))]! !!AEntity methodsFor: 'as yet unclassified' stamp: 'crl 8/18/2017 19:38'!isDictionary	^true! !!AEntity methodsFor: 'as yet unclassified' stamp: 'crl 8/19/2017 12:45'!keys	^self literalAttributesToSet, self nonLiteralAttributesToSet, self propertiesToSet! !!AEntity methodsFor: 'as yet unclassified' stamp: 'crl 8/18/2017 20:34'!literalAttributesToSet	^#()! !!AEntity methodsFor: 'as yet unclassified' stamp: 'crl 8/18/2017 20:34'!nonLiteralAttributesToSet	^#()! !!AEntity methodsFor: 'as yet unclassified' stamp: 'crl 8/19/2017 12:45'!propertiesToSet	^#(tag id)! !!AEntity methodsFor: 'as yet unclassified' stamp: 'crl 8/19/2017 13:49'!reanimate	self		initialize;		initializeFrom: retained! !!AEntity methodsFor: 'as yet unclassified' stamp: 'crl 8/19/2017 13:27'!retain	retained := WebUtils jsonEncode: self! !!AEntity methodsFor: 'as yet unclassified' stamp: 'crl 8/18/2017 20:19'!tag	^self class tag! !!AEntity methodsFor: 'as yet unclassified' stamp: 'crl 8/19/2017 13:27'!write	"Write a JSON description of myself to the current webpage's IndexedDB storage, suitable for later reanimation."		| stream |			[		stream := FileDirectory default fileNamed: self id, '.json'.		self retain.		stream nextPutAll: retained	]		ensure: [stream ifNotNilDo: [:theStream | theStream close]]! !!AEntity class methodsFor: 'as yet unclassified' stamp: 'crl 8/18/2017 20:21'!from: dictionary	^self new initializeFrom: dictionary! !!AEntity class methodsFor: 'as yet unclassified' stamp: 'crl 8/18/2017 20:51'!reanimateFromFileNamed: filename	| stream |		^[		| dictionary tag |				stream := FileDirectory default readOnlyFileNamed: filename.		dictionary := WebUtils jsonDecode: stream contentsOfEntireFile readStream.		tag := dictionary at: #tag.		(			(self allSubclasses)				detect: [:subclass | subclass tag = tag]				ifNone: [self error: 'I don''t know how to read instances of that class.']		)			from: dictionary	]		ensure: [stream ifNotNilDo: [:theStream | theStream close]]! !!AEntity class methodsFor: 'as yet unclassified' stamp: 'crl 8/18/2017 20:18'!tag	^'a-entity'! !!ChromeConsoleMessage methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 17:30'!initializeFrom: dictionary	super initializeFrom: dictionary.	url := Url absoluteFromText: url! !!ChromeConsoleMessage class methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 17:49'!fromDictionary: dictionary	^(MessageClasses at: (dictionary at: 'source')) new initializeFrom: dictionary! !!ChromeConsoleMessage class methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 18:07'!initialize	MessageClasses := (		(Dictionary new)			at: 'console-api' put: ChromeConsoleAPIConsoleMessage;			at: 'network' put: ChromeNetworkConsoleMessage;			at: 'javascript' put: ChromeJavaScriptConsoleMessage;			yourself)! !!HTMLTextAreaElement methodsFor: 'as yet unclassified' stamp: 'crl 9/18/2017 18:23'!clear	self value: ''! !!HTMLTextAreaElement methodsFor: 'as yet unclassified' stamp: 'crl 9/18/2017 19:30'!onInput: block	self at: #oninput put: block! !!HTMLTextAreaElement methodsFor: 'as yet unclassified' stamp: 'crl 7/12/2017 22:00'!value	^(proxy at: #value) counterpart simplestRepresentation! !!HTMLTextAreaElement methodsFor: 'as yet unclassified' stamp: 'crl 9/18/2017 18:23'!value: string	^proxy at: #value put: string! !!HTMLTextAreaElement class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!PerspectiveCamera methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!PerspectiveCamera class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!Cubic class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!ClassID methodsFor: 'as yet unclassified' stamp: 'crl 3/23/2019 05:04'!activeClass	^ConstantBehaviors		at: self classBaseID		ifAbsent: [			(EditHistory residesLocally not or: [EditHistory isTether])				ifTrue: [self activeClassObject]				ifFalse: [self activeClassEdition]]! !!ClassID methodsFor: 'as yet unclassified' stamp: 'crl 10/12/2016 14:34'!activeClassEdition	^EditHistory activeEditionForClassWithBaseID: self classBaseID! !!ClassID methodsFor: 'as yet unclassified' stamp: 'crl 9/6/2019 13:12'!activeClassObject	| classBaseID |		classBaseID := self classBaseID.		ProtoObject withAllSubclassesDo: [:class | (class baseID = classBaseID) ifTrue: [^class]].	^nil! !!ClassID methodsFor: 'as yet unclassified' stamp: 'crl 3/9/2008 19:35'!author	^self classAuthor! !!ClassID methodsFor: 'as yet unclassified' stamp: 'crl 3/9/2008 20:07'!author: author	self classAuthor: author! !!ClassID methodsFor: 'as yet unclassified' stamp: 'crl 3/9/2008 19:21'!authorID	^self classAuthorID! !!ClassID methodsFor: 'as yet unclassified' stamp: 'crl 7/6/2008 17:55'!authorID: aUUID	self classAuthorID: aUUID! !!ClassID methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2016 18:17'!classAuthor	"Answer the local Author of the class I describe, or nil if the system doesn't know about that author."	^EditHistory knownAuthorWithID: self classAuthorID! !!ClassID methodsFor: 'as yet unclassified' stamp: 'crl 3/9/2008 20:07'!classAuthor: author	self classAuthorID: author id! !!ClassID methodsFor: 'as yet unclassified' stamp: 'crl 3/9/2008 19:38'!classAuthorID	"Answer my class author ID part."	^UUID withAll: (		self			copyFrom: 17			to: 32)! !!ClassID methodsFor: 'as yet unclassified' stamp: 'crl 3/9/2008 20:06'!classAuthorID: aUUID	"Set my class author ID part to the bytes of aUUID."	self		replaceFrom: 17		to: 32		with: aUUID! !!ClassID methodsFor: 'as yet unclassified' stamp: 'crl 3/9/2008 20:08'!classBaseID	"Answer the base ID part for the class I describe."	^UUID withAll: (self copyFrom: 1 to: 16)! !!ClassID methodsFor: 'as yet unclassified' stamp: 'crl 3/9/2008 20:10'!classBaseID: aUUID	"Set the base ID part for the class I describe to the bytes of aUUID."	self		replaceFrom: 1		to: 16		with: aUUID! !!ClassID methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2008 18:57'!classID	^self! !!ClassID methodsFor: 'as yet unclassified' stamp: 'crl 3/9/2008 19:39'!classVersion	"Answer the version of the class I describe."	^((self at: 33) bitShift: 8) + (self at: 34)! !!ClassID methodsFor: 'as yet unclassified' stamp: 'crl 4/1/2008 19:08'!classVersion: sixteenBits	"Set the version of the class I describe."	self		at: 33		put: (sixteenBits bitShift: -8);		at: 34		put: (sixteenBits bitAnd: 2r11111111).	^sixteenBits! !!ClassID methodsFor: 'as yet unclassified' stamp: 'crl 9/6/2012 01:55'!edition	"^EditHistory classEditionWithID: self"	^EditHistory activeEditionForClassWithBaseID: self classBaseID! !!ClassID methodsFor: 'as yet unclassified' stamp: 'crl 11/15/2013 17:19'!id	^self! !!ClassID methodsFor: 'as yet unclassified' stamp: 'crl 1/13/2015 14:56'!installVia: remoteModule	"Install the class prescribed by the edition I identify in remoteModule's system."	| edition |	edition := self edition.	"Ensure that remoteModule's system has the superclass."	(remoteModule seesClassWithID: edition superclassID) ifFalse: [edition superclassID edition installVia: remoteModule].	remoteModule		installProtoclassEdition: self		withMetaclassEdition: (EditHistory classEditionWithID: edition counterpartID)! !!ClassID methodsFor: 'as yet unclassified' stamp: 'crl 7/15/2011 22:01'!pattern	^ClassIDPattern reference: self! !!ClassID methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 01:45'!printComponentNameOn: aStream	aStream nextPutAll: self edition name! !!ClassID methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2011 12:24'!printOn: aStream	"Print a textual representation of myself on aStream."	aStream nextPutAll: 'the ID for '.	self printComponentNameOn: aStream.	aStream		nextPutAll: ', version ';		print: self version;		nextPutAll: ' by ';		nextPutAll: self author name! !!ClassID methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 16:45'!tag	"Answer my transfer tag."	^ClassIDTag! !!ClassID methodsFor: 'as yet unclassified' stamp: 'crl 3/9/2008 19:39'!version	^self classVersion! !!ClassID class methodsFor: 'as yet unclassified' stamp: 'crl 3/3/2008 17:18'!for: aClass	^self forActiveClass: aClass! !!ClassID class methodsFor: 'as yet unclassified' stamp: 'crl 3/3/2008 17:18'!forActiveClass: aClass	^EditHistory idForActiveClassWithBaseID: aClass baseID! !!ClassID class methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 10:48'!forVersion: version ofClassWithBaseID: baseClassID byAuthor: anAuthorEdition	^((self new: self instanceSize) writeStream)		nextPutAll: baseClassID;		nextPutAll: anAuthorEdition id;		nextPut: (version bitShift: -8);		nextPut: (version bitAnd: 2r11111111);		contents! !!ClassID class methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 12:48'!initialize	ConstantBehaviors := Dictionary new.		{		ProtoObject.		Object.		Behavior.		ClassDescription.		Class.		Metaclass	}		do: [:protoclass |			{protoclass. protoclass class} do: [:behavior |				ConstantBehaviors					at: behavior baseID					put: behavior]]	! !!ClassID class methodsFor: 'as yet unclassified' stamp: 'crl 7/31/2007 18:14'!instanceSize	"Answer the size of each of my instances, in bytes."	^34! !!ADodecahedron methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!ADodecahedron class methodsFor: 'as yet unclassified' stamp: 'crl 8/19/2017 14:18'!tag	^'a-dodecahedron'! !!DeflateStream class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!OSCEventHandler class methodsFor: 'as yet unclassified' stamp: 'crl 6/12/2018 17:28'!startUp: resuming	"resuming ifTrue: [		(Webpage current document getElementById: 'scene') ifNotNilDo: [:scene |			scene				addEventListener: 'oscEvent'				with: [:event | OSCEventHandler handle: (OSCEvent from: event detail)]				with: false]]"! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 4/16/2017 23:52'!asArray	| array |		array := Array new: self length.		1		to: self length		do: [:index |			array				at: index				put: (self at: index - 1)].				^array! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'bf 11/20/2014 00:38'!asJSArgument	^ self! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'bf 11/20/2014 00:38'!asString	"Convert me to a string"	<primitive: 117> #(JavaScriptPlugin primitiveAsString 0 0) at: 1.	^ self primitiveFailed! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 5/30/2017 15:37'!asSymbol	^self asString asSymbol! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'bf 11/20/2014 00:38'!at: aKey	"get a property"	| error |	<primitive: 117> #(JavaScriptPlugin primitiveAt 0 0) at: 1.	(error := self primGetError)		ifNotNil: [^ self error: error].	^ self primitiveFailed! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'bf 11/20/2014 00:38'!at: aKey put: aValue	"set a property"	| error |	<primitive: 117> #(JavaScriptPlugin primitiveAtPut 0 0) at: 1.	^ self with: aValue retry: [:val | self at: aKey put: val]! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 3/26/2019 16:21'!break: message	self ifConnected: [		self console log: message.				self			alert: message;			debugger]! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 5/12/2017 14:47'!constructor	^self at: 'constructor'! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 4/16/2017 23:16'!counterpart	"Answer an instance of a Smalltalk class that corresponds to my constructor, and which provides API documentation and live interaction."	^JSObject counterpartFor: self! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 4/18/2018 17:26'!debugger	(JS Function new: 'debugger') call! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'bf 11/20/2014 00:38'!doesNotUnderstand: aMessage	"Call a function, or get/set an existing property. The function name / property name is the message selector up to the first colon. If the function name is 'new', create a new instance and call the constructor with args."	<primitive: 117> #(JavaScriptPlugin primitiveDoUnderstand 0 0) at: 1.	^self with: aMessage arguments retry: [:args |		self doesNotUnderstand: (Message selector: aMessage selector arguments: args)]! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 4/16/2017 22:05'!evaluate: source	| result |		JS at: #messageReceiver put: self.	(JS messageReceiver)		at: #messageFunction		put: (JS Function new: source).	result := JS messageReceiver messageFunction.	(JS Function new: 'delete messageReceiver.messageFunction') call.	(JS Function new: 'delete messageReceiver') call.			^result! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 4/28/2017 11:25'!foobly	<primitive: 'primitiveFoobly' module: 'JavaScriptPlugin'>	^ nil! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 4/28/2017 17:12'!ifConnected: connected	"If SqueakJS is running my object memory, evaluate aBlockClosure."	^self		ifConnected: connected		ifNotConnected: [nil]! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 4/28/2017 17:12'!ifConnected: connected ifNotConnected: notConnected	[self top]		on: Error		do: [:exception | ^notConnected value].	^connected value! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 5/7/2017 21:27'!isConnected	"If SqueakJS is running my object memory, evaluate aBlockClosure."	^self		ifConnected: [true]		ifNotConnected: [false]! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 4/16/2017 21:00'!isIdenticalTo: proxy	| object |		object := JS Object new.	object		at: #firstThing put: self;		at: #secondThing put: proxy;		at: #comparison put: (JS Function new: 'return this.firstThing == this.secondThing').			^object comparison! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 4/16/2017 22:04'!name	^self evaluate: 'return this.name'! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 6/18/2017 20:11'!newWithParameters: parameters	| parametersJS |		parametersJS := JS Array new.	parameters do: [:parameter | parametersJS push: parameter asJSArgument].	^(self primitiveNewWithParameters: parametersJS) counterpart! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'bf 11/20/2014 00:38'!primGetError	<primitive: 117> #(JavaScriptPlugin primitiveGetError 0 0) at: 1.	^ nil! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 6/14/2017 11:11'!primitiveNewWithParameters: parameters	<primitive: 117> #(JavaScriptPlugin primitiveNewWithParameters 0 0) at: 1.	^ self primitiveFailed! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 5/20/2017 21:20'!primitiveSqueakAsJSObject: object	<primitive: 117> #(JavaScriptPlugin primitiveSqueakAsJSObject 0 0) at: 1.	^ self primitiveFailed! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'bf 11/20/2014 00:38'!printOn: aStream	[aStream nextPutAll: self asString]		ifError: [:err :rcvr | ^ super printOn: aStream].! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 4/16/2017 21:56'!removeKey: key	^self evaluate: 'delete this.', key! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 2/1/2019 23:03'!stringify	^(JS window JSON stringify: self) asString! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'bf 11/20/2014 00:38'!typeof	"Answer my jsObject's type (a string)"	<primitive: 117> #(JavaScriptPlugin primitiveTypeof 0 0) at: 1.	^ self primitiveFailed! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'bf 11/20/2014 00:38'!with: argument retry: retryBlock	| error |	(error := self primGetError) ifNil: [^ self error: 'JSBridge error'].	(error beginsWith: 'asJSArgument') ifTrue: [		^retryBlock value: argument asJSArgument].	(error beginsWith: 'CallbackSemaphore') ifTrue: [		self class initCallbacks.		^retryBlock value: argument].	self error: error.! !!JSObjectProxy class methodsFor: 'as yet unclassified' stamp: 'bf 11/26/2014 18:52'!callbackProcess	[true] whileTrue: [		CallbackSemaphore wait.		[self handleCallback] fork].! !!JSObjectProxy class methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2017 11:04'!evaluate: source	^(JS Function new: 'return ', source, ';') call! !!JSObjectProxy class methodsFor: 'as yet unclassified' stamp: 'bf 11/21/2014 17:00'!examples	| comment |	"Create symbols in advance"	('alert: console log: document getElementsByTagName: navigator Object keys: Function length setTimeout:ms: createElement: appendChild: jQuery: hide: show: css: click: appendTo:'		findTokens: ' ') do: [:s | s asSymbol].	comment := self organization classComment asString.	^ comment copyFrom: (comment indexOf: $") to: comment size.! !!JSObjectProxy class methodsFor: 'as yet unclassified' stamp: 'crl 6/6/2018 18:33'!handleCallback	| block |		block := self primGetActiveCallbackBlock.	block		ifNil: [			Transcript				cr;				nextPutAll: 'active JavaScript callback block got nulled';				endEntry]		ifNotNil: [			| args result |						args := self primGetActiveCallbackArgs.			[result := block valueWithArguments: args] ifError: [:error :receiver |				ActiveWorld halt: error asString.				result := JS Error: error asString].						self primReturnFromCallback: result]! !!JSObjectProxy class methodsFor: 'as yet unclassified' stamp: 'crl 8/2/2016 22:20'!initCallbacks	CallbackProcess ifNotNil: [CallbackProcess terminate. CallbackProcess := nil].	CallbackSemaphore := Semaphore new.	self primInitCallbacks: (Smalltalk registerExternalObject: CallbackSemaphore).	CallbackProcess := [self callbackProcess] newProcess		priority: Processor lowIOPriority; resume.! !!JSObjectProxy class methodsFor: 'as yet unclassified' stamp: 'bf 11/21/2014 17:00'!initialize	"Create the JS global"	Smalltalk at: #JS put: self basicNew.	"If we have the plugin, show workspace"	[JS window] ifError: [:err :rcvr | ^self].	Smalltalk isMorphic		ifTrue: [self openExamples]		ifFalse: [[self openExamples] fork].! !!JSObjectProxy class methodsFor: 'as yet unclassified' stamp: 'bf 11/20/2014 00:38'!new	self error: 'Use "JS Object new" to create a new JavaScript object'.! !!JSObjectProxy class methodsFor: 'as yet unclassified' stamp: 'bf 11/21/2014 17:00'!openExamples	Workspace new		contents: 'Besides running regular Squeak images, SqueakJS can directly use JavaScript. It can interact with the DOM, access JavaScript libraries, and use Smalltalk code to create an interactive HTML interface. Try these examples:', self examples;		openLabel: 'JSBridge'.! !!JSObjectProxy class methodsFor: 'as yet unclassified' stamp: 'bf 11/26/2014 18:52'!primGetActiveCallbackArgs	<primitive: 117> #(JavaScriptPlugin primitiveGetActiveCallbackArgs 0 0) at: 1.	^ self primitiveFailed! !!JSObjectProxy class methodsFor: 'as yet unclassified' stamp: 'crl 6/27/2016 22:54'!primGetActiveCallbackBlock	<primitive: 117> #(JavaScriptPlugin primitiveGetActiveCallbackBlock 0 0) at: 1.	^nil! !!JSObjectProxy class methodsFor: 'as yet unclassified' stamp: 'crl 6/22/2016 19:53'!primGetError	<primitive: 117> #(JavaScriptPlugin primitiveGetError 0 0) at: 1.	^ nil! !!JSObjectProxy class methodsFor: 'as yet unclassified' stamp: 'bf 11/26/2014 18:52'!primInitCallbacks: semaIndex	<primitive: 117> #(JavaScriptPlugin primitiveInitCallbacks 0 0) at: 1.	^ self primitiveFailed! !!JSObjectProxy class methodsFor: 'as yet unclassified' stamp: 'crl 6/22/2016 19:55'!primReturnFromCallback: returnValue	<primitive: 117> #(JavaScriptPlugin primitiveReturnFromCallback 0 0) at: 1.	(self primGetError = 'No active callback') ifFalse: [self primitiveFailed]! !!NumberParserError methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!NumberParserError class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!TraitCompositionException methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!TraitCompositionException class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!PluggableWidgetSpec class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 8/26/2019 12:32'!addMorph: morph atIndex: index	"Try to use yet another single-morph HTML5PasteUpMorph."		| world window |	world := HTML5PasteUpMorph newWorld.	world privateAddMorph: morph atIndex: index.	world beOpaque; beDraggable.		window := world canvas canvas window.	(morph class == MenuMorph) ifTrue: [		| morphPosition |				morphPosition := morph position.		window			styleAt: #top			put: (self containingCanvas style top + morphPosition y) printString, 'px';			styleAt: #left			put: (self containingCanvas style left + morphPosition x) printString, 'px'].			^window! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2019 18:52'!addScript: source	^self body appendChild: (		(self createScript)			at: #text			put: source;			yourself)! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 3/28/2019 12:54'!body	^self document body! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 8/6/2017 08:36'!containingCanvas	^self class containingCanvas! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 7/28/2017 13:47'!createButtonFromPictureAt: url evaluating: block	| button |		button := self createElement: 'img'.		button		at: #src put: url;		at: #width put: 19;		at: #height put: 19;		at: #onclick put: block.			(button style)		at: #top put: 0;		at: #left put: 0;		at: #userSelect put: 'none';		at: #userDrag put: 'none'.			^button! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 7/28/2017 13:48'!createButtonLabeled: label evaluating: block	^(self createInputElement)		at: #type put: 'button';		at: #value put: label;		at: #onclick put: block;		yourself! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 7/28/2017 13:48'!createCanvas	^self createCanvasOfExtent: 700@450! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 7/28/2017 13:48'!createCanvasOfExtent: extent	^(self createElement: 'canvas')		at: #width put: extent x;		at: #height put: extent y;		yourself! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 7/28/2017 13:49'!createDiv	^self createElement: 'div'! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2019 16:24'!createDragHandleFromElement: handle forElement: element	(Top at: #dragElement)		call: nil		with: element		with: handle! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2019 15:58'!createDragHandleFromElementNamed: handleElementID forElementNamed: targetElementID	self		createDragHandleFromElementNamed: (self elementAt: handleElementID) proxy		forElementNamed: (self elementAt: targetElementID) proxy! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 3/28/2019 13:50'!createElement: type	| element |		element := self document createElement: type.		(type = 'script') ifFalse: [		element			styleAt: #transition put: 'all 500ms';			beTransparent;			beHidden;			yourself].		^element! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 7/28/2017 13:45'!createHTMLWorld	| div |		div := (		self			createWorldOfKind: 'HTML'			withCanvas: self createDiv).				(div window)		windowize;		dragWithMoveButton.			^div! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 9/17/2017 23:21'!createIFrameWithSource: source	| iframe |		iframe := self createElement: 'iframe'.		iframe		beHidden;		at: #src put: source.			self document body appendChild: iframe.		^iframe! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 7/28/2017 13:52'!createImage	^self createElement: 'img'! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 7/28/2017 13:53'!createInputElement	^self createElement: 'input'! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 7/28/2017 13:44'!createMorphicJSWorld	^self		createWorldOfKind: 'MorphicJS'		withCanvas: self createCanvas! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 7/28/2017 13:44'!createMorphicWorld	^self createMorphicWorldWithCanvas: nil! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 7/28/2017 13:42'!createMorphicWorldWithCanvas: canvas	^self		createWorldOfKind: 'Morphic'		withCanvas: (			canvas				ifNil: [self createCanvas]				ifNotNil: [canvas])! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 8/1/2017 22:16'!createParagraph	^self createElement: 'p'! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 3/28/2019 13:16'!createScript	^self createElement: 'script'! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 7/28/2017 13:53'!createStyleNamed: className withContent: content	^((TopDocument getElementsByTagName: 'head') at: 0) appendChild: (		(TopDocument createElement: 'style')			at: #type put: 'text/css';			at: #innerHTML put: content;			yourself)! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 7/28/2017 13:53'!createTextInput	^(self createInputElement)		at: #type put: 'text';		yourself! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 7/28/2017 13:43'!createWorldOfKind: worldKind	^self createWorldOfKind: worldKind withCanvas: (self createCanvas)! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2019 13:49'!createWorldOfKind: worldKind withCanvas: canvas	| handle handleID id window windowID |		"canvas beTransparent.	(Delay forMilliseconds: 500) wait."	id := String randomOfLength: 5.	window := self createDiv.	windowID := worldKind, '-window-', id.	window		at: #id		put: windowID.			(window style)		at: #transition put: 'opacity 500ms';		at: #position put: 'absolute';		at: #top put: 50;		at: #left put: 50.	handle := self createDiv.	handleID := worldKind, '-handle-', id.	handle at: #id put: handleID.	(handle style)		at: #position put: 'absolute';		at: #width put: '500px';		at: #height put: '30px'.		canvas at: #id put: worldKind, '-canvas-', id.	(canvas at: #width ifAbsent: [nil]) ifNil: [		canvas			at: #width put: 1000;			at: #height put: 400].	canvas		at: #handle put: handle;		at: #window put: window.			window		at: #canvas put: canvas;		at: #handle put: handle.			handle		at: #window put: window;		at: #canvas put: canvas.			(canvas style)		at: #outline put: 'none';		at: #borderRadius put: '5px'.	(self parentOfNewWorldWithCanvas: canvas) appendChild: (		window			appendChild: handle;			appendChild: canvas;			yourself).		canvas at: #tabIndex put: 0.	^canvas! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 8/19/2017 20:46'!cursorCanvas	^cursorCanvas! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 9/17/2017 15:40'!document	^document! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 3/27/2019 10:49'!elementAt: id	^TopDocument getElementById: id! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 7/28/2017 13:53'!evaluate: source	^(JS Function new: 'return ', source) call! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 9/17/2017 13:36'!finishProgress	self progress: 100.	[		(Delay forSeconds: 1) wait.		self status ifNotNil: [			self progressBar beTransparent.			self status beTransparent]	]		fork! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 6/14/2017 17:11'!focus	"If my system is embedded in a frame of a webpage, give input focus to that frame."	self class focus! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 6/14/2017 17:13'!fullscreen: fullscreen	"Set fullscreen mode accordingly."	self class fullscreen: fullscreen! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 6/14/2017 17:12'!fullscreenOff	"Turn fullscreen mode off."	self class fullscreenOff! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 6/14/2017 17:12'!fullscreenOn	"Turn fullscreen mode on."	self class fullscreenOn! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 6/14/2017 17:53'!ifOptionAt: option then: block	self class ifOptionAt: option then: block! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 3/27/2019 15:07'!initialize	Current := self.	cursorCanvas := (JS document getElementById: 'cursorCanvas') counterpart.	window := JS window counterpart.	document := window document.	self processOptions.	window focus! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2017 12:53'!jQueryFunction	^self window proxy at: '$'! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 7/23/2017 22:22'!loadScriptFrom: locator	self loadScriptFrom: locator then: []! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 8/2/2017 20:05'!loadScriptFrom: locator then: block	| script |		script := (		(self window document createElement: 'script')			at: 'type' put: 'text/javascript';			at: 'onload'			put: [block valueWithPossibleArgs: {script}];			yourself).				self window document head appendChild: script.	script at: 'src' put: locator! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 7/27/2017 13:53'!loadStylesheetFrom: locator	self window document head appendChild: (		(self window document createElement: 'link')			at: 'rel' put: 'stylesheet';			at: 'href' put: locator;			yourself)! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 6/14/2017 17:53'!optionAt: optionName	^self class optionAt: optionName! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 9/17/2017 15:41'!parentOfNewWorldWithCanvas: canvas	^TopDocument body! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 7/27/2017 16:29'!printOn: stream	stream		nextPutAll: 'the ';		nextPutAll: self class appName;		nextPutAll: ' web app, running from ';		print: url! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 6/14/2017 15:46'!processOptions	"Subclasses can initialize themselves as apps, from the SqueakJS.runSqueak() options."! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 7/26/2017 16:29'!progress: percentage	Top ifNotNil: [		self progressBar ifNotNilDo: [:bar |			bar				styleAt: #width				put: (percentage printString, '%')]]! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 6/16/2017 19:08'!progressBar	^TopDocument getElementById: 'progress'! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 6/14/2017 17:22'!removeElement: element	self class removeElement: element! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 6/14/2017 17:22'!removeElementWithID: id	self class removeElementWithID: id! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 3/30/2019 17:55'!run: block	| finished returnValue |		finished := Semaphore new.		(		(			(JS Function)				new: 'block'				with: 'return block.call()'		)			call: window proxy			with: block	)		then: [:value |			returnValue := value.			finished signal].			finished wait.	^returnValue! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 6/14/2017 14:30'!save	Pages at: url put: self! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 6/14/2017 17:23'!scale: float	self class scale: float! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 8/25/2019 12:04'!scrollToBottom	self window scrollTo: 0 with: TopDocument body scrollHeight! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 8/12/2019 12:22'!scrollToTop	self window scrollTo: 0 with: 0! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 10/22/2017 13:09'!selectionAt: id	^JQuery elementAt: id in: self! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 9/6/2017 17:40'!setHardwareCursorFor: cursor	(cursor == Cursor normal)		ifTrue: [JS document counterpart body styleAt: #cursor put: '']		ifFalse: [			(cursorCanvas styleAt: #top) isEmpty ifFalse: [				JS document counterpart body styleAt: #cursor put: 'none'.				cursorCanvas beVisible]]! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2019 17:48'!shortWindowizeElement: element closingWith: closeBlock	| transition tray |		element ifNil: [^self].	transition := (element style at: #transition) asString.	element		styleAt: #transition		put: (			(transition isEmpty)				ifTrue: ['opacity 500ms']				ifFalse: [transition, ', opacity 500ms']).		element		addWindowButtonCalled: 'closeButton'		fromImage: 'pictures/icons/windows/closeButton.png'		evaluating: [			[				element styleAt: #opacity put: 0.				(Delay forMilliseconds: 500) wait.				closeBlock value.				element remove			]				fork];		addWindowButtonCalled: 'moveButton'		fromImage: 'pictures/icons/windows/moveButton.png'		evaluating: [];		addWindowButtonCalled: 'collapseButton'		fromImage: 'pictures/icons/windows/collapseButton.png'		evaluating: [element collapse].			tray := element tray.	tray beTransparent; beVisible; beOpaque.	tray children do: [:child | child beOpaque].	self		createDragHandleFromElement: tray		forElement: element.	^element! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 3/27/2019 16:37'!shortWindowizeElementAt: elementName	self shortWindowizeElement: (self elementAt: elementName) closingWith: []! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2019 14:45'!shortWindowizeJQuerySelection: selection closingWith: closeBlock	| element transition |		element := selection element.	element ifNil: [^self].	transition := (element style at: #transition) asString.	element		styleAt: #transition		put: (			(transition isEmpty)				ifTrue: ['opacity 500ms']				ifFalse: [transition, ', opacity 500ms']).		element		addWindowButtonCalled: 'closeButton'		fromImage: 'pictures/window icons/closeButton.png'		evaluating: [			[				element styleAt: #opacity put: 0.				(Delay forMilliseconds: 500) wait.				closeBlock value.				element remove			]				fork];		addWindowButtonCalled: 'moveButton'		fromImage: 'pictures/window icons/moveButton.png'		evaluating: [];		addWindowButtonCalled: 'collapseButton'		fromImage: 'pictures/window icons/collapseButton.png'		evaluating: [element collapse].			element tray beTransparent; beVisible; beOpaque.	element tray children do: [:child | child beOpaque].	selection beDraggable! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 6/14/2017 17:24'!shrink	self class shrink! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 6/14/2017 17:24'!size: point	self class size: point! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 3/27/2019 16:14'!status	^([JS top document counterpart getElementById: 'status'] ifError: [^nil]) children first! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 3/27/2019 16:18'!status: string	Top ifNotNil: [		self status ifNotNilDo: [:status |.			status parentNode beTransparent.			(Delay forMilliseconds: 500) wait.			status at: #innerText put: string.			status parentNode beOpaque]]! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 6/14/2017 17:52'!styleAt: key put: value	self class styleAt: key put: value! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2019 14:50'!styleNewWindow: window	window beDraggable! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 6/18/2017 20:19'!top	^Top! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 6/18/2017 20:19'!topDocument	^TopDocument! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 6/14/2017 15:03'!url	^url! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 6/14/2017 14:28'!url: aURL	url := aURL! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 9/17/2017 15:40'!window	^window! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 3/28/2019 16:35'!windowizeElement: element	self windowizeElement: element closingWith: []! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 3/28/2019 18:01'!windowizeElement: element closingWith: closeBlock	^self		windowizeElement: element		withDragHandleAt: nil		closingWith: closeBlock! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 3/28/2019 18:02'!windowizeElement: element withDragHandleAt: dragHandleID	^self		windowizeElement: element		withDragHandleAt: dragHandleID		closingWith: []! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 3/30/2019 22:33'!windowizeElement: element withDragHandleAt: dragHandleID closingWith: closeBlock	| transition tray |		element ifNil: [^self].	transition := (element style at: #transition) asString.	element		styleAt: #transition		put: (			({'*opacity *'. '*all *'} anySatisfy: [:pattern | pattern match: transition])				ifTrue: [transition]				ifFalse: [transition, ', opacity 500ms']).		dragHandleID		ifNil: [			element				addWindowButtonCalled: 'closeButton'				fromImage: 'pictures/icons/windows/closeButton.png'				evaluating: [					[						element styleAt: #opacity put: 0.						(Delay forMilliseconds: 500) wait.						closeBlock value.						element remove					]						fork];				addWindowButtonCalled: 'moveButton'				fromImage: 'pictures/icons/windows/moveButton.png'				evaluating: [];				addWindowButtonCalled: 'collapseButton'				fromImage: 'pictures/icons/windows/collapseButton.png'				evaluating: [element collapse];				addWindowButtonCalled: 'fullscreenButton'				fromImage: 'pictures/icons/windows/fullscreenButton.png'				evaluating: [element fullscreen];				addWindowButtonCalled: 'rotateButton'				fromImage: 'pictures/icons/windows/rotateButton.png'				evaluating: [element rotate].			tray := element tray.						tray				beTransparent;				beVisible;				beOpaque.							tray children do: [:child | child beOpaque].						self				createDragHandleFromElement: tray				forElement: element]		ifNotNil: [self createDragHandleFromElementNamed: dragHandleID forElementNamed: element id].				^element! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 3/28/2019 17:53'!windowizeElementAt: elementName	elementName ifNotEmpty: [self windowizeElementAt: elementName closingWith: []]! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 3/27/2019 10:44'!windowizeElementAt: elementName closingWith: block	^self		windowizeElement: (self elementAt: elementName)		closingWith: block! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 3/27/2019 10:33'!windowizeJQuerySelection: selection closingWith: closeBlock	self		windowizeElement: selection element		closingWith: closeBlock! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 6/14/2017 22:18'!appID	^self subclassResponsibility! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 7/27/2017 16:29'!appName	^self name! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 4/14/2018 16:23'!applyBounds	self bounds: ((OldX @ OldY) extent: (OldWidth @ OldHeight))! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 7/24/2016 16:19'!at: key put: block	^Top at: key put: block! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 3/28/2019 12:41'!body	^TopDocument body! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 4/14/2018 16:21'!bounds: bounds	ContainingFrame ifNotNil: [		| newWidth newHeight |							newWidth := bounds width.		newHeight := bounds height.		ContainingDiv			styleAt: #transition			put: 'opacity 500ms, box-shadow 300ms, opacity 500ms, top 500ms, left 500ms';			styleAt: #top put: bounds top;			styleAt: #left put: bounds left;			styleAt: #width put: newWidth;			styleAt: #height put: newHeight.					ContainingCanvas			width: newWidth;			height: newHeight.					ContainingFrame			width: newWidth;			height: newHeight.					[			(Delay forMilliseconds: 500) wait.			ContainingDiv				styleAt: #transition				put: 'opacity 500ms, box-shadow 300ms, opacity 500ms'		]			fork]! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 4/27/2017 01:04'!browserZoomLevel	^JS Math round: (Top devicePixelRatio * 100)! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 5/15/2017 22:06'!canvas	^HTML5Canvas on: (self containingCanvas getContext: '2d')! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/3/2019 13:31'!captureCurrentExtent	OldWidth := ContainingCanvas width.	OldHeight := ContainingCanvas height.	OldX := ContainingDiv offsetLeft.	OldY := ContainingDiv offsetTop! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 6/14/2017 16:04'!containingCanvas	^ContainingCanvas! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 4/14/2018 15:13'!containingDiv	^ContainingDiv! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 4/12/2017 21:22'!containingFrame	^ContainingFrame! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 6/14/2017 14:32'!current	^Current! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 7/27/2017 14:14'!elementAt: id	^JQuery elementAt: id in: self! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 4/15/2017 00:56'!expand	self scale: 1! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 8/14/2019 20:12'!exportFile: filename	(		JS Function new: '			Squeak.fileGet(				''/', filename, ''',				function (buffer) {					var oReq = new XMLHttpRequest()					oReq.open(						''POST'',						''https://frankfurt.demo.blackpagedigital.com:8087/upload'',						true)					oReq.setRequestHeader(''filename'', ''', filename, ''')					oReq.onload = function (oEvent) {					}					oReq.send(buffer)},				alert)'			)		call! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 8/14/2019 20:23'!exportSnapshot	| base |		base := self imageFilenameBase.		self		exportFile: base, '.changes';		exportFile: base, '.image'! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 7/25/2016 21:40'!focus	"If my system is embedded in a frame of a webpage, give input focus to that frame."	ContainingFrame ifNotNil: [ContainingFrame contentWindow focus]! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 6/14/2017 14:26'!fromURL: url	^self new url: url! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/13/2019 21:44'!fullscreen: fullscreen	"Set fullscreen mode accordingly."	(Fullscreen == fullscreen) ifFalse: [		Fullscreen := fullscreen.		ContainingCanvas			ifNil: [				(Project current lastScreenModeSelected == fullscreen) ifFalse: [					fullscreen						ifTrue: [Project current fullScreenOn]						ifFalse: [Project current fullScreenOff]]]			ifNotNil: [				ContainingFrame ifNotNil: [					| newWidth newHeight newX newY |									ContainingFrame						styleAt: #transition put: '';						beTransparent.						fullscreen						ifTrue: [							self captureCurrentExtent.							newWidth := JS top innerWidth - 4.							newHeight := JS top innerHeight - 4.							newX := newY := 2.							ContainingDiv								styleAt: #boxShadow put: '';								styleAt: #border put: '']						ifFalse: [							newWidth := OldWidth.							newHeight := OldHeight.							newX := OldX.							newY := OldY.							ContainingDiv								styleAt: #boxShadow put: '1px 1px 7px #999, 2px 2px 8px #999, 3px 3px 9px #999';								styleAt: #border put: '2px inset gray'].									self bounds: ((newX @ newY) extent: (newWidth @ newHeight)).					JS top touch at: #orig put: nil.					self zoomOut.					[						(Delay forMilliseconds: 500) wait.						ContainingFrame styleAt: #transition put: 'opacity 500ms'.						ContainingFrame beOpaque					]						fork]]]! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 7/24/2016 18:01'!fullscreenOff	"Turn fullscreen mode off."	self fullscreen: false! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/2/2019 20:16'!fullscreenOn	"Turn fullscreen mode on."	self fullscreen: true.	JS ifConnected: [		(Delay forSeconds: 1) wait.		self scrollToTop]! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 4/15/2018 15:54'!height: height	OldHeight := height.	self applyBounds! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 6/14/2017 22:59'!ifOptionAt: optionName then: block	^self		ifOptionAt: optionName		then: block		else: []! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 18:38'!ifOptionAt: optionName then: affirmativeBlock else: negativeBlock	^Options		ifNil: [negativeBlock value]		ifNotNil: [			| option |				option := Options at: optionName.			^option				ifNil: [negativeBlock value]				ifNotNil: [affirmativeBlock value: option]]! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 8/14/2019 20:16'!imageFilenameBase	^(Smalltalk primImageName reversed readStream upTo: $/) reversed readStream upTo: $.! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 8/14/2019 20:11'!importFile: filename	(		JS Function new: '			var request = new XMLHttpRequest()						request.open(				''GET'',				''https://frankfurt.demo.blackpagedigital.com:8087/', filename, ''',				true)				request.responseType = ''blob''			request.onload = function (event) {				var blob = request.response								if (blob) {					var reader = new FileReader()							reader.onload = function () {						var buffer = this.result						console.log(							''Storing ', filename, ' ('' + buffer.byteLength + '' bytes)'')						Squeak.filePut(							''', filename, ''',							buffer,							function success() {								console.log(''', filename, ' written'')})}					reader.onerror = function() {						alert(''Failed to read ', filename, '.'')}			 					reader.readAsArrayBuffer(blob)}}					request.send()'	)		call! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 8/14/2019 20:23'!importSnapshot	| base |		base := self imageFilenameBase.		self		importFile: base, '.changes.export';		importFile: base, '.image.export'! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 8/19/2019 21:12'!initialize	self == Webpage ifTrue: [		Fullscreen := false.		Pages := Dictionary new.		Smalltalk addToStartUpList: self]! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 8/23/2016 15:53'!optionAt: optionName	^(Options at: optionName) asString! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 7/24/2016 16:22'!removeElement: element	element parentNode removeChild: element! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 7/27/2017 14:11'!removeElementWithID: id	| element |		element := self elementAt: id.	element ifNotNil: [element parentNode removeChild: element]! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 7/19/2017 18:37'!require: moduleName	^[Top require: moduleName]		on: Error		do: [:exception |			| semaphore |				semaphore := Semaphore new.						self				loadScriptFrom: 'https://wzrd.in/bundle/', moduleName				then: [semaphore signal].							semaphore wait.			Top require: moduleName]! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 3/27/2019 12:59'!resize	| newWidth newHeight |		newWidth := ContainingDiv clientWidth.	newHeight := ContainingDiv clientHeight.	ContainingCanvas		width: newWidth;		height: newHeight.			ContainingFrame		width: newWidth;		height: newHeight.			self captureCurrentExtent! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2017 11:24'!scale: float	| scale stream |		scale := float min: 1.	stream := (String new: 6) writeStream.		{		'width' -> OldWidth.		'height' -> OldHeight	}		do: [:association |			self				styleAt: association key				put: (					stream reset;					print: ((association value * scale) rounded max: 1);					nextPutAll: 'px';					contents)]! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 8/25/2019 11:56'!scrollToBottom	Current scrollToBottom! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 8/12/2019 12:23'!scrollToTop	Current scrollToTop! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 4/15/2017 00:54'!shrink	#(width height) do: [:dimension | self styleAt: dimension put: '0px']! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 4/23/2017 22:35'!size: point	| stream |		stream := (String new: 6) writeStream.		{		'width' -> point x.		'height' -> point y	}		do: [:association |			self				styleAt: association key				put: (					stream reset;					print: (association value rounded max: 1);					nextPutAll: 'px';					contents)]! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/4/2019 22:55'!skoobly	self perform: #wogga! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 18:37'!startUp: resuming	"After a system resumption, if the system is being run by SqueakJS in a web browser, reset constants related to that web browser's JavaScript environment."	| forceToScreen |	resuming ifTrue: [		(self == Webpage)			ifTrue: [				Fullscreen := false.								Top := TopDocument := ContainingDiv := ContainingCanvas := ContainingFrame := Current := Options := nil.				Preferences					setPreference: #fastDragWindowForMorphic					toValue: JS isConnected.								JS ifConnected: [					| url |															Top := [JS top counterpart magicWindow] on: Error do: [:exception | nil].					url := (						Top							ifNil: [String randomOfLength: 5]							ifNotNil: [								TopDocument := Top document.								Url absoluteFromText: Top location href asString]).					Options := (						(JS SqueakJS options at: #parameters)							ifNil: [nil]							ifNotNil: [JS SqueakJS options parameters counterpart]).												ContainingCanvas := JS document counterpart getElementById: 'squeak'.								Top ifNotNil: [ContainingFrame := Top document getElementById: #Caffeine].					ContainingCanvas ifNotNil: [						ContainingDiv := (							ContainingFrame								ifNil: [ContainingCanvas parentNode]								ifNotNil: [									self styleAt: #transition put: 'opacity 500ms'.									ContainingFrame parentNode parentNode]).						ContainingDiv at: #onresize put: [self resize].						ContainingCanvas at: #tabIndex put: 0.						self captureCurrentExtent.						ContainingCanvas onclick: [self focus]].										forceToScreen := [:event | Display forceToScreen].					Top						at: #onresize						put: forceToScreen; 						at: #onscroll						put: forceToScreen;						at: #onorientationchange						put: [:event |							forceToScreen value: event.							self scrollToTop].															ContainingCanvas ifNotNil: [						ContainingCanvas							styleAt: 'user-select'							put: [false]].											Pages						at: url						ifAbsent: [							self								ifOptionAt: 'appID'								then: [:appID |									| appClass |																		appClass := self allSubclasses detect: [:subclass | subclass appID = appID] ifNone: [nil].									appClass										ifNil: [nil]										ifNotNil: [											Pages												at: url												put: (appClass fromURL: url)]]								else: [nil]]]]]! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 3/27/2019 16:58'!styleAt: key	^ContainingCanvas style at: key! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 6/14/2017 17:51'!styleAt: key put: value	ContainingFrame ifNotNil: [ContainingFrame style at: key put: value].	ContainingCanvas style at: key put: value! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 7/24/2016 16:10'!top	^Top! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 7/24/2017 10:49'!topDocument	^TopDocument! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 4/14/2018 16:23'!width: width	OldWidth := width.	self applyBounds! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 7/27/2017 14:08'!window	^self top! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/4/2019 22:56'!wogga	3 halt! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 8/27/2019 16:53'!zoomOut	"Zoom out the containing canvas."		ContainingCanvas		styleAt: #left put: 0;		styleAt: #top put: 0;		styleAt: #width put: ContainingCanvas width;		styleAt: #height put: ContainingCanvas height! !!MouseClickState class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!ModuleDescription methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!ModuleDescription class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!BalloonFillData class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!Document methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!Document class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!Attr methodsFor: 'as yet unclassified' stamp: 'crl 8/1/2017 18:54'!name	^proxy at: #name! !!Attr methodsFor: 'as yet unclassified' stamp: 'crl 8/1/2017 21:34'!value	^(proxy at: #value) asString! !!Attr methodsFor: 'as yet unclassified' stamp: 'crl 8/1/2017 21:25'!value: value	^proxy at: #value put: value! !!Attr class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!PitchSet methodsFor: 'as yet unclassified' stamp: 'crl 8/17/2004 22:26'!at: anInteger	"Answer the pitch at anInteger."	^pitches at: anInteger! !!OSCEvent class methodsFor: 'as yet unclassified' stamp: 'crl 6/5/2018 13:58'!initialize	Types := (		(Dictionary new)			at: 'i'			put: [:string | string asNumber];			at: 'f'			put: [:string | string asNumber];			at: 's'			put: [:string | string];			at: 'b'			put: [:string | 3 halt];			at: 'T'			put: [:string | true];			at: 'F'			put: [:string | false];			at: 'N'			put: [:string | nil];			at: 'I'			put: [:string | Impulse];			at: 't'			put: [:string | 3 halt];			yourself)! !!SystemProgressBarMorph class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!NetworkError methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!NetworkError class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!ChromeResult methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 18:47'!initializeFrom: dictionary	id := dictionary at: 'id'.	result := dictionary at: 'result'! !!ChromeResult methodsFor: 'as yet unclassified' stamp: 'crl 7/30/2016 00:43'!invokes	^false! !!ChromeResult methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 18:48'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: ' for invocation ID ';		print: id! !!ChromeResult methodsFor: 'as yet unclassified' stamp: 'crl 8/2/2016 17:57'!result	^result! !!ChromeResult class methodsFor: 'as yet unclassified' stamp: 'crl 7/31/2016 00:05'!fromDictionary: dictionary for: tab	^self new initializeFrom: dictionary! !!AText methodsFor: 'as yet unclassified' stamp: 'crl 8/19/2017 15:17'!add	super add.	self		setAttribute: #value		with: 'This is some text.';		setAttribute: #width with: 5;		setAttribute: #height with: 1! !!AText methodsFor: 'as yet unclassified' stamp: 'crl 8/19/2017 15:13'!nonLiteralAttributesToSet	^super nonLiteralAttributesToSet, #(value width height)! !!AText class methodsFor: 'as yet unclassified' stamp: 'crl 8/19/2017 15:26'!tag	^'a-text'! !!OutgoingMessageExchange methodsFor: 'as yet unclassified' stamp: 'crl 9/2/2016 15:16'!deliver: answer	queue nextPut: answer! !!OutgoingMessageExchange methodsFor: 'as yet unclassified' stamp: 'crl 10/4/2016 12:01'!forward: aMessage for: theRemoteIdentity over: aTether	"Forward message to the remote object corresponding to remoteIdentity, using tether's network connection."	remoteIdentity := theRemoteIdentity.	^self forward: aMessage over: aTether! !!OutgoingMessageExchange methodsFor: 'as yet unclassified' stamp: 'crl 10/10/2016 22:49'!forward: payload over: aTether	tether := aTether.	process := Processor activeProcess.	message := payload.	"Register myself with the session for the convenience of human debuggers."	^[		tether addPendingOutgoingExchange: self.		self validateResult: queue next	]		ensure: [tether removePendingOutgoingExchange: self]! !!OutgoingMessageExchange methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2016 01:09'!initialize	"Initialize myself."	id := UUID new.	queue := SharedQueue new! !!OutgoingMessageExchange methodsFor: 'as yet unclassified' stamp: 'crl 10/10/2016 21:40'!printOn: stream	super printOn: stream.	stream		nextPutAll: ' of #';		nextPutAll: message selector! !!OutgoingMessageExchange methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 10:46'!storeOnTether: aTether
	aTether
		nextWordPut: MessageSendTag;
		store: message;
		nextWordPut: remoteIdentity;
		store: id! !!OutgoingMessageExchange methodsFor: 'as yet unclassified' stamp: 'crl 3/24/2019 21:14'!validateResult: result	| finalResult |		finalResult := result.		(finalResult recyclingHash = 0 and: [finalResult isKindOf: ExceptionMarker]) ifTrue: [		| remoteExceptionMarker suspendedContext bridgeContext oldPriority |		3 halt: 'about to open remote debugger'.		remoteExceptionMarker := finalResult remoteExceptionMarker.		suspendedContext := remoteExceptionMarker signalerContext.		bridgeContext := remoteExceptionMarker bridgeContext.		oldPriority := Processor activeProcess priority.		Processor activeProcess priority: Processor userSchedulingPriority.				RemoteDebugger			openContext: suspendedContext			inRemoteProcess: remoteExceptionMarker process			bridgeContext: bridgeContext			originalBridgeContextSender: (bridgeContext swapSender: thisContext sender sender sender sender sender sender sender)			label: remoteExceptionMarker label			contents: suspendedContext shortStack.				finalResult := queue next.		Processor activeProcess priority: oldPriority.].		^finalResult! !!OutgoingMessageExchange class methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2016 01:04'!forward: message for: remoteIdentity over: tether	"Forward message to the remote object corresponding to remoteIdentity, using tether's network connection."	^(self new)		forward: message		for: remoteIdentity		over: tether! !!ProjectViewOpenNotification class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!RemoteMessagingServiceInstructions methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!RemoteMessagingServiceInstructions class methodsFor: 'as yet unclassified' stamp: 'crl 8/31/2018 12:25'!dispatch: instruction  in: stream for: service	"Perform service's method corresponding to instruction."	| selector |		selector := classPool keyAtValue: instruction.	"Transcript cr; print: instruction; space; show: selector."	"ManagingSnowglobeMorph activeInstance logTimeOf: 'received ', selector."	service perform: selector with: stream! !!RemoteMessagingServiceInstructions class methodsFor: 'as yet unclassified' stamp: 'crl 7/20/2018 16:19'!initializeInstructions: instructions	classPool := Dictionary new.	instructions		inject: 1		into: [:runningValue :next | 			classPool at: next put: runningValue.			runningValue + 1]! !!TableLayoutProperties class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!MIDIEventAttribute methodsFor: 'as yet unclassified' stamp: 'crl 1/21/2003 10:17'!, aMagnitude	"Answer myself after applying aMagnitude."	^aMagnitude appliedTo: self! !!MIDIEventAttribute methodsFor: 'as yet unclassified' stamp: 'crl 1/24/2003 04:29'!= aMIDIEventAttribute	"Answer whether I am equivalent to aMIDIEventAttribute."	^self class == aMIDIEventAttribute class and: [index = aMIDIEventAttribute index]! !!MIDIEventAttribute methodsFor: 'as yet unclassified' stamp: 'crl 1/21/2003 09:57'!appliedTo: anObject	"Answer anObject, after applying myself to it."	^self subclassResponsibility! !!MIDIEventAttribute methodsFor: 'as yet unclassified' stamp: 'crl 1/24/2003 04:22'!hash	"Answer a hash which all objects equivalent to me share."	^self class hash + index hash! !!MIDIEventAttribute methodsFor: 'as yet unclassified' stamp: 'crl 1/21/2003 09:58'!index	"Answer my index."	^index! !!MIDIEventAttribute methodsFor: 'as yet unclassified' stamp: 'crl 1/21/2003 09:58'!index: anInteger	"Set my index to anInteger."	index _ anInteger! !!MIDIEventAttribute methodsFor: 'as yet unclassified' stamp: 'crl 1/21/2003 10:00'!name	"Answer a String describing me in general."	^self subclassResponsibility! !!MIDIEventAttribute methodsFor: 'as yet unclassified' stamp: 'crl 1/21/2003 10:10'!printOn: aStream	"Print a textual representation of myself on aStream."	aStream		nextPutAll: 'the ';		print: (index)th;		space;		nextPutAll: self name! !!MIDIEventAttribute class methodsFor: 'as yet unclassified' stamp: 'crl 1/21/2003 10:02'!at: anInteger	"Answer an instance of myself corresponding to anInteger."	^self new index: anInteger! !!JSDialogBoxMorph methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSDialogBoxMorph class methodsFor: 'as yet unclassified' stamp: 'crl 5/26/2017 11:23'!askYesNoQuestion: question entitled: title	^(self new)		askYesNo: title		with: question		with: MorphicJS world! !!JSDialogBoxMorph class methodsFor: 'as yet unclassified' stamp: 'crl 5/26/2017 11:40'!askYesNoQuestion: question entitled: title then: action	^(self new)		at: #action put: action;		askYesNo: title		with: question		with: MorphicJS world! !!SnowglobeWebEntranceInstructions methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!SnowglobeWebEntranceInstructions class methodsFor: 'as yet unclassified' stamp: 'crl 2/20/2019 13:20'!initialize	incomingEvent := 2r0000.	outgoingEvent := 2r0001.	connectWebsocket := 2r0010.	setOnMessageHandler := 2r0011.	send := 2r0110.	rightButtonEvent := 2r0111! !!EndOfStream class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!FunctionExpression methodsFor: 'as yet unclassified' stamp: 'crl 6/19/2017 13:14'!printSmalltalkOn: stream	stream nextPut: $[.			self params ifNotEmpty: [		self params do: [:parameter |			stream nextPut: $:.			parameter printSmalltalkOn: stream.			stream space].					stream nextPutAll: '| '].		body printSmalltalkOn: stream.	stream nextPut: $]! !!FunctionExpression class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!ToolIcons methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!AAnimation methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!AAnimation class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!Boolean methodsFor: 'as yet unclassified' stamp: 'crl 7/23/2017 14:16'!asChromeRemoteCallArgument	^{#value -> self}! !!Boolean methodsFor: 'as yet unclassified' stamp: 'bf 11/25/2014 18:12'!asJSArgument	"converted to JS true/false by plugin"	^self! !!Boolean methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 20:05'!simplifiedForJSON	"Answer a literal populated with my contents, suitable for JSON encoding."	^self! !!Boolean methodsFor: 'as yet unclassified' stamp: 'crl 5/20/2018 23:22'!storeOnTether: tether
	self subclassResponsibility! !!Boolean methodsFor: 'as yet unclassified' stamp: 'cmm 11/4/2013 20:52'!veryDeepCopy	"Overridden for performance to avoid #fixDependents."	^ self! !!Boolean methodsFor: 'as yet unclassified' stamp: 'crl 8/20/2017 13:45'!yourselfIfTrueDoFirst: aBlockClosure	^self subclassResponsibility! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/28/2000 16:49'!browseContext	selectedContext		ifNil: [^ self].	Browser newOnClass: self selectedClass selector: self selectedSelector!]style[(13 30 4 4 7 42 4 17)f1b,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'ar 2/11/2005 20:38'!buildWith: builder	"Create a pluggable version of me, answer a window"	| windowSpec listSpec textSpec |	windowSpec := builder pluggableWindowSpec new.	windowSpec model: self.	windowSpec label: 'Process Browser'.	windowSpec children: OrderedCollection new.	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		list: #processNameList; 		getIndex: #processListIndex; 		setIndex: #processListIndex:; 		menu: #processListMenu:; 		keyPress: #processListKey:from:;		frame: (0 @ 0 extent: 0.5 @ 0.5).	windowSpec children add: listSpec.	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		list: #stackNameList; 		getIndex: #stackListIndex; 		setIndex: #stackListIndex:; 		menu: #stackListMenu:; 		keyPress: #stackListKey:from:;		frame: (0.5 @ 0.0 extent: 0.5 @ 0.5).	windowSpec children add: listSpec.	textSpec := builder pluggableTextSpec new.	textSpec 		model: self;		getText: #selectedMethod; 		setText: nil; 		selection: nil; 		menu: nil;		frame: (0 @ 0.5 corner: 1 @ 1).	windowSpec children add: textSpec.	^builder build: windowSpec! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'rbb 3/1/2005 11:07'!changePriority	| str newPriority nameAndRules |	nameAndRules := self nameAndRulesForSelectedProcess.	nameAndRules third		ifFalse: [self inform: 'Nope, won''t change priority of ' , nameAndRules first.			^ self].	str := UIManager default 				request: 'New priority' 		  initialAnswer: selectedProcess priority asString.	newPriority := str asNumber asInteger.	newPriority		ifNil: [^ self].	(newPriority < 1			or: [newPriority > Processor highestPriority])		ifTrue: [self inform: 'Bad priority'.			^ self].	self class setProcess: selectedProcess toPriority: newPriority.	self updateProcessList! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'RAA 10/27/2000 15:21'!changeStackListTo: aCollection         stackList := aCollection.        self changed: #stackNameList.        self stackListIndex: 0! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/29/2000 10:18'!chasePointers	| saved |	selectedProcess		ifNil: [^ self].	saved := selectedProcess.	[selectedProcess := nil.	(Smalltalk includesKey: #PointerFinder)		ifTrue: [PointerFinder on: saved]		ifFalse: [self inspectPointers]]		ensure: [selectedProcess := saved]! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'sd 11/20/2005 21:27'!debugProcess	| nameAndRules |	nameAndRules := self nameAndRulesForSelectedProcess.	nameAndRules third		ifFalse: [self inform: 'Nope, won''t debug ' , nameAndRules first.			^ self].	self class debugProcess: selectedProcess.! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/27/2000 09:28'!exploreContext	selectedContext explore! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/27/2000 09:24'!exploreProcess	selectedProcess explore! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/27/2000 09:41'!exploreReceiver	selectedContext ifNotNil: [ selectedContext receiver explore ]! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'rbb 3/1/2005 11:08'!findContext	| initialProcessIndex initialStackIndex found |	initialProcessIndex := self processListIndex.	initialStackIndex := self stackListIndex.	searchString := UIManager default 			request: 'Enter a string to search for in the process stack lists'	  initialAnswer: searchString.	searchString isEmpty		ifTrue: [^ false].	self processListIndex: 1.	self stackListIndex: 1.	found := self nextContext.	found		ifFalse: [self processListIndex: initialProcessIndex.			self stackListIndex: initialStackIndex].	^ found! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/28/2000 11:44'!hasView	^self dependents isEmptyOrNil not! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2019 20:59'!initialExtent	^894@535! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'fbs 12/31/2013 14:03'!initialize	methodText := ''.	stackListIndex := 0.	searchString := ''.	lastUpdate := 0.	startedCPUWatcher := CPUWatcher cpuWatcherEnabled and: [ self startCPUWatcher ].	self updateProcessList; processListIndex: 1.	Browsers add: self! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 7/8/2000 20:23'!inspectContext	selectedContext inspect! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'crl 9/10/2017 21:19'!inspectPointers	| tc pointers |	selectedProcess ifNil: [^self].	tc := thisContext.	pointers := PointerFinder pointersTo: selectedProcess				except: { 						self processList.						tc.						self}.	pointers isEmpty ifTrue: [^self].	OrderedCollectionInspector 		openOn: pointers		withLabel: 'Objects pointing to ' , selectedProcess browserPrintString! !!ProcessBrowser methodsFor: 'as yet unclassified'!inspectProcess	selectedProcess inspect! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/27/2000 09:41'!inspectReceiver	selectedContext		ifNotNil: [selectedContext receiver inspect]! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/28/2000 21:48'!isAutoUpdating	^autoUpdateProcess notNil and: [ autoUpdateProcess isSuspended  not ]! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 6/18/2003 07:20'!isAutoUpdatingPaused	^autoUpdateProcess notNil and: [ autoUpdateProcess isSuspended ]! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'rbb 3/1/2005 11:08'!messageTally	| secString secs |	secString := UIManager default request: 'Profile for how many seconds?' initialAnswer: '4'.	secs := secString asNumber asInteger.	(secs isNil			or: [secs isZero])		ifTrue: [^ self].	[ TimeProfileBrowser spyOnProcess: selectedProcess forMilliseconds: secs * 1000 ] forkAt: selectedProcess priority + 1.! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/28/2000 12:13'!moreStack	self updateStackList: 2000! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 3/8/2001 13:35'!nameAndRulesFor: aProcess 	"Answer a nickname and two flags: allow-stop, and allow-debug"	aProcess == autoUpdateProcess ifTrue: [ ^{'my auto-update process'. true. true} ].	^self class nameAndRulesFor: aProcess ! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/28/2000 20:31'!nameAndRulesForSelectedProcess	"Answer a nickname and two flags: allow-stop, and allow-debug"	^self nameAndRulesFor: selectedProcess! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nice 2/8/2010 09:03'!nextContext	| initialProcessIndex initialStackIndex |	searchString isEmpty ifTrue: [ ^false ].	initialProcessIndex := self processListIndex.	initialStackIndex := self stackListIndex.	initialProcessIndex		to: self processList size		do: [:pi | self processListIndex: pi.					self stackNameList						withIndexDo: [:name :si | (pi ~= initialProcessIndex											or: [si > initialStackIndex])								ifTrue: [(name includesSubString: searchString)										ifTrue: [self stackListIndex: si.											^true]]]].	self processListIndex: initialProcessIndex.	self stackListIndex: initialStackIndex.	^ false! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/28/2000 08:19'!notify: errorString at: location in: aStream 	"A syntax error happened when I was trying to highlight my pc. 	Raise a signal so that it can be ignored."	Warning signal: 'syntax error'!]style[(8 11 5 8 5 7 3 107 2 7 23)f1b,f1cblack;b,f1b,f1cblack;b,f1b,f1cblack;b,f1,f1c137035000,f1,f1cblack;,f1! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 6/18/2003 07:20'!pauseAutoUpdate	self isAutoUpdating		ifTrue: [ autoUpdateProcess suspend ].	self updateProcessList! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 12:51'!pcRange	"Answer the indices in the source code for the method corresponding to  	the selected context's program counter value."	(selectedContext isNil or: [methodText isEmptyOrNil])		ifTrue: [^ 1 to: 0].	^selectedContext debuggerMap		rangeForPC: (selectedContext pc ifNotNil: [:pc| pc] ifNil: [selectedContext method endPC])		contextIsActiveContext: stackListIndex = 1! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/28/2000 20:53'!perform: selector orSendTo: otherTarget 	"Selector was just chosen from a menu by a user. If can respond, then  	perform it on myself. If not, send it to otherTarget, presumably the  	editPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ super perform: selector orSendTo: otherTarget]! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 6/30/2004 07:00'!prettyNameForProcess: aProcess 	| nameAndRules |	aProcess ifNil: [ ^'<nil>' ].	nameAndRules := self nameAndRulesFor: aProcess.	^ aProcess browserPrintStringWith: nameAndRules first! !!ProcessBrowser methodsFor: 'as yet unclassified'!processList	^ processList! !!ProcessBrowser methodsFor: 'as yet unclassified'!processListIndex	^ processListIndex! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'sd 11/20/2005 21:27'!processListIndex: index 	processListIndex := index.	selectedProcess := processList				at: index				ifAbsent: [].	self updateStackList.	self changed: #processListIndex.! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/29/2000 10:20'!processListKey: aKey from: aView 	^ aKey caseOf: {		[$i] -> [self inspectProcess].		[$I] -> [self exploreProcess].		[$c] -> [self chasePointers].		[$P] -> [self inspectPointers].		[$t] -> [self terminateProcess].		[$r] -> [self resumeProcess].		[$s] -> [self suspendProcess].		[$d] -> [self debugProcess].		[$p] -> [self changePriority].		[$m] -> [self messageTally].		[$f] -> [self findContext].		[$g] -> [self nextContext].		[$a] -> [self toggleAutoUpdate].		[$u] -> [self updateProcessList].		[$S] -> [self signalSemaphore].		[$k] -> [self moreStack]}		 otherwise: [self arrowKey: aKey from: aView]! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'LC 1/7/2002 16:35'!processListMenu: menu 	| pw |	selectedProcess		ifNotNil: [| nameAndRules | 			nameAndRules := self nameAndRulesForSelectedProcess.			menu addList: {{'inspect (i)'. #inspectProcess}. {'explore (I)'. #exploreProcess}. {'inspect Pointers (P)'. #inspectPointers}}.	(Smalltalk includesKey: #PointerFinder)		ifTrue: [ menu add: 'chase pointers (c)' action: #chasePointers.  ].			nameAndRules second				ifTrue: [menu add: 'terminate (t)' action: #terminateProcess.					selectedProcess isSuspended						ifTrue: [menu add: 'resume (r)' action: #resumeProcess]						ifFalse: [menu add: 'suspend (s)' action: #suspendProcess]].			nameAndRules third				ifTrue: [menu addList: {{'change priority (p)'. #changePriority}. {'debug (d)'. #debugProcess}}].			menu addList: {{'profile messages (m)'. #messageTally}}.			(selectedProcess suspendingList isKindOf: Semaphore)				ifTrue: [menu add: 'signal Semaphore (S)' action: #signalSemaphore].			menu add: 'full stack (k)' action: #moreStack.			menu addLine].	menu addList: {{'find context... (f)'. #findContext}. {'find again (g)'. #nextContext}}.	menu addLine.	menu		add: (self isAutoUpdating				ifTrue: ['turn off auto-update (a)']				ifFalse: ['turn on auto-update (a)'])		action: #toggleAutoUpdate.	menu add: 'update list (u)' action: #updateProcessList.	pw := Smalltalk at: #CPUWatcher ifAbsent: [].	pw ifNotNil: [		menu addLine.		pw isMonitoring				ifTrue: [ menu add: 'stop CPUWatcher' action: #stopCPUWatcher ]				ifFalse: [ menu add: 'start CPUWatcher' action: #startCPUWatcher  ]	].	^ menu! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 6/21/2004 09:59'!processNameList	"since processList is a WeakArray, we have to strengthen the result"	| pw tally |	pw := Smalltalk at: #CPUWatcher ifAbsent: [ ].	tally := pw ifNotNil: [ pw current ifNotNil: [ pw current tally ] ].	^ (processList asOrderedCollection		copyWithout: nil)		collect: [:each | | percent |			percent := tally				ifNotNil: [ ((((tally occurrencesOf: each) * 100.0 / tally size) roundTo: 1)						asString padded: #left to: 2 with: $ ), '% '  ]				ifNil: [ '' ].			percent, (self prettyNameForProcess: each)		] ! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 3/8/2001 13:23'!resumeProcess	selectedProcess		ifNil: [^ self].	self class resumeProcess: selectedProcess.	self updateProcessList! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'md 2/17/2006 09:32'!selectedClass	"Answer the class in which the currently selected context's method was  	found."	^ selectedClass		ifNil: [selectedClass := selectedContext receiver				ifNil: [selectedSelector := selectedContext method selector.					   selectedContext method methodClass]				ifNotNil: [selectedContext methodClass]]! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 2/16/2001 13:39'!selectedMethod	^ methodText ifNil: [methodText := selectedContext						ifNil: ['']						ifNotNil: [| pcRange | 							methodText := [ selectedContext sourceCode ]								ifError: [ :err :rcvr | 'error getting method text' ].							pcRange := self pcRange.							methodText asText								addAttribute: TextColor red								from: pcRange first								to: pcRange last;																addAttribute: TextEmphasis bold								from: pcRange first								to: pcRange last]]! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'md 2/17/2006 12:07'!selectedSelector	"Answer the class in which the currently selected context's method was  	found."	^ selectedSelector		ifNil: [selectedSelector := selectedContext receiver				ifNil: [selectedClass := selectedContext method methodClass					   selectedContext method selector]				ifNotNil: [selectedContext selector]]! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nice 2/8/2010 09:04'!setUpdateCallbackAfter: seconds 	[(Delay forSeconds: seconds) wait.	Project current addDeferredUIMessage: [self updateProcessList]] fork! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/29/2000 09:58'!signalSemaphore	(selectedProcess suspendingList isKindOf: Semaphore)		ifFalse: [^ self].	[selectedProcess suspendingList signal] fork.	(Delay forMilliseconds: 300) wait.	"Hate to make the UI wait, but it's convenient..."	self updateProcessList! !!ProcessBrowser methodsFor: 'as yet unclassified'!stackList	^ stackList! !!ProcessBrowser methodsFor: 'as yet unclassified'!stackListIndex	^ stackListIndex! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'eem 6/12/2008 12:41'!stackListIndex: index 	stackListIndex := index.	selectedContext := (stackList notNil						and: [index > 0]) ifTrue:							[stackList at: index ifAbsent: []].	selectedClass := nil.	selectedSelector := nil.	methodText := nil.	self changed: #stackListIndex.	self changed: #selectedMethod! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/28/2000 16:53'!stackListKey: aKey from: aView 	^ aKey caseOf: {		[$c] -> [self inspectContext].		[$C] -> [self exploreContext].		[$i] -> [self inspectReceiver].		[$I] -> [self exploreReceiver].		[$b] -> [self browseContext]}		 otherwise: [self arrowKey: aKey from: aView]! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/28/2000 16:53'!stackListMenu: aMenu 	| menu |	selectedContext		ifNil: [^ aMenu].	menu := aMenu				labels: 'inspect context (c)explore context (C)inspect receiver (i)explore receiver (I)browse (b)'				lines: #(2 4 )				selections: #(#inspectContext #exploreContext #inspectReceiver #exploreReceiver #browseContext ).	^ menu! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/28/2000 16:18'!stackNameList	^ stackList		ifNil: [#()]		ifNotNil: [stackList				collect: [:each | each asString]]! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'dtl 9/23/2009 20:36'!startAutoUpdate	self isAutoUpdatingPaused		ifTrue: [^ autoUpdateProcess resume].	self isAutoUpdating		ifFalse: [autoUpdateProcess := [[self hasView]						whileTrue: [(Delay forSeconds: 2) wait.							Project current addDeferredUIMessage: [self updateProcessList]].					autoUpdateProcess := nil] fork].	self updateProcessList! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 3/14/2001 09:26'!startCPUWatcher	"Answers whether I started the CPUWatcher"	| pw |	pw := Smalltalk at: #CPUWatcher ifAbsent: [ ^self ].	pw ifNotNil: [		pw isMonitoring ifFalse: [			pw startMonitoringPeriod: 5 rate: 100 threshold: 0.85.			self setUpdateCallbackAfter: 7.			^true		]	].	^false! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 6/18/2003 07:22'!stopAutoUpdate	autoUpdateProcess ifNotNil: [		autoUpdateProcess terminate.		autoUpdateProcess := nil].	self updateProcessList! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 3/14/2001 09:26'!stopCPUWatcher	| pw |	pw := Smalltalk at: #CPUWatcher ifAbsent: [ ^self ].	pw ifNotNil: [		pw stopMonitoring.		self updateProcessList.		startedCPUWatcher := false.	"so a manual restart won't be killed later"	]! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'sd 11/20/2005 21:27'!suspendProcess	| nameAndRules |	selectedProcess isSuspended		ifTrue: [^ self].	nameAndRules := self nameAndRulesForSelectedProcess.	nameAndRules second		ifFalse: [self inform: 'Nope, won''t suspend ' , nameAndRules first.			^ self].	self class suspendProcess: selectedProcess.	self updateProcessList! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'sd 11/20/2005 21:27'!terminateProcess	| nameAndRules |	nameAndRules := self nameAndRulesForSelectedProcess.	nameAndRules second		ifFalse: [self inform: 'Nope, won''t kill ' , nameAndRules first.			^ self].	self class terminateProcess: selectedProcess.		self updateProcessList! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/28/2000 08:36'!text	^methodText! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/28/2000 21:50'!toggleAutoUpdate	self isAutoUpdating		ifTrue: [ self stopAutoUpdate ]		ifFalse: [ self startAutoUpdate ].! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'ajh 7/21/2003 10:11'!updateProcessList	| oldSelectedProcess newIndex now |	now := Time millisecondClockValue.	now - lastUpdate < 500		ifTrue: [^ self].	"Don't update too fast"	lastUpdate := now.	oldSelectedProcess := selectedProcess.	processList := selectedProcess := selectedSelector := nil.	Smalltalk garbageCollectMost.	"lose defunct processes"	processList := Process allSubInstances				reject: [:each | each isTerminated].	processList := processList				sortBy: [:a :b | a priority >= b priority].	processList := WeakArray withAll: processList.	newIndex := processList				indexOf: oldSelectedProcess				ifAbsent: [0].	self changed: #processNameList.	self processListIndex: newIndex! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 7/8/2000 20:24'!updateStackList	self updateStackList: 20! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/28/2000 09:00'!updateStackList: depth 	| suspendedContext oldHighlight |	selectedProcess		ifNil: [^ self changeStackListTo: nil].	(stackList notNil and: [ stackListIndex > 0 ])		ifTrue: [oldHighlight := stackList at: stackListIndex].	selectedProcess == Processor activeProcess		ifTrue: [self				changeStackListTo: (thisContext stackOfSize: depth)]		ifFalse: [suspendedContext := selectedProcess suspendedContext.			suspendedContext				ifNil: [self changeStackListTo: nil]				ifNotNil: [self						changeStackListTo: (suspendedContext stackOfSize: depth)]].	self		stackListIndex: (stackList				ifNil: [0]				ifNotNil: [stackList indexOf: oldHighlight])! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 10/29/2000 08:56'!wasProcessSuspendedByProcessBrowser: aProcess	^self class suspendedProcesses includesKey: aProcess! !!ProcessBrowser methodsFor: 'as yet unclassified' stamp: 'nk 3/14/2001 08:03'!windowIsClosing	startedCPUWatcher ifTrue: [ CPUWatcher stopMonitoring ]! !!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'mtf 1/12/2011 19:34'!cleanUp"Remove terminated processes from my suspended list"	self suspendedProcesses keys do: [:ea |		ea isTerminated ifTrue: [self suspendedProcesses removeKey: ea]]! !!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'bf 1/11/2013 15:14'!debugProcess: aProcess	aProcess debugWithTitle: 'Interrupted from the Process Browser'.! !!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'nk 3/14/2001 08:59'!dumpTallyOnTranscript: tally	"tally is from ProcessorScheduler>>tallyCPUUsageFor:	Dumps lines with percentage of time, hash of process, and a friendly name"	tally sortedCounts do: [ :assoc | | procName |		procName := (self nameAndRulesFor: assoc value) first.		Transcript print: (((assoc key / tally size) * 100.0) roundTo: 1);			nextPutAll: '%   ';			print: assoc value identityHash; space;			nextPutAll: procName;			cr.	].	Transcript flush.! !!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'sd 11/20/2005 21:28'!initialize	"ProcessBrowser initialize"	Browsers ifNil: [ Browsers := WeakSet new ].	SuspendedProcesses ifNil: [ SuspendedProcesses := IdentityDictionary new ].	Smalltalk addToStartUpList: self.	Smalltalk addToShutDownList: self.	self registerInFlapsRegistry.	self registerWellKnownProcesses! !!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'dtl 2/27/2010 11:05'!isUIProcess: aProcess	^aProcess == Project uiProcess! !!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'dtl 2/5/2005 01:21'!nameAndRulesFor: aProcess 	"Answer a nickname and two flags: allow-stop, and allow-debug"	^ [aProcess caseOf: WellKnownProcesses		 otherwise: 			[(aProcess priority = Processor timingPriority					and: [aProcess suspendedContext receiver == Delay])				ifTrue: [{'the timer interrupt watcher'. false. false}]				ifFalse: [{aProcess suspendedContext asString. true. true}]]]		ifError: [:err :rcvr | {aProcess suspendedContext asString. true. true}]! !!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'ar 8/7/2009 22:23'!open	"ProcessBrowser open"	"Create and schedule a ProcessBrowser."	Smalltalk garbageCollect.	^ToolBuilder open: self new! !!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'fbs 3/8/2013 08:33'!prototypicalToolWindow	"Answer a window representing a prototypical instance of the receiver"	^ ToolBuilder build: self new! !!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 14:54'!registerInFlapsRegistry! !!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'dtl 2/5/2005 09:07'!registerWellKnownProcess: aBlockForProcess label: nickname allowStop: allowStop allowDebug: allowDebug	"Add an entry to the registry of well known processes. aBlockForProcess	evaluates to a known process to be identified by nickname, and allowStop	and allowDebug are flags controlling allowable actions for this process	in the browser."	WellKnownProcesses add: aBlockForProcess->[{nickname . allowStop . allowDebug}]! !!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'sd 11/20/2005 21:28'!registerWellKnownProcesses	"Associate each well-known process with a nickname and two flags: allow-stop, and allow-debug.	Additional processes may be added to this list as required"	WellKnownProcesses := OrderedCollection new.	self registerWellKnownProcess: []		label: 'no process'		allowStop: false		allowDebug: false.	self registerWellKnownProcess: [Smalltalk lowSpaceWatcherProcess]		label: 'the low space watcher'		allowStop: false		allowDebug: false.	self registerWellKnownProcess: [WeakArray runningFinalizationProcess]		label: 'the WeakArray finalization process'		allowStop: false		allowDebug: false.	self registerWellKnownProcess: [Processor activeProcess]		label: 'the UI process'		allowStop: false		allowDebug: true.	self registerWellKnownProcess: [Processor backgroundProcess]		label: 'the idle process'		allowStop: false		allowDebug: false.	self registerWellKnownProcess: [Sensor interruptWatcherProcess]		label: 'the user interrupt watcher'		allowStop: false		allowDebug: false.	self registerWellKnownProcess: [Sensor eventTicklerProcess]		label: 'the event tickler'		allowStop: false		allowDebug: false.	self registerWellKnownProcess: [Project uiProcess]		label: 'the inactive Morphic UI process'		allowStop: false		allowDebug: false.	self registerWellKnownProcess:			[Smalltalk at: #SoundPlayer ifPresent: [:sp | sp playerProcess]]		label: 'the Sound Player'		allowStop: false		allowDebug: false.	self registerWellKnownProcess:			[ScheduledControllers ifNotNil: [ScheduledControllers activeControllerProcess]]		label: 'the inactive MVC controller process'		allowStop: false		allowDebug: true.	self registerWellKnownProcess:			[Smalltalk at: #CPUWatcher ifPresent: [:cw | cw currentWatcherProcess]]		label: 'the CPUWatcher'		allowStop: false		allowDebug: false! !!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'nk 2/12/2002 10:09'!resumeProcess: aProcess	| priority |	priority := self suspendedProcesses				removeKey: aProcess				ifAbsent: [aProcess priority].	aProcess priority: priority.	aProcess suspendedContext ifNotNil: [ aProcess resume ]! !!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'nk 3/8/2001 17:07'!setProcess: aProcess toPriority: priority	| oldPriority |	oldPriority := self suspendedProcesses at: aProcess ifAbsent: [ ].	oldPriority ifNotNil: [ self suspendedProcesses at: aProcess put: priority ].	aProcess priority: priority.	^oldPriority! !!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'nk 6/18/2003 07:32'!shutDown	Browsers do: [ :ea | ea isAutoUpdating ifTrue: [ ea pauseAutoUpdate ]]! !!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'dtl 8/27/2012 18:44'!startUp	Browsers		do: [:ea | ea isAutoUpdatingPaused				ifTrue: [ea initialize; startAutoUpdate]				ifFalse: [ea initialize]]! !!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'dew 9/16/2001 01:53'!suspendProcess: aProcess	| priority |	priority := aProcess priority.	self suspendedProcesses at: aProcess put: priority.	"Need to take the priority down below the caller's	so that it can keep control after signaling the Semaphore"	(aProcess suspendingList isKindOf: Semaphore)		ifTrue: [aProcess priority: Processor lowestPriority.			aProcess suspendingList signal].	[aProcess suspend]		on: Error		do: [:ex | self suspendedProcesses removeKey: aProcess].	aProcess priority: priority.! !!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'nk 10/29/2000 08:55'!suspendedProcesses	"Answer a collection of processes that my instances have suspended.  	This is so that they don't get garbage collected."	^ SuspendedProcesses		ifNil: [SuspendedProcesses := IdentityDictionary new]! !!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'nk 3/8/2001 12:49'!tallyCPUUsageFor: seconds	"Compute CPU usage using a 10-msec sample for the given number of seconds,	then dump the usage statistics on the Transcript. The UI is free to continue, meanwhile"	"ProcessBrowser tallyCPUUsageFor: 10"	^self tallyCPUUsageFor: seconds every: 10! !!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'dtl 9/23/2009 20:36'!tallyCPUUsageFor: seconds every: msec	"Compute CPU usage using a msec millisecond sample for the given number of seconds,	then dump the usage statistics on the Transcript. The UI is free to continue, meanwhile"	"ProcessBrowser tallyCPUUsageFor: 10 every: 100"	| promise |	promise := Processor tallyCPUUsageFor: seconds every: msec.	[ | tally |		tally := promise value.		Smalltalk isMorphic			ifTrue: [ Project current addDeferredUIMessage: [ self dumpTallyOnTranscript: tally ] ]			ifFalse: [ [ Transcript open ] forkAt: Processor userSchedulingPriority.					[ (Delay forSeconds: 1) wait.					self dumpTallyOnTranscript: tally ] forkAt: Processor userSchedulingPriority.]	] fork.! !!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'nk 3/8/2001 13:25'!terminateProcess: aProcess	aProcess ifNotNil: [		self suspendedProcesses			removeKey: aProcess			ifAbsent: [].		aProcess terminate	].! !!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'asm 4/11/2003 12:39'!unload	"Unload the receiver from global registries"	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'sd 11/20/2005 21:28'!unregisterWellKnownProcess: aProcess	"Remove the first registry entry that matches aProcess. Use	with caution if more than one registry entry may match aProcess."	"self unregisterWellKnownProcess: Smalltalk lowSpaceWatcherProcess"	| entry |	entry := WellKnownProcesses		detect: [:e | e key value == aProcess]		ifNone: [^ self].	WellKnownProcesses remove: entry! !!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'nk 3/8/2001 13:26'!wasProcessSuspendedByProcessBrowser: aProcess	^self suspendedProcesses includesKey: aProcess! !!XMLNamespace methodsFor: 'as yet unclassified' stamp: 'crl 6/2/2011 00:38'!name	^name! !!XMLNamespace methodsFor: 'as yet unclassified' stamp: 'crl 6/2/2011 00:37'!name: aString specification: anotherString	name _ aString.	specification _ anotherString! !!XMLNamespace methodsFor: 'as yet unclassified' stamp: 'crl 6/4/2011 12:04'!printOn: aStream	"Write a textual description of myself on aStream."	aStream		nextPutAll: 'xmlns:';		nextPutAll: name;		nextPutAll: '="';		nextPutAll: specification;		nextPut: $"! !!XMLNamespace methodsFor: 'as yet unclassified' stamp: 'crl 6/2/2011 02:20'!specification	^specification! !!XMLNamespace class methodsFor: 'as yet unclassified' stamp: 'crl 6/2/2011 00:37'!named: namespaceName specifiedBy: specificationName	^(self new)		name: namespaceName		specification: specificationName! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 7/20/2010 20:07'!decodeMultipartForm: aStream boundary: boundary do: aBlock	"Parse the contents of a multipart/form-data submission.	Evaluate aBlock with three parts: The headers, the (parsed) form-data	arguments and the (undecoded) contents of the part. The sender is	expected to take care of other issues such as content-transfer-encoding	and similar headers."	| skip headers content disposition index params |	aStream upToAll: '--', boundary.	[aStream atEnd or:[(skip := aStream next: 2) = '--']] whileFalse:[		skip = String crlf ifFalse:[self error: 'Error decoding multipart/form-data fields'].		headers := Dictionary new.		(WebUtils readHeadersFrom: aStream) do:[:hdr| headers add: hdr].		content := aStream upToAll: String crlf, '--', boundary.		params := Dictionary new.		disposition := headers at: 'content-disposition' ifAbsent:[''].		#(name filename) do:[:arg| | len val |			len := arg size + 2.			index := disposition findString: arg,'='.			index > 0 ifTrue:[				val := disposition copyFrom: index + len to: (disposition indexOf: $" startingAt: index+len) - 1.				params at: arg put: val.			].		].		aBlock value: headers value: params value: content.	].! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 2/21/2010 09:54'!decodeUrlEncodedForm: aString	"Decodes the fields embedded in the url ?var1=val1&var2=val2"	^self decodeUrlEncodedForm: aString multipleValues: false! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 7/20/2010 20:37'!decodeUrlEncodedForm: aString do: aBlock	"Decodes the fields embedded in the url ?var1=val1&var2=val2.	Evaluates aBlock with the key/value pairs defined in the fields."	| args keyval index key value |	args := aString readStream.	[args atEnd] whileFalse:[		keyval := args upTo: $&.		(index := keyval indexOf: $=) = 0 ifTrue:[			key := keyval.			value := ''.		] ifFalse:[			key := keyval copyFrom: 1 to: index-1.			value := keyval copyFrom: index +1 to: keyval size.		].		key := key unescapePercentsWithTextEncoding: nil.		value := value unescapePercentsWithTextEncoding: nil.		aBlock value: key value: value.	].! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 7/20/2010 20:37'!decodeUrlEncodedForm: aString multipleValues: aBool	"Decodes the fields embedded in the url ?var1=val1&var2=val2"	| fields |	fields := Dictionary new.	self decodeUrlEncodedForm: aString do:[:key :value|		aBool 			ifTrue:[fields at: key put: (fields at: key ifAbsent:['']), value]			ifFalse:[fields at: key put: value].	].	^fields! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'klub 4/22/2013 14:53'!decodeUrlEncodedForm: aString multipleValues: aBool withConverter: aTextConverter	"Decodes the fields embedded in the url ?var1=val1&var2=val2"	| fields |	fields := Dictionary new.	self decodeUrlEncodedForm: aString do:[:key :value|		aBool 			ifTrue:[				fields 					at: key 					put: (fields at: key ifAbsent:['']), (value convertFromWithConverter: aTextConverter) ]			ifFalse:[				fields 					at: key 					put: (value convertFromWithConverter: aTextConverter) ].	].	^fields! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 5/10/2010 09:30'!defaultProxyServer	"Answer the default proxy server to use."	HTTPSocket httpProxyServer isEmptyOrNil ifTrue:[^''].	"Note: This is a hack since HTTPSocket is too specific for our use here."	HTTPSocket httpProxyPort = 80 ifTrue:[		"Assumes that port 80 means 'use default'"		^HTTPSocket httpProxyServer ifNil:['']	] ifFalse:[		^HTTPSocket httpProxyServer, ':', HTTPSocket httpProxyPort	].! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 1/17/2011 22:16'!encodeMultipartForm: fieldMap boundary: boundary	"Encodes the fieldMap as multipart/form-data.	The fieldMap may contain MIMEDocument instances to indicate the presence	of a file to upload to the server. If the MIMEDocument is present, its	content type and file name will be used for the upload.	The fieldMap can be EITHER an array of associations OR a Dictionary of 	key value pairs (the former is useful for providing multiple fields and/or 	specifying the order of fields)."	^String streamContents:[:stream|		(fieldMap as: Dictionary) keysAndValuesDo:[:fieldName :fieldValue | | fieldContent |			"Write multipart boundary and common headers"			stream nextPutAll: '--', boundary; crlf.			stream nextPutAll: 'Content-Disposition: form-data; name="', fieldName, '"'.			"Figure out if this is a file upload"			(fieldValue isKindOf: MIMEDocument) ifTrue:[				stream nextPutAll: ' filename="', fieldValue url pathForFile, '"'; crlf.				stream nextPutAll: 'Content-Type: ', fieldValue contentType.				fieldContent := (fieldValue content ifNil:[					(FileStream readOnlyFileNamed: fieldValue url pathForFile) contentsOfEntireFile.				]) asString.			] ifFalse: [fieldContent := fieldValue].			stream crlf; crlf.			stream nextPutAll: fieldContent asString.			stream crlf.		].		stream nextPutAll: '--', boundary, '--', String crlf.	].! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 6/1/2010 20:21'!encodeUrlEncodedForm: fieldMap	"Encodes the fieldsMap in the form of var1=val1&var2=val2.	The fieldMap can be EITHER an array of associations OR a Dictionary of 	key value pairs (the former is useful for providing multiple fields and/or 	specifying the order of fields)."	| associations |	associations := fieldMap isDictionary ifTrue:[fieldMap associations] ifFalse:[fieldMap].	^String streamContents:[:s|		associations do:[:assoc|			s nextPutAll: assoc key encodeForHTTP.			assoc value ifNotNil:[				s nextPutAll: '='.				s nextPutAll: assoc value asString encodeForHTTP			].		] separatedBy:[s nextPutAll:'&'].	].! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 7/20/2010 20:38'!extractWebSocketKey: field	"Decodes a WebSocket key:		Sec-WebSocket-Key1: 18x 6]8vM;54 *(5:  {   U1]8  z [  8		Sec-WebSocket-Key2: 1_ tx7X d  <  nw  334J702) 7]o}` 0		For each of these fields, the server has to take the digits from the		 value to obtain a number (in this case 1868545188 and 1733470270		respectively), then divide that number by the number of spaces		characters in the value (in this case 12 and 10) to obtain a 32-bit		number (155712099 and 173347027).  These two resulting numbers are		then used in the server handshake, as described below.	"	| digits spaces |	digits := spaces := 0.	field do:[:ch|		ch isDigit ifTrue:[digits := digits * 10 + ch digitValue].		ch = $ ifTrue:[spaces := spaces + 1].	].	^digits // spaces.! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 2/10/2012 13:53'!handleAuth: aBlock	"Utility method to handle web authentication requests interactively.	Use like here:		| wc |		wc := WebClient new.		WebUtils handleAuth:[wc httpGet: 'http://some.auth.required'].	"	| user pass |	^[aBlock value] on: WebAuthRequired do:[:ex|		"Allow outer handlers to take over authentication"		ex isNested ifFalse:[			user := UIManager default request:  ex message, 				'\Please enter your user name:' withCRs initialAnswer:''.			user ifNotEmpty:[				"Just a little obfuscation to avoid completely plain passwords"				pass := (UIManager default requestPassword:					'Please enter the password for "', user,'":') base64Encoded.				 ex username: user password: [pass base64Decoded]]].		ex pass].! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 8/12/2010 16:24'!hmacSha1: message key: signKey	"Compute the SHA1 HMAC for the given message"	| blockSize key ipad opad |	blockSize := 64. "SHA1 block size"	key := signKey asByteArray.	key size > blockSize ifTrue:[key := self sha1Hash: key].	key size < blockSize ifTrue:[key := key, (ByteArray new: blockSize - key size)].	ipad := ByteArray new: blockSize withAll: 16r36.	opad := ByteArray new: blockSize withAll: 16r5c.	^self sha1Hash: 		(key with: opad collect:[:b1 :b2| b1 bitXor: b2]), 		(self sha1Hash: (key with: ipad collect:[:b1 :b2| b1 bitXor: b2]), message)! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 2/10/2012 13:39'!jsonArray: anArray on: stream	"Encodes an array"	stream nextPut: $[.	anArray 		do:[:each| self jsonObj: each on: stream]		separatedBy:[stream nextPutAll:', '].	stream nextPut:$].! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 2/10/2012 13:43'!jsonArrayFrom: stream	"Decodes a JSON [value, *] array from the stream"	| ch result |	(ch := stream next) = $[ ifFalse:[^self error: 'JSON Array expected'].	stream skipSeparators.	stream peek = $] ifTrue:[stream next. ^#()].	result := WriteStream on: (Array new: 10).	["Decode the next value"	stream skipSeparators.	result nextPut: (self jsonDecode: stream).	stream skipSeparators.	(ch := stream next) = $]] whileFalse:[		ch = $, ifFalse:[^self error: 'Comma expected'].	].	^result contents! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 2/10/2012 13:39'!jsonChar: aCharacter on: stream	"Writes a single encoded character"	| ascii |	ascii := aCharacter asciiValue.	ascii < 32 ifTrue:["Control character"		ascii caseOf: {			[13]	-> [^stream nextPutAll: '\r'].			[12]	-> [^stream nextPutAll: '\f'].			[10]	-> [^stream nextPutAll: '\n'].			[9]		-> [^stream nextPutAll: '\t'].			[8]		-> [^stream nextPutAll: '\b'].		} otherwise:[			^stream nextPutAll: '\u'; nextPutAll: 				((ascii printStringBase: 16) padded: #left to: 4 with: $0)		].	].	(ascii >= 32 and:[ascii <=127]) ifTrue:["Ascii character"		(ascii = 34 or:[ascii = 92 or:[ascii = 47]]) ifTrue:[stream nextPut: $\].		^stream nextPut: aCharacter	].	"Encode other characters (control chars, accents, umlauts, unicode)"	stream nextPutAll:  		'\u', (((ascii bitAnd: 16rFFFF) printStringBase: 16) padded: #left to: 4 with: $0).! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 2/10/2012 13:46'!jsonCharFrom: stream	"Decodes a backslash-escaped character"	| ch |	^(ch := stream next) caseOf: {		[$u]		->	[Unicode value: 						(Integer readFrom: (stream next: 4) readStream base: 16)].		[$r] 	-> 	[Character cr].		[$n] 	-> 	[Character lf].		[$t] 	-> 	[Character tab].		[$b] 	->	[Character backspace].		[$f] 	->	[Character newPage].	} otherwise:[ch].! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 2/10/2012 13:48'!jsonDecode: stream	"Decodes an arbitrary JSON encoded value from the given stream"	stream skipSeparators.	^stream peek caseOf: {		[$"]		->	[self jsonStringFrom: stream].		[$t]		->	[self jsonTrueFrom: stream].		[$f]		->	[self jsonFalseFrom: stream].		[$n]		->	[self jsonNullFrom: stream].		[${]		-> 	[self jsonMapFrom: stream].		[$[]		->	[self jsonArrayFrom: stream].	} otherwise:[self jsonNumberFrom: stream].! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 2/10/2012 13:41'!jsonEncode: anObject	"Encode the given object as JSON"	^String streamContents:[:s| self jsonObj: anObject on: s]! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 2/10/2012 13:43'!jsonFalseFrom: stream	"Decodes 'false' from aStream"	((stream next: 5) = 'false' 		and:[stream atEnd or:[stream peek isAlphaNumeric not]]) 			ifFalse:[^self error: 'Expected ''false'''].	^false! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 2/10/2012 13:40'!jsonMap: aDictionary on: stream	"Encodes a dictionary"	stream nextPut: ${.	"Sorting keys ensures deterministic order"	aDictionary keys asArray sort do:[:key|		self jsonString: key on: stream.		stream nextPutAll:': '.		self jsonObj: (aDictionary at: key) on: stream.	] separatedBy:[stream nextPutAll: ', '].	stream nextPut: $}.! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 2/10/2012 13:45'!jsonMapFrom: stream	"Decodes a JSON {key:value, *} object from the stream"	| map ch key value |	map := Dictionary new.	(ch := stream next) = ${ ifFalse:[^self error: 'JSON Object expected'].	stream skipSeparators.	stream peek = $} ifTrue:[^map].	["Decode the next key:value pair"	stream skipSeparators.	key := self jsonStringFrom: stream.	stream skipSeparators.	stream next = $: ifFalse:[^self error: 'Key-value pair expected'].	value := self jsonDecode: stream.	map at: key put: value.	stream skipSeparators.	(ch := stream next) = $}] whileFalse:[		ch = $, ifFalse:[^self error: 'Comma expected'].	].	^map! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 2/10/2012 13:43'!jsonNullFrom: stream	"Decodes 'null' from aStream"	((stream next: 4) = 'null'		and:[stream atEnd or:[stream peek isAlphaNumeric not]]) 			ifFalse:[^self error: 'Expected ''null'''].	^nil! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 2/10/2012 13:38'!jsonNumber: aNumber on: stream	"Encodes a number"	| value |	value := aNumber.	value isInteger ifFalse:[value := aNumber asFloat].	stream print: aNumber.! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 2/10/2012 13:44'!jsonNumberFrom: stream	"Decodes a JSON number from the stream"	| ascii integer fraction scale sign expSign exponent value ch |	integer := fraction := 0. sign := scale := exponent := expSign := 1.	ascii := stream next asciiValue.	ascii = 45 "$- asciiValue" ifTrue:[		sign := -1.		ascii := stream next asciiValue.	].	"JSON requires at least one digit"	(ascii >= 48 and:[ascii <= 57]) ifFalse:[^self error: 'Digit expected'].	"Read the integer part"	integer := ascii - 48.	[ch := stream next ifNil:[^integer * sign].	ascii := ch asciiValue.	ascii >= 48 and:[ascii <= 57]] whileTrue:[		integer := (integer * 10) + (ascii - 48).	].	ascii = 46 "$. asciiValue" ifTrue:[		"Read the fraction part"		[ch := stream next ifNil:[^(integer * scale + fraction * sign) asFloat / scale].		ascii := ch asciiValue.		ascii >= 48 and:[ascii <= 57]] whileTrue:[			fraction := (fraction * 10) + (ascii - 48).			scale := scale * 10.		].		value := (integer * scale + fraction * sign) asFloat / scale asFloat.	] ifFalse:[value := integer * sign].	(ascii =  69 "$E asciiValue" or:[ascii =  101 "$e asciiValue"]) ifTrue:[		"Read exponent"		ascii := stream next asciiValue.		ascii = $- ifTrue:[			expSign := -1.			ascii := stream next asciiValue.		] ifFalse:[ascii = $+ ifTrue:[ascii := stream next asciiValue]].		exponent := ascii - 48.		[ch := stream next ifNil:[^value * (10 raisedTo: expSign * exponent)].		ascii := ch asciiValue.		ascii >= 48 and:[ascii <= 57]] whileTrue:[			exponent := (exponent * 10) + (ascii - 48).					].		exponent := exponent * expSign.	].	"Skip back before last character since number might be part of a sequence	like 1, 2, 3, 4, etc (which would eat the trailing comma)"	ch isAlphaNumeric ifTrue:[^self error: 'Delimiter expected'].	stream skip: -1.	exponent = 1 ifFalse:[		exponent < 0 ifTrue:[value := value asFloat].		value := value * (10 raisedTo: exponent).	].	^value! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'crl 7/8/2017 00:12'!jsonObj: anObject on: stream	"Encode a generic object"	anObject isString ifTrue:[^self jsonString: anObject on: stream].	anObject isNumber ifTrue:[^self jsonNumber: anObject on: stream].	anObject == nil ifTrue:[^stream nextPutAll: 'null'].	anObject == true ifTrue:[^stream nextPutAll: 'true'].	anObject == false ifTrue:[^stream nextPutAll: 'false'].	anObject isArray ifTrue:[^self jsonArray: anObject on: stream].	anObject isDictionary ifTrue:[^self jsonMap: anObject on: stream].	(anObject isKindOf: Collection) ifTrue: [		^self			jsonArray: (Array withAll: anObject)			on: stream].	self error: 'Cannot encode: ', anObject! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 2/10/2012 13:39'!jsonString: aString on: stream	"Encodes a string"	stream nextPut: $".	aString do:[:ch| self jsonChar: ch on: stream].	stream nextPut: $".! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 2/10/2012 13:46'!jsonStringFrom: stream	"Decodes a JSON encoded string"	| ch result |	(ch := stream next) = $" 		ifFalse:[^self error: 'String expected'].	result := WriteStream on: (String new: 20).	[(ch := stream next) == nil] whileFalse:[		ch = $" ifTrue:[^result contents].		ch = $\ ifTrue:[ch := self jsonCharFrom: stream].		result nextPut: ch.	].	^self error: 'Unterminated string'! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 2/10/2012 13:46'!jsonTrueFrom: stream	"Decodes 'true' from aStream"	((stream next: 4) = 'true'		and:[stream atEnd or:[stream peek isAlphaNumeric not]]) 			 ifFalse:[^self error: 'Expected ''true'''].	^true! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 7/28/2010 21:32'!logEntryFor: request response: response	"Create a log entry in common log format from the given request / response"	| entry logdate logsize |	"CLF prints date as [day/month/year:hour:min:sec zone]"	logdate := String streamContents:[:s| | date |		date := DateAndTime fromSeconds: DateAndTime totalSeconds.		s nextPut: $[.			date asDate printOn: s format: #( 1 2 3 $/ 2 1 2).		s nextPut: $:.			date asTime print24: true on: s.		s nextPutAll:(' ',			(date offset hours >= 0 ifTrue:['+'] ifFalse:['-']),			(date offset hours abs asString padded: #left to: 2 with: $0),			(date offset minutes abs asString padded: #left to: 2 with: $0)		).		s nextPut: $].	].	"CLF prints zero length as - "	logsize := response contentLength ifNil:[0].	logsize = 0 ifTrue:[logsize := '-'].	entry := String streamContents:[:s|		s 			nextPutAll: (request remoteHost ifNil:[				"Substitute with the host header"				(request headerAt: 'host') copyUpTo: $:			]);			nextPutAll: ' -'; 	"RFC 1413 identity of client"			nextPutAll: ' -';	"TODO: userid of authenticated user"			nextPutAll: ' ', logdate;			nextPutAll: ' "', request requestLine, '"';			nextPutAll: ' ', response code;			nextPutAll: ' ', logsize.	].	^entry! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 7/28/2010 20:01'!logRequest: request response: response on: streamOrFilename	"Log a request in common log format on the given stream / file."	| entry stream |	"Create the log entry for the request/response pair"	entry := self logEntryFor: request response: response.	"If the argument is a string, it represents the file name to log to"	streamOrFilename isString ifTrue:[		stream := [FileStream oldFileNamed: streamOrFilename] 			on: FileDoesNotExistException			do:[FileStream newFileNamed: streamOrFilename].		stream wantsLineEndConversion: true; setToEnd.	] ifFalse:[stream := streamOrFilename].	stream nextPutAll: entry; cr.	stream == streamOrFilename 		ifTrue:[stream flush]		ifFalse:[stream close].! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 12:45'!md5Digest: aStringOrByteArray	"This creates a little endian hex string to be used with various auth methods	This is the same as htdigest (apache) uses for its md5 digest auth db"	^(self md5HashStream: (ReadStream on: aStringOrByteArray asByteArray)) reversed hex! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 2/25/2010 23:29'!md5HashStream: aStream	"self md5HashStream: (ReadStream on: 'foo')"	| start buffer bytes sz n words hash |	hash := WordArray 		with: 16r67452301 		with: 16rEFCDAB89 		with: 16r98BADCFE 		with: 16r10325476.	words := WordArray new: 16.	buffer := ByteArray new: 64.	start := aStream position.	[aStream atEnd] whileFalse: [		bytes := aStream nextInto: buffer.		(bytes size < 64 or:[aStream atEnd]) ifTrue:[			sz := bytes size.			buffer replaceFrom: 1 to: sz with: bytes startingAt: 1.			buffer from: sz+1 to: buffer size put: 0.			sz < 56 ifTrue:[				buffer at: sz + 1 put: 128. "trailing bit"			] ifFalse:[				"not enough room for the length, so just pad this one, then..."				sz < 64 ifTrue:[buffer at: sz + 1 put: 128].				1 to: 16 do:[:i| words at: i put: (buffer unsignedLongAt: i*4-3 bigEndian: false)].				self md5Transform: words hash: hash.				"process one additional block of padding ending with the length"				buffer atAllPut: 0.				sz = 64 ifTrue: [buffer at: 1 put: 128].			].			"Fill in the final 8 bytes with the 64-bit length in bits."			n := (aStream position - start) * 8.			7 to: 0 by: -1 do:[:i| buffer at: (buffer size - i) put: ((n bitShift: 7 - i * -8) bitAnd: 255)].		].		1 to: 16 do:[:i| words at: i put: (buffer unsignedLongAt: i*4-3 bigEndian: false)].		self md5Transform: words hash: hash.	].	bytes := ByteArray new: 16.	bytes unsignedLongAt: 1 put: (hash at: 4) bigEndian: true.	bytes unsignedLongAt: 5 put: (hash at: 3) bigEndian: true.	bytes unsignedLongAt: 9 put: (hash at: 2) bigEndian: true.	bytes unsignedLongAt: 13 put: (hash at: 1) bigEndian: true.	^bytes! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 09:28'!md5Transform: in hash: hash	"This adds the incoming words to the existing hash"	| a b c d |	<primitive: 'primitiveMD5Transform' module: 'CroquetPlugin'>	a := hash at: 1.	b := hash at: 2.	c := hash at: 3.	d := hash at: 4.	a := self step1: a x: b y: c z: d data: (in at:  1) add: 16rD76AA478 shift: 7.	d := self step1: d x: a y: b z: c data: (in at:  2) add: 16rE8C7B756 shift: 12.	c := self step1: c x: d y: a z: b data: (in at:  3) add: 16r242070DB shift: 17.	b := self step1: b x: c y: d z: a data: (in at:  4) add: 16rC1BDCEEE shift: 22.	a := self step1: a x: b y: c z: d data: (in at:  5) add: 16rF57C0FAF shift:  7.	d := self step1: d x: a y: b z: c data: (in at:  6) add: 16r4787C62A shift: 12.	c := self step1: c x: d y: a z: b data: (in at:  7) add: 16rA8304613 shift: 17.	b := self step1: b x: c y: d z: a data: (in at:  8) add: 16rFD469501 shift: 22.	a := self step1: a x: b y: c z: d data: (in at:  9) add: 16r698098D8 shift:  7.	d := self step1: d x: a y: b z: c data: (in at: 10) add: 16r8B44F7AF shift: 12.	c := self step1: c x: d y: a z: b data: (in at: 11) add: 16rFFFF5BB1 shift: 17.	b := self step1: b x: c y: d z: a data: (in at: 12) add: 16r895CD7BE shift: 22.	a := self step1: a x: b y: c z: d data: (in at: 13) add: 16r6B901122 shift:  7.	d := self step1: d x: a y: b z: c data: (in at: 14) add: 16rFD987193 shift: 12.	c := self step1: c x: d y: a z: b data: (in at: 15) add: 16rA679438E shift: 17.	b := self step1: b x: c y: d z: a data: (in at: 16) add: 16r49B40821 shift: 22.	a := self step2: a x: b y: c z: d data: (in at:  2) add: 16rF61E2562 shift:  5.	d := self step2: d x: a y: b z: c data: (in at:  7) add: 16rC040B340 shift:  9.	c := self step2: c x: d y: a z: b data: (in at: 12) add: 16r265E5A51 shift: 14.	b := self step2: b x: c y: d z: a data: (in at:  1) add: 16rE9B6C7AA shift: 20.	a := self step2: a x: b y: c z: d data: (in at:  6) add: 16rD62F105D shift:  5.	d := self step2: d x: a y: b z: c data: (in at: 11) add: 16r02441453 shift:  9.	c := self step2: c x: d y: a z: b data: (in at: 16) add: 16rD8A1E681 shift: 14.	b := self step2: b x: c y: d z: a data: (in at:  5) add: 16rE7D3FBC8 shift: 20.	a := self step2: a x: b y: c z: d data: (in at: 10) add: 16r21E1CDE6 shift:  5.	d := self step2: d x: a y: b z: c data: (in at: 15) add: 16rC33707D6 shift:  9.	c := self step2: c x: d y: a z: b data: (in at:  4) add: 16rF4D50D87 shift: 14.	b := self step2: b x: c y: d z: a data: (in at:  9) add: 16r455A14ED shift: 20.	a := self step2: a x: b y: c z: d data: (in at: 14) add: 16rA9E3E905 shift:  5.	d := self step2: d x: a y: b z: c data: (in at:  3) add: 16rFCEFA3F8 shift:  9.	c := self step2: c x: d y: a z: b data: (in at:  8) add: 16r676F02D9 shift: 14.	b := self step2: b x: c y: d z: a data: (in at: 13) add: 16r8D2A4C8A shift: 20.	a := self step3: a x: b y: c z: d data: (in at:  6) add: 16rFFFA3942 shift:  4.	d := self step3: d x: a y: b z: c data: (in at:  9) add: 16r8771F681 shift: 11.	c := self step3: c x: d y: a z: b data: (in at: 12) add: 16r6D9D6122 shift: 16.	b := self step3: b x: c y: d z: a data: (in at: 15) add: 16rFDE5380C shift: 23.	a := self step3: a x: b y: c z: d data: (in at:  2) add: 16rA4BEEA44 shift:  4.	d := self step3: d x: a y: b z: c data: (in at:  5) add: 16r4BDECFA9 shift: 11.	c := self step3: c x: d y: a z: b data: (in at:  8) add: 16rF6BB4B60 shift: 16.	b := self step3: b x: c y: d z: a data: (in at: 11) add: 16rBEBFBC70 shift: 23.	a := self step3: a x: b y: c z: d data: (in at: 14) add: 16r289B7EC6 shift:  4.	d := self step3: d x: a y: b z: c data: (in at:  1) add: 16rEAA127FA shift: 11.	c := self step3: c x: d y: a z: b data: (in at:  4) add: 16rD4EF3085 shift: 16.	b := self step3: b x: c y: d z: a data: (in at:  7) add: 16r04881D05 shift: 23.	a := self step3: a x: b y: c z: d data: (in at: 10) add: 16rD9D4D039 shift:  4.	d := self step3: d x: a y: b z: c data: (in at: 13) add: 16rE6DB99E5 shift: 11.	c := self step3: c x: d y: a z: b data: (in at: 16) add: 16r1FA27CF8 shift: 16.	b := self step3: b x: c y: d z: a data: (in at:  3) add: 16rC4AC5665 shift: 23.	a := self step4: a x: b y: c z: d data: (in at:  1) add: 16rF4292244 shift:  6.	d := self step4: d x: a y: b z: c data: (in at:  8) add: 16r432AFF97 shift: 10.	c := self step4: c x: d y: a z: b data: (in at: 15) add: 16rAB9423A7 shift: 15.	b := self step4: b x: c y: d z: a data: (in at:  6) add: 16rFC93A039 shift: 21.	a := self step4: a x: b y: c z: d data: (in at: 13) add: 16r655B59C3 shift:  6.	d := self step4: d x: a y: b z: c data: (in at:  4) add: 16r8F0CCC92 shift: 10.	c := self step4: c x: d y: a z: b data: (in at: 11) add: 16rFFEFF47D shift: 15.	b := self step4: b x: c y: d z: a data: (in at:  2) add: 16r85845DD1 shift: 21.	a := self step4: a x: b y: c z: d data: (in at:  9) add: 16r6FA87E4F shift:  6.	d := self step4: d x: a y: b z: c data: (in at: 16) add: 16rFE2CE6E0 shift: 10.	c := self step4: c x: d y: a z: b data: (in at:  7) add: 16rA3014314 shift: 15.	b := self step4: b x: c y: d z: a data: (in at: 14) add: 16r4E0811A1 shift: 21.	a := self step4: a x: b y: c z: d data: (in at:  5) add: 16rF7537E82 shift:  6.	d := self step4: d x: a y: b z: c data: (in at: 12) add: 16rBD3AF235 shift: 10.	c := self step4: c x: d y: a z: b data: (in at:  3) add: 16r2AD7D2BB shift: 15.	b := self step4: b x: c y: d z: a data: (in at: 10) add: 16rEB86D391 shift: 21.	a := (a + (hash at: 1)) bitAnd: 16rFFFFFFFF. hash at: 1 put: a.	b := (b + (hash at: 2)) bitAnd: 16rFFFFFFFF. hash at: 2 put: b.	c := (c + (hash at: 3)) bitAnd: 16rFFFFFFFF. hash at: 3 put: c.	d := (d + (hash at: 4)) bitAnd: 16rFFFFFFFF. hash at: 4 put: d.	^hash! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 7/20/2010 20:06'!multipartBoundary	"Answer a string to be used as multpart boundary in posts"	^'----squeak-', Date today,'-', Time millisecondClockValue, '-webclient-----'.! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 8/24/2010 10:04'!oAuthSign: webRequest url: requestUrl extra: postFields using: params	"Sign the given webRequest using the set of oauth parameters provided"	| epoch timestamp nonce normalized baseString query signature key header extraKeys baseUrl |	"Allow providing an oauth_timestamp; HOWEVER this is only useful for	tests etc. For actual API calls the timestamp *must* match real-time closely	or else the request will be rejected".	timestamp := params at: 'oauth_timestamp' ifAbsent:[		"Timestamp is relative to Jan. 1st 1970 GMT"		epoch := DateAndTime year: 1970 day: 1 hour: 0 minute: 0 second: 0 			offset: (Duration seconds: 0).		(DateAndTime now asUTC - epoch) asSeconds.	].	"Same for nonces (although nonces can be reused)"	nonce := params at: 'oauth_nonce' ifAbsent:[UUID new hex].	"Assemble the required parameters. Start with the (POST) body fields."	normalized := (postFields as: Dictionary) associations asOrderedCollection.	"If present, extract any (GET) fields from the URL"	(requestUrl copyAfter: $?) ifNotEmpty:[:fields|		self decodeUrlEncodedForm: fields do:[:fkey :fval| normalized add: fkey -> fval]].	"Keep the extra argument keys so we can exclude them below"	extraKeys := normalized collect:[:assoc| assoc key] as: Set.	normalized add:('oauth_nonce' -> nonce).	normalized add: ('oauth_timestamp' -> timestamp asString).		normalized add: (params associationAt: 'oauth_consumer_key').	normalized add: (params associationAt: 'oauth_signature_method').	normalized add: (params associationAt: 'oauth_version').	(params includesKey: 'oauth_callback') ifTrue:[		normalized add: (params associationAt: 'oauth_callback').	].	(params includesKey: 'oauth_token') ifTrue:[		normalized add: (params associationAt: 'oauth_token').	].	(params includesKey: 'oauth_verifier') ifTrue:[		normalized add: (params associationAt: 'oauth_verifier').	].	normalized := normalized sort:[:a1 :a2| 		a1 key = a2 key 			ifTrue:[a1 value <= a2 value]			ifFalse:[a1 key <= a2 key]].	query := String streamContents:[:s|		normalized do:[:assoc|			s nextPutAll: assoc key.			s nextPutAll: '='.			s nextPutAll: assoc value encodeForHTTP.		] separatedBy:[s nextPutAll: '&'].	].	baseUrl := (requestUrl copyUpTo: $?) copyUpTo: $#.	baseString := webRequest method, 		'&', baseUrl encodeForHTTP, 		'&',  query encodeForHTTP.	key := (params at: 'oauth_consumer_secret'), 			'&', (params at: 'oauth_token_secret' ifAbsent:['']).	(params at: 'oauth_signature_method') caseOf: {		['HMAC-SHA1'] -> [			signature := (WebUtils hmacSha1: baseString key: key) base64Encoded		].	} otherwise:[self error: 'Unsupported signature method'].	header := String streamContents:[:s|		s nextPutAll: 'OAuth '.		"Even though we need to include the extra args in the computation,		they do NOT go into the OAuth header field."		normalized do:[:assoc|			(extraKeys includes: assoc key) 				ifFalse:[ s nextPutAll: assoc key, '="', assoc value encodeForHTTP, '",']].		s nextPutAll: 'oauth_signature="', signature encodeForHTTP, '"'.	].	webRequest headerAt: 'Authorization' put: header.! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 8/23/2010 21:55'!oAuthSign: webRequest url: requestUrl using: params	"Sign the given webRequest using the set of oauth parameters provided"	^self oAuthSign: webRequest url: requestUrl extra: #() using: params! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 11:57'!parseAuthParams: authHeader	"Parse the auth header to find authentication parameters"	| authParams stream key value|	authParams := Dictionary new.	stream := ReadStream on: authHeader.	authParams at: 'method' put: (stream upTo: Character space) asLowercase.	[stream skipSeparators.	stream atEnd] whileFalse:[		key := stream upTo: $=.		stream skipSeparators.		stream peek = $" 			ifTrue:[value := stream next; upTo: $". stream upTo: $,]			ifFalse:[value := stream upToAnyOf: ' ,' asCharacterSet].		authParams at: key asLowercase put: value.	].	^authParams! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 11/17/2011 10:16'!platformName	"Return the name of the platform we're running on."	^Smalltalk getSystemAttribute: 1001! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 2/22/2010 06:36'!proxyExceptionsDo: aBlock	"Evaluate aBlock with all registered proxy exceptions. 	Uses the information from HTTPSocket."	HTTPSocket httpProxyExceptions do: aBlock.! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 06:20'!proxyServerFor: serverName	"Answer the proxy server to use for the given server:port	Returns the proxy server:port to use or nil if no proxy is required."	| domain |	domain := serverName copyUpTo: $:.	self proxyExceptionsDo:[:pattern| (pattern match: domain) ifTrue:[^nil]].	^self defaultProxyServer ifEmpty:[nil]! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 3/31/2010 08:43'!quote: aString	"Quote the given string, escaping as necessary any embedded quotes"	^'"', (aString copyReplaceAll: '"' with: '\"'), '"'! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 09:29'!readHeadersFrom: aStream	"Parse http headers and answer a collection of key -> value pairs."	| headers nextLine existing |	headers := OrderedCollection new.	[nextLine := aStream upToAll: String crlf.	nextLine isEmpty] whileFalse:[		nextLine first isSeparator ifTrue:["Continuation as per HTTP 1.1 spec"			existing := headers last.			existing value: (existing value, String space, nextLine withBlanksTrimmed).		] ifFalse:["Regular header"			headers add: 				(nextLine copyUpTo: $:) asLowercase ->					(nextLine copyAfter: $:) withBlanksTrimmed.		].	].	^headers! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 09:28'!rotate: value by: amount	"Rotate value left by amount"	| lowMask highMask |	lowMask := (1 bitShift: 32-amount) - 1.	highMask := 16rFFFFFFFF - lowMask.	^((value bitAnd: lowMask) bitShift: amount) + 		((value bitAnd: highMask) bitShift: amount-32)! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 8/12/2010 16:31'!sha1Hash: message	"Compute the SHA1 hash for the given message. Slightly different from 	SecureHashAlgorithm to produce fixed-length byte arrays."	| sha hash |	sha := SecureHashAlgorithm new hashMessage: message.	hash := ByteArray new: 20.	1 to: 20 do:[:i| hash at: i put: (sha digitAt: 21-i)].	^hash! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 09:28'!step1: w x: x y: y z: z data: data add: add shift: s	"Step 1 in MD5 transformation"	| f result |	f := z bitXor: (x bitAnd: (y bitXor: z)).	result := w + f + data + add.	result := self rotate: result by: s.	^result + x bitAnd: 16rFFFFFFFF! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 09:28'!step2: w x: x y: y z: z data: data add: add shift: s	"Step 2 in MD5 transformation"	| f result |	f := y bitXor: (z bitAnd: (x bitXor: y)).	result := w + f + data + add.	result := self rotate: result by: s.	^result + x bitAnd: 16rFFFFFFFF! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 09:28'!step3: w x: x y: y z: z data: data add: add shift: s	"Step 3 in MD5 transformation"	| f result |	f := (x bitXor: y) bitXor: z.	result := w + f + data + add.	result := self rotate: result by: s.	^result + x bitAnd: 16rFFFFFFFF! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 09:28'!step4: w x: x y: y z: z data: data add: add shift: s	"Step 4 in MD5 transformation"	| f result |	f := y bitXor: (x bitOr: (z  bitXor: 16rFFFFFFFF)).	result := w + f + data + add.	result := self rotate: result by: s.	^result + x bitAnd: 16rFFFFFFFF! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 3/31/2010 08:45'!unquote: aString	"Unquote the given string, unescaping as necessary any embedded quotes"	(aString beginsWith: '"') ifFalse:[^aString].	(aString endsWith: '"') ifFalse:[^aString].	^(aString copyReplaceAll: '\"' with: '"') allButFirst allButLast! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 9/4/2010 11:33'!urlEncode: urlString	"For backwards compatibility only. Use 'urlString urlEncoded' if you can."	^urlString asUrl asString! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 11/17/2011 10:06'!vmVersion		"Return a string identifying the interpreter version"	^Smalltalk getSystemAttribute: 1004! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 7/8/2010 18:59'!webSocketHandshake: key1 with: key2 with: data	"Do the actual WebSocket handshake computation"	| bytes |	bytes := ByteArray new: 16.	bytes longAt: 1 put: key1 bigEndian: true.	bytes longAt: 5 put: key2 bigEndian: true.	bytes replaceFrom: 9 to: 16 with: data.	^(self md5HashStream: bytes readStream) reversed! !!WebUtils class methodsFor: 'as yet unclassified' stamp: 'ar 9/26/2011 10:30'!webSocketHash07: key	"Do the actual WebSocket hash computation"	| uid |	uid := '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'.	^(ByteArray newFrom: (SecureHashAlgorithm new hashMessage: key, uid)) reversed base64Encoded! !!Range methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!Range class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!DelayWaitTimeout methodsFor: 'as yet unclassified' stamp: 'ar 3/23/2009 16:37'!isExpired	"Did this timeout fire before the associated semaphore was signaled?"	^expired! !!DelayWaitTimeout methodsFor: 'as yet unclassified' stamp: 'ar 3/23/2009 16:38'!setDelay: anInteger forSemaphore: aSemaphore	super setDelay: anInteger forSemaphore: aSemaphore.	process := Processor activeProcess.	expired := false.! !!DelayWaitTimeout methodsFor: 'as yet unclassified' stamp: 'ar 3/24/2009 23:24'!signalWaitingProcess	"Release the given process from the semaphore it is waiting on.	This method relies on running at highest priority so that it cannot be preempted	by the process being released."	beingWaitedOn := false.	"Release the process but only if it is still waiting on its original list"	process suspendingList == delaySemaphore ifTrue:[		expired := true.		process suspend; resume.	].! !!DelayWaitTimeout methodsFor: 'as yet unclassified' stamp: 'ar 3/27/2009 22:26'!wait	"Wait until either the semaphore is signaled or the delay times out"	[self schedule.	"It is critical that the following has no suspension point so that	the test and the wait primitive are atomic. In addition, if the delay	is no longer being waited on while entering the way we know that it 	is expired because the delay has already fired."	beingWaitedOn 		ifTrue:[delaySemaphore wait]		ifFalse:[expired := true]] ensure:[self unschedule].	^self isExpired! !!BehavioralLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 10/29/2008 21:29'!activeClass	^classID activeClass! !!BehavioralLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 1/19/2011 18:03'!attach     "(classID activeClass == nil) ifTrue: [(EditHistory classEditionWithID: classID) install]"! !!BehavioralLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 10/14/2016 20:08'!classEdition
	^classID edition! !!BehavioralLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 10/29/2008 21:20'!classID	^classID! !!BehavioralLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 10/29/2008 21:19'!classID: aClassID	"Set my classID to aClassID."	classID _ aClassID! !!BehavioralLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 5/23/2007 19:31'!marks: anObject	^false! !!BehavioralLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 1/20/2011 01:31'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: ' with classID ';		print: classID! !!BehavioralLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2016 15:15'!storeOnTether: tether	"Store a copy of myself on tether, suitable for re-animation in a remote system."	tether nextWordPut: self tag.	classID storeOnTether: tether! !!BehavioralLiteralMarker class methodsFor: 'as yet unclassified' stamp: 'crl 8/26/2012 17:01'!forLiteralDefinedByClass: aClass	^self new classID: aClass id! !!BehavioralLiteralMarker class methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 18:50'!fromTether: tether	"Answer an instance of myself composed from bytes supplied by aStream, and objects supplied by anObjectTransferCorrespondent."	^self new classID: tether next! !!Nt methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!Nt class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!TelnetProtocolError class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!SqueakLicense methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!SqueakLicense class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!SmallInteger methodsFor: 'as yet unclassified' stamp: 'crl 7/23/2017 14:19'!asChromeRemoteCallArgument	^{#value -> self}! !!SmallInteger methodsFor: 'as yet unclassified' stamp: 'bf 11/25/2014 18:12'!asJSArgument	"converted to JS number by plugin"	^self! !!SmallInteger methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 11:00'!storeOnTether: tether
	tether nextWordPut: (
		(
			(self < 0)
				ifTrue: [
					tether nextWordPut: NegativeNumberTag.
					self negated]
				ifFalse: [self]
		)
			+ SmallIntegerTagBase)! !!WebSocket methodsFor: 'as yet unclassified' stamp: 'ar 9/26/2011 10:45'!handleMessage: msgData type: msgType	"Handle an incoming message of the given type"	self handle: 'message' arguments: (Array with: msgData with: msgType with: self)! !!WebSocket methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 13:57'!hostname	^name copyUpTo: $:! !!WebSocket methodsFor: 'as yet unclassified' stamp: 'crl 6/30/2017 11:29'!isConnected	^stream isConnected! !!WebSocket methodsFor: 'as yet unclassified' stamp: 'crl 6/30/2017 13:02'!noTimeout	stream noTimeout! !!WebSocket methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 14:02'!port	^(		(name readStream)			upTo: $:;			upToEnd	)		asNumber! !!JSParseNode methodsFor: 'as yet unclassified' stamp: 'crl 5/7/2017 14:09'!accesses	^false! !!JSParseNode methodsFor: 'as yet unclassified' stamp: 'crl 5/6/2017 15:50'!cacheProperties	| instanceVariableNames |		instanceVariableNames := self class allInstVarNames.	self properties do: [:propertyName |		(instanceVariableNames includes: propertyName) ifTrue: [			self				instVarNamed: propertyName				put: (proxy at: propertyName) counterpart simplestRepresentation]]! !!JSParseNode methodsFor: 'as yet unclassified' stamp: 'crl 5/7/2017 13:51'!declares	^false! !!JSParseNode methodsFor: 'as yet unclassified' stamp: 'crl 5/5/2017 23:11'!printSmalltalkOn: stream	self subclassResponsibility! !!JSParseNode methodsFor: 'as yet unclassified' stamp: 'crl 5/5/2017 20:11'!proxy: aJSObjectProxy	super proxy: aJSObjectProxy.	self cacheProperties! !!JSParseNode methodsFor: 'as yet unclassified' stamp: 'crl 6/19/2017 12:51'!smalltalk	| stream |		stream := (String new: 64) writeStream.	self printSmalltalkOn: stream.	^stream contents! !!JSParseNode class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!DecompilerConstructor class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!MultiResolutionCanvas class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!FrontendShellserver methodsFor: 'as yet unclassified' stamp: 'crl 7/27/2017 14:14'!at: tag	^Webpage elementAt: tag! !!ResumableTestFailure class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!Hydra methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 14:14'!initialize	proxy := ((JS top at: #Function) new: 'return new Hydra()') call! !!Hydra class methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 15:08'!firstOutput	^HydraOutput forProxy: JS top o0! !!Hydra class methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 21:20'!new	^Instance := super new! !!Hydra class methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 22:08'!osc: parameters	^Oscillator		frequency: parameters first		sync: parameters second		offset: parameters third! !!Hydra class methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 21:20'!start	self new! !!ArithmeticError methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!ArithmeticError class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!Location methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!Location class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!BasicInspector class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!SimpleButtonMorph methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 21:08'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	self addLabelItemsTo: aCustomMenu hand: aHandMorph.aCustomMenu add: 'change action selector' translated action: #setActionSelector.			aCustomMenu add: 'change arguments' translated action: #setArguments.			aCustomMenu add: 'change when to act' translated action: #setActWhen.			self addTargetingMenuItems: aCustomMenu hand: aHandMorph! !!Bitmap methodsFor: 'as yet unclassified' stamp: 'crl 4/16/2018 17:34'!decompressFromVisualWorksByteArray: bytes	<primitive: 'decompressVisualWorksBitmapFromByteArray' module: 'Flow'>	self primitiveFailed! !!HTMLBodyElement methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!HTMLBodyElement class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 7/9/2005 08:45'!+ operand	"operand conforms to protocol Duration"	| ticks | 	ticks := self ticks + (operand asDuration ticks) .	^ self class basicNew		ticks: ticks		offset: self offset; 		yourself! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 1/9/2004 05:39'!- operand	"operand conforms to protocol DateAndTime or protocol Duration"	^ (operand respondsTo: #asDateAndTime)		ifTrue: 			[ | lticks rticks |			lticks := self asLocal ticks.			rticks := operand asDateAndTime asLocal ticks.			Duration 				seconds: (SecondsInDay *(lticks first - rticks first)) + 							(lticks second - rticks second) 				nanoSeconds: (lticks third - rticks third) ]		ifFalse:		 	[ self + (operand negated) ]! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'cmm 6/1/2014 20:04'!< comparand 	"comparand conforms to protocol DateAndTime,	or can be converted into something that conforms."	| lvalue rvalue comparandAsDateAndTime |	comparandAsDateAndTime := comparand asDateAndTime.	offset = comparandAsDateAndTime offset		ifTrue:			[ lvalue := self.			rvalue := comparandAsDateAndTime ]		ifFalse:			[ lvalue := self asUTC.			rvalue := comparandAsDateAndTime asUTC ].	^ lvalue julianDayNumber < rvalue julianDayNumber or:		[ lvalue julianDayNumber > rvalue julianDayNumber			ifTrue: [ false ]			ifFalse:				[ lvalue secondsSinceMidnight < rvalue secondsSinceMidnight or:					[ lvalue secondsSinceMidnight > rvalue secondsSinceMidnight						ifTrue: [ false ]						ifFalse: [ lvalue nanoSecond < rvalue nanoSecond ] ] ] ]! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'cmm 6/1/2014 20:05'!= aDateAndTimeOrTimeStamp 	self == aDateAndTimeOrTimeStamp ifTrue: [ ^ true ].	((aDateAndTimeOrTimeStamp isKindOf: self class)		or: [aDateAndTimeOrTimeStamp isKindOf: DateAndTime orOf: TimeStamp])			ifFalse: [ ^ false ].	^ self offset = aDateAndTimeOrTimeStamp offset		ifTrue: [ self hasEqualTicks: aDateAndTimeOrTimeStamp ]		ifFalse: [ self asUTC hasEqualTicks: aDateAndTimeOrTimeStamp asUTC ]! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'klc 9/12/2010 15:56'!asDate	^ Date starting: self asDateAndTime! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 5/13/2003 07:46'!asDateAndTime	^ self! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'gk 8/31/2006 00:55'!asDuration	"Answer the duration since midnight."	^ Duration seconds: seconds nanoSeconds: nanos! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 8/23/2003 13:11'!asLocal		^ (self offset = self class localOffset)		ifTrue: [self]		ifFalse: [self utcOffset: self class localOffset]! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 5/13/2003 07:47'!asMonth	^ Month starting: self! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 7/27/2003 15:45'!asNanoSeconds	"Answer the number of nanoseconds since midnight"	^ self asDuration asNanoSeconds! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'cmm 2/2/2012 22:05'!asSeconds	"Return the number of seconds since the Squeak epoch"	^ (self - (self class epoch offset: offset)) asSeconds! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 8/24/2003 00:00'!asTime	^ Time seconds: seconds nanoSeconds: nanos! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 8/24/2003 00:02'!asTimeStamp	^ self as: TimeStamp! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 4/13/2006 10:21'!asUTC	^ offset isZero		ifTrue: [self]		ifFalse: [self utcOffset: 0]! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'bf 8/28/2008 13:45'!asUnixTime	"answer number of seconds since unix epoch (midnight Jan 1, 1970, UTC)"	^(self - self class unixEpoch) asSeconds! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 5/13/2003 07:47'!asWeek	^ Week starting: self! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 5/13/2003 07:47'!asYear	^ Year starting: self! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 7/1/2003 17:53'!day	^ self dayOfYear! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 7/27/2003 15:47'!dayMonthYearDo: aBlock	"Evaluation the block with three arguments: day month, year."	| l n i j dd mm yyyy |	l := jdn + 68569.	n := 4 * l // 146097.	l := l - (146097 * n + 3 // 4).	i := 4000 * (l + 1) // 1461001.	l := l - (1461 * i // 4) + 31.	j := 80 * l // 2447.	dd := l - (2447 * j // 80).	l := j // 11.	mm := j + 2 - (12 * l).	yyyy := 100 * (n - 49) + i + l.	^ aBlock		value: dd		value: mm		value: yyyy! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 8/23/2003 21:03'!dayOfMonth	"Answer which day of the month is represented by the receiver."	^ self		dayMonthYearDo: [ :d :m :y | d ]! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 8/24/2003 12:25'!dayOfWeek	"Sunday=1, ... , Saturday=7"	^ (jdn + 1 rem: 7) + 1! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 8/23/2003 10:34'!dayOfWeekAbbreviation	^ self dayOfWeekName copyFrom: 1 to: 3! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 5/13/2003 07:28'!dayOfWeekName	^ Week nameOfDay: self dayOfWeek! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'nice 12/26/2009 01:29'!dayOfYear	"This code was contributed by Dan Ingalls. It is equivalent to the terser		^ jdn - (Year year: self year) start julianDayNumber + 1 but much quicker."	^ self dayMonthYearDo:		[ :d :m :y |			| monthStart |			monthStart := #(1 32 60 91 121 152 182 213 244 274 305 335) at: m.			(m > 2 and: [ Year isLeapYear: y ])				ifTrue: [ monthStart + d ]				ifFalse: [ monthStart + d - 1 ]]! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 5/13/2003 07:48'!daysInMonth	"Answer the number of days in the month represented by the receiver."	^ self asMonth daysInMonth! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 5/13/2003 07:48'!daysInYear	"Answer the number of days in the year represented by the receiver."	^ self asYear daysInYear! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 7/27/2003 15:44'!daysLeftInYear	"Answer the number of days in the year after the date of the receiver."	^ self daysInYear - self dayOfYear! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 5/13/2003 07:49'!duration	^ Duration zero! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 7/27/2003 15:44'!firstDayOfMonth	^ self asMonth start day! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'dtl 5/14/2014 07:37'!floor	"Answer a copy with magnitude rounded down to the nearest whole second"	^self class basicNew		ticks: (self ticks at: 3 put: 0; yourself)		offset: offset.! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 7/28/2004 16:22'!hasEqualTicks: aDateAndTime		^ (jdn = aDateAndTime julianDayNumber)		and: [ (seconds = aDateAndTime secondsSinceMidnight)			and: [ nanos = aDateAndTime nanoSecond ] ]! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'pad 5/10/2012 17:00'!hash	| totalSeconds |	totalSeconds := seconds - offset asSeconds.	^ ((totalSeconds // 86400 + jdn) hashMultiply bitXor: totalSeconds \\86400) bitXor: nanos! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 5/13/2003 07:29'!hour	^ self hour24! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'avi 2/21/2004 18:46'!hour12	"Answer an <integer> between 1 and 12, inclusive, representing the hour 	of the day in the 12-hour clock of the local time of the receiver."	^ self hour24 - 1 \\ 12 + 1! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 5/13/2003 07:29'!hour24	^ (Duration seconds: seconds) hours! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 7/1/2003 18:30'!hours	^ self hour! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 5/13/2003 07:29'!isLeapYear	^ Year isLeapYear: self year! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 5/13/2003 07:49'!julianDayNumber	^ jdn! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'cmm 2/2/2012 19:02'!makeUTC	"Make the receiver's timezone UTC."	self primOffset: Duration zero! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 8/24/2003 11:03'!meridianAbbreviation	^ self asTime meridianAbbreviation! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 5/13/2003 07:49'!middleOf: aDuration	"Return a Timespan where the receiver is the middle of the Duration"	| duration |	duration := aDuration asDuration.	^ Timespan starting: (self - (duration / 2)) duration: duration! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'cmm 2/2/2012 20:06'!midnight	"Answer a DateAndTime starting at midnight of the same timezone offset as the receiver."	^ self class basicNew		setJdn: jdn		seconds: 0		nano: 0		offset: offset! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 5/13/2003 07:30'!minute	^ (Duration seconds: seconds) minutes! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 1/7/2004 15:45'!minutes	^ self minute! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 8/23/2003 21:05'!month	^ self 		dayMonthYearDo: [ :d :m :y | m ]! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 5/13/2003 07:30'!monthAbbreviation	^ self monthName copyFrom: 1 to: 3! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 5/13/2003 07:50'!monthIndex	^ self month! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 5/13/2003 07:30'!monthName	^ Month nameOfMonth: self month! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 5/13/2003 07:50'!nanoSecond	^ nanos! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 7/27/2003 15:49'!noon	"Answer a DateAndTime starting at noon"	^ self dayMonthYearDo: 		[ :d :m :y | self class year: y month: m day: d hour: 12 minute: 0 second: 0 ]! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'gk 8/30/2006 22:59'!normalize: i ticks: ticks base: base	| tick div quo rem |	tick := ticks at: i.	div := tick digitDiv: base neg: tick negative.	quo := (div at: 1) normalize.	rem := (div at: 2) normalize.	rem < 0 ifTrue: [ quo := quo - 1. rem := base + rem ].	ticks at: (i-1) put: ((ticks at: i-1) + quo).	ticks at: i put: rem! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 5/13/2003 07:30'!offset	^ offset! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 8/23/2003 21:09'!offset: anOffset	"Answer a <DateAndTime> equivalent to the receiver but with its local time 	being offset from UTC by offset."	^ self class basicNew 		ticks: self ticks offset: anOffset asDuration;		yourself! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'cmm 7/16/2011 15:32'!primOffset: aDuration	offset := aDuration! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'nk 3/12/2004 10:03'!printHMSOn: aStream	"Print just hh:mm:ss"	aStream		nextPutAll: (self hour asString padded: #left to: 2 with: $0);		nextPut: $:;		nextPutAll: (self minute asString padded: #left to: 2 with: $0);		nextPut: $:;		nextPutAll: (self second asString padded: #left to: 2 with: $0).! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'nk 3/12/2004 10:38'!printOn: aStream	"Print as per ISO 8601 sections 5.3.3 and 5.4.1.	Prints either:		'YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for positive years) or '-YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for negative years)"	^self printOn: aStream withLeadingSpace: false! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'dtl 10/31/2004 01:20'!printOn: aStream withLeadingSpace: printLeadingSpaceToo	"Print as per ISO 8601 sections 5.3.3 and 5.4.1.	If printLeadingSpaceToo is false, prints either:		'YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for positive years) or '-YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for negative years)	If printLeadingSpaceToo is true, prints either:		' YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for positive years) or '-YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for negative years)	"	self printYMDOn: aStream withLeadingSpace: printLeadingSpaceToo.	aStream nextPut: $T.	self printHMSOn: aStream.	self nanoSecond ~= 0 ifTrue:		[ | z ps |		ps := self nanoSecond printString padded: #left to: 9 with: $0.		z := ps findLast: [ :c | c asciiValue > $0 asciiValue ].		(z > 0) ifTrue: [aStream nextPut: $.].		ps from: 1 to: z do: [ :c | aStream nextPut: c ] ].	aStream		nextPut: (offset positive ifTrue: [$+] ifFalse: [$-]);		nextPutAll: (offset hours abs asString padded: #left to: 2 with: $0);		nextPut: $:;		nextPutAll: (offset minutes abs asString padded: #left to: 2 with: $0).	offset seconds = 0 ifFalse:		[ aStream			nextPut: $:;			nextPutAll: (offset seconds abs truncated asString) ].! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'nk 3/12/2004 10:29'!printYMDOn: aStream	"Print just YYYY-MM-DD part.	If the year is negative, prints out '-YYYY-MM-DD'."	^self printYMDOn: aStream withLeadingSpace: false.! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'nk 3/12/2004 10:29'!printYMDOn: aStream withLeadingSpace: printLeadingSpaceToo	"Print just the year, month, and day on aStream.	If printLeadingSpaceToo is true, then print as:		' YYYY-MM-DD' (if the year is positive) or '-YYYY-MM-DD' (if the year is negative)	otherwise print as:		'YYYY-MM-DD' or '-YYYY-MM-DD' "	| year month day |	self dayMonthYearDo: [ :d :m :y | year := y. month := m. day := d ].	year negative		ifTrue: [ aStream nextPut: $- ]		ifFalse: [ printLeadingSpaceToo ifTrue: [ aStream space ]].	aStream		nextPutAll: (year abs asString padded: #left to: 4 with: $0);		nextPut: $-;		nextPutAll: (month asString padded: #left to: 2 with: $0);		nextPut: $-;		nextPutAll: (day asString padded: #left to: 2 with: $0)! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 5/13/2003 07:31'!second	^ (Duration seconds: seconds) seconds! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 7/1/2003 18:31'!seconds	^ self second! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 7/28/2004 16:20'!secondsSinceMidnight	^ seconds! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'kph 10/13/2006 04:33'!setJdn: j seconds: s nano: n offset: ojdn := j.seconds := s.nanos :=  n.offset :=  o! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 8/23/2003 15:45'!ticks	"Private - answer an array with our instance variables. Assumed to be UTC "	^ Array with: jdn with: seconds with: nanos! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'gk 8/30/2006 23:01'!ticks: ticks offset: utcOffset	"ticks is {julianDayNumber. secondCount. nanoSeconds}"	self normalize: 3 ticks: ticks base: NanosInSecond.	self normalize: 2 ticks: ticks base: SecondsInDay.	jdn	:= ticks at: 1.	seconds	:= ticks at: 2.	nanos := ticks at: 3.	offset := utcOffset! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 9/4/2003 06:42'!timeZoneAbbreviation	^ self class localTimeZone abbreviation! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 9/4/2003 06:42'!timeZoneName	^ self class localTimeZone name! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 7/27/2003 15:50'!to: anEnd	"Answer a Timespan. anEnd conforms to protocol DateAndTime or protocol Timespan"	^ Timespan starting: self ending: (anEnd asDateAndTime)! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 9/25/2003 15:57'!to: anEnd by: aDuration	"Answer a Timespan. anEnd conforms to protocol DateAndTime or protocol Timespan"	^ (Schedule starting: self ending: (anEnd asDateAndTime))		schedule: (Array with: aDuration asDuration);		yourself! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 9/25/2003 16:01'!to: anEnd by: aDuration do: aBlock	"Answer a Timespan. anEnd conforms to protocol DateAndTime or protocol Timespan"	^ (self to: anEnd by: aDuration) scheduleDo: aBlock! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 8/23/2003 20:37'!utcOffset: anOffset	"Answer a <DateAndTime> equivalent to the receiver but offset from UTC by anOffset"	| equiv |	equiv := self + (anOffset asDuration - self offset).	^ equiv ticks: (equiv ticks) offset: anOffset asDuration; yourself! !!DateAndTime methodsFor: 'as yet unclassified' stamp: 'brp 8/23/2003 21:05'!year	^ self		dayMonthYearDo: [ :d :m :y | y ]! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'kph 12/11/2006 20:14'!clock 	 "the provider of real time seconds/milliseconds."	^ ClockProvider ! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'gk 8/31/2006 00:49'!clockPrecision	"One nanosecond precision"	^ Duration seconds: 0 nanoSeconds: 1! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'brp 5/13/2003 07:36'!current	^ self now! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'bf 7/3/2012 23:35'!date: aDate time: aTime	^ self 		year: aDate year 		day: aDate dayOfYear 		hour: aTime hour 		minute: aTime minute 		second: aTime second		offset: aDate start offset! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'brp` 8/24/2003 19:11'!epoch	"Answer a DateAndTime representing the Squeak epoch: 1 January 1901"	^ self julianDayNumber: SqueakEpoch! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'dtl 6/21/2009 23:37'!fromSeconds: seconds 	"Answer a DateAndTime since the Squeak epoch: 1 January 1901"	| integerSeconds nanos |	integerSeconds := seconds truncated.	integerSeconds = seconds		ifTrue: [nanos := 0]		ifFalse: [nanos := (seconds - integerSeconds * NanosInSecond) asInteger].	^ self basicNew		ticks: (Array				with: SqueakEpoch				with: integerSeconds				with: nanos)		offset: self localOffset! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'brp 5/13/2003 07:36'!fromString: aString	^ self readFrom: (ReadStream on: aString)! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'dtl 7/13/2009 13:08'!initialize	super initialize.	ClockProvider := Time.	LastTickSemaphore := Semaphore forMutualExclusion.	LastMilliSeconds := 0.	LastTick := 0.	Smalltalk addToStartUpList: self.	self startUp: true! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'ul 11/6/2010 23:37'!initializeOffsets	| durationSinceEpoch secondsSinceMidnight nowSecs |	LastTick := 0.	nowSecs := self clock secondsWhenClockTicks.	LastMilliSeconds := self millisecondClockValue.	durationSinceEpoch := Duration		days: SqueakEpoch		hours: 0		minutes: 0		seconds: nowSecs.	DaysSinceEpoch := durationSinceEpoch days.	secondsSinceMidnight := (durationSinceEpoch -		(Duration			days: DaysSinceEpoch			hours: 0			minutes: 0			seconds: 0)) asSeconds.	MilliSecondOffset := secondsSinceMidnight * 1000 - LastMilliSeconds! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'cmm 2/2/2012 19:14'!julianDayNumber: anInteger 	^ self		julianDayNumber: anInteger		offset: self localOffset! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'crl 9/16/2019 18:17'!julianDayNumber: anInteger offset: aDuration 	^ self basicNew		ticks: (Duration days: anInteger) ticks		offset: aDuration ;		 yourself! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'brp 9/4/2003 06:40'!localOffset	"Answer the duration we are offset from UTC"	^ self localTimeZone offset! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'brp 9/4/2003 06:39'!localTimeZone	"Answer the local time zone"	^ LocalTimeZone ifNil: [ LocalTimeZone := TimeZone default ]! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'nk 3/30/2004 09:53'!localTimeZone: aTimeZone	"Set the local time zone"	"	DateAndTime localTimeZone: (TimeZone offset:  0 hours name: 'Universal Time' abbreviation: 'UTC').	DateAndTime localTimeZone: (TimeZone offset: -8 hours name: 'Pacific Standard Time' abbreviation: 'PST').	"	LocalTimeZone := aTimeZone! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'brp 7/27/2003 17:09'!midnight	^ self now midnight! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'ul 11/6/2010 23:38'!milliSecondsSinceMidnight	| msm msClock |	"This is usually only during system startup..."	self waitForOffsets.	msClock := self millisecondClockValue.	msClock < LastMilliSeconds ifTrue: [ "rolled over"		MilliSecondOffset := MilliSecondOffset + (SmallInteger maxVal // 2) + 1 ].	LastMilliSeconds := msClock.	[	msm := msClock + MilliSecondOffset.	msm >= 86400000 ] whileTrue: [		"next day"		LastTick := -1.		DaysSinceEpoch := DaysSinceEpoch + 1.		MilliSecondOffset := MilliSecondOffset - 86400000 ].	"day rolled over sanity check"	(LastTick = -1 and: [		(Duration			days: SqueakEpoch			hours: 0			minutes: 0			seconds: self clock totalSeconds) days ~= DaysSinceEpoch ]) ifTrue: [		self initializeOffsets.		^ self milliSecondsSinceMidnight ].	^ msm.! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'kph 12/11/2006 21:13'!millisecondClockValue	^ self clock millisecondClockValue! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'brp 8/23/2003 20:57'!new	"Answer a DateAndTime representing the Squeak epoch: 1 January 1901"	^ self epoch! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'brp 7/27/2003 17:09'!noon	^ self now noon! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'cmm 2/2/2012 19:46'!now 	^ self nowWithOffset: self localOffset! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'cmm 7/4/2012 13:42'!nowWithOffset: aDuration 	| nanoTicks msm |	nanoTicks := (msm := self milliSecondsSinceMidnight) * 1000000.	"The following usually only executes at system startup."	^ LastTick < nanoTicks		ifTrue:			[ LastTick := nanoTicks.			self waitForOffsets.			self basicNew				setJdn: DaysSinceEpoch				seconds: msm // 1000				nano: msm \\ 1000 * 1000000				offset: aDuration ]		ifFalse:			[ LastTickSemaphore critical:				[ LastTick := LastTick + 1.				self waitForOffsets.				self basicNew					setJdn: DaysSinceEpoch					seconds: LastTick // 1000000000					nano: LastTick \\ 1000000000					offset: aDuration ] ]" [ 10000 timesRepeat: [ self now. ] ] timeToRun / 10000.0 . If calls to DateAndTime-c-#now are within a single millisecond the semaphore code to ensure that (self now <= self now) slows things down considerably by a factor of about 20.The actual speed of a single call to DateAndTime-now in milliseconds is demonstrated by the unguarded method below.[ 100000 timesRepeat: [ self todayAtMilliSeconds: (self milliSecondsSinceMidnight) ] ] timeToRun / 100000.0 .  0.00494 0.00481 0.00492 0.00495  "! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'bf 3/4/2013 15:17'!readFrom: aStream	| offset date time ch |	date := Date readFrom: aStream.	[aStream peek isDigit]		whileFalse: [aStream next].	time := Time readFrom: aStream.	(aStream atEnd or: [('+-Z' includes: aStream peek) not])		ifTrue: [offset := self localOffset]		ifFalse: [(aStream peekFor: $Z)			ifTrue: [offset := Duration zero]			ifFalse: [				ch := aStream next.				ch = $+ ifTrue: [ch := Character space].				offset := Duration fromString: ch asString, '0:', aStream upToEnd, ':0']].	^ self		year: date year		month: date monthIndex		day: date dayOfMonth		hour: time hour		minute: time minute		second: time second		nanoSecond: time nanoSecond		offset: offset	"	'-1199-01-05T20:33:14.321-05:00' asDateAndTime		' 2002-05-16T17:20:45.1+01:01' asDateAndTime		' 2002-05-16T17:20:45.02+01:01' asDateAndTime		' 2002-05-16T17:20:45.003+01:01' asDateAndTime		' 2002-05-16T17:20:45.0004+01:01' asDateAndTime  		' 2002-05-16T17:20:45.00005' asDateAndTime		' 2002-05-16T17:20:45.000006+01:01' asDateAndTime		' 2002-05-16T17:20:45.0000007+01:01' asDateAndTime		' 2002-05-16T17:20:45.00000008-01:01' asDateAndTime   		' 2002-05-16T17:20:45.000000009+01:01' asDateAndTime  		' 2002-05-16T17:20:45.0000000001+01:01' asDateAndTime   		' 2002-05-16T17:20' asDateAndTime		' 2002-05-16T17:20:45' asDateAndTime		' 2002-05-16T17:20:45+01:57' asDateAndTime 		' 2002-05-16T17:20:45-02:34' asDateAndTime 		' 2002-05-16T17:20:45+00:00' asDateAndTime		' 1997-04-26T01:02:03+01:02:3' asDateAndTime  	"! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'dtl 4/13/2011 08:10'!startUp: resuming	resuming ifFalse: [ ^ self ].	Time initializeMillisecondClockMask.	OffsetsAreValid := false.	[		self initializeOffsets.		OffsetsAreValid := true	] forkAt: Processor userInterruptPriority.! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'brp 7/27/2003 17:09'!today	^ self midnight! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'brp 8/24/2003 12:19'!tomorrow	^ self today asDate next asDateAndTime! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'kph 12/9/2006 23:46'!totalSeconds	^ self clock totalSeconds! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'bf 8/28/2008 13:19'!unixEpoch	"Answer a DateAndTime representing the Unix epoch (1 January 1970, midnight UTC)"	^ self basicNew		ticks: #(2440588 0 0) offset: Duration zero;		yourself.! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'jmv 10/19/2010 14:10'!waitForOffsets	OffsetsAreValid ifFalse: [		[			(Delay forSeconds: 1) wait.			OffsetsAreValid		] whileFalse	]! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'brp 8/23/2003 20:53'!year: year day: dayOfYear	"Return a DateAndTime"	^ self		year: year		day: dayOfYear		hour: 0		minute: 0		second: 0! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'brp 7/27/2003 15:25'!year: year day: dayOfYear hour: hour minute: minute second: second	^ self		year: year		day: dayOfYear		hour: hour		minute: minute		second: second		offset: self localOffset! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'brp 7/27/2003 15:28'!year: year day: dayOfYear hour: hour minute: minute second: second offset: offset 	"Return a DataAndTime"	| y d |	y := self		year: year		month: 1		day: 1		hour: hour		minute: minute		second: second		nanoSecond: 0		offset: offset.	d := Duration days: (dayOfYear - 1).	^ y + d! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'ul 10/15/2009 01:05'!year: year month: month day: day	"Return a DateAndTime, midnight local time"		^self 		year: year 		month: month 		day: day 		hour: 0		minute: 0! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'ul 10/15/2009 01:19'!year: year month: month day: day hour: hour minute: minute	"Return a DateAndTime"	^self 		year: year 		month: month 		day: day 		hour: hour		minute: minute		second: 0! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'brp 8/23/2003 21:00'!year: year month: month day: day hour: hour minute: minute second: second	"Return a DateAndTime"	^ self		year: year		month: month		day: day		hour: hour		minute: minute		second: second		offset: self localOffset! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'ul 10/15/2009 00:58'!year: year month: month day: day hour: hour minute: minute second: second nanoSecond: nanoCount offset: offset	"Return a DateAndTime"	| monthIndex daysInMonth p q r s julianDayNumber |	monthIndex := month isInteger ifTrue: [month] ifFalse: [Month indexOfMonth: month].	daysInMonth := Month		daysInMonth: monthIndex		forYear: year.	day < 1 ifTrue: [self error: 'day may not be zero or negative'].	day > daysInMonth ifTrue: [self error: 'day is after month ends']. 			p := (monthIndex - 14) quo: 12.	q := year + 4800 + p.	r := monthIndex - 2 - (12 * p).	s := (year + 4900 + p) quo: 100.	julianDayNumber := 		( (1461 * q) quo: 4 ) +			( (367 * r) quo: 12 ) - 				( (3 * s) quo: 4 ) + 					( day - 32075 ).	^self basicNew		setJdn: julianDayNumber 		seconds: hour * 60 + minute * 60 + second		nano: nanoCount		offset: offset;		yourself! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'brp 5/13/2003 07:36'!year: year month: month day: day hour: hour minute: minute second: second offset: offset	^ self		year: year		month: month		day: day		hour: hour		minute: minute		second: second		nanoSecond: 0		offset: offset! !!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'brp 8/24/2003 12:19'!yesterday	^ self today asDate previous asDateAndTime! !!UnusedVariable class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!RelativeDuration methodsFor: 'as yet unclassified' stamp: 'crl 8/14/2004 01:59'!+ aRelativeDuration	"Answer the sum of myself and aRelativeDuration."	| sum |	sum _ (self total + aRelativeDuration total) asFraction.	^(self class)		ofMagnitude: (			(sum = 0)				ifTrue: [magnitude]				ifFalse: [sum denominator reciprocal])		inQuantity: (sum numerator)! !!RelativeDuration methodsFor: 'as yet unclassified' stamp: 'crl 8/14/2004 02:00'!/ aNumber	"Answer the result of dividing myself by aNumber."	| quotient |	quotient _ (self total / aNumber) asFraction.	^(self class)		ofMagnitude: (			(quotient = 0)				ifTrue: [magnitude]				ifFalse: [quotient denominator reciprocal])		inQuantity: (quotient numerator)! !!RelativeDuration methodsFor: 'as yet unclassified' stamp: 'crl 10/5/2004 11:35'!< aRelativeDuration	^self total < aRelativeDuration total! !!RelativeDuration class methodsFor: 'as yet unclassified' stamp: 'crl 7/28/2003 18:55'!new	"Answer a new initialized instance of myself."	^super new initialize! !!ClassVariableLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 3/21/2019 03:54'!literal	"Answer the method literal I represent."	^(EditHistory residesLocally)		ifTrue: [key -> nil]		ifFalse: [			(self activeClass classPool)				associationAt: key				ifAbsent: [self activeClass classPool add: (key -> nil)]]! !!ClassVariableLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 10/29/2008 21:44'!marks: literal	| class |	class _ self activeClass.	^class		ifNil: [false]		ifNotNil: [			(				class classVariablesPool					associationAt: key					ifAbsent: [^false]			)				== literal]! !!ClassVariableLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2016 15:07'!tag	"Answer my transmission tag."	^ClassVariableLiteralMarkerTag! !!ClassVariableLiteralMarker class methodsFor: 'as yet unclassified' stamp: 'crl 3/21/2019 03:45'!canRepresent: literal inMethod: aCompiledMethod of: aClass	^(literal isKindOf: LookupKey) and: [(aClass edition holderOfClassVariablePoolAssociation: literal) ~~ nil]! !!ClassVariableLiteralMarker class methodsFor: 'as yet unclassified' stamp: 'crl 3/21/2019 03:46'!forLiteral: literal inMethod: aCompiledMethod ofClass: aClass	"Answer an instance of myself to represent literal when transferring aCompiledMethod from aClass."	^(self forLiteralDefinedByClass: (aClass edition holderOfClassVariablePoolAssociation: literal)) key: literal key! !!JSTextMorph methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSTextMorph class methodsFor: 'as yet unclassified' stamp: 'crl 5/30/2017 15:31'!fromString: string	^self newWithParameters: {string}! !!ClassIDPattern methodsFor: 'as yet unclassified' stamp: 'crl 7/15/2011 21:27'!classAuthorID	self maskFromByte: 33 to: 34! !!ClassIDPattern methodsFor: 'as yet unclassified' stamp: 'crl 7/15/2011 21:27'!classBaseID	self maskFromByte: 1 to: 16! !!ClassIDPattern class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!Date methodsFor: 'as yet unclassified' stamp: 'brp 8/23/2003 22:09'!addDays: dayCount 	^ (self asDateAndTime + (dayCount days)) asDate! !!Date methodsFor: 'as yet unclassified' stamp: 'tbn 7/11/2006 10:30'!addMonths: monthCount 	|year month maxDaysInMonth day |	year := self year + (monthCount + self monthIndex - 1 // 12).	month := self monthIndex + monthCount - 1 \\ 12 + 1.	maxDaysInMonth := Month daysInMonth: month forYear: year.	day := self dayOfMonth > maxDaysInMonth				ifTrue: [maxDaysInMonth]				ifFalse: [self dayOfMonth].	^ Date		newDay: day		month: month		year: year! !!Date methodsFor: 'as yet unclassified' stamp: 'brp 7/27/2003 16:10'!asDate	^ self! !!Date methodsFor: 'as yet unclassified' stamp: 'brp 7/27/2003 16:08'!asSeconds	"Answer the seconds since the Squeak epoch: 1 January 1901"	^ start asSeconds! !!Date methodsFor: 'as yet unclassified' stamp: 'brp 7/27/2003 16:10'!dayMonthYearDo: aBlock 	"Supply integers for day, month and year to aBlock and return the result"	^ start dayMonthYearDo: aBlock! !!Date methodsFor: 'as yet unclassified' stamp: 'brp 7/27/2003 16:08'!leap	"Answer whether the receiver's year is a leap year."	^ start isLeapYear ifTrue: [1] ifFalse: [0].! !!Date methodsFor: 'as yet unclassified' stamp: 'brp 7/27/2003 16:07'!mmddyyyy	"Answer the receiver rendered in standard U.S.A format mm/dd/yyyy.	Note that the name here is slightly misleading -- the month and day numbers don't show leading zeros, 	so that for example February 1 1996 is 2/1/96"	^ self printFormat: #(2 1 3 $/ 1 1)! !!Date methodsFor: 'as yet unclassified' stamp: 'avi 2/21/2004 18:12'!month	^ self asMonth! !!Date methodsFor: 'as yet unclassified' stamp: 'avi 2/29/2004 13:10'!monthIndex	^ super month! !!Date methodsFor: 'as yet unclassified' stamp: 'spfa 3/8/2004 13:52'!onNextMonth	^ self addMonths: 1! !!Date methodsFor: 'as yet unclassified' stamp: 'spfa 3/8/2004 13:52'!onPreviousMonth	^ self addMonths: -1! !!Date methodsFor: 'as yet unclassified' stamp: 'brp 1/16/2004 14:30'!previous: dayName 	"Answer the previous date whose weekday name is dayName."	| days |	days := 7 + self weekdayIndex - (self class dayOfWeek: dayName) \\ 7.	days = 0 ifTrue: [ days := 7 ].	^ self subtractDays: days! !!Date methodsFor: 'as yet unclassified' stamp: 'ul 8/12/2014 18:32'!printFormat: formatArray 	"Answer a String describing the receiver using the argument formatArray."	^String new: 17 streamContents: [ :stream |		self printOn: stream format: formatArray ]! !!Date methodsFor: 'as yet unclassified' stamp: 'BP 5/18/2000 18:05'!printOn: aStream	self printOn: aStream format: #(1 2 3 $  3 1 )! !!Date methodsFor: 'as yet unclassified' stamp: 'brp 7/27/2003 16:05'!printOn: aStream format: formatArray 	"Print a description of the receiver on aStream using the format 	denoted the argument, formatArray: 			#(item item item sep monthfmt yearfmt twoDigits) 			items: 1=day 2=month 3=year will appear in the order given, 			separated by sep which is eaither an ascii code or character. 			monthFmt: 1=09 2=Sep 3=September 			yearFmt: 1=1996 2=96 			digits: (missing or)1=9 2=09. 		See the examples in printOn: and mmddyy"	| gregorian twoDigits element monthFormat |	gregorian := self dayMonthYearDo: [ :d :m :y | {d. m. y} ].	twoDigits := formatArray size > 6 and: [(formatArray at: 7) > 1].	1 to: 3 do: 		[ :i | 			element := formatArray at: i.			element = 1				ifTrue: [twoDigits						ifTrue: [aStream								nextPutAll: (gregorian first asString										padded: #left										to: 2										with: $0)]						ifFalse: [gregorian first printOn: aStream]].			element = 2				ifTrue: [monthFormat := formatArray at: 5.					monthFormat = 1						ifTrue: [twoDigits								ifTrue: [aStream										nextPutAll: (gregorian middle asString												padded: #left												to: 2												with: $0)]								ifFalse: [gregorian middle printOn: aStream]].					monthFormat = 2						ifTrue: [aStream								nextPutAll: ((Month nameOfMonth: gregorian middle)										copyFrom: 1										to: 3)].					monthFormat = 3						ifTrue: [aStream								nextPutAll: (Month nameOfMonth: gregorian middle)]].			element = 3				ifTrue: [(formatArray at: 6)							= 1						ifTrue: [gregorian last printOn: aStream]						ifFalse: [aStream								nextPutAll: ((gregorian last \\ 100) asString										padded: #left										to: 2										with: $0)]].			i < 3				ifTrue: [(formatArray at: 4)							~= 0						ifTrue: [aStream nextPut: (formatArray at: 4) asCharacter]]]! !!Date methodsFor: 'as yet unclassified' stamp: 'di 9/22/2000 12:47'!storeOn: aStream	aStream print: self printString; nextPutAll: ' asDate'! !!Date methodsFor: 'as yet unclassified' stamp: 'brp 7/27/2003 16:09'!subtractDate: aDate 	"Answer the number of days between self and aDate"	^ (self start - aDate asDateAndTime) days! !!Date methodsFor: 'as yet unclassified' stamp: 'brp 8/23/2003 22:05'!subtractDays: dayCount 	^ (self asDateAndTime - (dayCount days)) asDate! !!Date methodsFor: 'as yet unclassified' stamp: 'brp 8/24/2003 12:04'!weekday	"Answer the name of the day of the week on which the receiver falls."	^ self dayOfWeekName! !!Date methodsFor: 'as yet unclassified' stamp: 'brp 8/24/2003 12:04'!weekdayIndex	"Sunday=1, ... , Saturday=7"	^ self dayOfWeek! !!Date methodsFor: 'as yet unclassified' stamp: 'brp 7/27/2003 16:04'!yyyymmdd	"Format the date in ISO 8601 standard like '2002-10-22'."	^ self printFormat: #(3 2 1 $- 1 1 2)! !!Date class methodsFor: 'as yet unclassified' stamp: 'brp 8/24/2003 00:00'!dateAndTimeNow	"Answer an Array whose with Date today and Time now."	^ Time dateAndTimeNow! !!Date class methodsFor: 'as yet unclassified' stamp: 'brp 7/1/2003 13:35'!dayOfWeek: dayName 	^ Week indexOfDay: dayName! !!Date class methodsFor: 'as yet unclassified' stamp: 'brp 7/1/2003 13:59'!daysInMonth: monthName forYear: yearInteger 	^ Month daysInMonth: monthName forYear: yearInteger.! !!Date class methodsFor: 'as yet unclassified' stamp: 'brp 7/1/2003 13:53'!daysInYear: yearInteger 	^ Year daysInYear: yearInteger.! !!Date class methodsFor: 'as yet unclassified' stamp: 'BG 3/16/2005 14:57'!easterDateFor: year "  compute the easter date.    source: Physikalisch-Technische Bundesanstalt Braunschweig.    Lichtenberg, H.: Zur Interpretation der Gaussschen Osterformel                     und ihrer Ausnahmeregeln,                     Historia Mathematica 24 (1997), pp. 441-444      http://www.ptb.de/de/org/4/44/441/oste.htm  "  | k m s a d r og sz oe day |  k := year // 100.  m := 15 + (3*k + 3//4) - (8*k + 13//25).   s := 2 - (3*k + 3// 4).  a := year \\ 19.  d := 19*a + m \\ 30.  r := d//29 + ((d//28) - (d//29)* (a// 11)).  og := 21 + d - r.  sz := 7 - (year//4 + year + s\\7).  oe := 7 - (og - sz\\7).  day := og + oe.  ^day <= 31    ifTrue: [Date newDay: day month: 3 year: year ]    ifFalse: [Date newDay: day - 31 month: 4 year: year].! !!Date class methodsFor: 'as yet unclassified' stamp: 'brp 1/16/2004 14:35'!firstWeekdayOfMonth: month year: year	"Answer the weekday index of the first day in <month> in the <year>."	^ (self newDay: 1 month: month year: year) weekdayIndex! !!Date class methodsFor: 'as yet unclassified' stamp: 'brp 7/27/2003 16:01'!fromDays: dayCount 	"Days since 1 January 1901"	^ self julianDayNumber: dayCount + SqueakEpoch! !!Date class methodsFor: 'as yet unclassified' stamp: 'brp 7/27/2003 16:02'!fromSeconds: seconds	"Answer an instance of me which is 'seconds' seconds after January 1, 1901."	^ self fromDays: ((Duration seconds: seconds) days)! !!Date class methodsFor: 'as yet unclassified' stamp: 'md 7/15/2006 18:06'!fromString: aString	"Answer an instance of created from a string with format mm.dd.yyyy."	^ self readFrom: aString readStream.! !!Date class methodsFor: 'as yet unclassified' stamp: 'brp 7/1/2003 13:39'!indexOfMonth: aMonthName 	^ Month indexOfMonth: aMonthName.! !!Date class methodsFor: 'as yet unclassified' stamp: 'cmm 2/2/2012 19:49'!julianDayNumber: aJulianDayNumber 	^ self starting:		(DateAndTime			julianDayNumber: aJulianDayNumber			offset: self defaultOffset)! !!Date class methodsFor: 'as yet unclassified' stamp: 'brp 7/1/2003 13:56'!leapYear: yearInteger 	^ Year leapYear: yearInteger! !!Date class methodsFor: 'as yet unclassified' stamp: 'brp 7/1/2003 13:37'!nameOfDay: dayIndex 	^ Week nameOfDay: dayIndex ! !!Date class methodsFor: 'as yet unclassified' stamp: 'brp 7/1/2003 13:40'!nameOfMonth: anIndex 	^ Month nameOfMonth: anIndex.! !!Date class methodsFor: 'as yet unclassified' stamp: 'brp 7/27/2003 16:02'!newDay: day month: month year: year 	^ self year: year month: month day: day! !!Date class methodsFor: 'as yet unclassified' stamp: 'brp 7/27/2003 16:01'!newDay: dayCount year: yearInteger	^ self year: yearInteger day: dayCount! !!Date class methodsFor: 'as yet unclassified' stamp: 'BG 3/16/2005 14:48'!orthodoxEasterDateFor: year "  compute the easter date according to the rules of the orthodox calendar.    source:     http://www.smart.net/~mmontes/ortheast.html   "     | r1 r2 r3 r4 ra rb r5 rc date |    r1 := year \\ 19.    r2 := year \\ 4.    r3 := year \\ 7.    ra := 19*r1 + 16.    r4 := ra \\ 30.    rb := r2 + r2 + (4*r3) + (6*r4).    r5 := rb \\ 7.    rc := r4 + r5.    date := Date newDay: 3 month: 4 year: year.    ^date addDays: rc.! !!Date class methodsFor: 'as yet unclassified' stamp: 'tfel 9/1/2009 07:08'!readFrom: aStream 	"Read a Date from the stream in any of the forms:  		<day> <month> <year>		(15 April 1982; 15-APR-82; 15.4.82; 15APR82)  		<month> <day> <year>		(April 15, 1982; 4/15/82)		<year>-<month>-<day>			(1982-04-15) (ISO8601)"	| day month year parsedNumber prefix |	aStream peek = $-		ifTrue: [prefix := -1]		ifFalse: [prefix := 1].	[aStream peek isAlphaNumeric]		whileFalse: [aStream skip: 1].	aStream peek isDigit		ifTrue: [			parsedNumber := (Integer readFrom: aStream) * prefix.			(parsedNumber < 0 or: [parsedNumber > 31])				ifTrue: [year := parsedNumber]].	[aStream peek isAlphaNumeric]		whileFalse: [aStream skip: 1].	aStream peek isLetter		ifTrue: ["MM-DD-YY or DD-MM-YY or YY-MM-DD"			month := WriteStream on: (String new: 10).			[aStream peek isLetter]				whileTrue: [month nextPut: aStream next].			month := month contents.			[aStream peek isAlphaNumeric]				whileFalse: [aStream skip: 1].			parsedNumber isNil				ifTrue: ["MM DD YY"					day := Integer readFrom: aStream]				ifFalse: [					year isNil						ifTrue: ["DD MM YY"							day := parsedNumber]]]		ifFalse: ["MM-DD-YY or DD-MM-YY or YY-MM-DD"			year isNil 				ifTrue: ["MM-DD-YY or DD-MM-YY"					parsedNumber > 12						ifTrue: ["DD-MM-YY"							day := parsedNumber.							month := Month nameOfMonth: (Integer readFrom: aStream)]						ifFalse: ["MM-DD-YY"							month := Month nameOfMonth: parsedNumber.							day := Integer readFrom: aStream]]				ifFalse: ["YY-MM-DD"					month := Month nameOfMonth: (Integer readFrom: aStream)]].	[aStream peek isAlphaNumeric]		whileFalse: [aStream skip: 1].	year isNil		ifTrue: [year := Integer readFrom: aStream]		ifFalse: [day := Integer readFrom: aStream].	(year < 100 and: [year >= 0]) 		ifTrue: [			year < 69 				ifTrue: [	year := 2000 + year]				ifFalse: [year := 1900 + year]].	^ self		year: year		month: month		day: day! !!Date class methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 1/15/2010 14:04'!readFrom: inputStream pattern: pattern	"Read a Date from the stream based on the pattern which can include the tokens:			y = A year with 1-n digits		yy = A year with 2 digits		yyyy = A year with 4 digits		m = A month with 1-n digits		mm = A month with 2 digits		d = A day with 1-n digits		dd = A day with 2 digits			...and any other Strings inbetween. Representing $y, $m and $d is done using	\y, \m and \d and slash itself with \\. Simple example patterns:		'yyyy-mm-dd'		'yyyymmdd'		'yy.mm.dd'		'y-m-d'	A year given using only two decimals is considered to be >2000."	| day month year patternStream char |	patternStream := pattern readStream.	[patternStream atEnd] whileFalse: [		inputStream atEnd ifTrue: [^nil].		char := patternStream next.		char = $\			ifTrue: [inputStream next = patternStream next ifFalse: [^nil]]			ifFalse: [				char = $y					ifTrue: [						(patternStream nextMatchAll: 'yyy')							ifTrue: [year := (inputStream next: 4) asInteger]							ifFalse: [								(patternStream peekFor: $y)									ifTrue: [										year := (inputStream next: 2) asInteger]									ifFalse: [										year := Integer readFrom: inputStream]]]					ifFalse: [						char = $m							ifTrue: [								(patternStream peekFor: $m)									ifTrue: [										month := (inputStream next: 2) asInteger]									ifFalse: [										month := Integer readFrom: inputStream]]							ifFalse: [								char = $d									ifTrue: [										(patternStream peekFor: $d)											ifTrue: [												day := (inputStream next: 2) asInteger]											ifFalse: [												day := Integer readFrom: inputStream]]									ifFalse: [										inputStream next = char ifFalse: [^nil]]]]]].	(year isNil | month isNil | day isNil) ifTrue: [^nil].	^self year: year month: month day: day! !!Date class methodsFor: 'as yet unclassified' stamp: 'cmm 2/2/2012 19:18'!starting: aDateAndTime 	^ self		starting: aDateAndTime midnight		duration: Duration oneDay! !!Date class methodsFor: 'as yet unclassified' stamp: 'crl 7/7/2017 22:56'!timestamp	| today |	today := Date today.	^((String new: 64) writeStream)		nextPutAll: today weekday;		nextPutAll: ', ';		print: today;		space;		nextPutAll: Time now print24;		nextPutAll: ' local time';		contents! !!Date class methodsFor: 'as yet unclassified' stamp: 'brp 7/27/2003 16:01'!today	^ self current! !!Date class methodsFor: 'as yet unclassified' stamp: 'brp 7/1/2003 18:09'!tomorrow	^ self today next! !!Date class methodsFor: 'as yet unclassified' stamp: 'cmm 2/2/2012 19:50'!year: year day: dayOfYear 	^ self starting:		(DateAndTime			year: year			day: dayOfYear			hour: 0			minute: 0			second: 0			offset: self defaultOffset)! !!Date class methodsFor: 'as yet unclassified' stamp: 'cmm 2/2/2012 19:50'!year: year month: month day: day 	^ self starting:		(DateAndTime			year: year			month: month			day: day			hour: 0			minute: 0			second: 0			offset: self defaultOffset)! !!Date class methodsFor: 'as yet unclassified' stamp: 'brp 7/1/2003 18:09'!yesterday	^ self today previous! !!PluggableTextMorphPlus methodsFor: 'as yet unclassified' stamp: 'crl 9/7/2017 23:15'!okToStyle	^(ActiveWorld isKindOf: HTML5PasteUpMorph) not and: [ styler		ifNil:[false]		ifNotNil: [:s | model aboutToStyle: s]]! !!PluggableTextMorphPlus class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 8/15/2018 13:34'!accept	3 halt! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 12:47'!arrowDown	! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 12:45'!arrowLeft	self select: text selectionStart - 1! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 12:44'!arrowRight	self select: text selectionStart + 1! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 12:47'!arrowUp	! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 12:43'!backspace	| oldContents selectionStart selectionEnd selected |		oldContents := text value.	selectionStart := text selectionStart.	selectionEnd := text selectionEnd.	selected := selectionStart ~~ selectionEnd.		(selectionEnd > 0) ifTrue: [		self			setText: (				(WriteStream on: (String new: 32))					nextPutAll: (						oldContents copyTo: (							selected								ifTrue: [selectionStart]								ifFalse: [selectionStart - 1]));					nextPutAll: (						oldContents							copyFrom: selectionEnd + 1							to: oldContents size);					contents);			select: (				selected					ifTrue: [selectionStart]					ifFalse: [selectionStart - 1])]! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 8/15/2018 13:32'!beClean	dirty := false! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 8/15/2018 13:31'!beDirty	dirty := true! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 01:17'!beginningOfLine	self select: 0! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 3/30/2019 22:37'!clearText	"self textAreas do: [:textarea |		(self clearText: textarea) ifFalse: [^false]].		self beClean."	^true! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2019 22:14'!clearText: textarea	"dirty ifTrue: [		(			self				confirm: 'There are unsaved changes.'				withChoices: #(keep discard)		)			ifTrue: [^false]].			textarea clear."	^true! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 17:22'!connect	super connect.		JS top document at: #oncontextmenu put: (JS Function new: 'return false').	[text == nil] whileTrue: [		(Delay forSeconds: 1) wait.		text := webpage document getElementById: tag, '-text'].		text id: appID, '-text'.	self		connectToTextArea: text;		beClean! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 22:06'!connectToTextArea: textarea	{		text parentNode.		text parentNode parentNode	}		do: [:node |			node				styleAt: #display put: 'flex';				styleAt: #flex put: '1'].				(text parentNode descendantAt: 'print it') onMouseUp: [:event | self printIt].	text onKeyDown: [:event | self handleKeyDown: event counterpart]					"onContextMenu: [:event |			| activeElement |						activeElement := self activeElement.						3 halt.						self				selectUsingMenuWithBlocks: (					(Dictionary new)						at: 'inspect'						put: [							| inspector |													inspector := self inspectItFor: activeElement.													activeElement parentNode parentNode appendChild: inspector app.							inspector beDraggable];						at: 'browse'						put: [self browseIt];						yourself)				for: activeElement				at: event screenX @ event screenY];"! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 13:43'!doIt	self resultAndInsertionPointFor: text! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 12:26'!endOfLine	self select: text innerText size! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 8/23/2018 14:15'!evaluate: expression	^Compiler evaluate: expression! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 00:35'!handleKeyDown: event	"Perform modifier key side-effects."		(		(			(event metaKey)				ifTrue: [MetaKeyBindings]				ifFalse: [					(event ctrlKey)						ifTrue: [ControlKeyBindings]						ifFalse: [							^(								NormalKeyBindings									at: event key									ifAbsent: [^self insert: event key into: text]							)								value: self]]		)			at: event key			ifAbsent: [^self]	)		value: self! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 3/30/2019 13:18'!initialize	super initialize.	styler := (		(SHTextStylerST80 new)			parseAMethod: true;			yourself)! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 15:46'!insert: string into: textarea	| oldContents selectionStart |		oldContents := textarea value.	selectionStart := textarea selectionStart.		self		setText: (			((String new: 32) writeStream)				nextPutAll: (oldContents copyFrom: 1 to: selectionStart );				nextPutAll: string;				nextPutAll: (					oldContents						copyFrom: textarea selectionEnd + 1						to: oldContents size);				contents);		select: selectionStart + 1! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2019 13:30'!inspectIt	| activeElement inspector |		activeElement := self activeElement.		(activeElement class == HTMLTextAreaElement) ifTrue: [		inspector := self inspectItFor: self activeElement.		activeElement parentNode parentNode appendChild: inspector element.		inspector beDraggable]! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 8/20/2018 15:53'!inspectItFor: textarea	^HTMLSmalltalkInspector new subject: (self resultAndInsertionPointFor: textarea) first! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 8/15/2018 13:33'!okayToClose	^self clearText! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 8/23/2018 15:16'!printIt	| activeElement |		activeElement := self activeElement.		(activeElement class == HTMLTextAreaElement) ifTrue: [self printItFor: self activeElement]! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 12:42'!printItFor: textarea	| oldContents newContents resultAndInsertionPoint result insertionPoint |		oldContents := textarea value.	newContents := (String new: 32) writeStream.	resultAndInsertionPoint := self resultAndInsertionPointFor: textarea.	result := resultAndInsertionPoint first asString.	insertionPoint := resultAndInsertionPoint second.		newContents		nextPutAll: (oldContents copyFrom: 1 to: insertionPoint);		space;		nextPutAll: result;		nextPutAll: (oldContents copyFrom: insertionPoint + 1 to: oldContents size).			self		setText: newContents contents;		selectFrom: insertionPoint		to: insertionPoint + 1 + result size! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 8/24/2018 18:09'!resultAndInsertionPointFor: textarea	| oldContents start end expression result insertionPoint |		oldContents := (textarea at: #value) asString.	start := textarea selectionStart.	end := textarea selectionEnd.		(start = end)		ifTrue: [			"Copy up to the linefeed after the insertion point from the previous linefeed."			| secondHalf |						secondHalf := (oldContents copyFrom: start + 1 to: oldContents size) readStream.						expression := ((oldContents copyFrom: 1 to: start) reversed readStream upTo: Character lf) reversed, (secondHalf upTo: Character lf).			insertionPoint := start + secondHalf position - (secondHalf atEnd ifTrue: [0] ifFalse: [1]) max: 0]		ifFalse: [			insertionPoint := end min: oldContents size.			expression := oldContents copyFrom: start + 1 to: insertionPoint].				result := self evaluate: expression.		^{result. insertionPoint}! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 01:20'!select: position	self selectFrom: position to: position! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 12:48'!selectAll	self		selectFrom: 0		to: text value size! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 01:20'!selectFrom: start to: end	text		at: #selectionStart		put: start;		at: #selectionEnd		put: end! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 12:42'!setText: string	text at: #value put: string! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 17:46'!showHTML: html	self showText: html! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 17:33'!showText: someText	text value: someText! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 8/19/2018 20:05'!textAreas	^{text}! !!HTMLSmalltalkTextEditor methodsFor: 'as yet unclassified' stamp: 'crl 9/10/2019 17:36'!textEditorName	^#builtIn! !!HTMLSmalltalkTextEditor class methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 01:19'!initialize	MetaKeyBindings := (		(Dictionary new)			at: 'a' put: [:tool | tool selectAll];			at: 'd' put: [:tool | tool doIt];			at: 'p' put: [:tool | tool printIt];			at: 'i' put: [:tool | tool inspectIt];			at: 'b' put: [:tool | tool backwardWord];			at: 'f' put: [:tool | tool forwardWord];			at: 'l' put: [:tool | tool cancel];			yourself).				ControlKeyBindings := (		(Dictionary new)			at: 'a' put: [:tool | tool beginningOfLine];			at: 'e' put: [:tool | tool endOfLine];			at: 'p' put: [:tool | tool previousLine];			at: 'n' put: [:tool | tool nextLine];			yourself).				NormalKeyBindings := (		(Dictionary new)			at: 'Shift' put: [:tool | ];			at: 'Backspace' put: [:tool | tool backspace];			at: 'ArrowLeft' put: [:tool | tool arrowLeft];			at: 'ArrowRight' put: [:tool | tool arrowRight];			at: 'ArrowUp' put: [:tool | tool arrowUp];			at: 'ArrowDown' put: [:tool | tool arrowDown];			yourself)! !!DAVClass methodsFor: 'as yet unclassified' stamp: 'crl 7/14/2017 00:03'!addInstanceVariableNamed: instanceVariableName	class		addInstVarName: instanceVariableName;		compile: (			((String new: 32) writeStream)				nextPutAll: instanceVariableName;				crtab;				nextPut: $^;				nextPutAll: instanceVariableName;				contents);		compile: (			((String new: 32) writeStream)				nextPutAll: instanceVariableName;				nextPutAll: ': anObject';				crtab;				nextPutAll: instanceVariableName;				nextPutAll: ' _ anObject';				contents).	{self localSlots. self allSlots} do: [:someSlots | someSlots addInstanceVariableNamed: instanceVariableName]! !!DAVClass methodsFor: 'as yet unclassified' stamp: 'crl 1/5/2015 03:27'!class: aClass	class _ aClass.	self name: class name.	class isMeta ifFalse: [(self addSubdirectoryNamed: 'metaclass') addClass: class class].	"Calculate the contents of the subclasses subdirectory on read."	subclasses _ self addSubdirectoryNamed: 'subclasses'.		methods _ self addSubdirectoryNamed: 'methods'.	localMethods _ methods addSubdirectoryNamed: 'local'.	class selectors do: [:selector |		localMethods addSubdirectory: (			DAVMethod				forMethodAt: selector				in: class)].	slots _ self addSubdirectoryNamed: 'slots'.	localSlots _ slots addSubdirectoryNamed: 'local'.	class instVarNames do: [:instanceVariableName |		localSlots addSubdirectory: (			DAVSlot				forSlotNamed: instanceVariableName				inClass: class)]! !!DAVClass methodsFor: 'as yet unclassified' stamp: 'crl 1/4/2015 01:41'!subject	^class! !!DAVClass class methodsFor: 'as yet unclassified' stamp: 'crl 1/4/2015 01:48'!canRepresentAnInstanceOf: aClass	^aClass isMeta! !!DAVClass class methodsFor: 'as yet unclassified' stamp: 'crl 1/2/2015 17:28'!for: aClass	^self new class: aClass! !!FormStub class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:55'!foo! !!HTMLDivElement methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2017 09:50'!fullscreen	Webpage fullscreenOn! !!HTMLDivElement class methodsFor: 'as yet unclassified' stamp: 'crl 9/18/2017 16:39'!tag	^'div'! !!BalloonCanvas class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!CharacterData methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!CharacterData class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!DAVSessionResume methodsFor: 'as yet unclassified' stamp: 'crl 1/12/2015 00:16'!initialName	^'resume'! !!DAVSessionResume methodsFor: 'as yet unclassified' stamp: 'crl 1/12/2015 03:42'!progressMessage	^'Resuming...'! !!DAVSessionResume methodsFor: 'as yet unclassified' stamp: 'crl 1/15/2015 02:37'!sideEffect	"(Delay forSeconds: 1) wait.	HTTPServer activeServer close.	session resume.	HTTPServer activeServer open"! !!DAVSessionResume class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!ShortIntegerArray methodsFor: 'as yet unclassified' stamp: 'crl 2/15/2019 11:38'!asJSArgument	^self! !!DAVFile methodsFor: 'as yet unclassified' stamp: 'crl 8/19/2016 21:09'!adoptBlocksFrom: oldFile	update _ oldFile updateBlock! !!DAVFile methodsFor: 'as yet unclassified' stamp: 'crl 8/11/2016 17:56'!basicContents	^contents! !!DAVFile methodsFor: 'as yet unclassified' stamp: 'crl 1/3/2015 23:08'!container	^container! !!DAVFile methodsFor: 'as yet unclassified' stamp: 'crl 1/5/2015 12:39'!container: aDAVDirectory	container _ aDAVDirectory! !!DAVFile methodsFor: 'as yet unclassified' stamp: 'crl 8/11/2016 17:56'!contentLength	^(name = '.update')		ifTrue: [contents size]		ifFalse: [			| updateFile |			updateFile _ container fileNamed: '.update'.			(updateFile notNil and: [(contents size > 0) or: [updateFile basicContents = 'Updating...']])				ifTrue: [contents size]				ifFalse: [self contents size]]! !!DAVFile methodsFor: 'as yet unclassified' stamp: 'crl 8/11/2016 15:17'!contents	super contents.	^contents! !!DAVFile methodsFor: 'as yet unclassified' stamp: 'crl 8/9/2016 22:26'!contents: aString	self touch.	contents _ aString! !!DAVFile methodsFor: 'as yet unclassified' stamp: 'crl 1/3/2015 23:08'!delete	container delete: self! !!DAVFile methodsFor: 'as yet unclassified' stamp: 'crl 8/2/2016 12:11'!emitBodyOn: request	request nextPutAll: self responsePayload! !!DAVFile methodsFor: 'as yet unclassified' stamp: 'crl 8/12/2016 14:35'!initialize	super initialize.	contents _ ''! !!DAVFile methodsFor: 'as yet unclassified' stamp: 'crl 7/13/2017 11:45'!isDirectory	^false! !!DAVFile methodsFor: 'as yet unclassified' stamp: 'crl 7/13/2017 10:45'!moveTo: destination	| newName oldFile |	newName _ (destination reverse readStream upTo: $/) reverse.	oldFile _ container fileNamed: newName.	oldFile		ifNil: [ShadowFiles at: name put: self]		ifNotNil: [			self adoptBlocksFrom: oldFile.			oldFile delete].	name _ newName.	^true! !!DAVFile methodsFor: 'as yet unclassified' stamp: 'crl 1/3/2015 23:04'!postCopy	self container: nil! !!DAVFile methodsFor: 'as yet unclassified' stamp: 'crl 7/13/2017 10:42'!responsePayload	self update.	^contents! !!DAVFile methodsFor: 'as yet unclassified' stamp: 'crl 1/4/2015 01:09'!statusForResponseProperty: property forResource: resource	property print: (resource contentLength).	^DAVStatus ok! !!DAVFile class methodsFor: 'as yet unclassified' stamp: 'crl 8/19/2016 23:13'!initialize	ShadowFiles _ Dictionary new! !!DAVFile class methodsFor: 'as yet unclassified' stamp: 'crl 8/5/2016 00:47'!named: aString updateWith: block	^(self named: aString) update: block! !!DAVFile class methodsFor: 'as yet unclassified' stamp: 'crl 1/2/2015 18:00'!named: aString withContents: contents	^(self named: aString) contents: contents! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 1/9/2014 10:41'!add	"Add myself to the edit history."	EditHistory addModuleEdition: self! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/13/2011 16:57'!addMethodID: aMethodID	^methods add: aMethodID! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 1/9/2014 08:38'!author: anAuthor	super author: anAuthor.	description author: anAuthor.	activeTagsEdition author: anAuthor! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/9/2011 17:08'!baseID	^description baseID! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/10/2011 13:15'!classes	| classes |	classes := IdentitySet new.	methods do: [:methodID | classes add: methodID activeClass theNonMetaClass].	^classes asSortedCollection: [:earlier :later | earlier allSuperclasses size < later allSuperclasses size]! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/6/2011 03:36'!cullPrerequisitesForModules: modules	| oldPrerequisites |	prerequisites isEmpty ifTrue: [^self].	oldPrerequisites := prerequisites.	prerequisites := OrderedCollection with: oldPrerequisites first.	(oldPrerequisites copyFrom: 2) do: [:moduleID | (((self transitivePrerequisitesIn: modules resultsSoFar: IdentitySet new) collect: [:module | module id]) includes: moduleID) ifFalse: [prerequisites add: moduleID]]! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 5/17/2007 14:24'!date	^description date! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/3/2008 17:53'!defineClass: remoteClass	"Define a new class, equivalent to remoteClass, in my system."	"Create a corresponding metaclass, then instantiate a corresponding protoclass."	| remoteMetaclass superMetaclass superclass newMetaclass newClassName newClass |	remoteMetaclass := remoteClass class.	newMetaclass := Metaclass new.	"Since we're getting all our information from a live class, we don't need to do format checks. We can also assume that all the superclasses of remoteClass have already been defined."	superMetaclass := remoteMetaclass superclass id activeClass.	newMetaclass		superclass: superMetaclass		methodDictionary: MethodDictionary new		format: remoteMetaclass format;		setInstVarNames: remoteMetaclass instVarNames;		organization: nil.	superMetaclass addSubclass: newMetaclass.	remoteMetaclass overrides do: [:selector | newMetaclass installPlaceholderAt: selector].	newClass := newMetaclass new.	"Missing class pool variables and shared pools are installed, when needed, by the subsequent installation of methods which use them."	superclass := remoteClass superclass id activeClass.	newClassName := remoteClass name.	newClass		superclass: superclass		methodDict: MethodDictionary new		format: remoteClass format		name: newClassName		organization: nil		instVarNames: remoteClass instVarNames		classVariablesPool: Dictionary new		receivedPools: OrderedCollection new";		comment: remoteClass comment asString".	remoteClass overrides do: [:selector | newClass installPlaceholderAt: selector].	superclass addSubclass: newClass.	Smalltalk at: newClassName put: newClass.	SystemOrganization		classify: newClassName		under: remoteClass category! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 5/17/2007 11:32'!description	^description! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/13/2011 21:47'!description: aModuleDescription	description := aModuleDescription! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2011 15:17'!fixMethodIDs	"Replace each method ID with a selector that has spaces with a method ID with a proper selector."	methods copy do: [:methodID |		(methodID selector anySatisfy: [:character | character isSeparator]) ifTrue: [			| index |			index := 53.			[(Character value: (methodID at: index)) isSeparator] whileFalse: [index := index + 1].			methods				remove: methodID;				add: (methodID copyTo: index - 1)]]! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 1/9/2014 13:40'!fullDescription	^description description! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 5/17/2007 14:25'!id	"Answer my id."	^description id! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/12/2011 17:14'!id: aModuleID	"Set my id to aModuleID."	description id: aModuleID! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/13/2011 16:20'!initialize	"Initialize myself."	super initialize.	description := ModuleDescription new.	prerequisites := Set new.	methods := Set new! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2008 15:50'!initializeClassWithID: aClassID	"Initialize the class with ID aClassID."	aClassID activeClass initialize! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2011 17:54'!initializePrerequisites	prerequisites := Set new! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/3/2012 16:39'!installClassEdition: aClassEdition	aClassEdition install! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/16/2011 03:01'!installMethodEdition: aMethodEdition	| installedID oldID |	installedID := aMethodEdition install id.	oldID := (		methods			detect: [:methodID | methodID classID = installedID classID and: [methodID selector = installedID selector and: [methodID authorID = installedID authorID]]]			ifNone: [nil]).	oldID == nil ifFalse: [methods remove: oldID].	methods add: installedID! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/18/2008 14:05'!installProtoclassEdition: aProtoclassEdition withMetaclassEdition: aMetaclassEdition	aProtoclassEdition installWithMetaclassEdition: aMetaclassEdition! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/3/2012 15:07'!manifestForClassIDs: classIDs	"Answer a description of which classes corresponding to classIDs are present in the local system."	^classIDs manifestFor: [:classID | self seesClassWithID: classID]! !!ModuleEdition methodsFor: 'as yet unclassified'!manifestForMethodIDs: methodIDs	"Answer a description of which methods corresponding to methodIDs are present in the local system."	^methodIDs manifestFor: [:methodID | self seesMethodWithID: methodID]! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2011 14:44'!methods	^methods! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/13/2011 21:46'!methods: aCollection	methods := aCollection! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 5/17/2007 14:25'!name	"Answer my name."	^description name! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 5/17/2007 14:25'!name: aString	"Set my name to aString."	description name: aString! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/9/2011 17:23'!newPrerequisite	"Answer a new local module to record prerequisites for me."	^ModuleEdition new! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2011 21:20'!prerequisites	^prerequisites! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/13/2011 21:46'!prerequisites: aCollection	prerequisites := aCollection! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/6/2011 03:39'!prerequisitesIn: modules	^prerequisites collect: [:moduleID | modules detect: [:module | module id = moduleID]]! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 5/17/2007 14:52'!printOn: aStream	"Write a textual representation of myself to aStream."	description printOn: aStream! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/16/2011 11:54'!provide: provisions to: remoteModule retrievingManifestVia: manifestRetrievalBlock	"Provide the elements of provisions to remoteModule, retrieving a summary of what it needs via manifestRetrievalBlock."	| sequencedProvisions |	sequencedProvisions := provisions asArray.	(		manifestRetrievalBlock value: (			sequencedProvisions collect: [:provision | provision id])	)		completeVia: [:index |			| provision |			provision := sequencedProvisions at: index.			"Transcript				cr;				nextPutAll: 'providing ';				print: provision;				nextPutAll: '...'; endEntry."			provision installVia: remoteModule.			"Transcript				nextPutAll: ' done';				endEntry"]! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2007 11:33'!require: aModule	"Add aModule to my prerequisites."	prerequisites add: aModule id! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/11/2011 13:54'!searchingLinkForTag: tag	^self searchingLinkForTag: tag named: tag! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/12/2011 15:02'!searchingLinkForTag: tag named: title	| stream |	stream := (String new: 32) writableStream.	stream		nextPutAll: '<a href="http://www.google.com/cse?cx=014544899280474072937%3A424tpybcglk&ie=UTF-8&q=';		nextPutAll: (tag copyReplaceAll: ' ' with: '%20').	('*-*-*-*-*' match: tag) ifFalse: [stream nextPutAll: '%208B430E53-E882-4786-A562-8F1FEB84F684'].	stream		nextPutAll: '&sa=Search&siteurl=www.google.com%2Fcse%2Fhome%3Fcx%3D014544899280474072937%3A424tpybcglk';		nextPutAll: '">';		nextPutAll: title;		nextPutAll: '</a>'.	^stream contents! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/6/2012 13:04'!seesClassWithID: aClassID	"Answer whether I can see, in the local system, the class corresponding to aMethodID."	^EditHistory includesActiveClassWithID: aClassID! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/3/2008 17:53'!seesMethodNamedByID: aMethodID	"Answer whether I can see, in the local system, the method corresponding to aMethodID, but any version, any author."	^(aMethodID activeClass == nil)		ifTrue: [false]		ifFalse: [			(aMethodID activeClass)				compiledMethodAt: aMethodID selector				ifAbsent: [^false].			true]! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 6/30/2008 17:14'!seesMethodWithID: aMethodID	"Answer whether I can see, in the local system, the method corresponding to aMethodID."	^EditHistory includesActiveMethodWithID: aMethodID! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2011 14:49'!selectors	| selectors |	selectors := IdentitySet new.	methods do: [:methodID | selectors add: methodID selector].	^selectors! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2011 03:04'!selectorsAt: class	^((methods select: [:methodID | methodID activeClass == class]) collect: [:methodID | methodID selector]) asSortedCollection! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/6/2011 03:40'!sentSelectors	| sentSelectors |	sentSelectors := IdentitySet new.	methods do: [:methodID | sentSelectors addAll: methodID sentSelectors].	^sentSelectors! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/6/2011 03:04'!setInitialPrerequisitesFromModules: modules	| sentSelectors |	sentSelectors := IdentitySet new.	methods do: [:methodID | sentSelectors addAll: methodID sentSelectors].	prerequisites := (modules select: [:module | module selectors includesAnyOf: sentSelectors]) collect: [:module | module id]! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 5/17/2007 14:25'!site	^description site! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/9/2011 19:13'!site: aString	description site: aString! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/26/2016 19:42'!spaceDelimitedListFromStrings: stringsArray	"Answer a space-delimited string composed from the strings in stringsArray."	^(stringsArray isEmpty)		ifTrue: ['']		ifFalse: [			| stream |			stream := WriteStream on: (String new: 16).			stringsArray do: [:string |				stream					nextPutAll: string;					space].			stream skipBack; contents]! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/13/2011 21:44'!storeOnProxyStream: aStream for: aMessagingSession	super storeOnProxyStream: aStream for: aMessagingSession.	aMessagingSession		store: prerequisites;		store: methods;		store: description! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 5/17/2007 14:25'!summary	^description summary! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/7/2012 19:09'!synchronizeWith: remoteModule	"Synchronize myself with remoteModule, synchronizing our respective systems in the process."	"Note that, for security reasons, all message-sending is one-way, from this system (providing) to the remote system (consuming)."	"Note that, on the remote side, little attention has yet been paid to possible traffic optimizations. It'd be better to let the message interface stabilize first."	remoteModule		name: self name;		id: self id.	"Ensure that remoteModule's system is synchronized with all my prerequisite modules."	prerequisites do: [:moduleID |		(			EditHistory				activeModuleEditionWithID: moduleID				ifAbsent: [self error: 'A prerequisite module is missing.']		)			synchronizeWith: remoteModule newPrerequisite].	"Ensure that remoteModule's system has all the affected classes."	self		provide: (methods collect: [:methodID | methodID classID])		to: remoteModule		retrievingManifestVia: [:provisionIDs | remoteModule manifestForClassIDs: provisionIDs].	"Ensure that remoteModule's system has all the added methods."	"For each method...	- Make sure remoteModule's system has its overrides, if any, so that the transferred method won't mistakenly get run instead of an override later. See >>defineOverridesOfMethodWithSelector:via: for an old approach.	- Make sure remoteModule's system has all the classes referred to in the transferred method's literals. See >>ensureClassVia:.	- Make sure remoteModule's system has the methods for any self-send messages the transferred method contains (so that remoteModule's system won't run some existing superclass method by mistake). See >>messagesSentToSelfDo:andMessagesSentToSuperDo:withClass: and >>definePrerequisiteMethodNamed:asSeenFrom:via:.	- If the transferred method performs a super-send, make sure remoteModule's system has the super method in question (the behavior where it lives has already been defined in the process of defining aClass)."	self		provide: methods		to: remoteModule		retrievingManifestVia: [:provisionIDs | remoteModule manifestForMethodIDs: provisionIDs]! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2016 15:32'!tag	^ModuleEditionTag! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/6/2011 02:54'!transitivePrerequisitesIn: modules resultsSoFar: results	prerequisites do: [:moduleID |		| prerequisite |		prerequisite := modules detect: [:each | each id = moduleID].		(results includes: prerequisite) ifFalse: [			results				add: prerequisite;				addAll: (					prerequisite						transitivePrerequisitesIn: modules						resultsSoFar: results)]].	^results! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 5/17/2007 14:25'!version	^description version! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2011 13:32'!version: aVersion	^description version: aVersion! !!ModuleEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/17/2011 21:32'!webpage	| stream |	stream := (String new: 800) writableStream.	stream		nextPutAll: '<html><head><title>Naiad module: ';		nextPutAll: self name;		nextPutAll: ' by ';		print: author;		nextPutAll: '</title><body>';		cr;		nextPutAll: '<pre>';		nextPutAll: 'Naiad module: ';		nextPutAll: (			self				searchingLinkForTag: self baseID printString				named: self name);		cr: 2;		nextPutAll: 'author: ';		nextPutAll: (			self				searchingLinkForTag: author id printString				named: author name);		cr: 2;		nextPutAll: 'license: ';		nextPutAll: (			self				searchingLinkForTag: license class baseID printString				named: license printString);		cr: 2;		nextPutAll: 'description: ';		cr: 2;		nextPutAll: (			('     ', description description)				filledTo: 70				withNewlineString: Character cr asString);		cr: 2;		nextPutAll: 'current version: ';		print: self version;		cr: 2;		nextPutAll: 'timestamp: ';		print: timestamp;		cr: 2;		nextPutAll: 'tags:'.	self tags do: [:tag |		stream			space;			nextPutAll: (self searchingLinkForTag: tag)].	stream		cr: 2;		nextPutAll: 'prerequisites:'.	(prerequisites size = 1)		ifTrue: [			stream				space;				nextPutAll: (self searchingLinkForTag: prerequisites only baseID printString)]		ifFalse: [			prerequisites do: [:prerequisite |				stream					cr;					nextPutAll: '     ';					nextPutAll: (self searchingLinkForTag: prerequisite baseID printString)]].	stream		cr: 2;		nextPutAll: '<a href="';		nextPutAll: (InstallRemoteModule forModule: self) encoded;		nextPutAll: '">';		nextPutAll: 'installation link';		nextPutAll: '</a>';		space;		nextPutAll: '(for those who have a Spoon system running locally, resolves to ';		nextPutAll: self site hostname;		nextPut: $);		cr;		nextPutAll: '<br><hr><br>IDs relevant to this module:';		cr: 2;		space: 11;		nextPutAll: 'Naiad master tag: 8B430E53-E882-4786-A562-8F1FEB84F684';		cr;		space: 6;		nextPutAll: 'this module''s base ID: ';		print: self baseID;		cr;		space: 2;		nextPutAll: 'this module''s author''s ID: ';		print: self author id;		cr;		space;		nextPutAll: 'this module''s license''s ID: ';		print: license class baseID.	prerequisites isEmpty ifFalse: [		stream			cr;			space: 4;			nextPutAll: 'prerequisite module IDs: ';			print: prerequisites first baseID.		(prerequisites size > 1) ifTrue: [			(prerequisites copyFrom: 2) do: [:prerequisite |				stream					cr;					space: 29;					print: prerequisite baseID]]].	stream nextPutAll: '</pre></body></html>'.	^stream contents! !!ModuleEdition class methodsFor: 'as yet unclassified' stamp: 'crl 11/12/2014 08:58'!modularize	"self modularize"	| modules |	modules := OrderedCollection new.	ModularizationStream := StandardFileStream fileNamed: '/Users/craig/me/tmp/modularization.txt'.	[		[ModularizationStream atEnd] whileFalse: [			| token module class |			token := self nextToken.			(IndentLevel < 9)				ifTrue: [module := modules add: (ModuleEdition named: token)]				ifFalse: [					(IndentLevel = 9)						ifTrue: [class := Smalltalk at: token]						ifFalse: [							| selector meta |							selector := token.							meta := '(class)*' match: selector.							meta ifTrue: [selector := (selector copyFrom: 9) asSymbol].							module addMethodID: (								(									MethodID										forVersion: 1										ofMethodAt: selector										inActiveClass: (											meta												ifTrue: [class class]												ifFalse: [class])								)									methodAuthorID: Author current id;									yourself)]]]	]		ensure: [ModularizationStream close].	^modules! !!ModuleEdition class methodsFor: 'as yet unclassified' stamp: 'crl 11/12/2014 08:58'!named: aString	^(self new)		name: aString;		author: Author current;		yourself! !!ModuleEdition class methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2011 02:10'!nextToken	| token peek |	token := (String new: 16) writableStream.	IndentLevel := 0.	[		peek := ModularizationStream peek.		peek isSeparator or: [peek isDigit or: [peek = $.]]	]		whileTrue: [			ModularizationStream next.			IndentLevel := (				(peek = Character lf)					ifTrue: [0]					ifFalse: [IndentLevel + 1])].	[ModularizationStream peek = Character lf] whileFalse: [token nextPut: ModularizationStream next].	^token contents asSymbol! !!ModuleEdition class methodsFor: 'as yet unclassified' stamp: 'crl 7/13/2011 21:46'!readFromProxyStream: aStream for: aMessagingSession	^(super readFromProxyStream: aStream for: aMessagingSession)		prerequisites: aMessagingSession next;		methods: aMessagingSession next;		description: aMessagingSession next;		yourself! !!SpecialSelectorNode class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!I methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!I class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!ClassChangeRecord class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!FutureNode class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!FileServices methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!ClassCategoryReader class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!Author methodsFor: 'as yet unclassified' stamp: 'crl 11/6/2014 09:22'!died: aBoolean	died := aBoolean! !!Author methodsFor: 'as yet unclassified' stamp: 'crl 11/6/2014 09:22'!emailAddress: aString	emailAddress := aString! !!Author methodsFor: 'as yet unclassified' stamp: 'crl 11/6/2014 09:22'!id	^id! !!Author methodsFor: 'as yet unclassified' stamp: 'crl 11/6/2014 09:22'!id: aUUID	id := aUUID! !!Author methodsFor: 'as yet unclassified' stamp: 'crl 11/6/2014 09:23'!initialize	"Initialize myself."	self		id: UUID new;		died: false! !!Author methodsFor: 'as yet unclassified' stamp: 'crl 11/6/2014 09:23'!name	^name! !!Author methodsFor: 'as yet unclassified' stamp: 'crl 11/6/2014 09:23'!name: aString	name := aString! !!Author methodsFor: 'as yet unclassified' stamp: 'crl 11/6/2014 09:23'!printOn: aStream	aStream nextPutAll: name.	emailAddress ifNotNil: [		aStream			nextPutAll: ' <';			nextPutAll: emailAddress;			nextPut: $>]! !!Author methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 15:45'!storeOnTether: tether	tether		nextWordPut: self tag;		store: id;		store: name;		store: emailAddress;		store: website;		store: died! !!Author methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 16:16'!tag	^AuthorTag! !!Author methodsFor: 'as yet unclassified' stamp: 'crl 11/6/2014 09:24'!website: aString	website := aString! !!Author class methodsFor: 'as yet unclassified' stamp: 'crl 11/12/2014 08:55'!current	^CurrentAuthor! !!Author class methodsFor: 'as yet unclassified' stamp: 'crl 11/14/2014 17:09'!currentAuthor: anAuthor	CurrentAuthor := anAuthor! !!Author class methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 18:50'!fromTether: tether	^(self new)		id: tether next;		name: tether next;		emailAddress: tether next;		website: tether next;		died: tether next! !!Author class methodsFor: 'as yet unclassified' stamp: 'crl 11/11/2014 20:55'!initialize	AnUnknownAuthor := (		(self named: 'an unknown author')			id: (UUID fromString: '292CE1ED-304D-4578-A31D-A53DB458CF6D');			yourself).	CurrentAuthor := AnUnknownAuthor! !!Author class methodsFor: 'as yet unclassified' stamp: 'crl 11/6/2014 09:25'!named: aString	^self new name: aString! !!Author class methodsFor: 'as yet unclassified' stamp: 'crl 11/6/2014 09:50'!new	^super new initialize! !!True methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 19:46'!storeOnTether: tether
	tether nextWordPut: TrueTag! !!True methodsFor: 'as yet unclassified' stamp: 'crl 8/20/2017 13:45'!yourselfIfTrueDoFirst: aBlockClosure	aBlockClosure value.	^self! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2012 12:50'!activateClassEdition: aClassEdition	aClassEdition author ifNotNil: [self rememberAuthor: aClassEdition author].	self addClassEdition: aClassEdition.	lastEdit := lastEdit nextEditConveying: aClassEdition! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2012 12:53'!activateMethodEdition: aMethodEdition	aMethodEdition author ifNotNil: [self rememberAuthor: aMethodEdition author].	(activeClassEditions at: aMethodEdition classBaseID) activateMethodEdition: aMethodEdition.	lastEdit := lastEdit nextEditConveying: aMethodEdition.	^aMethodEdition! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2012 11:02'!activateModuleEdition: aModuleEdition	self addModuleEdition: aModuleEdition.	lastEdit := lastEdit nextEditConveying: aModuleEdition! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 1/12/2009 14:47'!activeClassNames	"Answer a sorted (alphabetical) collection of the names of all the active classes."	| activeClassNames |	activeClassNames := SortedCollection new.	activeClassEditions valuesDo: [:classEdition | classEdition isMeta ifFalse: [activeClassNames add: classEdition name]].	^activeClassNames! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 9/30/2016 17:32'!activeEditionForClassNamed: className	^activeClassEditions detect: [:edition | edition name = className] ifNone: [nil]! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2008 16:23'!activeEditionForClassWithBaseID: aUUID	^activeClassEditions at: aUUID ifAbsent: [nil]! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 6/30/2008 17:39'!activeMethodEditionWithID: aMethodID	^(activeClassEditions at: aMethodID classBaseID ifAbsent: [^nil]) activeMethodEditionWithID: aMethodID! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 7/15/2011 21:46'!activeMethodEditionsMatching: aMethodIDPattern	| editions |	editions := OrderedCollection new.	activeClassEditions do: [:classEdition | editions addAll: (classEdition activeMethodEditionsMatching: aMethodIDPattern)].	^editions! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 7/13/2011 21:34'!activeModuleEditionWithID: aModuleID ifAbsent: aBlockClosure	| moduleEdition |	moduleEdition := (		activeModuleEditions			at: aModuleID baseID			ifAbsent: [^aBlockClosure value]).	^(moduleEdition id = aModuleID)		ifTrue: [moduleEdition]		ifFalse: [aBlockClosure value]! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 3/31/2008 20:25'!addClassEdition: aClassEdition	| classBaseID previousClassEdition |	classBaseID := aClassEdition classBaseID.	previousClassEdition := activeClassEditions at: classBaseID ifAbsent: [nil].	previousClassEdition ifNotNil: [		previousClassEdition nextEdition: aClassEdition.		aClassEdition previousEdition: previousClassEdition].	^activeClassEditions at: classBaseID put: aClassEdition! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 7/9/2011 17:08'!addModuleEdition: aModuleEdition	| moduleBaseID previousModuleEdition |	moduleBaseID := aModuleEdition baseID.	previousModuleEdition := activeModuleEditions at: moduleBaseID ifAbsent: [nil].	previousModuleEdition ifNotNil: [		previousModuleEdition nextEdition: aModuleEdition.		aModuleEdition previousEdition: previousModuleEdition].	^activeModuleEditions at: moduleBaseID put: aModuleEdition! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/14/2016 20:11'!allAccessesTo: instVarName from: aClass
	"Return a sequence of MethodReferences of all methods of aClass or it's sub/superclass that refer to the instance variable instVarName."
	
	| result |
	
	result := OrderedCollection new.
	
	aClass withAllSubAndSuperclassesDo: [:class | 
		(class whichSelectorsAccess: instVarName) do: [:selector | result add: (class referenceToSelector: selector)]].
	
	^result! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 19:19'!allBehaviors	^Generator on: [ :generator |		self allBehaviorsDo: [ :each |			generator yield: each ] ]! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 19:20'!allBehaviorsDo: aBlock 	"Evaluate the argument, aBlock, for each kind of Behavior in the system 	(that is, Object and its subclasses and Traits).	ar 7/15/1999: The code below will not enumerate any obsolete or anonymous	behaviors for which the following should be executed:		Smalltalk allObjectsDo:[:obj| obj isBehavior ifTrue:[aBlock value: obj]].	but what follows is way faster than enumerating all objects."	self allClassesAndTraitsDo: [ :class |		aBlock value: class.		class isTrait ifFalse: [ "class of a Trait is Trait, there are no MetaTraits"			aBlock value: class class ] ]! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 19:19'!allCallsOn: aLiteral 	"Answer a sorted collection of all the methods that call on aLiteral even deeply embedded in literal array."	"self default browseAllCallsOn: #open:label:."		^self systemNavigation		allCallsOn: aLiteral		fromBehaviors: self allBehaviors		sorted: true! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 22:51'!allCallsOn: aLiteral fromBehaviors: behaviors sorted: sorted	"Answer a collection of all the methods implemented by behaviors that call on aLiteral even deeply embedded in literal array."		| result special thorough byte |	result := OrderedCollection new.	special := Smalltalk hasSpecialSelector: aLiteral ifTrueSetByte: [ :b | byte := b ].	"Possibly search for symbols imbedded in literal arrays"	thorough := aLiteral isSymbol and: [ self class thoroughSenders ].	behaviors do: [ :behavior |		| list | 		list := behavior whichSelectorsReferTo: aLiteral special: special byte: byte thorough: thorough.		list do: [ :selector |			result add: (MethodReference class: behavior selector: selector environment: self) ] ].	sorted ifTrue: [ result sort ].	^result! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/10/2016 11:04'!allCallsOnClass: aBehavior	"Answer a sorted collection of all the methods that refer to aBehavior."		| theClass result |	theClass := aBehavior theNonMetaClass.	result := self 		allCallsOn: (			self class thoroughSenders				ifTrue: [  theClass name ]				ifFalse: [ self bindingOf: theClass name ])		fromBehaviors: self allBehaviors		sorted: false.	self allClassesDo: [ :class |		(class sharedPools includes: theClass) ifTrue: [			result add: (ClassReference class: class) ] ].	^result sort! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 19:21'!allClassesAndTraitsDo: aBlock		self		allClassesDo: aBlock;		allTraitsDo: aBlock! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 19:22'!allClassesDo: aBlock	"Evaluate the argument, aBlock, for each class in the system."	activeClassEditions do: [ :edition |		aBlock value: edition ]! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 21:44'!allImplementorsOf: aSelector 	"Answer a sorted collection of all the methods which are named aSelector."		| result |	result := OrderedCollection new.	self allBehaviorsDo: [ :class |		(class includesSelector: aSelector) ifTrue: [			result add: (MethodReference class: class selector: aSelector environment: self) ] ].	^result sort! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/14/2016 20:12'!allStoresInto: varName from: aClass 
	"Answer a sequence of MewthodReferences for all the receiver's methods 
	 or any methods of a subclass/superclass that assign to the instance variable name."
	"self new allStoresInto: 'contents' from: Collection."
	| result roots |
	result := OrderedCollection new.
	(aClass theNonMetaClass inheritsFrom: SharedPool) ifTrue:
		[roots := self allClasses select: [:class| class sharedPools includes: aClass theNonMetaClass].
		  roots do:
			[:root|
			 root withAllSubclassesDo:
				[:class|
				 (class whichMethodsStoreInto: varName), 
				 (class class whichMethodsStoreInto: varName) do:
					[:eachMethod|
					 result add: eachMethod methodReference]]]].
	aClass withAllSubAndSuperclassesDo:
		[ : class |
		(class theNonMetaClass whichMethodsStoreInto: varName),
		(class theMetaClass whichMethodsStoreInto: varName) do:
			[ : eachMethod |
			result add: eachMethod methodReference ] ].
	^result! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 21:41'!allTraitsDo: aBlock! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2008 19:57'!applyComment: aString toActiveClassWithBaseID: classBaseID	(activeClassEditions at: classBaseID ifAbsent: [^self]) applyComment: aString! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/30/2008 21:33'!associateActiveProtoclassWithBaseID: protoclassBaseID withActiveMetaclassWithBaseID: metaclassBaseID	| protoclassEdition metaclassEdition |	protoclassEdition := activeClassEditions at: protoclassBaseID.	metaclassEdition := activeClassEditions at: metaclassBaseID.	protoclassEdition counterpartID: metaclassEdition id.	metaclassEdition counterpartID: protoclassEdition id! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/11/2016 17:33'!associationAt: aSymbol ifAbsent: aBlock	^self bindingOf: aSymbol! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 14:44'!at: className ifPresent: block	activeClassEditions do: [:edition |		edition name = className ifTrue: [			block value: edition.			^edition]].	^nil! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 3/19/2019 04:16'!beTether	tethering := true! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/12/2016 00:33'!bindingOf: symbol	| edition |		edition := (		activeClassEditions			detect: [:each | each name = symbol]			ifNone: [nil]).				^edition		ifNil: [nil]		ifNotNil: [edition nameLiteral]! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/14/2016 20:10'!browseAllAccessesTo: instVarName from: aClass
	"Create and schedule a Message Set browser for all the receiver's methods or any methods of a subclass/superclass that refer to the instance variable name."
	"self new browseAllAccessesTo: 'contents' from: Collection."
	
	^ self 
		browseMessageList: [ (self allAccessesTo: instVarName from: aClass) sort ]
		name: 'Accesses to ' , instVarName 
		autoSelect: instVarName! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 19:18'!browseAllCallsOn: aLiteral	self systemNavigation browseAllCallsOn: aLiteral in: self! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/14/2016 20:07'!browseAllCallsOn: aLiteral in: environment
	"Create and schedule a message browser on each method that refers to aLiteral."
	"self default browseAllCallsOn: #open:label:."

	self headingAndAutoselectForLiteral: aLiteral do: [ :label :autoSelect |
		self
			browseMessageList: [ environment allCallsOn: aLiteral ]
			name: label
			autoSelect: autoSelect]! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/10/2016 11:01'!browseAllCallsOnClass: aBehavior	"Create and schedule a message browser on each method that refers to aBehavior."	"self default browseAllCallsOnClass: Array"		| behaviorName |	behaviorName := aBehavior theNonMetaClass name.	super systemNavigation		browseMessageList: [ self allCallsOnClass: aBehavior ]		name: 'Users of ', behaviorName		autoSelect: behaviorName! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 22:59'!browseAllImplementorsOf: selector 	"Create and schedule a message browser on each method that implements 	the message whose selector is the argument, selector. For example,  	Smalltalk browseAllImplementorsOf: #at:put:."	^ super systemNavigation		browseMessageList: (self allImplementorsOf: selector)		name: 'Implementors of ' , selector! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/14/2016 20:12'!browseAllStoresInto: varName from: aClass
	"Create and schedule a Message Set browser for all the receiver's methods 
	or any methods of a subclass/superclass that refer to the instance variable name."
	"self new browseAllStoresInto: 'contents' from: Collection."
	^ self
		browseMessageList: (self allStoresInto: varName from: aClass)
		name: 'Stores into ' , varName
		autoSelect: varName! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/14/2016 20:08'!browseMessageList: messageListOrBlock name: labelString autoSelect: autoSelectString
	"Create and schedule a MessageSet browser on the message list. If messageListOrBlock is a block, then evaluate it to get the message list."

	| messageList title |
	messageList := messageListOrBlock isBlock
		ifTrue: [ Cursor wait showWhile: messageListOrBlock ]
		ifFalse: [ messageListOrBlock ].
	messageList size = 0 ifTrue: [
		^self inform: 'There are no', String cr, labelString ].
	title := messageList size > 1
		ifFalse: [ labelString ]
		ifTrue: [ labelString, ' [', messageList size printString, ']' ].
	ToolSet 
		browseMessageSet: messageList 
		name: title 
		autoSelect: autoSelectString! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/14/2016 20:11'!browseVariableAssignments: aClass 
	aClass chooseVarThenDo:
		[ : aVar | self
			browseAllStoresInto: aVar
			from: aClass ]! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/14/2016 20:09'!browseVariableReferences: aClass
	aClass chooseVarThenDo:
		[ : aVar | (aClass allInstVarNames includes: aVar)
			ifTrue:
				[ self
					browseAllAccessesTo: aVar
					from: aClass ]
			ifFalse: [ self browseAllCallsOn: aVar ] ]! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/1/2016 00:48'!classEditionWithID: aClassID	^aClassID		ifNil: [nil]		ifNotNil: [			(				activeClassEditions					at: aClassID classBaseID					ifAbsent: [^nil]			)				editionWithID: aClassID]! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 23:00'!confirmRemovalOf: aSelector on: aClass 	"Determine if it is okay to remove the given selector. Answer 1 if it  	should be removed, 2 if it should be removed followed by a senders  	browse, and 3 if it should not be removed."	| count answer caption allCalls |	allCalls := self allCallsOn: aSelector.	(count := allCalls size) = 0		ifTrue: [^ 1].	"no senders -- let the removal happen without warning"	count = 1		ifTrue: [(allCalls first actualClass == aClass					and: [allCalls first methodSymbol == aSelector])				ifTrue: [^ 1]].	"only sender is itself"	caption := 'This message has ' , count printString , ' sender'.	count > 1		ifTrue: [caption := caption copyWith: $s].	answer := UIManager default 		chooseFrom: #('Remove it'				'Remove, then browse senders'				'Don''t remove, but show me those senders'				'Forget it -- do nothing -- sorry I asked') title: caption.	answer = 3		ifTrue: [super systemNavigation				browseMessageList: allCalls				name: 'Senders of ' , aSelector				autoSelect: aSelector keywords first].	answer = 0		ifTrue: [answer := 3].	"If user didn't answer, treat it as cancel"	^ answer min: 3! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 7/6/2008 15:38'!createCheckpointNamed: aString	activeCheckpoint := activeCheckpoint nextCheckpointNamed: aString.	lastEdit := lastEdit nextEditConveying: activeCheckpoint! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 4/1/2008 19:28'!currentAndRemovedSelectorsForClassWithBaseID: aUUID	| edition selectors |	edition := activeClassEditions at: aUUID ifAbsent: [^#()].	selectors := IdentitySet new.	[edition == nil] whileFalse: [		selectors addAll: edition selectors.		edition := edition previousEdition].	^selectors! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 11/13/2014 16:54'!currentAuthor	^currentAuthor! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 11/13/2014 16:55'!currentAuthor: anAuthor	currentAuthor := anAuthor! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 6/1/2009 17:34'!duplicateOn: remoteEditHistory	"just duplicate the activeClassEditions, do the rest manually"	activeClassEditions do: [:classEdition | classEdition duplicateOn: remoteEditHistory]! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/1/2016 22:00'!editionForActiveClassNamed: className	^activeClassEditions detect: [:edition | edition isMeta not and: [edition name = className]] ifNone: [nil]! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2016 14:24'!editionForActiveMethodAt: selector inClassWithBaseID: aUUID	^(activeClassEditions at: aUUID ifAbsent: [^nil]) activeMethodEditionAt: selector! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 11/16/2008 17:42'!editionOfMethodAt: selector inClassWithBaseID: aUUID	"Answer the most recent edition of that class with an edition of that method."	^(activeClassEditions at: aUUID ifAbsent: [^nil]) editionOfMethodAt: selector	! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 9/29/2016 20:43'!editionsForActiveClassesWithSuperclassID: classID	^activeClassEditions select: [:edition | edition superclassID = classID]! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 4/14/2008 16:10'!editionsOfClassesNamed: className	"Every class could have had that name in the past, so this is a relatively expensive operation."	| editions |	editions := OrderedCollection new.	activeClassEditions do: [:edition | edition isMeta ifFalse: [editions addAll: (edition editionsOfClassesNamed: className)]].	^editions ! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2008 19:26'!editionsOfMethodAt: selector inClassWithBaseID: aUUID	"Find the most recent edition of that class with an edition of that method, then ask that method edition for a collection of itself and all its predecessors."	^(activeClassEditions at: aUUID) editionsOfMethodAt: selector	! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/14/2016 20:07'!headingAndAutoselectForLiteral: aLiteral do: binaryBlock 
	"Evaluate binaryBlock with either Users of ... or Senders of ... plus the auto-select string for the given literal.  aLiteral can be a Symbol, a VariableBinding or an arbitrary object."
	| autoSelect |
	^ aLiteral isSymbol
		ifTrue:
			[ binaryBlock
				value: 'Senders of ' , aLiteral
				value: (aLiteral keywords ifEmpty: [aLiteral] ifNotEmpty: [:keys | keys first]) ]
		ifFalse:
			[ autoSelect := aLiteral isVariableBinding
				ifTrue: [ aLiteral key ]
				ifFalse: [ aLiteral printString ].
			binaryBlock
				value: 'Users of ' , autoSelect
				value: autoSelect ]! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 1/21/2011 21:07'!id	^id! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/1/2016 00:44'!idForActiveClassWithBaseID: aUUID	^(activeClassEditions at: aUUID ifAbsent: [^nil]) id! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 12/6/2014 00:18'!idForActiveMethodAt: selector inClassWithBaseID: aUUID	^((activeClassEditions at: aUUID ifAbsent: [^nil]) activeMethodEditionAt: selector) id! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 9/3/2012 16:04'!includesActiveClassWithID: aClassID	"Answer whether the system includes an active class with ID aClassID."	| edition |	edition := activeClassEditions at: aClassID classBaseID ifAbsent: [^false].	^edition adds and: [edition id = aClassID]! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 7/3/2008 14:41'!includesActiveMethodWithID: aMethodID	"Answer whether the system includes an active method with ID aMethodID."	activeClassEditions do: [:classEdition |		(classEdition includesActiveMethodWithID: aMethodID) ifTrue: [^true]].	^false! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 3/19/2019 04:17'!initialize	"Initialize myself."	id := UUID new.	activeModuleEditions := Dictionary new.	activeClassEditions := Dictionary new.	knownAuthors := Dictionary new.	self rememberAuthor: Author current.	activeCheckpoint := Checkpoint named: 'the minimal state' following: nil.	lastEdit := Edit conveying: activeCheckpoint following: nil.	tethering := false! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 3/4/2008 21:04'!installedModules	^activeModuleEditions values! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 3/19/2019 04:17'!isTether	^tethering! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2016 17:15'!knownAuthorWithID: authorID	^knownAuthors at: authorID ifAbsent: [nil]! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2016 17:16'!knownAuthorWithName: authorName	^(knownAuthors values)		detect: [:edition | edition name = authorName]		ifNone: [nil]! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2016 17:16'!knowsAuthorWithID: authorID	"Answer whether the system includes a known author with ID authorID."	^knownAuthors includesKey: authorID! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 1/10/2011 04:28'!lastEdit	^lastEdit! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 1/10/2011 04:27'!lastEdit: anEdit	lastEdit := anEdit! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 7/9/2011 17:20'!newModuleToSynchronizeWith: remoteModule	^activeModuleEditions		at: remoteModule baseID		put: (ModuleEdition new id: remoteModule id)! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 22:48'!numberOfImplementorsOf: aSelector 	"Answer a count of the implementors of the given selector found in the  	system"	"self new numberOfImplementorsOf: #contents.  	self new numberOfImplementorsOf: #nobodyImplementsThis.  	self new numberOfimplementorsOf: #numberOfImplementorsOf:."	| aCount |	aCount := 0.	self		allBehaviorsDo: [:class | (class includesSelector: aSelector)				ifTrue: [aCount := aCount + 1]].	^ aCount! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 9/26/2016 19:41'!quit	"[		(Delay forSeconds: 2) wait.		Interpreter quit	]		fork."	^true! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 17:39'!rememberActiveClass: aClass
	"Remember the current definition of aClass."

	| classBaseID isMeta nextEdition highestOldVersion |

	isMeta := aClass isMeta.
	highestOldVersion := 0.
	classBaseID := aClass baseID.

	nextEdition := (
		(
			(
				isMeta
					ifTrue: [MetaclassEdition]
					ifFalse: [ProtoclassEdition]
			)
				forObjectWithID: (
					ClassID
						forVersion: highestOldVersion + 1
						ofClassWithBaseID: classBaseID
						byAuthor: Author current)
		)
			superclassID: (
				(aClass baseID = (UUID fromString: '50351767-5c29-4a78-9507-b5adf59d987b'))
					ifTrue: [nil]
					ifFalse: [self idForActiveClassWithBaseID: aClass superclass baseID])
			instanceVariableNames: aClass instVarNames
			counterpartID: nil
			totalNumberOfInstanceVariables: aClass allInstVarNames size
			isVariable: aClass isVariable
			isWords: aClass isWords
			isPointers: aClass isPointers
			isWeak: aClass isWeak
			is64Bit: false).
	
	isMeta ifFalse: [
		nextEdition
			name: aClass name
			classPoolKeys: aClass classPoolKeys
			"Revisit this after setting up all the published pool names."
			receivedPoolIDs: nil
			publishedPoolIDs: "aClass publishedPools keys"#()].

	self activateClassEdition: nextEdition! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2016 15:41'!rememberAuthor: anAuthor	| authorID |	authorID := anAuthor id.		(knownAuthors includesKey: authorID) ifFalse: [knownAuthors at: authorID put: anAuthor]! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 3/31/2008 21:45'!rememberRemovalOfActiveClassWithBaseID: aUUID	self activateClassEdition: (ClassEdition new classBaseID: aUUID)! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 4/1/2008 19:25'!rememberRemovalOfMethodAt: selector inActiveClassWithBaseID: aUUID	lastEdit := lastEdit nextEditConveying: ((activeClassEditions at: aUUID) rememberRemovalOfMethodAt: selector)! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 3/17/2008 21:29'!removedSelectorsForClassWithBaseID: aUUID	| classEdition removedSelectors |	removedSelectors := Set new.	classEdition := activeClassEditions at: aUUID.	[classEdition == nil] whileFalse: [		removedSelectors addAll: classEdition removedSelectors.		classEdition := classEdition previousEdition].	^removedSelectors! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/14/2016 13:09'!sourceCodeForMethodAt: selector inClassWithBaseID: uuid
	| edition |
	
	edition := self editionForActiveMethodAt: selector inClassWithBaseID: uuid.

	^edition
		ifNil: [nil]
		ifNotNil: [edition source]! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 3/25/2019 02:26'!swapInMethodAt: selector in: remoteClass	"Install the method at selector in the local counterpart to remoteClass, into remoteClass."		| classID activeClass lookupClass method |		classID := remoteClass id.	activeClass := classID activeClass.	activeClass ifNil: [3 halt].	lookupClass := activeClass.	[method == nil and: [lookupClass ~~ nil]] whileTrue: [		method := (			lookupClass				compiledMethodAt: selector				ifAbsent: [					lookupClass := lookupClass superclass.					nil])].		lookupClass ifNil: [self error: 'No such method.'].		Transcript		cr;		print: activeClass.				activeClass == lookupClass ifFalse: [			Transcript				nextPut: $(;				print: lookupClass;				nextPut: $)].					Transcript					nextPutAll: '>>';		nextPutAll: selector;		endEntry.	remoteClass tether peer installMethodEdition: method edition! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 22:50'!systemNavigation	^self! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 19:22'!whichSelectorsReferTo: literal special: specialFlag byte: specialByte thorough: thorough	"Answer a set of selectors whose methods access the argument as a literal. If thorough is true, then dives into the compact literal notation, making it slow but thorough "	| who |	who := IdentitySet new.	self selectorsAndMethodsDo: [ :selector :method |		(((thorough			ifFalse: [ method hasLiteral: literal ]			ifTrue: [ method hasLiteralThorough: literal ]) or: [				specialFlag and: [ method scanFor: specialByte ] ]) and: [			literal isVariableBinding not or: [				"N.B. (method indexOfLiteral: literal) < method numLiterals copes with l;ooking for				Float bindingOf: #NaN, since (Float bindingOf: #NaN) ~= (Float bindingOf: #NaN)."				(method indexOfLiteral: literal) ~= 0] ]) ifTrue: [			who add: selector ] ].	^who! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 10/1/2016 20:54'!wipeAllMethodHistory	activeClassEditions do: [:edition | edition initialize]! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 10/17/2016 15:28'!activateMethodEdition: aMethodEdition	^LocalHistory activateMethodEdition: aMethodEdition! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 7/13/2011 20:32'!activateModuleEdition: aModuleEdition	LocalHistory activateModuleEdition: aModuleEdition! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 7/13/2011 20:46'!activeClassEditionWithID: aClassID	^LocalHistory activeClassEditionWithID: aClassID! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2016 21:29'!activeClassWithBaseID: baseID	Object withAllSubclassesDo: [:class | class baseID = baseID ifTrue: [^class]].	^nil! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 10/17/2016 14:23'!activeEditionForClassWithBaseID: aUUID	^LocalHistory activeEditionForClassWithBaseID: aUUID! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 7/16/2011 17:40'!activeMethodEditionWithID: aMethodID	^LocalHistory activeMethodEditionWithID: aMethodID! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 7/15/2011 22:02'!activeMethodEditionsMatching: aMethodIDPattern	^LocalHistory activeMethodEditionsMatching: aMethodIDPattern! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 7/13/2011 21:25'!activeModuleEditionWithID: aModuleID	^self activeModuleEditionWithBaseID: aModuleID ifAbsent: [nil]! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 7/13/2011 21:24'!activeModuleEditionWithID: aModuleID ifAbsent: block	^LocalHistory activeModuleEditionWithID: aModuleID ifAbsent: block! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 1/9/2014 10:40'!addModuleEdition: aModuleEdition	LocalHistory addModuleEdition: aModuleEdition! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2008 18:14'!applyComment: aString toActiveClass: class	LocalHistory		applyComment: aString		toActiveClassWithBaseID: class baseID! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 2/10/2008 15:14'!associateActiveProtoclass: protoclass withActiveMetaclass: metaclass	LocalHistory associateActiveProtoclassWithBaseID: protoclass baseID withActiveMetaclassWithBaseID: metaclass baseID! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 9/18/2008 13:54'!classEditionWithID: aClassID	^LocalHistory classEditionWithID: aClassID! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 3/19/2019 04:20'!connectTo: url	"Connect to the tether service at url."		ImprintingTether ifNotNil: [		ImprintingTether close.		ImprintingTether := LocalHistory := nil].		ImprintingTether := Tether to: url.	LocalHistory := ImprintingTether peer history.	LocalHistory beTether! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 3/31/2008 16:52'!currentAndRemovedSelectorsForClassWithBaseID: aUUID	^LocalHistory currentAndRemovedSelectorsForClassWithBaseID: aUUID! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 2/9/2009 18:58'!duplicateOn: remoteEditHistory	LocalHistory duplicateOn: remoteEditHistory! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 9/30/2016 20:12'!editionForActiveClassNamed: className	^LocalHistory editionForActiveClassNamed: className! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2016 14:24'!editionForActiveMethodAt: selector inClassWithBaseID: aUUID	^LocalHistory editionForActiveMethodAt: selector inClassWithBaseID: aUUID! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 3/31/2008 16:53'!editionOfMethodAt: selector inClassWithBaseID: aUUID	^LocalHistory		editionOfMethodAt: selector		inClassWithBaseID: aUUID! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 9/29/2016 20:43'!editionsForActiveClassesWithSuperclassID: classID	^LocalHistory editionsForActiveClassesWithSuperclassID: classID! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 4/14/2008 15:58'!editionsOfClassesNamed: className	^LocalHistory editionsOfClassesNamed: className! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2008 19:26'!editionsOfMethodAt: selector inClass: aClass	^LocalHistory		editionsOfMethodAt: selector		inClassWithBaseID: aClass baseID! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 3/31/2008 16:53'!editionsOfMethodAt: selector inClassWithBaseID: aUUID	^LocalHistory		editionsOfMethodAt: selector		inClassWithBaseID: aUUID! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2016 18:13'!idForActiveClassWithBaseID: aUUID	^LocalHistory idForActiveClassWithBaseID: aUUID! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 12/6/2014 00:22'!idForActiveMethodAt: selector inClassWithBaseID: aUUID	^LocalHistory idForActiveMethodAt: selector inClassWithBaseID: aUUID! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 6/30/2008 17:16'!includesActiveClassWithID: aClassID	"Answer whether the system includes an active class with ID aClassID."	^LocalHistory includesActiveClassWithID: aClassID! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 6/30/2008 17:14'!includesActiveMethodWithID: aMethodID	"Answer whether the system includes a method with ID aMethodID."	^LocalHistory includesActiveMethodWithID: aMethodID! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2016 15:34'!initialize	self new! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 7/13/2011 20:43'!installedModuleWithBaseID: aUUID ifAbsent: aBlockClosure	^LocalHistory installedModuleWithBaseID: aUUID ifAbsent: aBlockClosure! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 3/4/2008 21:03'!installedModules	^LocalHistory installedModules! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 1/9/2015 14:46'!isConnected	^LocalHistory recyclingHash ~~ 0 or: [LocalHistory isKindOf: self]! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 3/19/2019 04:23'!isTether	^self residesLocally and: [LocalHistory isTether]! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 21:13'!isTethered	^ImprintingTether notNil and: [ImprintingTether isConnected]! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2016 17:15'!knownAuthorWithID: authorID	^LocalHistory knownAuthorWithID: authorID! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 3/16/2008 21:33'!local	^LocalHistory! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 2/24/2012 11:17'!local: anEditHistory	LocalHistory := anEditHistory! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2012 12:59'!new	^LocalHistory := super new initialize! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 3/17/2008 17:39'!pastAndPresentSelectorsForClass: aClass	^LocalHistory pastAndPresentSelectorsForClassWithBaseID: aClass baseID! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 16:51'!peer	^MemoryProfile current peer! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 9/6/2012 01:52'!rememberActiveClass: aClass	LocalHistory rememberActiveClass: aClass" by: LocalAuthor"! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 17:33'!rememberAllActiveClasses	Class allSubclassesDo: [:metaclass |		metaclass remember.		metaclass soleInstance remember]! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 11/5/2014 12:19'!rememberAuthor: anAuthorEdition	LocalHistory rememberAuthor: anAuthorEdition! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 3/31/2008 16:47'!rememberRemovalOfActiveClass: aClass	LocalHistory rememberRemovalOfActiveClass: aClass! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 3/31/2008 16:53'!rememberRemovalOfMethodAt: selector inActiveClassWithBaseID: aUUID	LocalHistory rememberRemovalOfMethodAt: selector inActiveClassWithBaseID: aUUID! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 3/17/2008 21:31'!removedSelectorsForClass: aClass	^LocalHistory removedSelectorsForClassWithBaseID: aClass baseID! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 8/22/2009 21:11'!residesLocally	^LocalHistory recyclingHash = 0! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 17:32'!sourceCodeForMethodAt: selector inClassWithBaseID: uuid	^LocalHistory sourceCodeForMethodAt: selector inClassWithBaseID: uuid! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 3/16/2019 23:24'!swapInMethodAt: selector in: class	"Swap in the method at selector in class in the tethered system to the corresponding local class. Install any necessary prerequisites."		LocalHistory swapInMethodAt: selector in: class! !!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 22:52'!thoroughSenders	^true! !!SubclassResponsibility methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!SubclassResponsibility class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!ChromeWorkerAPI class methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 12:42'!domain	^'Worker'! !!ChangeListForProjects class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!WordArrayForSegment class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!Float methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2019 01:43'!adaptToInteger: rcvr andCompare: selector 	"If I am involved in comparison with an Integer, convert myself to a	Fraction. This way, no bit is lost and comparison is exact."		self isFinite		ifFalse: [			selector == #= ifTrue: [^false].			selector == #~= ifTrue: [^true].			self isNaN ifTrue: [^ false].			(selector = #< or: [selector = #'<='])				ifTrue: [^ self positive].			(selector = #> or: [selector = #'>='])				ifTrue: [^ self positive not].			^self error: 'unknow comparison selector'].			"Try to avoid asTrueFraction because it can cost"	selector == #= ifTrue: [		self fractionPart = 0.0 ifFalse: [^false]].	selector == #~= ifTrue: [		self fractionPart = 0.0 ifFalse: [^true]].		rcvr isAnExactFloat ifTrue: [^rcvr asExactFloat perform: selector with: self].	selector == #= ifTrue: [^false].	selector == #~= ifTrue: [^true].	^ rcvr perform: selector with: self asTrueFraction! !!Float methodsFor: 'as yet unclassified' stamp: 'crl 7/23/2017 14:18'!asChromeRemoteCallArgument	^{#value -> self}! !!Float methodsFor: 'as yet unclassified' stamp: 'bf 11/25/2014 18:12'!asJSArgument	"converted to JS number by plugin"	^self! !!Float methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 19:46'!storeOnTether: tether
	tether nextWordPut: FloatTag.
	self printString storeOnTether: tether! !!Float class methodsFor: 'as yet unclassified'!fromTether: tether	^self readFrom: tether next readStream! !!MenuIcons methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!MIDIInputMap methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!MIDIInputMap class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/1/2016 22:34'!= aClassEdition	^self baseID = aClassEdition baseID! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/11/2016 11:04'!acceptsLoggingOfCompilation	"weird name is so that it will come lexically before #compile, so that a clean build can make it through.  7/7/96 sw"	^ true! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/16/2011 02:01'!activateMethodEdition: aMethodEdition	| edition highestOldVersion methodAuthorID |	highestOldVersion := 0.	methodAuthorID := aMethodEdition methodAuthorID.	edition := activeMethodEditions at: aMethodEdition selector ifAbsent: [nil].	[edition == nil] whileFalse: [		(edition methodAuthorID = methodAuthorID) ifTrue: [highestOldVersion := highestOldVersion max: edition methodVersion].		edition := edition previousEdition].	aMethodEdition adds ifTrue: [		(aMethodEdition methodVersion = 0) ifTrue: [			"This method edition is being activated for the first time in any edit history; assign the version and class edition."			aMethodEdition				version: highestOldVersion + 1;				classEdition: self]].	^self addMethodEdition: aMethodEdition! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/30/2008 03:02'!activeClass	^id activeClass! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/12/2016 14:36'!activeClassObject	^self id activeClassObject! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2016 14:27'!activeMethodEditionAt: selector	^activeMethodEditions at: selector ifAbsent: [^nil]! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/19/2019 04:59'!activeMethodEditionWithID: aMethodID	^activeMethodEditions		at: aMethodID selector		ifAbsent: [			(EditHistory isTether)				ifTrue: [					"Generate on demand."										| activeClass |										activeClass := self activeClass.										activeClass						newEditionForMethod: aMethodID method						at: aMethodID selector						withSource: (activeClass sourceCodeAt: aMethodID selector)]				ifFalse: [nil]]! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/15/2011 21:47'!activeMethodEditionsMatching: aMethodIDPattern	^activeMethodEditions select: [:methodEdition | aMethodIDPattern match: methodEdition id]! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/29/2008 13:32'!activeSuperclass	^superclassID activeClass! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/17/2016 15:27'!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: category notifying: requestor	^EditHistory activateMethodEdition: (		self			newEditionForMethod: compiledMethod			at: selector			withSource: compiledMethod decompile)! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/10/2016 20:54'!addMethodEdition: aMethodEdition	| selector previousMethodEdition |	selector := aMethodEdition selector.	previousMethodEdition := activeMethodEditions at: selector ifAbsent: [nil].	(previousMethodEdition = aMethodEdition) ifFalse: [		previousMethodEdition ifNotNil: [			previousMethodEdition nextEdition: aMethodEdition.			aMethodEdition previousEdition: previousMethodEdition].		activeMethodEditions at: selector put: aMethodEdition]! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/30/2016 23:19'!adds	^isVariable notNil! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 16:12'!allClassVarNames	"Answer a Set of the names of the receiver's class variables, including those defined in the superclasses of the receiver."	| aSet |	^ self superclass == nil		ifTrue: 			[self classVarNames asSet]  "This is the keys so it is a new Set."		ifFalse: 			[aSet := self superclass allClassVarNames.			aSet addAll: self classVarNames.			aSet]! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 01:50'!allInstVarNames	| selectedEdition allInstanceVariableNames |		selectedEdition := self.	allInstanceVariableNames := OrderedCollection new.		[selectedEdition == nil] whileFalse: [		allInstanceVariableNames addAll: selectedEdition instVarNames reversed.		selectedEdition := selectedEdition superclass].		^allInstanceVariableNames reversed asArray! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/29/2016 20:44'!allSubclassesDo: aBlock 	"Evaluate the argument, aBlock, for each of the receiver's subclasses."	(EditHistory editionsForActiveClassesWithSuperclassID: self id) do: [:edition |		aBlock value: edition.		edition allSubclassesDo: aBlock]! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 16:15'!allSuperclasses	| superclasses selectedEdition |		superclasses := OrderedCollection new.	selectedEdition := self superclass.		[selectedEdition == nil] whileFalse: [		superclasses add: selectedEdition.		selectedEdition := selectedEdition superclass].		^superclasses! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/29/2016 16:49'!allSuperclassesDo: aBlock 	"Evaluate the argument, aBlock, for each of the receiver's superclasses."	superclassID == nil		ifFalse: [			| edition |						edition := superclassID edition.						aBlock value: edition.			edition allSuperclassesDo: aBlock]! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/31/2008 21:58'!authorID	^self classAuthorID! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/29/2016 16:38'!baseID	^self classBaseID! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/12/2016 15:05'!binding	^self subclassResponsibility! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/10/2016 00:24'!bindingOf: varName environment: anEnvironment	^self superclass bindingOf: varName environment: anEnvironment! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 16:11'!chooseVarThenDo: aBlock 	"Put up a menu of all the instance variables in the receiver, and whenthe user chooses one, evaluate aBlock with the chosen variable as itsparameter."	| lines labelStream allVars index |	(self allInstVarNames size + self theNonMetaClass allClassVarNames size) = 0 ifTrue: [ ^ self inform: 'There are no variables.' ].	allVars := OrderedCollection new.	lines := OrderedCollection new.	labelStream := WriteStream on: (String new: 200).	self withAllSuperclasses reverseDo:		[ : class | | vars |		vars := class instVarNames , class theNonMetaClass classVarNames.		vars do:			[ : var | labelStream				 nextPutAll: var ;				 cr.			allVars add: var ].		vars isEmpty ifFalse: [ lines add: allVars size ] ].	labelStream skip: -1.	"cut last CR"	(lines size > 0 and: [ lines last = allVars size ]) ifTrue: [ lines removeLast ].	"dispense with inelegant line beneath last item"	index := UIManager default		chooseFrom: (labelStream contents subStrings: {Character cr})		lines: lines		title: 'Variables in ' , self name.	index = 0 ifTrue: [ ^ self ].	aBlock value: (allVars at: index)! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/31/2008 17:21'!classBaseID: aUUID	id classBaseID: aUUID! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 15:09'!classSide	^self subclassResponsibility! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/29/2016 14:08'!classVarNames	"Answer a collection of the names of the class variables defined in the receiver."	^self classPool keys asArray sort! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/29/2016 14:07'!classVariablesString	"Answer a string of my class variable names separated by spaces."	^String streamContents: [ :stream | 		self classVarNames 			do: [ :each | stream nextPutAll: each ]			separatedBy: [ stream space ] ]! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/11/2016 11:03'!compile: text classified: category notifying: requestor	| stamp |	stamp := self acceptsLoggingOfCompilation ifTrue: [Utilities changeStamp] ifFalse: [nil].	^ self compile: text classified: category		withStamp: stamp notifying: requestor! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/11/2016 11:05'!compile: text classified: category withStamp: changeStamp notifying: requestor	^ self compile: text classified: category withStamp: changeStamp notifying: requestor logSource: self acceptsLoggingOfCompilation! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 23:21'!compile: text classified: category withStamp: changeStamp notifying: requestor logSource: logSource 	| methodAndNode selector |	methodAndNode := self		compile: text asString		notifying: requestor		trailer: CompiledMethodTrailer empty		ifFail: [ ^ nil ].	selector := methodAndNode selector.	logSource ifTrue:		[ self			logMethodSource: text			forMethodWithNode: methodAndNode			inCategory: category			withStamp: changeStamp			notifying: requestor.		RecentMessages default			recordSelector: selector			forClass: methodAndNode method methodClass			inEnvironment: nil].	^self		addAndClassifySelector: selector		withMethod: methodAndNode method		inProtocol: category		notifying: requestor! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/11/2016 11:12'!compile: code notifying: requestor trailer: bytes ifFail: failBlock	"Compile code without logging the source in the changes file"	| methodNode |	methodNode  := self newCompiler				compile: code				in: self				notifying: requestor				environment: EditHistory local				ifFail: failBlock.	^ CompiledMethodWithNode generateMethodFromNode: methodNode trailer: bytes! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/10/2016 15:34'!compiledMethodAt: selector	^self compiledMethodAt: selector ifAbsent: [nil]! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 14:50'!compiledMethodAt: selector ifAbsent: block	| edition |		edition := activeMethodEditions at: selector ifAbsent: [^block value].	^(edition adds)		ifTrue: [edition]		ifFalse: [block value]! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/30/2016 14:15'!compilerClass	"Answer a compiler class appropriate for source methods of this class."	^Compiler! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/3/2012 21:04'!counterpartID	^counterpartID! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/30/2008 21:27'!counterpartID: aClassID	counterpartID := aClassID! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/12/2016 00:12'!decompilerClass	^Decompiler! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/29/2016 14:03'!definition	| aStream path superclass |	superclass := superclassID edition.	aStream := WriteStream on: (String new: 300).	superclassID == nil		ifTrue: [aStream nextPutAll: 'ProtoObject']		ifFalse: [path := ''.				self environment scopeFor: superclass name from: nil						envtAndPathIfFound: [:envt :remotePath | path := remotePath].				aStream nextPutAll: path , superclass name].	aStream nextPutAll: self kindOfSubclass;			store: self name.	(self hasTraitComposition and: [self traitComposition notEmpty]) ifTrue: [		aStream cr; tab; nextPutAll: 'uses: ';			nextPutAll: self traitCompositionString].	aStream cr; tab; nextPutAll: 'instanceVariableNames: ';			store: self instanceVariablesString.	aStream cr; tab; nextPutAll: 'classVariableNames: ';			store: self classVariablesString.	aStream cr; tab; nextPutAll: 'poolDictionaries: ';			store: self sharedPoolsString.	aStream cr; tab; nextPutAll: 'category: ';			store: (SystemOrganization categoryOfElement: self name) asString.	superclass ifNil: [ 		aStream nextPutAll: '.'; cr.		aStream nextPutAll: self name.		aStream space; nextPutAll: 'superclass: nil'. ].	^ aStream contents! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 12/19/2010 11:56'!duplicateOn: remoteEditHistory	Transcript nextPut: $.; endEntry.	remoteEditHistory activateClassEdition: self.	activeMethodEditions do: [:methodEdition | remoteEditHistory activateMethodEdition: methodEdition]! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/12/2016 00:37'!edition	^self! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 6/26/2011 03:39'!editionOfMethodAt: selector	^activeMethodEditions		at: selector		ifAbsent: [			^(previousEdition == nil)				ifTrue: [nil]				ifFalse: [previousEdition editionOfMethodAt: selector]]! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/31/2008 20:57'!editionWithID: aClassID	^(id = aClassID)		ifTrue: [self]		ifFalse: [			previousEdition				ifNil: [nil]				ifNotNil: [previousEdition editionWithID: aClassID]]! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 4/14/2008 16:18'!editionsOfClassesSuchThat: aBlockClosure	| editions edition |	editions := OrderedCollection new.	edition := self.	[edition == nil] whileFalse: [		(aBlockClosure value: edition) ifTrue: [editions add: edition].		edition := edition previousEdition].	^editions reversed! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/9/2008 14:58'!editionsOfMethodAt: selector	^(self editionOfMethodAt: selector) yourselfAndAllPriorEditions! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/29/2016 14:03'!environment	"Return the environment in which the receiver is declared"	^Smalltalk globals! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/30/2016 23:31'!format	| formatVersion |		formatVersion := self class formatVersion.		^(formatVersion = 11)		ifTrue: [self version11Format]		ifFalse: [			(formatVersion = 12)				ifTrue: [self version12Format]				ifFalse: [self error: 'unsupported class format version']]! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/29/2016 14:46'!hasComment	^activeCommentEdition notNil! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/29/2016 14:06'!hasTraitComposition	"Backstop. When traits are unloaded we never have a trait composition"	^false! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/1/2016 22:35'!hash	^self classBaseID! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/21/2019 03:45'!holderOfClassVariablePoolAssociation: anAssociation 	| classVariablesPoolHolder |	classVariablesPoolHolder := (		(self isMeta)			ifTrue: [self activeClass soleInstance]			ifFalse: [self activeClass]).	[classVariablesPoolHolder == nil] whileFalse: [		((classVariablesPoolHolder classPool includesKey: anAssociation key) and: [(classVariablesPoolHolder classPool at: anAssociation key) == anAssociation value]) ifTrue: [^classVariablesPoolHolder].		classVariablesPoolHolder := classVariablesPoolHolder superclass].	^nil! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/3/2008 14:41'!includesActiveMethodWithID: aMethodID	| edition |	edition := activeMethodEditions at: aMethodID ifAbsent: [^false].	^edition adds! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/30/2016 21:39'!includesSelector: aSymbol 	"Answer whether the message whose selector is the argument is in the 	method dictionary of the receiver's class."	^activeMethodEditions includesKey: aSymbol! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 17:36'!inheritsFrom: aClass 	"Answer whether the argument, aClass, is on the receiver's superclass 	chain."	| aSuperclass |	aSuperclass := self superclass.	[aSuperclass == nil]		whileFalse: 			[aSuperclass == aClass ifTrue: [^true].			aSuperclass := aSuperclass superclass].	^false! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/30/2016 23:15'!initialize	super initialize.	activeMethodEditions := Dictionary new.	is64Bit := false! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/14/2016 19:11'!instSize	"Answer the number of named instance variables	(as opposed to indexed variables) of the receiver."	| formatVersion |		formatVersion := self class formatVersion.		^(formatVersion = 11)		ifTrue: [			| format |			format := self format.			((format bitShift: -10) bitAnd: 16rC0) + ((format bitShift: -1) bitAnd: 16r3F) - 1]		ifFalse: [			(formatVersion = 12)				ifTrue: [self format bitAnd: 16rFFFF]				ifFalse: [self error: 'unsupported format version']]! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/30/2016 23:29'!instSpec	^ (self format bitShift: -7) bitAnd: 16rF! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 15:03'!instVarIndexFor: instVarName ifAbsent: aBlock	"Answer the index of the named instance variable."	| index |	index := instanceVariableNames == nil 				ifTrue: [0]				ifFalse: [instanceVariableNames indexOf: instVarName ifAbsent: [0]].	index = 0 ifTrue: 		[^superclassID == nil 			ifTrue: [aBlock value]			ifFalse: [superclassID edition instVarIndexFor: instVarName ifAbsent: aBlock]].	^superclassID == nil 			ifTrue: [index]		ifFalse: [index + superclassID edition instSize]! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 01:52'!instVarNames	^instanceVariableNames! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/9/2016 23:46'!instVarNamesAndOffsetsDo: aBinaryBlock	"This is part of the interface between the compiler and a class's instance or field names.	 The class should enumerate aBinaryBlock with the instance variable name strings and	 their integer offsets.  The order is important. Names evaluated later will override the	 same names occurring earlier."	| superInstSize superclass |		superclass := self superclass.	(superInstSize := superclass notNil ifTrue: [superclass instSize] ifFalse: [0]) > 0 ifTrue:		[superclass instVarNamesAndOffsetsDo: aBinaryBlock].	1 to: self instSize - superInstSize do:		[:i| aBinaryBlock value: (instanceVariableNames at: i) value: i + superInstSize]! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/3/2012 20:09'!install	self subclassResponsibility! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/12/2016 00:38'!instanceSide	^ self theNonMetaClass! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/29/2016 14:07'!instanceVariablesString	"Answer a string of my instance variable names separated by spaces."	^String streamContents: [ :stream |		self instVarNames 			do: [ :each | stream nextPutAll: each ]			separatedBy: [ stream space ] ]! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2008 16:25'!isActive	^(EditHistory activeEditionForClassWithBaseID: self classBaseID) == self! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/12/2016 00:30'!isBehavior	^true! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/12/2016 00:38'!isClassSide	^self isMeta! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 4/14/2008 15:33'!isMeta	"Answer whether I describe a Metaclass."	^self subclassResponsibility! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/30/2016 21:40'!isSelectorOverridden: aSelector	(activeMethodEditions includesKey: aSelector)		ifFalse: [^ false].			self allSubclassesDo: [ :edition |		(edition includesSelector: aSelector)			ifTrue: [ ^ true ] ].	^ false! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/29/2016 16:46'!isSelectorOverride: aSelector	(self includesSelector: aSelector)		ifFalse: [^ false].	self allSuperclassesDo: [ :class | 		(class includesSelector: aSelector) 			ifTrue: [ ^ true ] ].	^ false! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/1/2016 22:20'!isTrait	^false! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 14:46'!isUniClass	"Answer whether the receiver is a uniclass."	^ self name endsWithDigit! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/29/2016 14:06'!isVariable	"Answer whether the receiver has indexable variables."	^ self instSpec >= 2! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/29/2016 14:05'!isWeak	"Answer whether the receiver has contains weak references."	^ self instSpec = 4! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/29/2016 14:04'!kindOfSubclass	"Answer a String that is the keyword that describes the receiver's kind 	of subclass, either a regular subclass, a variableSubclass, a  	variableByteSubclass, a variableWordSubclass, or a weakSubclass."	self isWeak		ifTrue: [^ ' weakSubclass: '].	^ self isVariable		ifTrue: [self isBits				ifTrue: [self isBytes						ifTrue: [ ' variableByteSubclass: ']						ifFalse: [ ' variableWordSubclass: ']]				ifFalse: [ ' variableSubclass: ']]		ifFalse: [ ' subclass: ']! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/9/2016 23:48'!literalScannedAs: scannedLiteral environment: anEnvironment notifying: requestor	"Postprocesses a literal scanned by Scanner scanToken (esp. xLitQuote).	If scannedLiteral is not an association, answer it.	Else, if it is of the form:		nil->#NameOfMetaclass	answer nil->theMetaclass, if any has that name, else report an error.	Else, if it is of the form:		#NameOfGlobalVariable->anythiEng	answer the global, class, or pool association with that nameE, if any, else	add it to Undeclared a answer the new Association."	| key value |	(scannedLiteral isVariableBinding)		ifFalse: [^ scannedLiteral].	key := scannedLiteral key.	value := scannedLiteral value.	key ifNil: "###<metaclass soleInstance name>"		[(self bindingOf: value environment: anEnvironment) ifNotNil:			[:assoc|			(assoc value isKindOf: Behavior) ifTrue: 				[^ nil->assoc value class]].			 requestor notify: 'No such metaclass'.			 ^false].	(key isSymbol) ifTrue: "##<global var name>"		[(self bindingOf: key environment: anEnvironment) ifNotNil:			[:assoc | ^assoc].		^ anEnvironment undeclared: key].	requestor notify: '## must be followed by a non-local variable name'.	^false"	Form literalScannedAs: 14 notifying: nil 14	Form literalScannedAs: #OneBitForm notiEfying: nil  OneBitForm	Form literalScannedAs: ##OneBitForm notifying: nil  OneBitForm->a Form	Form literalScannedAs: ##Form notifying: nil   Form->Form	Form literalScannedAs: ###Form notifying: nil   nilE->Form class"! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/11/2016 17:34'!logMethodSource: aText forMethodWithNode: aCompiledMethodWithNode inCategory: category withStamp: changeStamp notifying: requestor! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 15:13'!methodDict	^activeMethodEditions! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/30/2008 16:39'!methodEditionAt: selector put: aMethodEdition	| previousMethodEdition |	previousMethodEdition := activeMethodEditions at: selector ifAbsent: [nil].	previousMethodEdition ifNotNil: [		previousMethodEdition nextEdition: aMethodEdition.		aMethodEdition previousEdition: previousMethodEdition].	^activeMethodEditions at: selector put: aMethodEdition! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/31/2008 15:58'!methodEditionWithID: aMethodID	^(		activeMethodEditions			at: aMethodID selector			ifAbsent: [				^previousEdition					ifNil: [nil]					ifNotNil: [previousEdition methodEditionWithID: aMethodID]]	)		editionWithID: aMethodID! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/1/2016 22:10'!name	^self subclassResponsibility! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/11/2016 11:13'!newCompiler	"Answer a Compiler suitable for compiling this Behavior"	^self compilerClass new parser: self newParser! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/12/2016 00:13'!newEditionForMethod: method at: selector withSource: source	| literalsArray instructions |	literalsArray := (		"Don't bother with the method properties or class binding."		(method literals copyFrom: 1 to: method literals size - 2) collect: [:literal | 			MethodLiteralTransmissionMarker				forLiteral: literal				inMethod: method				ofClass: self]).	(method primitive = 117) ifTrue: [		"Clear the cached session ID and function index from the special first literal that external-call methods have."		(literalsArray first literal)			at: 3 put: 0;			at: 4 put: 0].	instructions := (ByteArray new: method endPC - method initialPC + 1) writeStream.	method initialPC		to: method endPC		do: [:index | instructions nextPut: (method at: index)].		^(MethodEdition new)		id: (			MethodID				"The actual version will be assigned later."				forVersion: 0				ofMethodAt: selector				inActiveClass: self);		headerVersion: MethodEdition localHeaderVersion		instructions: instructions contents		literalMarkers: literalsArray		header: method header		primitive: method primitive		initialPC: method initialPC		endPC: method endPC		source: source		classEdition: self edition;		methodAuthor: Author current;		yourself! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/30/2016 14:14'!newParser	"Answer a Parser suitable for parsing source code in this Behavior"	^self parserClass new! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/12/2016 00:38'!noteCompilationOf: ignored meta: alsoIgnored! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 14:46'!organization	^self remoteClass organization! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/30/2016 14:14'!parserClass	"Answer a parser class to use for parsing method headers."	^self compilerClass parserClass! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 16:52'!peer	^EditHistory peer! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/11/2016 11:15'!possibleVariablesFor: misspelled continuedFrom: oldResults	| results |	results := misspelled correctAgainstDictionary: self classPool continuedFrom: oldResults.	self sharedPools do: [:pool | 		results := misspelled correctAgainstDictionary: pool continuedFrom: results ].	superclassID == nil		ifTrue: 			[ ^ misspelled correctAgainstDictionary: self environment continuedFrom: results ]		ifFalse:			[ ^ self superclass possibleVariablesFor: misspelled continuedFrom: results ]! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2008 22:31'!printComponentNameOn: aStream withOuterAuthor: anAuthorEdition	aStream nextPutAll: 'the removal of '.	previousEdition printComponentNameOn: aStream withOuterAuthor: anAuthorEdition! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/30/2016 16:03'!printOn: aStream forEdit: anEdit	(self isTemporary)		ifTrue: [aStream nextPutAll: 'a temporary']		ifFalse: [aStream nextPutAll: 'the'].			aStream nextPutAll: ' edition for '.	self		printComponentNameOn: aStream		withOuterAuthor: nil.	aStream nextPutAll: ', created at '.	(anEdit notNil and: [anEdit timestamp - timestamp < 5])		ifTrue: [aStream nextPutAll: 'the same time']		ifFalse: [			timestamp ifNil: [timestamp := Time totalSeconds].			aStream				print: (Date fromSeconds: timestamp);				nextPutAll: ', ';				print: (Time fromSeconds: timestamp)]! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 14:06'!referenceToSelector: selector	^MethodReference		class: self		selector: selector		environment: EditHistory local! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/31/2008 12:37'!reinstateMethodEdition: aMethodEdition	| selector mostRecentMethodEdition |	selector := aMethodEdition selector.	mostRecentMethodEdition := activeMethodEditions at: selector.	activeMethodEditions at: selector put: aMethodEdition.	mostRecentMethodEdition removes ifTrue: [		"Forget it."		mostRecentMethodEdition previousEdition nextEdition: nil]! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/31/2008 15:47'!rememberRemovalOfMethodAt: selector	^self addMethodEdition: (		MethodEdition new id: (			(				activeMethodEditions					at: selector					ifAbsent: [						"That method didn't exist to begin with."						^nil]			)				id))! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 16:37'!remoteClass	^MemoryProfile current peer classWithBaseID: self classBaseID! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 16:52'!remoteEnvironment	^self peer environment! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/30/2008 15:22'!removedSelectors	"Answer a set of the selectors of all the methods which have been removed from the class edition I describe."	| removedSelectors |	removedSelectors := Set new.	activeMethodEditions keysDo: [:selector | (activeMethodEditions at: selector) removes ifTrue: [removedSelectors add: selector]].	^removedSelectors! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/31/2008 21:48'!removes	^self adds not! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2008 18:45'!selectors	^activeMethodEditions keys! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 15:12'!selectorsAndMethodsDo: selectorAndMethodBlock	"Evaluate the two argument selectorAndMethodBlock for all the selector/method pairs in my method dictionary."	^ self methodDict keysAndValuesDo: selectorAndMethodBlock! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/10/2016 11:05'!sharedPools	"Answer a Set of the names of the pools (Dictionaries) that the receiver 	shares.	9/12/96 tk  sharedPools have an order now"	^ OrderedCollection new! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 17:24'!shoutParserClass	"Answer the parser class"	^SHParserST80! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 17:22'!sourceCodeAt: selector ifAbsent: aBlock	^ (self methodDict at: selector ifAbsent: [^ aBlock value]) getSourceFor: selector in: self! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/29/2016 16:37'!sourceCodeTemplate	"Answer an expression to be edited and evaluated in order to define 	methods in this class or trait."	^'message selector and argument names	"comment stating purpose of message"	| temporary variable names |	statements'! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 17:22'!sourceMethodAt: selector ifAbsent: aBlock	"Answer the paragraph corresponding to the source code for the 	argument."	^ (self sourceCodeAt: selector ifAbsent: [^ aBlock value]) asText makeSelectorBoldIn: self! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/30/2016 22:59'!storeOnTether: tether	super storeOnTether: tether.	tether		store: superclassID;		store: instanceVariableNames;		store: counterpartID;		next16BitsPut: totalNumberOfInstanceVariables;		store: isVariable;		store: isWords;		store: isPointers;		store: isWeak;		store: is64Bit! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/30/2016 19:50'!subclass: requestedSubclassName instanceVariableNames: requestedInstanceVariableNames classVariableNames: requestedClassVariableNames poolDictionaries: requestedPoolDictionaryNames category: requestedCategory	| newClass edition |		newClass := (		(self temporaryCopy install)			subclass: requestedSubclassName			instanceVariableNames: requestedInstanceVariableNames			classVariableNames: requestedClassVariableNames			poolDictionaries: requestedPoolDictionaryNames			category: requestedCategory).				{newClass class. newClass} do: [:behavior | behavior remember].			edition := newClass edition.	(Smalltalk at: requestedSubclassName) removeFromSystem.	^edition! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 03:05'!subclasses	| subclasses |		subclasses := OrderedCollection new.		self allSubclassesDo: [:subclass | subclasses add: subclass].	^subclasses asArray! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 01:53'!superclass	^superclassID		ifNil: [nil]		ifNotNil: [superclassID edition]! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/3/2012 16:57'!superclassID	^superclassID! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/1/2016 00:51'!superclassID: theSuperclassID instanceVariableNames: instanceVariableNameString counterpartID: theCounterpartID totalNumberOfInstanceVariables: theTotalNumberOfInstanceVariables isVariable: isVariableBoolean isWords: isWordsBoolean isPointers: isPointersBoolean isWeak: isWeakBoolean is64Bit: is64BitBoolean	superclassID := theSuperclassID.	instanceVariableNames := instanceVariableNameString.	counterpartID := theCounterpartID.	totalNumberOfInstanceVariables := theTotalNumberOfInstanceVariables.	isVariable := isVariableBoolean.	isWords := isWordsBoolean.	isPointers := isPointersBoolean.	isWeak := isWeakBoolean.	is64Bit := is64BitBoolean! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 03:03'!theNonMetaClass	^self subclassResponsibility! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/29/2016 14:33'!traitComposition	"Backstop. When traits are unloaded we never have a trait composition"	^#()! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 17:24'!ultimateSourceCodeAt: selector ifAbsent: aBlock	"Return the source code at selector, deferring to superclass if necessary"	^ self sourceCodeAt: selector ifAbsent:		[superclassID			ifNil:				[aBlock value]			 ifNotNil:				[superclassID edition ultimateSourceCodeAt: selector ifAbsent: aBlock]]! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/9/2016 23:40'!variablesAndOffsetsDo: aBinaryBlock	"This is the interface between the compiler and a class's instance or field names.  The	 class should enumerate aBinaryBlock with the field definitions (with nil offsets) followed	 by the instance variable name strings and their integer offsets (1-relative).  The order is	 important; names evaluated later will override the same names occurring earlier."	"Only need to do instance variables here.  CProtoObject introduces field definitions."	self instVarNamesAndOffsetsDo: aBinaryBlock! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/9/2008 20:00'!version	^self classVersion! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/30/2016 23:28'!version11Format	"Compute the format for the given instance specfication."	| cClass instSpec sizeHiBits fmt |	self flag: #instSizeChange."Smalltalk browseAllCallsOn: #instSizeChange.Smalltalk browseAllImplementorsOf: #fixedFieldsOf:.Smalltalk browseAllImplementorsOf: #instantiateClass:indexableSize:.""	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.	For now the format word is...		<2 bits=instSize//64><5 bits=cClass><4 bits=instSpec><6 bits=instSize\\64><1 bit=0>	But when we revise the image format, it should become...		<5 bits=cClass><4 bits=instSpec><8 bits=instSize><1 bit=0>"	sizeHiBits := (totalNumberOfInstanceVariables+1) // 64.	cClass := 0.  "for now"	instSpec := isWeak		ifTrue:[4]		ifFalse:[isPointers				ifTrue: [isVariable						ifTrue: [totalNumberOfInstanceVariables>0 ifTrue: [3] ifFalse: [2]]						ifFalse: [totalNumberOfInstanceVariables>0 ifTrue: [1] ifFalse: [0]]]				ifFalse: [isWords ifTrue: [6] ifFalse: [8]]].	fmt := sizeHiBits.	fmt := (fmt bitShift: 5) + cClass.	fmt := (fmt bitShift: 4) + instSpec.	fmt := (fmt bitShift: 6) + ((totalNumberOfInstanceVariables+1)\\64).  "+1 since prim size field includes header"	fmt := (fmt bitShift: 1). "This shift plus integer bit lets wordSize work like byteSize"	^fmt! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/30/2016 23:24'!version12Format	"Compute the format for the given instance specfication.	 Above Cog Spur the class format is		<5 bits inst spec><16 bits inst size>	 where the 5-bit inst spec is			0	= 0 sized objects (UndefinedObject True False et al)			1	= non-indexable objects with inst vars (Point et al)			2	= indexable objects with no inst vars (Array et al)			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)			4	= weak indexable objects with inst vars (WeakArray et al)			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)			6	= unused			7	= immediates (SmallInteger, Character)			8	= unused			9	= reserved for 64-bit indexable		10-11	= 32-bit indexable (Bitmap)		12-15	= 16-bit indexable		16-23	= 8-bit indexable		24-31	= compiled methods (CompiledMethod)"	| instSpec |	instSpec := isWeak					ifTrue:						[isVariable							ifTrue: [4]							ifFalse: [5]]					ifFalse:						[isPointers							ifTrue:								[isVariable									ifTrue: [totalNumberOfInstanceVariables > 0 ifTrue: [3] ifFalse: [2]]									ifFalse: [totalNumberOfInstanceVariables > 0 ifTrue: [1] ifFalse: [0]]]							ifFalse:								[isVariable									ifTrue: [isWords ifTrue: [10] ifFalse: [16]]									ifFalse: [7]]].	^(instSpec bitShift: 16) + totalNumberOfInstanceVariables! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/31/2008 17:48'!version: sixteenBits	^self classVersion: sixteenBits! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/11/2016 17:35'!wantsChangeSetLogging	^false! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 21:50'!whichCategoryIncludesSelector: selector	| activeClass |		activeClass := self remoteClass.	^activeClass		ifNil: [nil]		ifNotNil: [activeClass whichCategoryIncludesSelector: selector]! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 17:38'!whichMethodsStoreInto: varName 	"Answer a collection of CompiledMethod whose methods access the argument, varName,	 as a named class or pool variable. Or let super try with a named instance variable."	^(self bindingOf: varName)		ifNil: [			| instVarIndex |			instVarIndex := self instVarIndexFor: varName ifAbsent: [ ^Array new ].			self methodDict values select: [:eachMethod | eachMethod writesField: instVarIndex ]]		ifNotNil: [:ref| self methodDict values select: [:eachMethod| eachMethod writesRef: ref]]! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 14:55'!whichSelectorsAccess: instVarName 	"Answer a collection of selectors whose methods access the argument, instVarName, as a named instance variable."	"Point whichSelectorsAccess: 'x'."		| instVarIndex |	instVarIndex := self instVarIndexFor: instVarName ifAbsent: [ ^Array new ].	^Array streamContents: [ :stream |		self selectorsAndMethodsDo: [ :selector :method |			((method readsField: instVarIndex) or: [				method writesField: instVarIndex ]) ifTrue: [					stream nextPut: selector ] ] ]! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 19:23'!whichSelectorsReferTo: literal special: specialFlag byte: specialByte thorough: thorough	"Answer a set of selectors whose methods access the argument as a literal. If thorough is true, then dives into the compact literal notation, making it slow but thorough "	| who |	who := IdentitySet new.	self selectorsAndMethodsDo: [ :selector :method |		(((thorough			ifFalse: [ method hasLiteral: literal ]			ifTrue: [ method hasLiteralThorough: literal ]) or: [				specialFlag and: [ method scanFor: specialByte ] ]) and: [			literal isVariableBinding not or: [				"N.B. (method indexOfLiteral: literal) < method numLiterals copes with l;ooking for				Float bindingOf: #NaN, since (Float bindingOf: #NaN) ~= (Float bindingOf: #NaN)."				(method indexOfLiteral: literal) ~= 0] ]) ifTrue: [			who add: selector ] ].	^who! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 16:16'!withAllSubAndSuperclassesDo: aBlock	self withAllSubclassesDo: aBlock.	self allSuperclassesDo: aBlock.! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 16:16'!withAllSubclassesDo: aBlock 	"Evaluate the argument, aBlock, for the receiver and each of its 	subclasses."	aBlock value: self.	self allSubclassesDo: aBlock! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 16:13'!withAllSuperclasses	"Answer an OrderedCollection of the receiver and the receiver's 	superclasses. The first element is the receiver, 	followed by its superclass; the last element is Object."	| temp |	temp := self allSuperclasses.	temp addFirst: self.	^ temp! !!ClassEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 21:58'!withAllSuperclassesDo: aBlock 	"Evaluate the argument, aBlock, for each of the receiver's superclasses."	aBlock value: self.	self superclass == nil		ifFalse: [self superclass withAllSuperclassesDo: aBlock]! !!ClassEdition class methodsFor: 'as yet unclassified' stamp: 'crl 9/30/2016 23:24'!formatVersion	^12! !!ClassEdition class methodsFor: 'as yet unclassified' stamp: 'crl 9/30/2016 23:07'!fromTether: tether	^(super fromTether: tether)		superclassID: tether next		instanceVariableNames: tether next		counterpartID: tether next		totalNumberOfInstanceVariables: tether next16Bits		isVariable: tether next		isWords: tether next		isPointers: tether next		isWeak: tether next		is64Bit: tether next! !!Edition methodsFor: 'as yet unclassified' stamp: 'crl 10/10/2016 11:53'!author	^author		ifNil: [Author anUnknownAuthor]		ifNotNil: [author]! !!Edition methodsFor: 'as yet unclassified' stamp: 'crl 8/26/2012 04:29'!author: anAuthorEdition	author := anAuthorEdition.	"license ifNil: [license := author license]"! !!Edition methodsFor: 'as yet unclassified' stamp: 'crl 7/9/2011 22:00'!component	^self! !!Edition methodsFor: 'as yet unclassified' stamp: 'crl 11/13/2014 17:12'!initialize	timestamp := Time totalSeconds! !!Edition methodsFor: 'as yet unclassified' stamp: 'crl 9/16/2012 15:28'!isNewerThan: anEdition	^((timestamp == nil) or: [anEdition timestamp == nil])		ifTrue: [false]		ifFalse: [timestamp > anEdition timestamp]! !!Edition methodsFor: 'as yet unclassified' stamp: 'crl 10/10/2016 19:39'!isTemporary	^nextEdition == self! !!Edition methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2008 17:57'!license	^license! !!Edition methodsFor: 'as yet unclassified' stamp: 'crl 7/6/2008 15:33'!license: aLicense	license := aLicense! !!Edition methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2008 18:39'!nextEdition	^nextEdition! !!Edition methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2008 18:39'!nextEdition: anEdition	nextEdition := anEdition! !!Edition methodsFor: 'as yet unclassified' stamp: 'crl 2/14/2008 23:02'!previousEdition	^previousEdition! !!Edition methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2008 18:39'!previousEdition: anEdition	previousEdition := anEdition! !!Edition methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2008 22:49'!printAuthorOn: aStream withOuterAuthor: anAuthorEdition	aStream nextPutAll: ' by '.	(author == anAuthorEdition)		ifTrue: [aStream nextPutAll: 'the same author']		ifFalse: [aStream print: author]! !!Edition methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2008 22:31'!printComponentNameOn: aStream withOuterAuthor: anAuthorEdition	self subclassResponsibility! !!Edition methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2008 16:34'!printOn: aStream	self printOn: aStream forEdit: nil! !!Edition methodsFor: 'as yet unclassified' stamp: 'crl 9/30/2016 16:00'!printOn: aStream forEdit: anEdit	(self isTemporary)		ifTrue: [aStream nextPutAll: 'a temporary']		ifFalse: [aStream nextPutAll: 'the'].			aStream nextPutAll: ' edition for '.	self		printComponentNameOn: aStream		withOuterAuthor: (			anEdit				ifNil: [self component author]				ifNotNil: [anEdit author]).	('* created at *' match: aStream contents) ifFalse: [		aStream nextPutAll: ', created at '.		(anEdit notNil and: [anEdit timestamp - timestamp < 5])			ifTrue: [aStream nextPutAll: 'the same time']			ifFalse: [				timestamp ifNil: [timestamp := Time totalSeconds].				aStream					print: (Date fromSeconds: timestamp);					nextPutAll: ', ';					print: (Time fromSeconds: timestamp)]]! !!Edition methodsFor: 'as yet unclassified' stamp: 'crl 7/6/2008 17:32'!storeAuthorFor: aMessagingSession	aMessagingSession store: author! !!Edition methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 15:47'!storeOnTether: tether	tether nextWordPut: self tag.	self storeAuthorFor: tether.	tether		store: license;		store: timestamp! !!Edition methodsFor: 'as yet unclassified' stamp: 'crl 5/24/2007 22:33'!tag	^self subclassResponsibility! !!Edition methodsFor: 'as yet unclassified' stamp: 'crl 10/10/2016 19:39'!temporaryCopy	| copy |		copy := self copy.		^copy		nextEdition: copy;		yourself! !!Edition methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2008 21:54'!timestamp	^timestamp! !!Edition methodsFor: 'as yet unclassified' stamp: 'crl 7/6/2008 15:33'!timestamp: aSmallInteger	timestamp := aSmallInteger! !!Edition class methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 18:51'!fromTether: tether	| edition author |	edition := self new.	author := tether next.	author ifNotNil: [		EditHistory residesLocally ifTrue: [			"If I'm in a history memory, fix the author to be the equivalent instance we already have, if any."			| existingAuthor |			existingAuthor := EditHistory knownAuthorWithID: author id.			existingAuthor ifNotNil: [author := existingAuthor]].		edition author: author].	edition		license: tether next;		timestamp: tether next.	^edition! !!Rank methodsFor: 'as yet unclassified' stamp: 'crl 11/18/2004 00:15'!+ anInteger	"Answer a rank corresponding to my index plus anInteger."	^(index + anInteger) th! !!Rank methodsFor: 'as yet unclassified' stamp: 'crl 11/18/2004 00:15'!- anInteger	"Answer a rank corresponding to my index minus anInteger."	^(index - anInteger) th! !!Rank methodsFor: 'as yet unclassified' stamp: 'crl 11/18/2004 00:19'!\\ anInteger	"Answer a rank corresponding to my index modulo anInteger."	^(index \\ anInteger) th! !!Rank methodsFor: 'as yet unclassified' stamp: 'crl 1/19/2003 18:06'!a	"Answer the member of the A pitch class that corresponds to me."	^Pitch classAMember: index! !!Rank methodsFor: 'as yet unclassified' stamp: 'crl 1/19/2003 18:07'!b	"Answer the member of the B pitch class that corresponds to me."	^Pitch classBMember: index! !!Rank methodsFor: 'as yet unclassified' stamp: 'crl 1/19/2003 18:06'!c	"Answer the member of the C pitch class that corresponds to me."	^Pitch classCMember: index! !!Rank methodsFor: 'as yet unclassified' stamp: 'crl 1/19/2003 18:10'!channel	"Answer the MIDI channel corresponding to me."	^MIDIChannel at: index! !!Rank methodsFor: 'as yet unclassified' stamp: 'crl 1/21/2003 10:02'!controller	"Answer the MIDI controller corresponding to me."	^MIDIController at: index! !!Rank methodsFor: 'as yet unclassified' stamp: 'crl 1/19/2003 18:07'!d	"Answer the member of the D pitch class that corresponds to me."	^Pitch classDMember: index! !!Rank methodsFor: 'as yet unclassified' stamp: 'crl 7/21/2003 13:46'!degree	"Answer the scale degree corresponding to me."	^ScaleDegree at: index! !!Rank methodsFor: 'as yet unclassified' stamp: 'crl 11/19/2006 23:40'!display	"Answer the display corresponding to me."	^Interpreter displays at: index! !!Rank methodsFor: 'as yet unclassified' stamp: 'crl 1/19/2003 18:07'!e	"Answer the member of the E pitch class that corresponds to me."	^Pitch classEMember: index! !!Rank methodsFor: 'as yet unclassified' stamp: 'crl 1/19/2003 18:06'!f	"Answer the member of the F pitch class that corresponds to me."	^Pitch classFMember: index! !!Rank methodsFor: 'as yet unclassified' stamp: 'crl 1/19/2003 18:07'!g	"Answer the member of the G pitch class that corresponds to me."	^Pitch classGMember: index! !!Rank methodsFor: 'as yet unclassified' stamp: 'crl 11/29/2006 12:53'!index	^index! !!Rank methodsFor: 'as yet unclassified' stamp: 'crl 1/19/2003 18:08'!index: anInteger	"Set my index to anInteger."	index _ anInteger! !!Rank methodsFor: 'as yet unclassified' stamp: 'crl 9/29/2004 12:28'!inversion	^Inversion withIndex: index! !!Rank methodsFor: 'as yet unclassified' stamp: 'crl 2/17/2006 18:16'!key	"Answer the MIDI keyboard key corresponding to me."	^0th a + (index - 21)! !!Rank methodsFor: 'as yet unclassified' stamp: 'crl 10/14/2003 04:20'!printOn: aStream	"Print a textual representation of myself onto aStream."	aStream nextPutAll: (		[			#(				first				second				third				fourth				fifth				sixth				seventh				eighth			)				at: index		]			ifError: [				index printString, (					(index between: 11 and: 13)						ifTrue: ['th']						ifFalse: [[#(st nd rd) at: index abs \\ 10] ifError: ['th']])])! !!Rank methodsFor: 'as yet unclassified' stamp: 'crl 4/20/2006 14:15'!quothMethodAnnotation	^#followsRankLiteral! !!Rank methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2004 21:07'!storeOn: aStream	aStream		print: index;		nextPutAll: (			(index between: 11 and: 13)				ifTrue: ['th']				ifFalse: [[#(st nd rd) at: index abs \\ 10] ifError: ['th']])! !!Rank methodsFor: 'as yet unclassified' stamp: 'crl 1/24/2003 04:07'!velocity	"Answer a MIDI velocity corresponding to me."	^MIDIVelocity at: index! !!Rank class methodsFor: 'as yet unclassified' stamp: 'crl 1/19/2003 18:07'!for: anInteger	"Answer an instance of myself corresponding to anInteger."	^self new index: anInteger! !!JSScrollFrameMorph methodsFor: 'as yet unclassified' stamp: 'crl 6/2/2017 22:18'!addCaffeineWorkspace: workspace	self setContents: workspace! !!JSScrollFrameMorph class methodsFor: 'as yet unclassified' stamp: 'crl 5/30/2017 13:26'!on: morph	^(self new)		add: morph;		yourself! !!ChromeEmulationAPI class methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 12:40'!domain	^'Emulation'! !!AScene methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!AScene class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!KeyWordNode methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!KeyWordNode class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!FMBassoonSound class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!Web methodsFor: 'as yet unclassified' stamp: 'crl 1/17/2015 17:06'!handleFor: anExternalResource	^anExternalResource javaScriptHandle! !!Web class methodsFor: 'as yet unclassified' stamp: 'crl 10/25/2016 22:30'!installerLocatorString	"JavaScript came with the machine."		^self shouldNotImplement! !!Web class methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2016 11:59'!userAgentPlatformTagPatterns	^#()! !!Unix methodsFor: 'as yet unclassified' stamp: 'crl 1/15/2015 00:10'!defaultProcessorNameTail	^'spoonvm'! !!Unix methodsFor: 'as yet unclassified' stamp: 'crl 1/15/2015 00:11'!processorFolderName	^'Linux/lib/spoon/4.4.7-2357'! !!Unix class methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2016 12:12'!installerLocatorString	^'http://blackpagedigital.com/context/installers/linux/squeak.zip'! !!Unix class methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2016 11:58'!userAgentPlatformTagPatterns	^#('Linux*' 'OpenBSD*' 'SunOS*' 'HP-UX' 'X11')! !!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 21:18'!fuseClassHierarchiesInto: fusedMethods	"Fuse entire class hierarchies."	{		FileDirectory.		PluggableListMorph.		SocketStream.		WebMessage.		Socket.		MimeConverter.		ProcessSpecificVariable.		AbstractSound.		ClassCategoryReader.		ImageReadWriter.		IndentingListItemMorph.		DirectoryEntry.		SimpleServiceEntry.		WebSocket.		InstructionClient.		SystemWindow.		FileList.		CodeHolder.		Collection.		CharacterScanner.		MorphicEvent.		Inspector.		CommandHistory.		DAVResource.		LanguageEnvironment.		BitBlt.		ParseNodeVisitor.		EncodedCharSet.		LayoutPolicy.		TTGlyph.		Envelope.		SharedPool.		BasicRequestor.
		ServiceProvider.		ServiceAction.		PreferenceBrowserMorph.		TextDiffBuilder.		HostPlatform.		FillStyle.		BorderStyle.		BlockStartLocator.		TextComposer.		AbstractResizerMorph.		DebuggerMethodMap.		AbstractFont.		ToolBuilderSpec.		ParseNode.		ToolBuilder.		UserInputEvent.		Preferences.		AbstractEvent.		Number.		InputSensor.		ContextPart.		Debugger.		Project.		Boolean.		Exception.		Collection.		Edition.		MethodLiteralTransmissionMarker.		Portal.		License.		Manifest.		BitMatchingPattern.		Inspector.		JSObject.		Canvas.		ByteTextConverter.		Form.		Color	}		do: [:class | self fuseSuperclass: class into: fusedMethods]! !!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/7/2019 18:57'!fuseProtoclass: protoclass into: fusedMethods	{		protoclass.		protoclass class	}		do: [:behavior |			| class |						class := behavior.						[{Object. nil} includes: class] whileFalse: [				(class methodDict isEmpty)					ifTrue: [						class compile: 'foo' classified: 'fusing'.						(class compiledMethodAt: #foo) fuse]					ifFalse: [class methodsDo: [:method | fusedMethods add: method]].				class := class superclass]]! !!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 23:15'!fuseSingleClassesInto: fusedMethods	{		SocketAddressInformation.		DelayWaitTimeout.		Number.		WebUtils.		ThirtyTwoBitRegister.		SecureHashAlgorithm.		DiffElement.		ProcessBrowser.		CPUWatcher.		TransferMorph.		DeepCopier.		MethodReference.		Random.		SoundService.		ExternalObjectTable.		ChangeRecord.		SystemChangeNotifier.		ClassBuilder.		Beeper.		GZipReadStream.		InternalTranslator.		ServerDirectory.		PluggableTreeItemNode.		PluggableTreeMorph.		FilePath.		MorphicEventDispatcher.		Utilities.		Command.		WebClient.		SystemProgressMorph.		InternetConfiguration.		NetNameResolver.		ChromeExtensionUrl.		SystemNavigation.		ColorTheme.		LocaleID.		XMLNamespace.		CharacterBlock.		UndefinedObject.		LimitedWriteStream.		HttpUrl.		SystemProgressBarMorph.		HaloSpec.		ResourceManager.		RemoteString.		ListChooser.		TextKern.		TTKernPair.		Clipboard.		Latin1Environment.		EventManager.		Global.		Time.		SoundPlayer.		PopUpMenu.		SelectorBrowser.		DualChangeSorter.		TextAlignment.		FMSound.		PaintBoxColorPicker.		ThreePhaseButtonMorph.		PaintInvokingMorph.		ProjectViewMorph.		ClockMorph.		EllipseMorph.		ObjectsTool.		UpdatingSimpleButtonMorph.		CurveMorph.		MagnifierMorph.		ListItemWrapper.		ObjectExplorerWrapper.		SoundRecorder.		RecordingControlsMorph.		TimeZone.		BaseSoundSystem.		DummySoundSystem.		TraitOrganizer.		ServiceShortcuts.		ServiceCancelled.		ServiceRegistry.		ServiceGui.		ServicePreferences.		TheWorldMainDockingBar.		TraitAlias.		ClassTrait.		PragmaPreference.		Workspace.		ChangeList.		ChangeSorter.		NewColorPickerMorph.		BrowseAvailableModules.		CounterpartRequest.		InstallRemoteModule.		PreferenceBrowser.		ToolIcons.		UpdatingMenuItemMorph.		PointerFinder.		ParseNodeEnumerator.		ParseNodeVisitor.		ZipWriteStream.		ZipEncoder.		TextDomainManager.		StepMessage.		SystemWindowButton.		UTF8TextConverter.		FillInTheBlankMorph.		RealEstateAgent.		TransformMorph.		PluggableTextMorphPlus.		Preference.		WindowColorSpec.		UserDialogBoxMorph.		WindowColorRegistry.		TheWorldMenu.		PluggableListMorphPlus.		PluggableTextMorph.		TextMorphForEditView.		TextLine.		DeflateStream.		AdditionalMethodState.		Compiler.		CompilationCue.		Association.		PluggableButtonMorphPlus.		PluggablePanelMorph.		SketchMorph.		LayoutFrame.		IconicButton.		SimpleButtonMorph.		StandardScriptingSystem.		MessageNames.		FileServices.		ClassBinding.		Webpage current class.		FileDirectory.		Metaclass.		ClassDescription.		Behavior.		Class.		MethodDictionary.		DisplayText.		ProtoObject.		Tether.		ExceptionMarker.		InstructionPrinter.		Author.		EditHistory.		ModuleDescription.		ModuleID.		Version.		Other.		SmalltalkImage.		Environment.		ChangeSet.		ClassChangeRecord.		MethodChangeRecord.		ToolSet.		SystemBrowser.		StandardToolSet.		Message.		MessageSend.		Process.		ProcessorScheduler.		BlockClosure.		BlockContext.		SharedQueue.		TranscriptStream.		Categorizer.		Character.		ExtendedNumberParser.		JSObjectProxy.		SystemOrganizer.		Shaker.		Decompiler.		PolygonMorph.		SmalltalkEditor.		Pragma.		BalloonEngine.		MultiByteFileStream.		BalloonEdgeData.		BalloonFillData.		UTF8ClipboardInterpreter.		BreakpointManager.		ZipConstants.		MorphicUIManager.		MenuLineMorph.		NewBalloonMorph.		BalloonMorph.		AbstractLauncher.		AutoStart.		ObjectHistory.		Parser.		MenuMorph.		AlignmentMorph.		StringMorph.		MenuItemMorph.		MorphicTransform.		MenuIcons.		LayoutCell.		TableLayoutProperties.		Rectangle.		BorderStyle.		SimpleBorder.		TextFontReference.		Browser.		Point.		HandMorph.		PasteUpMorph.		WorldState.		MessageTally.		PluggableWindowSpec.		ScrollBar.		MorphicModel.		SHParserST80.		PluggableTextSpec.		Point.		SystemWindow.		PluggableButtonMorph.		PluggableSystemWindow.		CompiledMethodTrailer.		TextEmphasis.		SHTextStylerST80.		TextMorph.		PluggableListMorph.		LazyListMorph.		ScrollPane.		Monitor.		TextColor.		MouseOverHandler.		SHRange.		CharacterScanner.		CompositionScanner.		EventHandler.		MouseClickState.		MorphExtension.		IdentityTransform.		TopGripMorph.		TextStyle.		ProportionalSplitterMorph.		NewParagraph	}		do: [:class | self fuseProtoclass: class into: fusedMethods]! !!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 3/20/2019 17:46'!fuseSuperclass: superclass into: fusedMethods	superclass withAllSubclassesDo: [:class | self fuseProtoclass: class into: fusedMethods]! !!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/6/2019 21:07'!shake	| fusedMethods weakArray navigation reloadingMethod numberOfClassesRemoved |		weakArray := WeakArray with: Object new.	navigation := SystemNavigation new.		fusedMethods := (		(OrderedCollection new)			addAll: {				Object compiledMethodAt: #defaultBackgroundColor.				Object compiledMethodAt: #primitiveError:.				Object compiledMethodAt: #perform:.								Object compiledMethodAt: #perform:with:.				Object compiledMethodAt: #perform:with:with:.				Object compiledMethodAt: #perform:with:with:with:.				Object compiledMethodAt: #perform:with:with:with:with:.				Object compiledMethodAt: #perform:withArguments:.						Object compiledMethodAt: #perform:withArguments:inSuperclass:.						Object compiledMethodAt: #perform:withEnoughArguments:.				Object compiledMethodAt: #isSymbol.				Behavior reloadingMethod.				EditHistory compiledMethodAt: #swapInMethodAt:in:.				Object compiledMethodAt: #currentWorld.				Object compiledMethodAt: #adaptToInteger:andSend:.				Object compiledMethodAt: #in:.				Object compiledMethodAt: #addDependent:.				Symbol compiledMethodAt: #isSymbol.				ContextPart compiledMethodAt: #selector.				ContextPart compiledMethodAt: #arguments.				CompiledMethod compiledMethodAt: #selector.				UUIDGenerator compiledMethodAt: #semaphoreForGenerator.				UUIDGenerator compiledMethodAt: #randomGenerator.				ProtoObject compiledMethodAt: #initialize.				BlockClosure compiledMethodAt: #value.				BlockContext compiledMethodAt: #value.				Semaphore compiledMethodAt: #wait.				UndefinedObject compiledMethodAt: #release.				ClassOrganizer compiledMethodAt: #traitComposition.				ByteString class compiledMethodAt: #stringHash:initialHash:};			yourself).			{		#(id isNil notNil isInteger removeFromSystem removeFromSystem: hashBytes:startingWith: size species signal resumptionTime primGetNextEvent: bitAnd: new: new negative at: at:put: bitShiftMagnitude: bitOr: < randomCounter / + asFloat bitXor: identityHash basicAt: basicAt:put: basicNew: basicNew isMethodProperties).		CompiledMethodTrailer trailerKindDecoders.	}		do: [:set |			set do: [:selector |		(navigation allImplementorsOf: selector) do: [:reference | fusedMethods add: reference compiledMethod]]].	self		fuseSingleClassesInto: fusedMethods;		fuseClassHierarchiesInto: fusedMethods.				fusedMethods do: [:method | method fuse].		Behavior setReloadingMethod.	reloadingMethod := Behavior reloadingMethod.	Shaker class swapOutMethodAt: #test:.	(Shaker test: 42) = 42 ifFalse: [self error: 'history system not working'].		"Set the selector and class-binding literals of the reloading method to things which make sense in the JS debugger."	Behavior setReloadingMethod.	LRUCache allInstancesDo: [:cache | cache reset].	ScrollBar boxOfSize: 10@10 color: Color blue.	Inspector inspect: 3.	ToolBuilder default.	WeakArray restartFinalizationProcess.	[3 error: 'ignored'] on: Error do: [:exception | ].	EventSensor install.	Delay initialize.	(Delay forSeconds: 1) wait.	Sensor fetchMoreEvents.		{		BlockClosure.		ContextPart	}		do: [:class |			class allSubInstancesDo: [:methodHolder | methodHolder fuse]].		JS at: #shaking put: true.	Smalltalk		primitiveGarbageCollect;		primitiveFusedGarbageCollect;		primitiveFusedGarbageCollect.			numberOfClassesRemoved := -1.		[numberOfClassesRemoved = 0] whileFalse: [		numberOfClassesRemoved := 0.		(Class allSubclasses asSortedCollection: [:earlier :later | earlier depth <= later depth]) asArray reversed do: [:metaclass |			(				metaclass soleInstance subclasses isEmpty not or: [					{						metaclass.						metaclass soleInstance					}						anySatisfy: [:behavior |							behavior methodDict anySatisfy: [:method | method ~~ reloadingMethod]]]			)				ifFalse: [					metaclass soleInstance removeFromSystem.					numberOfClassesRemoved := numberOfClassesRemoved + 1]]].		Smalltalk garbageCollect! !!Shaker class methodsFor: 'as yet unclassified' stamp: 'crl 3/26/2019 12:59'!shake	^self new shake! !!TransformMorph class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!VariableDeclaration methodsFor: 'as yet unclassified' stamp: 'crl 5/6/2017 16:23'!declarators	^declarations! !!VariableDeclaration methodsFor: 'as yet unclassified' stamp: 'crl 5/7/2017 13:52'!declares	^true! !!VariableDeclaration methodsFor: 'as yet unclassified' stamp: 'crl 5/6/2017 16:31'!printSmalltalkOn: stream	declarations do: [:declarator | declarator printSmalltalkOn: stream]! !!VariableDeclaration class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!TinyMCEEditor methodsFor: 'as yet unclassified' stamp: 'crl 4/1/2019 00:20'!backspace	"Set my content to be the current content with the selected characters removed (or with the character to the left of the caret removed, if there are no characters selected)."		| range startContainer endContainer startOffset endOffset |		range := self range.	startContainer := range startContainer.	endContainer := range endContainer.	startOffset := range startOffset.	endOffset := range endOffset.	((startContainer isSameNode: endContainer) and: [startOffset = endOffset and: [startContainer class == JSText]])		ifTrue: [startContainer remove]		ifFalse: [			(startOffset = endOffset)				ifTrue: [(startContainer childNodes at: startOffset) ifNotNilDo: [:node | node remove]]				ifFalse: [range deleteContents]]! !!TinyMCEEditor methodsFor: 'as yet unclassified' stamp: 'crl 3/31/2019 13:25'!proxy: aJSObjectProxy	super proxy: aJSObjectProxy.	body := self getBody! !!TinyMCEEditor methodsFor: 'as yet unclassified' stamp: 'crl 3/31/2019 22:40'!range	^self selection getRng! !!TinyMCEEditor class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!ReturnStatement methodsFor: 'as yet unclassified' stamp: 'crl 5/7/2017 00:32'!printSmalltalkOn: stream	stream nextPut: $^.	argument printSmalltalkOn: stream! !!ReturnStatement class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!MIDIPacket methodsFor: 'as yet unclassified' stamp: 'crl 9/4/2008 16:24'!message	^message! !!MIDIPacket methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2008 16:39'!message: messageBytes timestamp: theTimestamp	message _ messageBytes.	timestamp _ theTimestamp.	MIDIStream showDebugOutput ifTrue: [Transcript cr; nextPutAll: 'received '; print: messageBytes; nextPutAll: ' at '; print: self timestamp; endEntry]! !!MIDIPacket methodsFor: 'as yet unclassified' stamp: 'crl 9/7/2008 18:46'!timestamp	^(timestamp first bitShift: 24) + (timestamp second bitShift: 16) + (timestamp third bitShift: 8) + timestamp fourth! !!MIDIPacket class methodsFor: 'as yet unclassified' stamp: 'crl 9/1/2008 17:00'!withMessage: message andTimestamp: timestamp	^(self new) message: message timestamp: timestamp! !!JSFileReader methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSFileReader class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!DebuggerMethodMapForBlueBookMethods class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!CP1253TextConverter methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:55'!foo! !!SnowglobeInstructions methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!SnowglobeInstructions class methodsFor: 'as yet unclassified' stamp: 'crl 7/20/2018 14:47'!initialize	"Initialize myself."	self initializeInstructions: #(startSession handleDisplayEventIn: handleMouseEventIn: handleKeyboardEventIn: stopSession restoreDisplay fullscreenOff showCursor hideCursor drawRubberBand closeWindowIn: mapWindowIn: unmapWindowIn:)! !!ServiceShortcuts methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!Scene methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!Scene class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!BitBlt methodsFor: 'as yet unclassified' stamp: 'crl 5/14/2017 11:10'!displayScannerFor: para foreground: foreColor background: backColor ignoreColorChanges: shadowMode	^ (DisplayScanner new text: para text textStyle: para textStyle			foreground: foreColor background: backColor fillBlt: self			ignoreColorChanges: shadowMode)		setPort: self clone! !!ChromeRenderingAPI class methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 12:41'!domain	^'Rendering'! !!JSWebSocket methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 14:16'!hostname	^(self url readStream)		upToAll: '//';		upTo: $:! !!JSWebSocket methodsFor: 'as yet unclassified' stamp: 'crl 6/30/2017 11:30'!isConnected	^self readyState = 1! !!JSWebSocket methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 14:15'!port	^(		(self url readStream)			upTo: $:;			upTo: $:;			upTo: $/	)		asNumber! !!JSWebSocket class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!FloatArray class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!MouseOverHandler class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!JSONObject methodsFor: 'as yet unclassified' stamp: 'crl 8/8/2016 14:14'!at: key	^dictionary at: key! !!JSONObject methodsFor: 'as yet unclassified' stamp: 'crl 8/5/2016 23:48'!at: key put: value	^dictionary at: key put: value! !!JSONObject methodsFor: 'as yet unclassified' stamp: 'crl 8/5/2016 22:32'!dictionary: aDictionary	dictionary _ aDictionary! !!JSONObject methodsFor: 'as yet unclassified' stamp: 'crl 8/7/2016 16:13'!doesNotUnderstand: aMessage	| element |		element := dictionary at: aMessage selector.	^(element isKindOf: Dictionary)		ifTrue: [self class on: element]		ifFalse: [element]! !!JSONObject methodsFor: 'as yet unclassified' stamp: 'crl 8/5/2016 22:36'!includesKey: key	^dictionary includesKey: key! !!JSONObject methodsFor: 'as yet unclassified' stamp: 'crl 8/5/2016 22:36'!keysAndValuesDo: block	^dictionary keysAndValuesDo: block! !!JSONObject methodsFor: 'as yet unclassified' stamp: 'crl 8/6/2016 00:11'!printOn: aStream	super printOn: aStream.	dictionary printElementsOn: aStream! !!JSONObject methodsFor: 'as yet unclassified' stamp: 'crl 8/19/2016 15:22'!value	^self at: 'value'! !!JSONObject class methodsFor: 'as yet unclassified' stamp: 'crl 6/27/2017 11:18'!fromString: string	^self on: (WebUtils jsonDecode: string readStream)! !!JSONObject class methodsFor: 'as yet unclassified' stamp: 'crl 8/5/2016 22:32'!on: dictionary	^self new dictionary: dictionary! !!Text methodsFor: 'as yet unclassified' stamp: 'crl 5/20/2018 23:24'!storeOnTether: tether
	self asString storeOnTether: tether! !!WebMIDIInput methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!WebMIDIInput class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'crl 5/4/2017 22:26'!printJavaScriptOn: stream indent: level 	stream nextPutAll: name! !!TempVariableNode class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!OrderedCollectionInspector class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!ImageReadWriter class methodsFor: 'as yet unclassified' stamp: 'crl 5/15/2017 13:37'!putForm: aForm onStream: aWriteStream	"Store the given form on a file of the given name."	| writer |	writer := self on: aWriteStream.	writer nextPutImage: aForm.	writer close.! !!AppRegistry methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!KeyedIdentitySet class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!Base64MimeConverter methodsFor: 'as yet unclassified' stamp: 'tk 12/9/97 13:34'!mimeDecode	"Convert a stream in base 64 with only a-z,A-Z,0-9,+,/ to a full byte stream of characters.  Reutrn a whole stream for the user to read."	| nibA nibB nibC nibD |	[mimeStream atEnd] whileFalse: [		(nibA := self nextValue) ifNil: [^ dataStream].		(nibB := self nextValue) ifNil: [^ dataStream].		dataStream nextPut: ((nibA bitShift: 2) + (nibB bitShift: -4)) asCharacter.		nibB := nibB bitAnd: 16rF.		(nibC := self nextValue) ifNil: [^ dataStream].		dataStream nextPut: ((nibB bitShift: 4) + (nibC bitShift: -2)) asCharacter.		nibC := nibC bitAnd: 16r3.		(nibD := self nextValue) ifNil: [^ dataStream].		dataStream nextPut: ((nibC bitShift: 6) + nibD) asCharacter.		].	^ dataStream! !!Base64MimeConverter methodsFor: 'as yet unclassified' stamp: 'tk 12/9/97 13:39'!mimeDecodeToByteArray	"Convert a stream in base 64 with only a-z,A-Z,0-9,+,/ to a full ByteArray of 0-255 values.  Reutrn a whole stream for the user to read."	| nibA nibB nibC nibD |	[mimeStream atEnd] whileFalse: [		(nibA := self nextValue) ifNil: [^ dataStream].		(nibB := self nextValue) ifNil: [^ dataStream].		dataStream nextPut: ((nibA bitShift: 2) + (nibB bitShift: -4)).		nibB := nibB bitAnd: 16rF.		(nibC := self nextValue) ifNil: [^ dataStream].		dataStream nextPut: ((nibB bitShift: 4) + (nibC bitShift: -2)).		nibC := nibC bitAnd: 16r3.		(nibD := self nextValue) ifNil: [^ dataStream].		dataStream nextPut: ((nibC bitShift: 6) + nibD).		].	^ dataStream! !!Base64MimeConverter methodsFor: 'as yet unclassified' stamp: 'ar 4/15/2008 17:58'!mimeEncode	"Convert from data to 6 bit characters."	| phase1 phase2 raw nib lineLength |	phase1 := phase2 := false.	lineLength := 0.	[dataStream atEnd] whileFalse: [		(multiLine and:[lineLength >= 70]) ifTrue: [ mimeStream cr.  lineLength := 0. ].		data := raw := dataStream next asInteger.		nib := (data bitAnd: 16rFC) bitShift: -2.		mimeStream nextPut: (ToCharTable at: nib+1).		(raw := dataStream next) ifNil: [raw := 0. phase1 := true].		data := ((data bitAnd: 3) bitShift: 8) + raw asInteger.		nib := (data bitAnd: 16r3F0) bitShift: -4.		mimeStream nextPut: (ToCharTable at: nib+1).		(raw := dataStream next) ifNil: [raw := 0. phase2 := true].		data := ((data bitAnd: 16rF) bitShift: 8) + (raw asInteger).		nib := (data bitAnd: 16rFC0) bitShift: -6.		mimeStream nextPut: (ToCharTable at: nib+1).		nib := (data bitAnd: 16r3F).		mimeStream nextPut: (ToCharTable at: nib+1).		lineLength := lineLength + 4.].	phase1 ifTrue: [mimeStream skip: -2; nextPut: $=; nextPut: $=.			^ mimeStream].	phase2 ifTrue: [mimeStream skip: -1; nextPut: $=.			^ mimeStream].! !!Base64MimeConverter methodsFor: 'as yet unclassified' stamp: 'ar 4/15/2008 17:58'!multiLine	"Determines whether we allow multi-line encodings (the default) or force everything into a single line (for use with URLs etc. where the continuation marker and the line break cause problems)"	^multiLine! !!Base64MimeConverter methodsFor: 'as yet unclassified' stamp: 'ar 4/15/2008 17:58'!multiLine: aBool	"Determines whether we allow multi-line encodings (the default) or force everything into a single line (for use with URLs etc. where the continuation marker and the line break cause problems)"	multiLine := aBool! !!Base64MimeConverter methodsFor: 'as yet unclassified' stamp: 'ul 6/17/2011 12:36'!nextValue	"The next six bits of data char from the mimeStream, or nil.  Skip all other chars"	| raw num |	[raw := mimeStream next.	raw ifNil: [^ nil].	"end of stream"	raw == $= ifTrue: [^ nil].	num := FromCharTable at: raw asciiValue + 1.	num ifNotNil: [^ num].	"else ignore space, return, tab, ..."	] repeat! !!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'tk 2/19/2000 15:53'!decodeInteger: mimeString	| bytes sum |	"Decode the MIME string into an integer of any length"	bytes := (Base64MimeConverter mimeDecodeToBytes: 				(ReadStream on: mimeString)) contents.	sum := 0.	bytes reverseDo: [:by | sum := sum * 256 + by].	^ sum! !!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'nice 7/26/2014 23:00'!encodeInteger: int	| strm |	"Encode an integer of any length and return the MIME string"	strm := WriteStream on: (ByteArray new: int digitLength).	1 to: int digitLength do: [:ii | strm nextPut: (int digitAt: ii)].	^ ((self mimeEncode: strm readStream) contents) copyUpTo: $=	"remove padding"! !!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'nice 7/30/2013 01:59'!initialize	FromCharTable := Array new: 256.	"nils"	ToCharTable := ($A to: $Z) , ($a to: $z) , ($0 to: $9) , '+/'.	ToCharTable keysAndValuesDo: [:ind :char |		FromCharTable at: char asciiValue + 1 put: ind - 1].! !!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'nice 7/26/2014 23:03'!mimeDecodeToBytes: aStream 	"Return a ReadStream of the original ByteArray.  aStream has only 65 innocuous character values.  aStream is not binary.  (See class comment). 4 bytes in aStream goes to 3 bytes in output."	| me |	aStream position: 0.	me := self new mimeStream: aStream.	me dataStream: (WriteStream on: (ByteArray new: aStream size * 3 // 4)).	me mimeDecodeToByteArray.	^ me dataStream readStream! !!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'nice 7/26/2014 23:01'!mimeDecodeToChars: aStream 	"Return a ReadWriteStream of the original String.  aStream has only 65 innocuous character values.  It is not binary.  (See class comment). 4 bytes in aStream goes to 3 bytes in output."	| me |	aStream position: 0.	me := self new mimeStream: aStream.	me dataStream: (WriteStream on: (String new: aStream size * 3 // 4)).	me mimeDecode.	^ me dataStream readStream! !!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'ar 3/9/2010 22:17'!mimeEncode: aStream	"Return a ReadWriteStream of characters.  The data of aStream is encoded as 65 innocuous characters.  (See class comment). 3 bytes in aStream goes to 4 bytes in output."	^self mimeEncode: aStream multiLine: true atStart: true! !!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'ar 3/9/2010 22:17'!mimeEncode: aStream multiLine: aBool	"Return a ReadWriteStream of characters.  The data of aStream is encoded as 65 innocuous characters.  (See class comment). 3 bytes in aStream goes to 4 bytes in output."	^self mimeEncode: aStream multiLine: aBool atStart: true! !!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'nice 7/26/2014 22:59'!mimeEncode: aStream multiLine: aBool atStart: resetInput	"Return a ReadStream of characters.  The data of aStream is encoded as 65 innocuous characters.  (See class comment). 3 bytes in aStream goes to 4 bytes in output."	| me |	resetInput ifTrue:[aStream position: 0].	me := self new dataStream: aStream.	me multiLine: aBool.	me mimeStream: (WriteStream on: (String new: aStream size + 20 * 4 // 3)).	me mimeEncode.	^ me mimeStream readStream! !!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'ar 3/9/2010 22:17'!mimeEncodeContinue: aStream	"Return a ReadWriteStream of characters.  The data of aStream is encoded as 65 innocuous characters.  (See class comment). 3 bytes in aStream goes to 4 bytes in output."	^self mimeEncode: aStream multiLine: true atStart: false! !!MyTestError methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!MyTestError class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!SmalltalkImage methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2019 01:41'!datedVersion	"Answer the version of this release."	^'2019.3'! !!SmalltalkImage methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 23:37'!jsSpecialObjectsArray: newArray	<primitive: 'setSpecialObjectsArray' module: 'Flow'>	self primitiveFailed! !!SmalltalkImage methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2019 01:41'!lastUpdateString	"Smalltalk lastUpdateString"	^'latest update: #' translated, '2019.3'! !!SmalltalkImage methodsFor: 'as yet unclassified' stamp: 'crl 3/13/2019 22:12'!primitiveFusedGarbageCollect	"Primitive. Reclaims all garbage, including unfused methods, and answers the number of bytes of available space."	<primitive: 164>	^ self primBytesLeft! !!SmalltalkImage methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 00:52'!recreateSpecialObjectsArray	"Smalltalk recreateSpecialObjectsArray"		"To external package developers:	**** DO NOT OVERRIDE THIS METHOD.  *****	If you are writing a plugin and need additional special object(s) for your own use, 	use addGCRoot() function and use own, separate special objects registry "		"The Special Objects Array is an array of objects used by the Squeak virtual machine.	 Its contents are critical and accesses to it by the VM are unchecked, so don't even	 think of playing here unless you know what you are doing."	| newArray |	newArray := Array new: 124.	"Nil false and true get used throughout the interpreter"	newArray at: 1 put: nil.	newArray at: 2 put: false.	newArray at: 3 put: true.	"This association holds the active process (a ProcessScheduler)"	newArray at: 4 put: (self specialObjectsArray at: 4) "(self bindingOf: #Processor) but it answers an Alias".	"Numerous classes below used for type checking and instantiation"	newArray at: 5 put: Bitmap.	newArray at: 6 put: SmallInteger.	newArray at: 7 put: ByteString.	newArray at: 8 put: Array.	newArray at: 9 put: Smalltalk.	newArray at: 10 put: Float.	newArray at: 11 put: MethodContext.	newArray at: 12 put: BlockContext.	newArray at: 13 put: Point.	newArray at: 14 put: LargePositiveInteger.	newArray at: 15 put: Display.	newArray at: 16 put: Message.	newArray at: 17 put: CompiledMethod.	newArray at: 18 put: (self specialObjectsArray at: 18).	"(low space Semaphore)"	newArray at: 19 put: Semaphore.	newArray at: 20 put: Character.	newArray at: 21 put: #doesNotUnderstand:.	newArray at: 22 put: #cannotReturn:.	newArray at: 23 put: nil. "This is the process signalling low space."	"An array of the 32 selectors that are compiled as special bytecodes,	 paired alternately with the number of arguments each takes."	newArray at: 24 put: #(	#+ 1 #- 1 #< 1 #> 1 #<= 1 #>= 1 #= 1 #~= 1							#* 1 #/ 1 #\\ 1 #@ 1 #bitShift: 1 #// 1 #bitAnd: 1 #bitOr: 1							#at: 1 #at:put: 2 #size 0 #next 0 #nextPut: 1 #atEnd 0 #== 1 #class 0							#blockCopy: 1 #value 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0 ).	"An array of the 255 Characters in ascii order.	 Cog inlines table into machine code at: prim so do not regenerate it."	newArray at: 25 put: (self specialObjectsArray at: 25).	newArray at: 26 put: #mustBeBoolean.	newArray at: 27 put: ByteArray.	newArray at: 28 put: Process.	"An array of up to 31 classes whose instances will have compact headers"	newArray at: 29 put: self compactClassesArray.	newArray at: 30 put: (self specialObjectsArray at: 30). "(delay Semaphore)"	newArray at: 31 put: (self specialObjectsArray at: 31). "(user interrupt Semaphore)"	"Entries 32 - 34 unreferenced. Previously these contained prototype instances to be copied for fast initialization"	newArray at: 32 put: nil. "was (Float new: 2)"	newArray at: 33 put: nil. "was (LargePositiveInteger new: 4)"	newArray at: 34 put: nil. "was Point new"	newArray at: 35 put: #cannotInterpret:.	"Note: This must be fixed once we start using context prototypes (yeah, right)"	"(MethodContext new: CompiledMethod fullFrameSize)."	newArray at: 36 put: (self specialObjectsArray at: 36). "Is the prototype MethodContext (unused by the VM)"	newArray at: 37 put: BlockClosure.	"(BlockContext new: CompiledMethod fullFrameSize)."	newArray at: 38 put: (self specialObjectsArray at: 38). "Is the prototype BlockContext (unused by the VM)"	"array of objects referred to by external code"	newArray at: 39 put: (self specialObjectsArray at: 39).	"preserve external semaphores"	newArray at: 40 put: nil. "Reserved for Mutex in Cog VMs"	newArray at: 41 put: nil. "Reserved for a LinkedList instance for overlapped calls in CogMT"	"finalization Semaphore"	newArray at: 42 put: ((self specialObjectsArray at: 42) ifNil: [Semaphore new]).	newArray at: 43 put: LargeNegativeInteger.	"External objects for callout.	 Note: Written so that one can actually completely remove the FFI."	newArray at: 44 put: (self at: #ExternalAddress ifAbsent: []).	newArray at: 45 put: (self at: #ExternalStructure ifAbsent: []).	newArray at: 46 put: (self at: #ExternalData ifAbsent: []).	newArray at: 47 put: (self at: #ExternalFunction ifAbsent: []).	newArray at: 48 put: (self at: #ExternalLibrary ifAbsent: []).	newArray at: 49 put: #aboutToReturn:through:.	newArray at: 50 put: #run:with:in:.	"51 reserved for immutability message"	"newArray at: 51 put: #attemptToAssign:withIndex:."	newArray at: 51 put: (self specialObjectsArray at: 51 ifAbsent: []).	newArray at: 52 put: #(nil "nil => generic error" #'bad receiver'							#'bad argument' #'bad index'							#'bad number of arguments'							#'inappropriate operation'  #'unsupported operation'							#'no modification' #'insufficient object memory'							#'insufficient C memory' #'not found' #'bad method'							#'internal error in named primitive machinery'							#'object may move' #'resource limit exceeded'							#'object is pinned').	"53 to 55 are for Alien"	newArray at: 53 put: (self at: #Alien ifAbsent: []).	newArray at: 54 put: #invokeCallbackContext::. "use invokeCallback:stack:registers:jmpbuf: for old Alien callbacks."	newArray at: 55 put: (self at: #UnsafeAlien ifAbsent: []).	"Weak reference finalization"	newArray at: 56 put: (self at: #WeakFinalizationList ifAbsent: []).	"reserved for foreign callback process"	newArray at: 57 put: (self specialObjectsArray at: 57 ifAbsent: []).	newArray at: 58 put: #unusedBytecode.	newArray		 at: 108 put: Other;		 at: 109 put: #forward:;		 at: 110 put: #remoteIdentity:tether:;		 at: 111 put: #recyclingHash;		 at: 112 put: #counterpart;		 at: 113 put: #isNil;		 at: 114 put: #nextInstance;		 at: 115 put: #storeOnTether:;		at: 116 put: #startReportingSends;		at: 117 put: (MethodID new: 128);		at: 118 put: Semaphore new;		at: 119 put: #stopReportingSends;		at: 120 put: #unreportedWait;		at: 121 put: #unreportedSignal;		at: 122 put: #tether;		at: 123 put: Behavior reloadingMethod;		at: 124 put: JSObjectProxy.	"Now replace the interpreter's reference in one atomic operation"	self specialObjectsArray becomeForward: newArray.	JS ifConnected: [Smalltalk jsSpecialObjectsArray: newArray]! !!XMLWarningException methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!XMLWarningException class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!HTMLParagraphElement methodsFor: 'as yet unclassified' stamp: 'crl 9/10/2017 20:35'!text: string	| oldInnerHTML newInnerHTML |		oldInnerHTML := self innerHTML readStream.	newInnerHTML := (String new: oldInnerHTML size) writeStream.	newInnerHTML nextPutAll: string.	oldInnerHTML upTo: $<.	newInnerHTML		nextPut: $<;		nextPutAll: oldInnerHTML upToEnd.			self innerHTML: newInnerHTML contents! !!HTMLParagraphElement class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!TopRightGripMorph class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!CommentNode class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!HTMLImageElement methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!HTMLImageElement class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!Debugger methodsFor: 'as yet unclassified' stamp: 'crl 4/18/2018 18:10'!openNotifierContents: msgString label: label	"Create, schedule and answer a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active process has not been suspended.  The sender will do this."	| msg builder spec |	"Transcript		nextPutAll: (			(interruptedProcess suspendedContext)				ifNil: ['(no stack)']				ifNotNil: [interruptedProcess suspendedContext longStack]);		endEntry."			Sensor flushKeyboard.	savedCursor := Cursor currentCursor.	Cursor currentCursor: Cursor normal.	msg := (label beginsWith: 'Space is low')		ifTrue: [self lowSpaceChoices, (msgString ifNil: [String empty])]		ifFalse: [msgString].	builder := ToolBuilder default.	spec := self buildNotifierWith: builder label: label message: (msg ifNil: [label]).	self expandStack.	^[builder openDebugger: spec] ensure:		[errorWasInUIProcess := Project current spawnNewProcessIfThisIsUI: interruptedProcess]! !!Debugger class methodsFor: 'as yet unclassified' stamp: 'crl 6/6/2018 17:19'!morphicOpenOn: process context: context label: title contents: contentsStringOrNil fullView: bool	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."	| errorWasInUIProcess debugger |	JS ifConnected: [JS debugger].	errorWasInUIProcess := Project current spawnNewProcessIfThisIsUI: process.	[Preferences logDebuggerStackToFile		ifTrue: [Smalltalk logSqueakError: title inContext: context]] on: Error do: [:ex | ex return: nil].	WorldState addDeferredUIMessage: [ 		"schedule debugger in deferred UI message to address redraw		problems after opening a debugger e.g. from the testrunner."		[			debugger := self new process: process controller: nil context: context.			bool				ifTrue: [debugger openFullNoSuspendLabel: title]				ifFalse: [debugger openNotifierContents: contentsStringOrNil label: title].			debugger errorWasInUIProcess: errorWasInUIProcess.		] on: Error do: [:ex |				self primitiveError: 					'Original error: ', 					title asString, '.	Debugger error: ', 				([ex description] on: Error do: ['a ', ex class printString]), ':'			]	].	process suspend.! !!Debugger class methodsFor: 'as yet unclassified' stamp: 'dtl 2/27/2011 16:37'!openOn: process context: context label: title contents: contentsStringOrNil fullView: bool	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short	view of the sender stack and provides a menu that lets the user open a full debugger.	Dispatch the request to a method appropriate for the active project."	^ Project current		dispatchTo: self		addPrefixAndSend: #OpenOn:context:label:contents:fullView:		withArguments: { process . context . title . contentsStringOrNil . bool }! !!JSFrameMorph methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSFrameMorph class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!Iterator methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!Iterator class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!MorphicProject methodsFor: 'as yet unclassified' stamp: 'crl 9/14/2019 17:29'!setAsBackground: aForm	"Set  aForm as a background image."	| thisWorld target newColor |	thisWorld := self currentWorld.	target := Form extent: Display extent depth: Display depth.	newColor := InfiniteForm with: target.	aForm displayScaledOn: target.	aForm rememberCommand:		(Command new cmdWording: 'set background to a picture' translated;			undoTarget: thisWorld selector: #color: argument: thisWorld color;			redoTarget: thisWorld selector: #color: argument: newColor).	thisWorld color: newColor! !!Socket methodsFor: 'as yet unclassified' stamp: 'bolot 7/16/1999 14:36'!accept	"Accept a connection from the receiver socket.	Return a new socket that is connected to the client"	^Socket acceptFrom: self.! !!Socket methodsFor: 'as yet unclassified' stamp: 'ul 10/25/2014 17:38'!acceptFrom: aSocket	"Initialize a new socket handle from an accept call"	self initializeSocketHandleUsing: [ :semaIndex :readSemaIndex :writeSemaIndex |		self			primAcceptFrom: aSocket socketHandle			receiveBufferSize: 8000			sendBufSize: 8000			semaIndex: semaIndex			readSemaIndex: readSemaIndex			writeSemaIndex: writeSemaIndex ]! !!Socket methodsFor: 'as yet unclassified' stamp: 'ar 4/30/1999 04:25'!address	"Shortcut"	^self localAddress! !!Socket methodsFor: 'as yet unclassified' stamp: 'ikp 6/9/2007 09:35'!bindTo: aSocketAddress	| status |	self initializeNetwork.	status := self primSocketConnectionStatus: socketHandle.	(status == Unconnected)		ifFalse: [InvalidSocketStatusException signal: 'Socket status must Unconnected when binding it to an address'].	self primSocket: socketHandle bindTo: aSocketAddress.! !!Socket methodsFor: 'as yet unclassified' stamp: 'jm 9/11/97 20:29'!close	"Close this connection gracefully. For TCP, this sends a close request, but the stream remains open until the other side also closes it."	self primSocketCloseConnection: socketHandle.  "close this end"! !!Socket methodsFor: 'as yet unclassified' stamp: 'jm 11/4/97 07:15'!closeAndDestroy	"First, try to close this connection gracefully. If the close attempt fails or times out, abort the connection. In either case, destroy the socket. Do nothing if the socket has already been destroyed (i.e., if its socketHandle is nil)."	self closeAndDestroy: 20.! !!Socket methodsFor: 'as yet unclassified' stamp: 'marcus.denker 9/14/2008 21:20'!closeAndDestroy: timeoutSeconds	"First, try to close this connection gracefully. If the close attempt fails or times out, abort the connection. In either case, destroy the socket. Do nothing if the socket has already been destroyed (i.e., if its socketHandle is nil)."	socketHandle ifNotNil: [			self isConnected ifTrue: [				self close.  "close this end"				(self waitForDisconnectionFor: timeoutSeconds) ifFalse: [						"The other end didn't close so we just abort the connection"						self primSocketAbortConnection: socketHandle]].			self destroy].! !!Socket methodsFor: 'as yet unclassified' stamp: 'ikp 6/8/2007 22:11'!connectNonBlockingTo: aSocketAddress	| status |	self initializeNetwork.	status := self primSocketConnectionStatus: socketHandle.	(status == Unconnected)		ifFalse: [InvalidSocketStatusException signal: 'Socket status must Unconnected before opening a new connection'].	self primSocket: socketHandle connectTo: aSocketAddress.! !!Socket methodsFor: 'as yet unclassified' stamp: 'dtl 6/3/2012 19:28'!connectNonBlockingTo: hostAddress port: port	"Initiate a connection to the given port at the given host address. This operation will return immediately; follow it with waitForConnectionUntil: to wait until the connection is established."	| status |	self initializeNetwork.	status := self primSocketConnectionStatus: socketHandle.	(status == Unconnected)		ifFalse: [InvalidSocketStatusException signal: 'Socket status must Unconnected before opening a new connection'].	NetNameResolver useOldNetwork		ifTrue: [self primSocket: socketHandle connectTo: hostAddress port: port]		ifFalse: [ | socketAddress |			socketAddress := hostAddress asSocketAddress.			socketAddress port: port.			self connectNonBlockingTo: socketAddress]! !!Socket methodsFor: 'as yet unclassified' stamp: 'ikp 6/8/2007 22:09'!connectTo: aSocketAddress	self connectTo: aSocketAddress waitForConnectionFor: Socket standardTimeout! !!Socket methodsFor: 'as yet unclassified' stamp: 'dtl 6/3/2012 09:47'!connectTo: hostAddress port: port	"Initiate a connection to the given port at the given host address.	Waits until the connection is established or time outs."	NetNameResolver useOldNetwork		ifTrue: [self connectTo: hostAddress port: port waitForConnectionFor: Socket standardTimeout]		ifFalse: [ | socketAddress |			socketAddress := hostAddress asSocketAddress.			socketAddress port: port.			self connectTo: socketAddress]! !!Socket methodsFor: 'as yet unclassified' stamp: 'dtl 6/13/2012 21:28'!connectTo: hostAddress port: port waitForConnectionFor: timeout 	"Initiate a connection to the given port at the given host 	address. Waits until the connection is established or time outs."	self connectNonBlockingTo: hostAddress port: port.	self		waitForConnectionFor: timeout		ifTimedOut: [ConnectionTimedOut signal: 'Cannot connect to ', hostAddress printString]		ifRefused: [ConnectionRefused signal: 'Cannot connect to ', hostAddress printString]! !!Socket methodsFor: 'as yet unclassified' stamp: 'dtl 6/13/2012 21:29'!connectTo: aSocketAddress waitForConnectionFor: timeout 	self connectNonBlockingTo: aSocketAddress.	self		waitForConnectionFor: timeout		ifTimedOut: [ConnectionTimedOut signal: 'Cannot connect to ', aSocketAddress printString]		ifRefused: [ConnectionRefused signal: 'Cannot connect to ', aSocketAddress printString]! !!Socket methodsFor: 'as yet unclassified' stamp: 'mir 5/8/2003 16:03'!connectToHostNamed: hostName port: portNumber	| serverIP |	serverIP := NetNameResolver addressForName: hostName timeout: 20.	^self connectTo: serverIP port: portNumber! !!Socket methodsFor: 'as yet unclassified' stamp: 'jm 2/25/1999 13:52'!dataAvailable	"Return true if this socket has unread received data."	socketHandle == nil ifTrue: [^ false].	^ self primSocketReceiveDataAvailable: socketHandle! !!Socket methodsFor: 'as yet unclassified' stamp: 'ul 10/27/2014 16:44'!destroy	"Destroy this socket. Its connection, if any, is aborted and its resources are freed. Do nothing if the socket has already been destroyed (i.e., if its socketHandle is nil)."	socketHandle ifNotNil: [		self isValid ifTrue: [ self primSocketDestroy: socketHandle ].		Smalltalk unregisterExternalObjects: { 			semaphore.			readSemaphore.			writeSemaphore }.		socketHandle := nil.		readSemaphore := writeSemaphore := semaphore := nil.		self unregister ]! !!Socket methodsFor: 'as yet unclassified' stamp: 'jm 9/15/97 12:22'!discardReceivedData	"Discard any data received up until now, and return the number of bytes discarded."	| buf totalBytesDiscarded |	buf := String new: 10000.	totalBytesDiscarded := 0.	[self isConnected and: [self dataAvailable]] whileTrue: [		totalBytesDiscarded :=			totalBytesDiscarded + (self receiveDataInto: buf)].	^ totalBytesDiscarded! !!Socket methodsFor: 'as yet unclassified' stamp: 'jm 3/10/98 11:56'!disconnect	"Break this connection, no matter what state it is in. Data that has been sent but not received will be lost."	self primSocketAbortConnection: socketHandle.! !!Socket methodsFor: 'as yet unclassified' stamp: 'ul 10/27/2014 16:44'!finalize	self primSocketDestroyGently: socketHandle.	Smalltalk unregisterExternalObjects: {		semaphore.		readSemaphore.		writeSemaphore }! !!Socket methodsFor: 'as yet unclassified' stamp: 'mir 2/22/2002 16:25'!getOption: aName 	"Get options on this socket, see Unix man pages for values for 	sockets, IP, TCP, UDP. IE SO_KEEPALIVE	returns an array, element one is an status number (0 ok, -1 read only option)	element two is the resulting of the requested option"	(socketHandle == nil or: [self isValid not])		ifTrue: [InvalidSocketStatusException signal: 'Socket status must valid before getting an option'].	^self primSocket: socketHandle getOption: aName"| foo options |Socket initializeNetwork.foo := Socket newTCP.foo connectTo: (NetNameResolver addressFromString: '192.168.1.1') port: 80.foo waitForConnectionUntil: (Socket standardDeadline).options := {'SO_DEBUG'. 'SO_REUSEADDR'. 'SO_REUSEPORT'. 'SO_DONTROUTE'.'SO_BROADCAST'. 'SO_SNDBUF'. 'SO_RCVBUF'. 'SO_KEEPALIVE'.'SO_OOBINLINE'. 'SO_PRIORITY'. 'SO_LINGER'. 'SO_RCVLOWAT'.'SO_SNDLOWAT'. 'IP_TTL'. 'IP_HDRINCL'. 'IP_RCVOPTS'.'IP_RCVDSTADDR'. 'IP_MULTICAST_IF'. 'IP_MULTICAST_TTL'.'IP_MULTICAST_LOOP'. 'UDP_CHECKSUM'. 'TCP_MAXSEG'.'TCP_NODELAY'. 'TCP_ABORT_THRESHOLD'. 'TCP_CONN_NOTIFY_THRESHOLD'. 'TCP_CONN_ABORT_THRESHOLD'. 'TCP_NOTIFY_THRESHOLD'.'TCP_URGENT_PTR_TYPE'}.1 to: options size do: [:i | | fum |	fum :=foo getOption: (options at: i).	Transcript show: (options at: i),fum printString;cr].foo := Socket newUDP.foo setPeer: (NetNameResolver addressFromString: '192.168.1.9') port: 7.foo waitForConnectionUntil: (Socket standardDeadline).1 to: options size do: [:i | | fum |	fum :=foo getOption: (options at: i).	Transcript show: (options at: i),fum printString;cr]."! !!Socket methodsFor: 'as yet unclassified' stamp: 'ul 10/25/2014 17:38'!initialize: socketType	"Initialize a new socket handle. If socket creation fails, socketHandle will be set to nil."	self initializeSocketHandleUsing: [ :semaIndex :readSemaIndex :writeSemaIndex |		self primSocketCreateNetwork: 0			type: socketType			receiveBufferSize: 8000			sendBufSize: 8000			semaIndex: semaIndex			readSemaIndex: readSemaIndex			writeSemaIndex: writeSemaIndex ]! !!Socket methodsFor: 'as yet unclassified' stamp: 'ul 10/25/2014 17:38'!initialize: socketType family: family	"Initialize a new socket handle. If socket creation fails, socketHandle will be set to nil."	NetNameResolver useOldNetwork ifTrue: [ ^self initialize: socketType ].	self initializeSocketHandleUsing: [ :semaIndex :readSemaIndex :writeSemaIndex |		self primSocketCreateNetwork: family			type: socketType			receiveBufferSize: 8000			sendBufSize: 8000			semaIndex: semaIndex			readSemaIndex: readSemaIndex			writeSemaIndex: writeSemaIndex ]! !!Socket methodsFor: 'as yet unclassified' stamp: 'mir 2/22/2002 15:48'!initializeNetwork	self class initializeNetwork! !!Socket methodsFor: 'as yet unclassified' stamp: 'ul 10/27/2014 16:44'!initializeSocketHandleUsing: aBlock	"Initialize a new socket handle. If socket creation fails, socketHandle will be set to nil."		| semaphoresAndIndexes semaphores indexes |	semaphoresAndIndexes := Smalltalk newExternalSemaphores: 3.	semaphores := semaphoresAndIndexes at: 1.	indexes := semaphoresAndIndexes at: 2.	semaphore := semaphores at: 1.	readSemaphore := semaphores at: 2.	writeSemaphore := semaphores at: 3.	(socketHandle := aBlock valueWithArguments: indexes)		ifNotNil: [ self register ]		ifNil: [			"socket creation failed"			semaphore := readSemaphore := writeSemaphore := nil.			Smalltalk unregisterExternalObjects: semaphores ]! !!Socket methodsFor: 'as yet unclassified' stamp: 'jm 2/25/1999 13:52'!isConnected	"Return true if this socket is connected."	socketHandle == nil ifTrue: [^ false].	^ (self primSocketConnectionStatus: socketHandle) == Connected! !!Socket methodsFor: 'as yet unclassified' stamp: 'JMM 5/5/2000 12:15'!isOtherEndClosed	"Return true if this socket had the other end closed."	socketHandle == nil ifTrue: [^ false].	^ (self primSocketConnectionStatus: socketHandle) == OtherEndClosed! !!Socket methodsFor: 'as yet unclassified' stamp: 'JMM 5/5/2000 12:17'!isThisEndClosed	"Return true if this socket had the this end closed."	socketHandle == nil ifTrue: [^ false].	^ (self primSocketConnectionStatus: socketHandle) == ThisEndClosed! !!Socket methodsFor: 'as yet unclassified' stamp: 'jm 2/25/1999 13:54'!isUnconnected	"Return true if this socket's state is Unconnected."	socketHandle == nil ifTrue: [^ false].	^ (self primSocketConnectionStatus: socketHandle) == Unconnected! !!Socket methodsFor: 'as yet unclassified' stamp: 'jm 2/25/1999 13:54'!isUnconnectedOrInvalid	"Return true if this socket is completely disconnected or is invalid."	| status |	socketHandle == nil ifTrue: [^ true].	status := self primSocketConnectionStatus: socketHandle.	^ (status = Unconnected) | (status = InvalidSocket)! !!Socket methodsFor: 'as yet unclassified' stamp: 'jm 2/25/1999 13:51'!isValid	"Return true if this socket contains a valid, non-nil socket handle."	| status |	socketHandle == nil ifTrue: [^ false].	status := self primSocketConnectionStatus: socketHandle.	^ status ~= InvalidSocket! !!Socket methodsFor: 'as yet unclassified' stamp: 'jm 2/25/1999 13:54'!isWaitingForConnection	"Return true if this socket is waiting for a connection."	socketHandle == nil ifTrue: [^ false].	^ (self primSocketConnectionStatus: socketHandle) == WaitingForConnection! !!Socket methodsFor: 'as yet unclassified' stamp: 'mir 2/22/2002 16:25'!listenOn: port	"Listen for a connection on the given port. This operation will return immediately; follow it with waitForConnectionUntil: to wait until a connection is established."	| status |	status := self primSocketConnectionStatus: socketHandle.	(status == Unconnected)		ifFalse: [InvalidSocketStatusException signal: 'Socket status must Unconnected before listening for a new connection'].	self primSocket: socketHandle listenOn: port.! !!Socket methodsFor: 'as yet unclassified' stamp: 'mir 2/22/2002 16:25'!listenOn: portNumber backlogSize: backlog	"Listen for a connection on the given port.	If this method succeeds, #accept may be used to establish a new connection"	| status |	status := self primSocketConnectionStatus: socketHandle.	(status == Unconnected)		ifFalse: [InvalidSocketStatusException signal: 'Socket status must Unconnected before listening for a new connection'].	self primSocket: socketHandle listenOn: portNumber backlogSize: backlog.! !!Socket methodsFor: 'as yet unclassified' stamp: 'dtl 6/3/2012 13:19'!listenOn: portNumber backlogSize: backlog interface: ifAddr	"Listen for a connection on the given port.	If this method succeeds, #accept may be used to establish a new connection"	| status |	status := self primSocketConnectionStatus: socketHandle.	(status == Unconnected)		ifFalse: [InvalidSocketStatusException signal: 'Socket status must Unconnected before listening for a new connection'].	self primSocket: socketHandle listenOn: portNumber backlogSize: backlog interface: ifAddr asByteArray.! !!Socket methodsFor: 'as yet unclassified' stamp: 'ikp 6/9/2007 09:39'!listenWithBacklog: backlogSize	| status |	self initializeNetwork.	status := self primSocketConnectionStatus: socketHandle.	(status == Unconnected)		ifFalse: [InvalidSocketStatusException signal: 'Socket status must Unconnected before it can listen for connections'].	self primSocket: socketHandle listenWithBacklog: backlogSize.! !!Socket methodsFor: 'as yet unclassified' stamp: 'dtl 6/4/2012 07:49'!localAddress	self isWaitingForConnection ifFalse: [		self			waitForConnectionFor: Socket standardTimeout			ifTimedOut: [				NetNameResolver useOldNetwork					ifTrue: [^ByteArray new: 4]					ifFalse: [^(ByteArray new: 4) asSocketAddress]]].	NetNameResolver useOldNetwork		ifTrue: [^self primSocketLocalAddress: socketHandle]		ifFalse: [^(self primSocketLocalAddress: socketHandle) asSocketAddress]! !!Socket methodsFor: 'as yet unclassified' stamp: 'mtf 10/18/2011 18:51'!localAddressPortString	^ self localAddressString, ':', self localPort printString! !!Socket methodsFor: 'as yet unclassified' stamp: 'mtf 10/18/2011 18:50'!localAddressString	^ NetNameResolver stringFromAddress: self localAddress! !!Socket methodsFor: 'as yet unclassified' stamp: 'ul 11/25/2010 21:21'!localPort	self isWaitingForConnection ifFalse: [		self			waitForConnectionFor: Socket standardTimeout			ifTimedOut: [ ^0] ].	^ self primSocketLocalPort: socketHandle! !!Socket methodsFor: 'as yet unclassified' stamp: 'ikp 6/9/2007 10:28'!localSocketAddress	| size addr |	size := self primSocketLocalAddressSize: socketHandle.	addr := SocketAddress new: size.	self primSocket: socketHandle localAddressResult: addr.	^addr! !!Socket methodsFor: 'as yet unclassified' stamp: 'dtl 8/15/2012 08:09'!peerName	"Return the name of the host I'm connected to, or nil if its name isn't known to the domain name server or the request times out."	"Note: Slow. Calls the domain name server, taking up to 20 seconds to time out. Even when sucessful, delays of up to 13 seconds have been observed during periods of high network load." 	^NetNameResolver useOldNetwork		ifFalse: [ self remoteAddress hostName ]		ifTrue: [ NetNameResolver			nameForAddress: self remoteAddress			timeout: 20 ]! !!Socket methodsFor: 'as yet unclassified' stamp: 'ar 4/30/1999 04:25'!port	"Shortcut"	^self localPort! !!Socket methodsFor: 'as yet unclassified' stamp: 'ar 2/2/2001 15:09'!primAcceptFrom: aHandle receiveBufferSize: rcvBufSize sendBufSize: sndBufSize semaIndex: semaIndex	"Create and return a new socket handle based on accepting the connection from the given listening socket"	<primitive: 'primitiveSocketAccept' module: 'SocketPlugin'>	^self primitiveFailed! !!Socket methodsFor: 'as yet unclassified' stamp: 'ul 4/20/2011 01:55'!primAcceptFrom: aHandle receiveBufferSize: rcvBufSize sendBufSize: sndBufSize semaIndex: semaIndex readSemaIndex: aReadSema writeSemaIndex: aWriteSema	"Create and return a new socket handle based on accepting the connection from the given listening socket"		<primitive: 'primitiveSocketAccept3Semaphores' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'as yet unclassified' stamp: 'ikp 6/9/2007 09:36'!primSocket: socketID bindTo: socketAddress	<primitive: 'primitiveSocketBindTo' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'as yet unclassified' stamp: 'ikp 6/8/2007 22:08'!primSocket: socketID connectTo: socketAddress	<primitive: 'primitiveSocketConnectTo' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'as yet unclassified' stamp: 'ar 2/2/2001 15:09'!primSocket: socketID connectTo: hostAddress port: port	"Attempt to establish a connection to the given port of the given host. This is an asynchronous call; query the socket status to discover if and when the connection is actually completed."	<primitive: 'primitiveSocketConnectToPort' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'as yet unclassified' stamp: 'JMM 5/25/2000 21:48'!primSocket: socketID getOption: aString 	"Get some option information on this socket. Refer to the UNIX 	man pages for valid SO, TCP, IP, UDP options. In case of doubt	refer to the source code.	TCP_NODELAY, SO_KEEPALIVE are valid options for example	returns an array containing the error code and the option value"	<primitive: 'primitiveSocketGetOptions' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'as yet unclassified' stamp: 'ar 2/2/2001 15:09'!primSocket: socketID listenOn: port	"Listen for a connection on the given port. This is an asynchronous call; query the socket status to discover if and when the connection is actually completed."	<primitive: 'primitiveSocketListenWithOrWithoutBacklog' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'as yet unclassified' stamp: 'ar 2/2/2001 15:09'!primSocket: aHandle listenOn: portNumber backlogSize: backlog	"Primitive. Set up the socket to listen on the given port.	Will be used in conjunction with #accept only."	<primitive: 'primitiveSocketListenWithOrWithoutBacklog' module: 'SocketPlugin'>	self destroy. "Accept not supported so clean up"! !!Socket methodsFor: 'as yet unclassified' stamp: 'ikp 9/1/2003 20:33'!primSocket: aHandle listenOn: portNumber backlogSize: backlog interface: ifAddr	"Primitive. Set up the socket to listen on the given port.	Will be used in conjunction with #accept only."	<primitive: 'primitiveSocketListenOnPortBacklogInterface' module: 'SocketPlugin'>	self destroy. "Accept not supported so clean up"! !!Socket methodsFor: 'as yet unclassified' stamp: 'ikp 6/9/2007 09:39'!primSocket: socketID listenWithBacklog: backlogSize	<primitive: 'primitiveSocketListenWithBacklog' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'as yet unclassified' stamp: 'ikp 6/9/2007 10:23'!primSocket: socketID localAddressResult: socketAddress	<primitive: 'primitiveSocketLocalAddressResult' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'as yet unclassified' stamp: 'ar 2/2/2001 15:09'!primSocket: socketID receiveDataInto: aStringOrByteArray startingAt: startIndex count: count	"Receive data from the given socket into the given array starting at the given index. Return the number of bytes read or zero if no data is available."	<primitive: 'primitiveSocketReceiveDataBufCount' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'as yet unclassified' stamp: 'JMM 5/24/2000 17:19'!primSocket: socketID receiveUDPDataInto: aStringOrByteArray startingAt: startIndex count: count	"Receive data from the given socket into the given array starting at the given index. 	Return an Array containing the amount read, the host address byte array, the host port, and the more flag"	<primitive: 'primitiveSocketReceiveUDPDataBufCount' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'as yet unclassified' stamp: 'ikp 6/9/2007 10:23'!primSocket: socketID remoteAddressResult: socketAddress	<primitive: 'primitiveSocketRemoteAddressResult' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'as yet unclassified' stamp: 'ar 2/2/2001 15:09'!primSocket: socketID sendData: aStringOrByteArray startIndex: startIndex count: count	"Send data to the remote host through the given socket starting with the given byte index of the given byte array. The data sent is 'pushed' immediately. Return the number of bytes of data actually sent; any remaining data should be re-submitted for sending after the current send operation has completed."	"Note: In general, it many take several sendData calls to transmit a large data array since the data is sent in send-buffer-sized chunks. The size of the send buffer is determined when the socket is created."	<primitive: 'primitiveSocketSendDataBufCount' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'as yet unclassified' stamp: 'JMM 5/25/2000 00:08'!primSocket: socketID sendUDPData: aStringOrByteArray toHost: hostAddress  port: portNumber startIndex: startIndex count: count	"Send data to the remote host through the given socket starting with the given byte index of the given byte array. The data sent is 'pushed' immediately. Return the number of bytes of data actually sent; any remaining data should be re-submitted for sending after the current send operation has completed."	"Note: In general, it many take several sendData calls to transmit a large data array since the data is sent in send-buffer-sized chunks. The size of the send buffer is determined when the socket is created."	<primitive:  'primitiveSocketSendUDPDataBufCount' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'as yet unclassified' stamp: 'ar 7/18/2000 11:42'!primSocket: socketID setOption: aString value: aStringValue	"Set some option information on this socket. Refer to the UNIX 	man pages for valid SO, TCP, IP, UDP options. In case of doubt	refer to the source code.	TCP_NODELAY, SO_KEEPALIVE are valid options for example	returns an array containing the error code and the negotiated value"	<primitive: 'primitiveSocketSetOptions' module: 'SocketPlugin'>	^nil! !!Socket methodsFor: 'as yet unclassified' stamp: 'ar 2/2/2001 15:09'!primSocket: socketID setPort: port	"Set the local port associated with a UDP socket.	Note: this primitive is overloaded.  The primitive will not fail on a TCP socket, but	the effects will not be what was desired.  Best solution would be to split Socket into	two subclasses, TCPSocket and UDPSocket."	<primitive: 'primitiveSocketListenWithOrWithoutBacklog' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'as yet unclassified' stamp: 'ar 2/2/2001 15:09'!primSocketAbortConnection: socketID	"Terminate the connection on the given port immediately without going through the normal close sequence. This is an asynchronous call; query the socket status to discover if and when the connection is actually terminated."	<primitive: 'primitiveSocketAbortConnection' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'as yet unclassified' stamp: 'ar 2/2/2001 15:09'!primSocketCloseConnection: socketID	"Close the connection on the given port. The remote end is informed that this end has closed and will do no further sends. This is an asynchronous call; query the socket status to discover if and when the connection is actually closed."	<primitive: 'primitiveSocketCloseConnection' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'as yet unclassified' stamp: 'ar 2/2/2001 15:09'!primSocketConnectionStatus: socketID	"Return an integer reflecting the connection status of this socket. For a list of possible values, see the comment in the 'initialize' method of this class. If the primitive fails, return a status indicating that the socket handle is no longer valid, perhaps because the Squeak image was saved and restored since the socket was created. (Sockets do not survive snapshots.)"	<primitive: 'primitiveSocketConnectionStatus' module: 'SocketPlugin'>	^ InvalidSocket! !!Socket methodsFor: 'as yet unclassified' stamp: 'ar 2/2/2001 15:09'!primSocketCreateNetwork: netType type: socketType receiveBufferSize: rcvBufSize sendBufSize: sendBufSize semaIndex: semaIndex	"Return a new socket handle for a socket of the given type and buffer sizes. Return nil if socket creation fails.	The netType parameter is platform dependent and can be used to encode both the protocol type (IP, Xerox XNS, etc.) and/or the physical network interface to use if this host is connected to multiple networks. A zero netType means to use IP protocols and the primary (or only) network interface.	The socketType parameter specifies:		0	reliable stream socket (TCP if the protocol is IP)		1	unreliable datagram socket (UDP if the protocol is IP)	The buffer size parameters allow performance to be tuned to the application. For example, a larger receive buffer should be used when the application expects to be receiving large amounts of data, especially from a host that is far away. These values are considered requests only; the underlying implementation will ensure that the buffer sizes actually used are within allowable bounds. Note that memory may be limited, so an application that keeps many sockets open should use smaller buffer sizes. Note the macintosh implementation ignores this buffer size. Also see setOption to get/set socket buffer sizes which allows you to set/get the current buffer sizes for reading and writing. 	If semaIndex is > 0, it is taken to be the index of a Semaphore in the external objects array to be associated with this socket. This semaphore will be signalled when the socket status changes, such as when data arrives or a send completes. All processes waiting on the semaphore will be awoken for each such event; each process must then query the socket state to figure out if the conditions they are waiting for have been met. For example, a process waiting to send some data can see if the last send has completed."	<primitive: 'primitiveSocketCreate' module: 'SocketPlugin'>	^ nil  "socket creation failed"! !!Socket methodsFor: 'as yet unclassified' stamp: 'ul 4/20/2011 01:56'!primSocketCreateNetwork: netType type: socketType receiveBufferSize: rcvBufSize sendBufSize: sendBufSize semaIndex: semaIndex readSemaIndex: aReadSema writeSemaIndex: aWriteSema	"See comment in primSocketCreateNetwork: with one semaIndex. However you should know that some implementations ignore the buffer size and this interface supports three semaphores,  one for open/close/listen and the other two for reading and writing"	<primitive: 'primitiveSocketCreate3Semaphores' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'as yet unclassified' stamp: 'ar 2/2/2001 15:09'!primSocketDestroy: socketID	"Release the resources associated with this socket. If a connection is open, it is aborted."	<primitive: 'primitiveSocketDestroy' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'as yet unclassified' stamp: 'ar 2/2/2001 15:09'!primSocketDestroyGently: socketID	"Release the resources associated with this socket. If a connection is open, it is aborted.	Do not fail if the receiver is already closed."	<primitive: 'primitiveSocketDestroy' module: 'SocketPlugin'>! !!Socket methodsFor: 'as yet unclassified' stamp: 'ar 2/2/2001 15:09'!primSocketError: socketID	"Return an integer encoding the most recent error on this socket. Zero means no error."	<primitive: 'primitiveSocketError' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'as yet unclassified' stamp: 'ar 2/2/2001 15:09'!primSocketLocalAddress: socketID	"Return the local host address for this socket."	<primitive: 'primitiveSocketLocalAddress' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'as yet unclassified' stamp: 'ikp 6/9/2007 10:24'!primSocketLocalAddressSize: handle	<primitive: 'primitiveSocketLocalAddressSize' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'as yet unclassified' stamp: 'ar 2/2/2001 15:09'!primSocketLocalPort: socketID	"Return the local port for this socket, or zero if no port has yet been assigned."	<primitive: 'primitiveSocketLocalPort' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'as yet unclassified' stamp: 'ar 2/2/2001 15:09'!primSocketReceiveDataAvailable: socketID	"Return true if data may be available for reading from the current socket."	<primitive: 'primitiveSocketReceiveDataAvailable' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'as yet unclassified' stamp: 'ar 2/2/2001 15:09'!primSocketRemoteAddress: socketID	"Return the remote host address for this socket, or zero if no connection has been made."	<primitive: 'primitiveSocketRemoteAddress' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'as yet unclassified' stamp: 'ikp 6/9/2007 10:24'!primSocketRemoteAddressSize: handle	<primitive: 'primitiveSocketRemoteAddressSize' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'as yet unclassified' stamp: 'ar 2/2/2001 15:09'!primSocketRemotePort: socketID	"Return the remote port for this socket, or zero if no connection has been made."	<primitive: 'primitiveSocketRemotePort' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'as yet unclassified' stamp: 'ar 2/2/2001 15:09'!primSocketSendDone: socketID	"Return true if there is no send in progress on the current socket."	<primitive: 'primitiveSocketSendDone' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'as yet unclassified' stamp: 'mtf 3/14/2011 19:59'!primitiveFailed: selector	SocketPrimitiveFailed signal: selector asString, ' failed'! !!Socket methodsFor: 'as yet unclassified' stamp: 'ul 4/20/2011 02:00'!primitiveOnlySupportsOneSemaphore		self deprecated: 'All sockets have 3 semaphores.'.	^false! !!Socket methodsFor: 'as yet unclassified' stamp: 'jm 11/23/1998 11:57'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '[', self statusString, ']'.! !!Socket methodsFor: 'as yet unclassified' stamp: 'ul 4/20/2011 01:54'!readSemaphore		^readSemaphore! !!Socket methodsFor: 'as yet unclassified' stamp: 'mir 5/15/2003 13:52'!receiveAvailableData	"Receive all available data (if any). Do not wait." 	| buffer bytesRead |	buffer := String new: 2000.	bytesRead := self receiveAvailableDataInto: buffer.	^buffer copyFrom: 1 to: bytesRead! !!Socket methodsFor: 'as yet unclassified' stamp: 'mir 5/15/2003 13:52'!receiveAvailableDataInto: buffer	"Receive all available data into the given buffer and return the number of bytes received.	Note the given buffer may be only partially filled by the received data.	Do not wait for data."	^self receiveAvailableDataInto: buffer startingAt: 1! !!Socket methodsFor: 'as yet unclassified' stamp: 'mu 8/9/2003 18:04'!receiveAvailableDataInto: buffer startingAt: startIndex	"Receive all available data into the given buffer and return the number of bytes received.	Note the given buffer may be only partially filled by the received data.	Do not wait for data."	| bufferPos bytesRead |	bufferPos := startIndex.	[self dataAvailable		and: [bufferPos-1 < buffer size]] 		whileTrue: [			bytesRead := self receiveSomeDataInto: buffer startingAt: bufferPos.			bufferPos := bufferPos + bytesRead].	^bufferPos - startIndex! !!Socket methodsFor: 'as yet unclassified' stamp: 'yo 10/10/2005 18:47'!receiveAvailableDataIntoBuffer: buffer	"Receive all available data (if any). Do not wait." 	| bytesRead |	bytesRead := self receiveAvailableDataInto: buffer.	^buffer copyFrom: 1 to: bytesRead! !!Socket methodsFor: 'as yet unclassified' stamp: 'mir 5/15/2003 16:05'!receiveData	"Receive data into the given buffer and return the number of bytes received. 	Note the given buffer may be only partially filled by the received data.	Waits for data once.	Either returns data or signals a time out or connection close."	| buffer bytesRead |	buffer := String new: 2000.	bytesRead := self receiveDataInto: buffer.	^buffer copyFrom: 1 to: bytesRead! !!Socket methodsFor: 'as yet unclassified' stamp: 'mir 5/15/2003 16:05'!receiveDataInto: aStringOrByteArray	"Receive data into the given buffer and return the number of bytes received. 	Note the given buffer may be only partially filled by the received data.	Waits for data once.	Either returns data or signals a time out or connection close."	^self receiveDataInto: aStringOrByteArray startingAt: 1! !!Socket methodsFor: 'as yet unclassified' stamp: 'ul 4/20/2011 01:55'!receiveDataInto: aStringOrByteArray fromHost: hostAddress port: portNumber	| datagram |	"Receive a UDP packet from the given hostAddress/portNumber, storing the data in the given buffer, and return the number of bytes received. Note the given buffer may be only partially filled by the received data."	[		datagram := self receiveUDPDataInto: aStringOrByteArray.		((datagram at: 2) = hostAddress and: [(datagram at: 3) = portNumber]) 			ifTrue: [^datagram at: 1]			ifFalse: [^0]] repeat! !!Socket methodsFor: 'as yet unclassified' stamp: 'ul 11/15/2010 12:04'!receiveDataInto: aStringOrByteArray startingAt: aNumber	"Receive data into the given buffer and return the number of bytes received. 	Note the given buffer may be only partially filled by the received data.	Waits for data once.  The answer may be zero (indicating that no data was 	available before the socket closed)."	| bytesRead closed |	bytesRead := 0.	closed := false.	[closed not and: [bytesRead = 0]]		whileTrue: [			self waitForDataIfClosed: [closed := true].			bytesRead := self primSocket: socketHandle				receiveDataInto: aStringOrByteArray				startingAt: aNumber				count: aStringOrByteArray size-aNumber+1].	^bytesRead! !!Socket methodsFor: 'as yet unclassified' stamp: 'ul 11/15/2010 12:04'!receiveDataSignallingClosedInto: aStringOrByteArray startingAt: aNumber	"Receive data into the given buffer and return the number of bytes received. 	Note the given buffer may be only partially filled by the received data.	Waits for data until something is read or the socket is closed, upon which	we signal."	| bytesRead |	bytesRead := 0.	[bytesRead = 0]		whileTrue: [			self waitForData.			bytesRead := self primSocket: socketHandle				receiveDataInto: aStringOrByteArray				startingAt: aNumber				count: aStringOrByteArray size-aNumber+1].	^bytesRead! !!Socket methodsFor: 'as yet unclassified' stamp: 'gk 2/9/2005 12:24'!receiveDataSignallingTimeout: timeout into: aStringOrByteArray startingAt: aNumber	"Receive data into the given buffer and return the number of bytes received. 	Note the given buffer may be only partially filled by the received data.	Wait for data once for the specified nr of seconds.  This method will	throw exceptions on timeout or the socket closing."	self waitForDataFor: timeout.	^self primSocket: socketHandle		receiveDataInto: aStringOrByteArray		startingAt: aNumber		count: aStringOrByteArray size-aNumber+1! !!Socket methodsFor: 'as yet unclassified' stamp: 'svp 9/23/2003 00:03'!receiveDataTimeout: timeout	"Receive data into the given buffer and return the number of bytes received. 	Note the given buffer may be only partially filled by the received data.	Waits for data once."	| buffer bytesRead |	buffer := String new: 2000.	bytesRead := self receiveDataTimeout: timeout into: buffer.	^buffer copyFrom: 1 to: bytesRead! !!Socket methodsFor: 'as yet unclassified' stamp: 'svp 9/23/2003 00:01'!receiveDataTimeout: timeout into: aStringOrByteArray 	"Receive data into the given buffer and return the number of bytes received. 	Note the given buffer may be only partially filled by the received data.	Waits for data once."	^self receiveDataTimeout: timeout into: aStringOrByteArray startingAt: 1! !!Socket methodsFor: 'as yet unclassified' stamp: 'svp 9/22/2003 23:58'!receiveDataTimeout: timeout into: aStringOrByteArray startingAt: aNumber	"Receive data into the given buffer and return the number of bytes received. 	Note the given buffer may be only partially filled by the received data.	Wait for data once for the specified nr of seconds.  The answer may be 	zero (indicating that there was no data available within the given timeout)."	self waitForDataFor: timeout ifClosed: [] ifTimedOut: [].	^self primSocket: socketHandle		receiveDataInto: aStringOrByteArray		startingAt: aNumber		count: aStringOrByteArray size-aNumber+1! !!Socket methodsFor: 'as yet unclassified' stamp: 'mir 5/15/2003 16:18'!receiveDataWithTimeout	"Receive data into the given buffer and return the number of bytes received. 	Note the given buffer may be only partially filled by the received data.	Waits for data once.	Either returns data or signals a time out or connection close."	| buffer bytesRead |	buffer := String new: 2000.	bytesRead := self receiveDataWithTimeoutInto: buffer.	^buffer copyFrom: 1 to: bytesRead! !!Socket methodsFor: 'as yet unclassified' stamp: 'mir 5/15/2003 16:18'!receiveDataWithTimeoutInto: aStringOrByteArray	"Receive data into the given buffer and return the number of bytes received. 	Note the given buffer may be only partially filled by the received data.	Waits for data once.	Either returns data or signals a time out or connection close."	^self receiveDataWithTimeoutInto: aStringOrByteArray startingAt: 1! !!Socket methodsFor: 'as yet unclassified' stamp: 'svp 9/23/2003 00:01'!receiveDataWithTimeoutInto: aStringOrByteArray startingAt: aNumber	"Receive data into the given buffer and return the number of bytes received. 	Note the given buffer may be only partially filled by the received data.	Waits for data once."	^self receiveDataTimeout: Socket standardTimeout into: aStringOrByteArray startingAt: aNumber ! !!Socket methodsFor: 'as yet unclassified' stamp: 'mir 5/15/2003 13:46'!receiveSomeData	"Receive currently available data (if any). Do not wait." 	| buffer bytesRead |	buffer := String new: 2000.	bytesRead := self receiveSomeDataInto: buffer.	^buffer copyFrom: 1 to: bytesRead! !!Socket methodsFor: 'as yet unclassified' stamp: 'mir 5/15/2003 13:46'!receiveSomeDataInto: aStringOrByteArray	"Receive data into the given buffer and return the number of bytes received. Note the given buffer may be only partially filled by the received data."	^self receiveSomeDataInto: aStringOrByteArray startingAt: 1! !!Socket methodsFor: 'as yet unclassified' stamp: 'mir 5/15/2003 13:46'!receiveSomeDataInto: aStringOrByteArray startingAt: aNumber	"Receive data into the given buffer and return the number of bytes received. Note the given buffer may be only partially filled by the received data."	^ self primSocket: socketHandle		receiveDataInto: aStringOrByteArray		startingAt: aNumber		count: aStringOrByteArray size-aNumber+1! !!Socket methodsFor: 'as yet unclassified' stamp: 'JMM 6/3/2000 21:54'!receiveUDPDataInto: aStringOrByteArray	"Receive UDP data into the given buffer and return the number of bytes received. Note the given buffer may be only partially filled by the received data. What is returned is an array, the first element is the bytes read, the second the sending bytearray address, the third the senders port, the fourth, true if more of the datagram awaits reading"	^ self primSocket: socketHandle		receiveUDPDataInto: aStringOrByteArray		startingAt: 1		count: aStringOrByteArray size! !!Socket methodsFor: 'as yet unclassified' stamp: 'ar 3/21/98 17:40'!register	^self class register: self! !!Socket methodsFor: 'as yet unclassified' stamp: 'dtl 6/3/2012 23:26'!remoteAddress	NetNameResolver useOldNetwork		ifTrue: [^self primSocketRemoteAddress: socketHandle]		ifFalse: [^(self primSocketRemoteAddress: socketHandle) asSocketAddress]! !!Socket methodsFor: 'as yet unclassified' stamp: 'mtf 10/18/2011 18:51'!remoteAddressPortString	^ self remoteAddressString, ':', self remotePort printString! !!Socket methodsFor: 'as yet unclassified' stamp: 'mtf 10/18/2011 18:50'!remoteAddressString	^ NetNameResolver stringFromAddress: self remoteAddress! !!Socket methodsFor: 'as yet unclassified' stamp: 'jm 9/17/97 14:34'!remotePort	^ self primSocketRemotePort: socketHandle! !!Socket methodsFor: 'as yet unclassified' stamp: 'ul 8/15/2012 17:08'!remoteSocketAddress	NetNameResolver useOldNetwork		ifTrue: [ ^self primSocketRemoteAddress: socketHandle ]		ifFalse: [			| size addr |			size := self primSocketRemoteAddressSize: socketHandle.			addr := SocketAddress new: size.			self primSocket: socketHandle remoteAddressResult: addr.			^addr]! !!Socket methodsFor: 'as yet unclassified' stamp: 'JMM 5/9/2000 15:32'!semaphore	^semaphore! !!Socket methodsFor: 'as yet unclassified' stamp: 'mir 5/15/2003 18:33'!sendData: aStringOrByteArray	"Send all of the data in the given array, even if it requires multiple calls to send it all. Return the number of bytes sent."	"An experimental version use on slow lines: Longer timeout and smaller writes to try to avoid spurious timeouts."	| bytesSent bytesToSend count |	bytesToSend := aStringOrByteArray size.	bytesSent := 0.	[bytesSent < bytesToSend] whileTrue: [		(self waitForSendDoneFor: 60)			ifFalse: [ConnectionTimedOut signal: 'send data timeout; data not sent'].		count := self primSocket: socketHandle			sendData: aStringOrByteArray			startIndex: bytesSent + 1			count: (bytesToSend - bytesSent min: 5000).		bytesSent := bytesSent + count].	^ bytesSent! !!Socket methodsFor: 'as yet unclassified' stamp: 'ar 7/20/1999 17:23'!sendData: buffer count: n	"Send the amount of data from the given buffer"	| sent |	sent := 0.	[sent < n] whileTrue:[		sent := sent + (self sendSomeData: buffer startIndex: sent+1 count: (n-sent))].! !!Socket methodsFor: 'as yet unclassified' stamp: 'ul 4/20/2011 01:53'!sendData: aStringOrByteArray toHost: hostAddress port: portNumber	"Send a UDP packet containing the given data to the specified host/port."	^self sendUDPData: aStringOrByteArray toHost: hostAddress port: portNumber! !!Socket methodsFor: 'as yet unclassified' stamp: 'jm 2/25/1999 13:54'!sendDone	"Return true if the most recent send operation on this socket has completed."	socketHandle == nil ifTrue: [^ false].	^ self primSocketSendDone: socketHandle! !!Socket methodsFor: 'as yet unclassified' stamp: 'ls 1/5/1999 15:05'!sendSomeData: aStringOrByteArray	"Send as much of the given data as possible and answer the number of bytes actually sent."	"Note: This operation may have to be repeated multiple times to send a large amount of data."	^ self		sendSomeData: aStringOrByteArray		startIndex: 1		count: aStringOrByteArray size! !!Socket methodsFor: 'as yet unclassified' stamp: 'ls 3/3/1999 18:59'!sendSomeData: aStringOrByteArray startIndex: startIndex	"Send as much of the given data as possible starting at the given index. Answer the number of bytes actually sent."	"Note: This operation may have to be repeated multiple times to send a large amount of data."	^ self		sendSomeData: aStringOrByteArray		startIndex: startIndex		count: (aStringOrByteArray size - startIndex + 1)! !!Socket methodsFor: 'as yet unclassified' stamp: 'mtf 3/5/2011 17:54'!sendSomeData: aStringOrByteArray startIndex: startIndex count: count	^ self sendSomeData: aStringOrByteArray startIndex: startIndex count: count for: Socket standardTimeout! !!Socket methodsFor: 'as yet unclassified' stamp: 'fbs 2/18/2011 08:58'!sendSomeData: aStringOrByteArray startIndex: startIndex count: count for: aTimeoutInSeconds	"Send up to count bytes of the given data starting at the given index. Answer the number of bytes actually sent."	"Note: This operation may have to be repeated multiple times to send a large amount of data."	| bytesSent |	(self waitForSendDoneFor: aTimeoutInSeconds)		ifTrue: [			bytesSent := self primSocket: socketHandle				sendData: aStringOrByteArray				startIndex: startIndex				count: count]		ifFalse: [ConnectionTimedOut signal: 'send data timeout; data not sent'].	^ bytesSent! !!Socket methodsFor: 'as yet unclassified' stamp: 'mir 2/19/2002 18:33'!sendStreamContents: stream	"Send the data in the stream. Close the stream.	Usefull for directly sending contents of a file without reading into memory first."	self sendStreamContents: stream checkBlock: [true]! !!Socket methodsFor: 'as yet unclassified' stamp: 'nice 12/26/2009 21:50'!sendStreamContents: stream checkBlock: checkBlock	"Send the data in the stream. Close the stream after you are done. After each block of data evaluate checkBlock and abort if it returns false.	Usefull for directly sending contents of a file without reading into memory first."	[	| chunkSize buffer |	chunkSize := 5000.	buffer := ByteArray new: chunkSize.	stream binary.	[stream atEnd and: [checkBlock value]]		whileFalse: [			buffer := stream next: chunkSize into: buffer.			self sendData: buffer]]		ensure: [stream close]! !!Socket methodsFor: 'as yet unclassified' stamp: 'dtl 6/19/2012 22:14'!sendUDPData: aStringOrByteArray toHost: hostAddress port: portNumber	"Send a UDP packet containing the given data to the specified host/port."	| bytesToSend bytesSent count |	bytesToSend := aStringOrByteArray size.	bytesSent := 0.	[bytesSent < bytesToSend] whileTrue: [		(self waitForSendDoneFor: 20)			ifFalse: [ConnectionTimedOut signal: 'send data timeout; data not sent'].		count := self primSocket: socketHandle			sendUDPData: aStringOrByteArray			toHost: hostAddress asByteArray			port: portNumber			startIndex: bytesSent + 1			count: bytesToSend - bytesSent.		count isZero ifTrue: [NetworkError signal: 'failed to send data']..		bytesSent := bytesSent + count].	^ bytesSent! !!Socket methodsFor: 'as yet unclassified' stamp: 'mir 2/22/2002 16:30'!setOption: aName value: aValue 	| value |	"setup options on this socket, see Unix man pages for values for 	sockets, IP, TCP, UDP. IE SO_KEEPALIVE	returns an array, element one is the error number	element two is the resulting of the negotiated value.	See getOption for list of keys"	(socketHandle == nil or: [self isValid not])		ifTrue: [InvalidSocketStatusException signal: 'Socket status must valid before setting an option'].	value := aValue asString.	aValue == true ifTrue: [value := '1'].	aValue == false ifTrue: [value := '0'].	^ self primSocket: socketHandle setOption: aName value: value! !!Socket methodsFor: 'as yet unclassified' stamp: 'dtl 6/3/2012 19:32'!setPeer: hostAddress port: port	"Set the default send/recv address."	self primSocket: socketHandle connectTo: hostAddress asByteArray port: port.! !!Socket methodsFor: 'as yet unclassified' stamp: 'ar 4/30/1999 04:29'!setPort: port	"Associate a local port number with a UDP socket.  Not applicable to TCP sockets."	self primSocket: socketHandle setPort: port.! !!Socket methodsFor: 'as yet unclassified' stamp: 'ul 12/7/2014 05:48'!setPort: portNumber interface: ifAddr	"Allow an UDP socket to bind to a specific interface." 	self primSocket: socketHandle listenOn: portNumber backlogSize: 0 interface: ifAddr asByteArray.! !!Socket methodsFor: 'as yet unclassified' stamp: 'JMM 5/8/2000 23:24'!socketError	^self primSocketError: socketHandle! !!Socket methodsFor: 'as yet unclassified' stamp: 'ar 7/16/1999 17:22'!socketHandle	^socketHandle! !!Socket methodsFor: 'as yet unclassified' stamp: 'jm 2/25/1999 13:56'!statusString	"Return a string describing the status of this socket."	| status |	socketHandle == nil ifTrue: [^ 'destroyed'].	status := self primSocketConnectionStatus: socketHandle.	status = InvalidSocket ifTrue: [^ 'invalidSocketHandle'].	status = Unconnected ifTrue: [^ 'unconnected'].	status = WaitingForConnection ifTrue: [^ 'waitingForConnection'].	status = Connected ifTrue: [^ 'connected'].	status = OtherEndClosed ifTrue: [^ 'otherEndClosedButNotThisEnd'].	status = ThisEndClosed ifTrue: [^ 'thisEndClosedButNotOtherEnd'].	^ 'unknown socket status'! !!Socket methodsFor: 'as yet unclassified' stamp: 'ar 3/21/98 17:41'!unregister	^self class unregister: self! !!Socket methodsFor: 'as yet unclassified' stamp: 'dc 10/21/2008 08:19'!waitForAcceptFor: timeout	"Wait and accept an incoming connection. Return nil if it falis"	self waitForConnectionFor: timeout ifTimedOut: [^ nil].	^ self isConnected		ifTrue:[self accept]		! !!Socket methodsFor: 'as yet unclassified' stamp: 'svp 7/27/2003 00:23'!waitForAcceptFor: timeout ifTimedOut: timeoutBlock	"Wait and accept an incoming connection"	self waitForConnectionFor: timeout ifTimedOut: [^timeoutBlock value].	^self accept! !!Socket methodsFor: 'as yet unclassified' stamp: 'dtl 6/13/2012 21:30'!waitForConnectionFor: timeout	"Wait up until the given deadline for a connection to be established. Return true if it is established by the deadline, false if not."	^self 		waitForConnectionFor: timeout 		ifTimedOut: [ConnectionTimedOut signal: 'Failed to connect in ', timeout asString, ' seconds']		ifRefused: [ConnectionRefused signal: 'Failed to connect in ', timeout asString, ' seconds']! !!Socket methodsFor: 'as yet unclassified' stamp: 'dtl 6/13/2012 21:32'!waitForConnectionFor: timeout ifTimedOut: timeoutBlock	"Wait up until the given deadline for a connection to be established. Return true if it is established by the deadline, false if not."	^ self waitForConnectionFor: timeout ifTimedOut: timeoutBlock ifRefused: timeoutBlock! !!Socket methodsFor: 'as yet unclassified' stamp: 'dtl 6/13/2012 21:18'!waitForConnectionFor: timeout ifTimedOut: timeoutBlock ifRefused: refusedBlock	"Wait up until the given deadline for a connection to be established. Return true if it is established by the deadline, false if not."	| startTime msecsDelta msecsEllapsed status |	startTime := Time millisecondClockValue.	msecsDelta := (timeout * 1000) truncated.	status := self primSocketConnectionStatus: socketHandle.	status = Connected ifTrue: [^true].	[(status = WaitingForConnection) and: [(msecsEllapsed := Time millisecondsSince: startTime) < msecsDelta]]		whileTrue: [			semaphore waitTimeoutMSecs: msecsDelta - msecsEllapsed.			status := self primSocketConnectionStatus: socketHandle].	status = Connected		ifFalse: [			status = WaitingForConnection				ifTrue: [timeoutBlock value]				ifFalse: [refusedBlock value].			^false].	^ true! !!Socket methodsFor: 'as yet unclassified' stamp: 'dtl 6/13/2012 21:04'!waitForConnectionUntil: deadline	"Wait up until the given deadline for a connection to be established. Return true if it is established by the deadline, false if not."	| status |	status := self primSocketConnectionStatus: socketHandle.	self isConnected ifTrue: [^status].	[(status = WaitingForConnection) and: [Time millisecondClockValue < deadline]]		whileTrue: [			semaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue).			status := self primSocketConnectionStatus: socketHandle].	^ status = Connected! !!Socket methodsFor: 'as yet unclassified' stamp: 'svp 9/23/2003 00:09'!waitForData	"Wait for data to arrive.  This method will block until	data is available or the socket is closed.  If the socket is closed	a ConnectionClosed exception will be signaled."	^self waitForDataIfClosed:		[ConnectionClosed signal: 'Connection close while waiting for data.']! !!Socket methodsFor: 'as yet unclassified' stamp: 'svp 7/27/2003 00:18'!waitForDataFor: timeout	"Wait for the given nr of seconds for data to arrive.	Signal a time out or connection close exception if either happens before data becomes available."	^self		waitForDataFor: timeout		ifClosed: [ConnectionClosed signal: 'Connection closed while waiting for data.']		ifTimedOut: [ConnectionTimedOut signal: 'Data receive timed out.']! !!Socket methodsFor: 'as yet unclassified' stamp: 'ul 8/13/2014 21:14'!waitForDataFor: timeout ifClosed: closedBlock ifTimedOut: timedOutBlock	"Wait for the given nr of seconds for data to arrive."		| startTime msecsDelta |	startTime := Time millisecondClockValue.	msecsDelta := (timeout * 1000) truncated.	[(Time millisecondsSince: startTime) < msecsDelta] whileTrue: [		(self primSocketReceiveDataAvailable: socketHandle)			ifTrue: [^self].		self isConnected			ifFalse: [^closedBlock value].		"Providing a maximum for the time for waiting is a workaround for a VM bug which causes sockets waiting for data forever in some rare cases, because the semaphore doesn't get signaled. Remove the ""min: self class maximumReadSemaphoreWaitTimeout"" part when the bug is fixed."		self readSemaphore waitTimeoutMSecs: 			((msecsDelta - (Time millisecondsSince: startTime) max: 0) min: self class maximumReadSemaphoreWaitTimeout).	].	(self primSocketReceiveDataAvailable: socketHandle)		ifFalse: [			self isConnected				ifTrue: [^timedOutBlock value]				ifFalse: [^closedBlock value]].! !!Socket methodsFor: 'as yet unclassified' stamp: 'ul 8/13/2014 21:16'!waitForDataIfClosed: closedBlock	"Wait indefinitely for data to arrive.  This method will block until	data is available or the socket is closed."	[		(self primSocketReceiveDataAvailable: socketHandle)			ifTrue: [^self].		self isConnected			ifFalse: [^closedBlock value].		"Providing a maximum for the time for waiting is a workaround for a VM bug which causes sockets waiting for data forever in some rare cases, because the semaphore doesn't get signaled. Replace the ""waitTimeoutMSecs: self class maximumReadSemaphoreWaitTimeout"" part with ""wait"" when the bug is fixed."		self readSemaphore waitTimeoutMSecs: self class maximumReadSemaphoreWaitTimeout ] repeat! !!Socket methodsFor: 'as yet unclassified' stamp: 'ul 8/13/2014 21:15'!waitForDisconnectionFor: timeout	"Wait for the given nr of seconds for the connection to be broken.	Return true if it is broken by the deadline, false if not.	The client should know the connection is really going to be closed	(e.g., because he has called 'close' to send a close request to the other end)	before calling this method."	| startTime msecsDelta status |	startTime := Time millisecondClockValue.	msecsDelta := (timeout * 1000) truncated.	status := self primSocketConnectionStatus: socketHandle.	[((status == Connected) or: [(status == ThisEndClosed)]) and:	 [(Time millisecondsSince: startTime) < msecsDelta]] whileTrue: [		self discardReceivedData.		"Providing a maximum for the time for waiting is a workaround for a VM bug which causes sockets waiting for data forever in some rare cases, because the semaphore doesn't get signaled. Remove the ""min: self class maximumReadSemaphoreWaitTimeout"" part when the bug is fixed."		self readSemaphore waitTimeoutMSecs: 			((msecsDelta - (Time millisecondsSince: startTime) max: 0) min: self class maximumReadSemaphoreWaitTimeout).		status := self primSocketConnectionStatus: socketHandle].	^ status ~= Connected! !!Socket methodsFor: 'as yet unclassified' stamp: 'Pmm 11/20/2010 23:47'!waitForSendDoneFor: timeout	"Wait up until the given deadline for the current send operation to complete. Return true if it completes by the deadline, false if not."	| startTime msecsDelta msecsEllapsed sendDone |	startTime := Time millisecondClockValue.	msecsDelta := (timeout * 1000) truncated.	[(sendDone := self primSocketSendDone: socketHandle) not and: [ self isConnected			"Connection end and final data can happen fast, so test in this order"		and: [(msecsEllapsed := Time millisecondsSince: startTime) < msecsDelta]]] whileTrue: [			self writeSemaphore waitTimeoutMSecs: msecsDelta - msecsEllapsed].	^ sendDone! !!Socket methodsFor: 'as yet unclassified' stamp: 'ul 4/20/2011 01:56'!writeSemaphore		^writeSemaphore! !!Socket class methodsFor: 'as yet unclassified' stamp: 'ls 9/24/1999 09:45'!acceptFrom: aSocket	^[ super new acceptFrom: aSocket ]		repeatWithGCIf: [ :sock | sock isValid not ]! !!Socket class methodsFor: 'as yet unclassified' stamp: 'ar 4/30/1999 04:15'!createIfFail: failBlock	"Attempt to create a new socket. If successful, return the new socket. Otherwise, return the result of evaluating the given block. Socket creation can fail if the network isn't available or if there are not sufficient resources available to create another socket."	"Note: The default creates a TCP socket"	^self tcpCreateIfFail: failBlock! !!Socket class methodsFor: 'as yet unclassified' stamp: 'tk 4/9/98 15:54'!deadServer	^ DeadServer! !!Socket class methodsFor: 'as yet unclassified' stamp: 'tk 4/9/98 15:56'!deadServer: aStringOrNil	"Keep the machine name of the most recently encoutered non-responding machine.  Next time the user can move it to the last in a list of servers to try."	DeadServer := aStringOrNil! !!Socket class methodsFor: 'as yet unclassified' stamp: 'ul 11/25/2010 21:16'!deadlineSecs: secs	"Return a deadline time the given number of seconds from now."	self deprecated: 'Using this method may result in clock rollover related bug. Don''t use it.'. 	^ Time millisecondClockValue + (secs * 1000) truncated! !!Socket class methodsFor: 'as yet unclassified' stamp: 'ar 12/12/2001 19:12'!initialize	"Socket initialize"	"Socket Types"	TCPSocketType := 0.	UDPSocketType := 1.	"Socket Status Values"	InvalidSocket := -1.	Unconnected := 0.	WaitingForConnection := 1.	Connected := 2.	OtherEndClosed := 3.	ThisEndClosed := 4.	RegistryThreshold := 100. "# of sockets"! !!Socket class methodsFor: 'as yet unclassified' stamp: 'mir 2/22/2002 15:01'!initializeNetwork	"Initialize the network drivers and the NetNameResolver. Do nothing if the network is already initialized."	"Note: The network must be re-initialized every time Squeak starts up, so applications that persist across snapshots should be prepared to re-initialize the network as needed. Such applications should call 'Socket initializeNetwork' before every network transaction. "	NetNameResolver initializeNetwork! !!Socket class methodsFor: 'as yet unclassified' stamp: 'nice 12/25/2013 21:57'!loopbackTest	"Send data from one socket to another on the local machine.	Tests most of the socket primitives."	"100 timesRepeat: [Socket loopbackTest]"	| sock1 sock2 bytesToSend sendBuf receiveBuf done bytesSent bytesReceived t extraBytes packetsSent packetsRead |	Transcript		cr;		show: 'starting loopback test';		cr.	Transcript		show: '---------- Connecting ----------';		cr.	self initializeNetwork.	sock1 := self new.	sock2 := self new.	sock1 listenOn: 54321.	sock2 connectTo: NetNameResolver localHostAddress port: 54321.	sock1 waitForConnectionFor: self standardTimeout.	sock2 waitForConnectionFor: self standardTimeout.	sock1 isConnected ifFalse: [self error: 'sock1 not connected'].	sock2 isConnected ifFalse: [self error: 'sock2 not connected'].	Transcript		show: 'connection established';		cr.	bytesToSend := 5000000.	sendBuf := String new: 5000 withAll: $x.	receiveBuf := String new: 50000.	done := false.	packetsSent := packetsRead := bytesSent := bytesReceived := 0.	t := Time millisecondsToRun: 					[[done] whileFalse: 							[(sock1 sendDone and: [bytesSent < bytesToSend]) 								ifTrue: 									[packetsSent := packetsSent + 1.									bytesSent := bytesSent + (sock1 sendSomeData: sendBuf)].							sock2 dataAvailable 								ifTrue: 									[packetsRead := packetsRead + 1.									bytesReceived := bytesReceived + (sock2 receiveDataInto: receiveBuf)].							done := bytesSent >= bytesToSend and: [bytesReceived = bytesSent]]].	Transcript		show: 'closing connection';		cr.	sock1 waitForSendDoneFor: self standardTimeout.	sock1 close.	sock2 waitForDisconnectionFor: self standardTimeout.	extraBytes := sock2 discardReceivedData.	extraBytes > 0 		ifTrue: 			[Transcript				show: ' *** received ' , extraBytes size printString , ' extra bytes ***';				cr].	sock2 close.	sock1 waitForDisconnectionFor: self standardTimeout.	sock1 isUnconnectedOrInvalid ifFalse: [self error: 'sock1 not closed'].	sock2 isUnconnectedOrInvalid ifFalse: [self error: 'sock2 not closed'].	Transcript		show: '---------- Connection Closed ----------';		cr.	sock1 destroy.	sock2 destroy.	Transcript		show: 'loopback test done; time = ' , t printString;		cr.	Transcript		show: (bytesToSend asFloat / t printShowingMaxDecimalPlaces: 2), '* 1000 bytes/sec';		cr.	Transcript endEntry! !!Socket class methodsFor: 'as yet unclassified' stamp: 'ul 8/13/2014 21:09'!maximumReadSemaphoreWaitTimeout	<preference: 'Maximum readSemaphore wait timeout.'	category: 'general'	description: 'The number of milliseconds for which we''ll wait for the readSemaphore of a Socket to signal. This is used by a workaround for a VM bug. Lower values use more CPU, but result in less delay in extremal cases.'	type: #Number>	^MaximumReadSemaphoreWaitTimeout ifNil: [ 500 ]! !!Socket class methodsFor: 'as yet unclassified' stamp: 'ul 8/13/2014 21:04'!maximumReadSemaphoreWaitTimeout: anInteger	"The number of milliseconds for which we'll wait for the readSemaphore to signal. This is used by a workaround for a VM bug."	MaximumReadSemaphoreWaitTimeout := anInteger! !!Socket class methodsFor: 'as yet unclassified' stamp: 'jm 1/14/1999 12:13'!nameForWellKnownTCPPort: portNum	"Answer the name for the given well-known TCP port number. Answer a string containing the port number if it isn't well-known."	| portList entry |	portList := #(		(7 'echo') (9 'discard') (13 'time') (19 'characterGenerator')		(21 'ftp') (23 'telnet') (25 'smtp')		(80 'http') (110 'pop3') (119 'nntp')).	entry := portList detect: [:pair | pair first = portNum] ifNone: [^ 'port-', portNum printString].	^ entry last! !!Socket class methodsFor: 'as yet unclassified' stamp: 'ar 4/30/1999 04:13'!new	"Return a new, unconnected Socket. Note that since socket creation may fail, it is safer to use the method createIfFail: to handle such failures gracefully; this method is primarily for backward compatibility and may be disallowed in a future release."	"Note: The default creates a TCP socket - this is also backward compatibility."	^self newTCP! !!Socket class methodsFor: 'as yet unclassified' stamp: 'gk 12/15/2005 01:03'!newAcceptCheck	"Check if the platform has support for the BSD style accept()."	"Socket newAcceptCheck"		| socket |	self initializeNetwork.	socket := self newTCP.	socket listenOn: 44444 backlogSize: 4.	socket isValid ifTrue: [		self inform: 'Everything looks OK for the BSD style accept()'	] ifFalse: [		self inform: 'It appears that you DO NOT have support for the BSD style accept()'].	socket destroy! !!Socket class methodsFor: 'as yet unclassified' stamp: 'mir 1/5/2007 18:27'!newTCP	"Create a socket and initialise it for TCP"	^self newTCP: SocketAddressInformation addressFamilyINET4! !!Socket class methodsFor: 'as yet unclassified' stamp: 'ikp 6/8/2007 23:02'!newTCP: family	"Create a socket and initialise it for TCP"	self initializeNetwork.	^[ super new initialize: TCPSocketType family: family ]		repeatWithGCIf: [ :socket | socket isValid not ]! !!Socket class methodsFor: 'as yet unclassified' stamp: 'mir 1/5/2007 18:27'!newUDP	"Create a socket and initialise it for UDP"	^self newUDP: SocketAddressInformation addressFamilyINET4! !!Socket class methodsFor: 'as yet unclassified' stamp: 'mir 6/17/2007 21:20'!newUDP: family	"Create a socket and initialise it for UDP"	self initializeNetwork.	^[ super new initialize: UDPSocketType family: family ]		repeatWithGCIf: [ :socket | socket isValid not ]! !!Socket class methodsFor: 'as yet unclassified' stamp: 'ul 11/25/2010 21:09'!ping: hostName	"Ping the given host. Useful for checking network connectivity. The host must be running a TCP echo server."	"Socket ping: 'squeak.cs.uiuc.edu'"	| tcpPort sock serverAddr startTime echoTime |	tcpPort := 7.  "7 = echo port, 13 = time port, 19 = character generator port"	serverAddr := NetNameResolver addressForName: hostName timeout: 10.	serverAddr ifNil: [ ^self inform: 'Could not find an address for ', hostName ].	sock := Socket new.	sock connectNonBlockingTo: serverAddr port: tcpPort.	[sock waitForConnectionFor: 10]		on: ConnectionTimedOut		do: [:ex |			(self confirm: 'Continue to wait for connection to ', hostName, '?')				ifTrue: [ex retry]				ifFalse: [					sock destroy.					^ self]].	sock sendData: 'echo!!'.	startTime := Time millisecondClockValue.	[sock waitForDataFor: 15]		on: ConnectionTimedOut		do: [:ex | (self confirm: 'Packet sent but no echo yet; keep waiting?')			ifTrue: [ex retry]].	echoTime := Time millisecondClockValue - startTime.	sock destroy.	self inform: hostName, ' responded in ', echoTime printString, ' milliseconds'.! !!Socket class methodsFor: 'as yet unclassified' stamp: 'ul 11/25/2010 21:34'!pingPorts: portList on: hostName timeOutSecs: timeOutSecs	"Attempt to connect to each of the given sockets on the given host. Wait at most timeOutSecs for the connections to be established. Answer an array of strings indicating the available ports."	"Socket pingPorts: #(7 13 19 21 23 25 80 110 119) on: 'squeak.org' timeOutSecs: 15"	| serverAddr sockets startTime timeoutMsecs done result unconnectedCount connectedCount waitingCount |	serverAddr := NetNameResolver addressForName: hostName timeout: 10.	serverAddr ifNil: [ 			self inform: 'Could not find an address for ' , hostName.			^ #() ].	sockets := portList		collect: [ :portNum | 			| sock |			sock := Socket new.			[ sock connectTo: serverAddr port: portNum ] 				on: ConnectionTimedOut				do: [ ].			sock ].	startTime := Time millisecondClockValue.	timeoutMsecs := (1000 * timeOutSecs) truncated.	done := false.	[ done ]		whileFalse: [ 			unconnectedCount := 0.			connectedCount := 0.			waitingCount := 0.			sockets				do: [ :s | 					s isUnconnectedOrInvalid						ifTrue: [ unconnectedCount := unconnectedCount + 1 ]						ifFalse: [ 							s isConnected								ifTrue: [ connectedCount := connectedCount + 1 ].							s isWaitingForConnection								ifTrue: [ waitingCount := waitingCount + 1 ] ] ].			waitingCount = 0				ifTrue: [ done := true ].			connectedCount = sockets size				ifTrue: [ done := true ].			(Time millisecondsSince: startTime) >= timeoutMsecs				ifTrue: [ done := true ] ].	result := (sockets select: [ :s | s isConnected ]) collect: [ :s | self nameForWellKnownTCPPort: s remotePort ].	sockets do: [ :s | s destroy ].	^ result! !!Socket class methodsFor: 'as yet unclassified' stamp: 'jm 1/14/1999 17:25'!pingPortsOn: hostName	"Attempt to connect to a set of well-known sockets on the given host, and answer the names of the available ports."	"Socket pingPortsOn: 'www.disney.com'"	^ Socket		pingPorts: #(7 13 19 21 23 25 80 110 119)		on: hostName		timeOutSecs: 20! !!Socket class methodsFor: 'as yet unclassified' stamp: 'mir 2/22/2002 14:59'!primInitializeNetwork: resolverSemaIndex	"Initialize the network drivers on platforms that need it, such as the Macintosh, and return nil if network initialization failed or the reciever if it succeeds. Since mobile computers may not always be connected to a network, this method should NOT be called automatically at startup time; rather, it should be called when first starting a networking application. It is a noop if the network driver has already been initialized. If non-zero, resolverSemaIndex is the index of a VM semaphore to be associated with the network name resolver. This semaphore will be signalled when the resolver status changes, such as when a name lookup query is completed."	"Note: some platforms (e.g., Mac) only allow only one name lookup query at a time, so a manager process should be used to serialize resolver lookup requests."	<primitive: 'primitiveInitializeNetwork' module: 'SocketPlugin'>	^ nil  "return nil if primitive fails"! !!Socket class methodsFor: 'as yet unclassified' stamp: 'ul 8/27/2010 23:24'!register: anObject		^self registry add: anObject! !!Socket class methodsFor: 'as yet unclassified' stamp: 'ul 8/27/2010 23:24'!registry	^Registry ifNil: [ Registry := WeakRegistry new ]! !!Socket class methodsFor: 'as yet unclassified' stamp: 'ar 12/12/2001 19:12'!registryThreshold	"Return the registry threshold above which socket creation may fail due to too many already open sockets. If the threshold is reached, a full GC will be issued if the creation of a socket fails."	^RegistryThreshold! !!Socket class methodsFor: 'as yet unclassified' stamp: 'ar 12/12/2001 19:12'!registryThreshold: aNumber	"Return the registry threshold above which socket creation may fail due to too many already open sockets. If the threshold is reached, a full GC will be issued if the creation of a socket fails."	RegistryThreshold := aNumber! !!Socket class methodsFor: 'as yet unclassified' stamp: 'nice 12/25/2013 21:57'!sendTest	"Send data to the 'discard' socket of the given host.	Tests the speed of one-way data transfers across the	network to the given host. Note that most hosts	do not run a discard server."	"Socket sendTest"	| sock bytesToSend sendBuf bytesSent t serverName serverAddr |	Transcript cr; show: 'starting send test'; cr.	self initializeNetwork.	serverName := UIManager default request: 'What is the destination server?' initialAnswer: 'create.ucsb.edu'.	serverAddr := NetNameResolver addressForName: serverName timeout: 10.	serverAddr = nil 		ifTrue: [^self inform: 'Could not find an address for ' , serverName].	sock := self new.	Transcript show: '---------- Connecting ----------';cr.	sock connectTo: serverAddr port: 9.	sock isConnected ifFalse: [		sock destroy.		^self inform: 'could not connect'].	Transcript show: 'connection established; sending data'; cr.	bytesToSend := 1000000.	sendBuf := String new: 64 * 1024 withAll: $x.	bytesSent := 0.	t := Time millisecondsToRun: 					[[bytesSent < bytesToSend] whileTrue: 							[sock sendDone 								ifTrue: [bytesSent := bytesSent + (sock sendSomeData: sendBuf)]]].	sock waitForSendDoneFor: self standardTimeout.	sock destroy.	Transcript show: '---------- Connection Closed ----------'; cr;		show: 'send test done; time = ' , t printString; cr;		show: (bytesToSend asFloat / t printShowingMaxDecimalPlaces: 2), ' * 1000 bytes/sec';cr;endEntry! !!Socket class methodsFor: 'as yet unclassified' stamp: 'mir 5/15/2003 16:17'!standardDeadline	"Return a default deadline time some seconds into the future."	^ self deadlineSecs: self standardTimeout! !!Socket class methodsFor: 'as yet unclassified' stamp: 'mir 5/15/2003 16:16'!standardTimeout	^45! !!Socket class methodsFor: 'as yet unclassified' stamp: 'mir 1/5/2007 18:21'!tcpCreateIfFail: failBlock	"Attempt to create a new socket. If successful, return the new socket. Otherwise, return the result of evaluating the given block. Socket creation can fail if the network isn't available or if there are not sufficient resources available to create another socket."	| sock |	self initializeNetwork.	sock := self newTCP.	sock isValid ifFalse: [^ failBlock value].	^ sock! !!Socket class methodsFor: 'as yet unclassified' stamp: 'ul 11/11/2010 07:24'!timeTest	"Socket timeTest"	| serverName serverAddr s |	Transcript show: 'initializing network ... '.	self initializeNetwork.	Transcript		show: 'ok';		cr.	serverName := UIManager default request: 'What is your time server?'				initialAnswer: 'localhost'.	serverName isEmpty 		ifTrue: 			[^Transcript				show: 'never mind';				cr].	serverAddr := NetNameResolver addressForName: serverName timeout: 10.	serverAddr = nil 		ifTrue: [self error: 'Could not find the address for ' , serverName].	s := self new.	Transcript		show: '---------- Connecting ----------';		cr.	s connectTo: serverAddr port: 13.	"13 is the 'daytime' port number"	s waitForConnectionUntil: (self deadlineSecs: 1).	Transcript show: 'the time server reports: ' , s receiveData.	s closeAndDestroy.	Transcript		show: '---------- Connection Closed ----------';		cr! !!Socket class methodsFor: 'as yet unclassified' stamp: 'ul 11/11/2010 07:24'!timeTestUDP	"Socket timeTestUDP"	| serverName serverAddr s |	Transcript show: 'initializing network ... '.	self initializeNetwork.	Transcript		show: 'ok';		cr.	serverName := UIManager default request: 'What is your time server?'				initialAnswer: 'localhost'.	serverName isEmpty 		ifTrue: 			[^Transcript				show: 'never mind';				cr].	serverAddr := NetNameResolver addressForName: serverName timeout: 10.	serverAddr = nil 		ifTrue: [self error: 'Could not find the address for ' , serverName].	s := self newUDP.	"a 'random' port number will be allocated by the system"	"Send a packet to the daytime port and it will reply with the current date."	Transcript		show: '---------- Sending datagram from port ' , s port printString 					, ' ----------';		cr.	s 		sendData: '!!'		toHost: serverAddr		port: 13.	"13 is the daytime service"	Transcript show: 'the time server reports: ' , s receiveData.	s closeAndDestroy.	Transcript		show: '---------- Socket closed ----------';		cr! !!Socket class methodsFor: 'as yet unclassified' stamp: 'mir 1/5/2007 18:22'!udpCreateIfFail: failBlock	"Attempt to create a new socket. If successful, return the new socket. Otherwise, return the result of evaluating the given block. Socket creation can fail if the network isn't available or if there are not sufficient resources available to create another socket."	| sock |	self initializeNetwork.	sock := self newUDP.	sock isValid ifFalse: [^ failBlock value].	^ sock! !!Socket class methodsFor: 'as yet unclassified' stamp: 'ul 8/27/2010 23:24'!unregister: anObject		^self registry remove: anObject ifAbsent: nil! !!Socket class methodsFor: 'as yet unclassified' stamp: 'ar 4/30/1999 04:21'!wildcardAddress	"Answer a don't-care address for use with UDP sockets."	^ByteArray new: 4		"0.0.0.0"! !!Socket class methodsFor: 'as yet unclassified' stamp: 'ar 4/30/1999 04:21'!wildcardPort	"Answer a don't-care port for use with UDP sockets.  (The system will allocate an	unused port number to the socket.)"	^0! !!HTMLLinkElement methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!HTMLLinkElement class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!WarpBlt class methodsFor: 'as yet unclassified' stamp: 'crl 6/22/2016 15:31'!scale: srcForm by: scalePoint smoothing: cellSize	^self		rotate: srcForm		degrees: 0		center: srcForm boundingBox center		scaleBy: scalePoint		smoothing: cellSize! !!Ee methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!Ee class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!DAVSlot methodsFor: 'as yet unclassified' stamp: 'crl 1/3/2015 14:13'!class: aDAVClass	class _ aDAVClass! !!DAVSlot methodsFor: 'as yet unclassified' stamp: 'crl 1/11/2015 02:31'!initialize	super initialize.	self addFileNamed: 'comment' withContents: 'You can write a comment about this slot here.'! !!DAVSlot class methodsFor: 'as yet unclassified' stamp: 'crl 1/3/2015 14:13'!forSlotNamed: aSymbol in: aDAVClass	^(self named: aSymbol)		class: aDAVClass;		yourself! !!LoginFailedException class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!EventSensor methodsFor: 'as yet unclassified' stamp: 'nk 4/11/2001 18:28'!processKeyboardEvent: evt	"process a keyboard event, updating InputSensor state"	| charCode pressCode |	"Never update keyboardBuffer if we have an eventQueue active"	mouseButtons := (mouseButtons bitAnd: 7) bitOr: ((evt at: 5) bitShift: 3).	eventQueue ifNotNil:[^self]. 	charCode := evt at: 3.	charCode = nil ifTrue:[^self]. "extra characters not handled in MVC"	pressCode := evt at: 4.	pressCode = EventKeyChar ifFalse:[^self]. "key down/up not handled in MVC"	"mix in modifiers"	charCode := charCode bitOr: ((evt at: 5) bitShift: 8).	keyboardBuffer nextPut: charCode.! !!Monitor class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!UIManager methodsFor: 'as yet unclassified' stamp: 'crl 5/18/2017 13:37'!builderClass	"Answer the kind of tool builder to use, possibly influenced by project preferences"	^(Smalltalk at: #ToolBuilderError)		ifTrue: [MorphicToolBuilder]		ifFalse: [builderClass ifNil: [ builderClass := ToolBuilder findDefault ]]! !!ServiceBrowserMorph class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!GeneralMIDIDrumPitches methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!GeneralMIDIDrumPitches class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!MyResumableTestError class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!Categorizer methodsFor: 'as yet unclassified' stamp: 'crl 4/2/2019 16:29'!printOn: aStream 	"Refer to the comment in Object|printOn:."	| elementIndex |	elementIndex := 1.	1 to: categoryArray size do: 		[:i | 		aStream nextPut: $(.		(categoryArray at: i) asString printOn: aStream.		[elementIndex <= (categoryStops at: i)]			whileTrue: 				[aStream space; nextPutAll: (elementArray at: elementIndex ifAbsent: ['none']).				elementIndex := elementIndex + 1].		aStream nextPut: $); cr]! !!BlockClosure methodsFor: 'as yet unclassified' stamp: 'crl 5/17/2017 15:15'!asJSArgument	^self! !!BlockClosure methodsFor: 'as yet unclassified' stamp: 'crl 3/21/2019 06:59'!fuse	self method ifNotNilDo: [:it | it fuse]! !!BlockClosure methodsFor: 'as yet unclassified' stamp: 'crl 7/20/2017 10:09'!javaScriptObject	| stream |		stream := (String new: 32) writeStream.		self decompile printJavaScriptOn: stream indent: 0.	^(JS Function new: 'return ', stream contents) call! !!AAssets methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!AAssets class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!BreakpointManager methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!CharacterBlockScannerForMVC class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!ScaledDecimal methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 19:48'!storeOnTether: tether
	tether
		nextWordPut: ScaledDecimalTag;
		store: fraction;
		store: scale! !!ScaledDecimal class methodsFor: 'as yet unclassified'!fromTether: tether	^self newFromNumber: tether next scale: tether next! !!Environment methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2019 00:45'!bind: aSymbol to: anObject	| binding newBinding |	newBinding := aSymbol => anObject.		binding := declarations associationAt: aSymbol ifAbsent: [nil].	binding ifNotNil: 		[binding class == newBinding class			ifTrue: [binding value: anObject]			ifFalse: [binding becomeForward: newBinding].		^anObject].		binding := undeclared associationAt: aSymbol ifAbsent: [nil].	binding	        ifNil: [binding := newBinding]	        ifNotNil: 			[undeclared removeKey: aSymbol.			binding class == newBinding class				ifTrue: [binding value: anObject]				ifFalse: [binding becomeForward: newBinding]].				declarations add: binding.	bindings add: binding.	self binding: binding addedTo: self.	^anObject! !!Environment methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 23:16'!binding: aBinding removedFrom: anEnvironment! !!Environment methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 21:18'!initializeWithSystemDictionary: old		self initialize.	info := EnvironmentInfo 		name: 'Smalltalk'		organization: old organization		packages: nil.	old associationsDo: [:assc | declarations add: assc].	(old at: #Undeclared) associationsDo: [:assc | undeclared add: assc].	(declarations at: #Smalltalk) instVarNamed: 'globals' put: self.	declarations at: #Undeclared put: undeclared.! !!Environment class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 23:21'!current	^self default! !!EncodingMismatch methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!EncodingMismatch class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!Character methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 20:02'!simplifiedForJSON	"Answer a literal populated with my contents, suitable for JSON encoding."	^self! !!Character methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 19:46'!storeOnTether: tether
	tether
		nextWordPut: CharacterTag;
		nextWordPut: self asInteger! !!Character class methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 00:57'!fromTether: tether	^self value: tether nextWord! !!AbsoluteLoudness methodsFor: 'as yet unclassified' stamp: 'crl 8/22/2017 11:34'!* number	^normalizedValue * number! !!AbsoluteLoudness methodsFor: 'as yet unclassified' stamp: 'crl 8/9/2017 11:13'!, object	^object applyAbsoluteLoudness: self! !!AbsoluteLoudness methodsFor: 'as yet unclassified' stamp: 'crl 8/22/2017 13:07'!= loudness	^self class = loudness class and: [normalizedValue = loudness normalizedValue]! !!AbsoluteLoudness methodsFor: 'as yet unclassified' stamp: 'crl 8/9/2017 11:18'!appliedTo: object	^object applyAbsoluteLoudness: self! !!AbsoluteLoudness methodsFor: 'as yet unclassified' stamp: 'crl 8/22/2017 13:07'!normalizedValue	^normalizedValue! !!AbsoluteLoudness methodsFor: 'as yet unclassified' stamp: 'crl 8/8/2017 16:51'!normalizedValue: ratio	normalizedValue := ratio! !!AbsoluteLoudness methodsFor: 'as yet unclassified' stamp: 'crl 8/24/2017 12:45'!printOn: stream	stream		print: (normalizedValue * 100) asInteger;		nextPutAll: ' percent loudness'! !!AbsoluteLoudness class methodsFor: 'as yet unclassified' stamp: 'crl 8/8/2017 16:51'!withNormalizedValue: ratio	^self new normalizedValue: ratio! !!PluggableButtonMorphPlus class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!RemoteTempVectorNode class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!DAVSessionSuspend methodsFor: 'as yet unclassified' stamp: 'crl 1/12/2015 00:16'!initialName	^'suspend'! !!DAVSessionSuspend methodsFor: 'as yet unclassified' stamp: 'crl 1/12/2015 03:42'!progressMessage	^'Stopping...'! !!DAVSessionSuspend methodsFor: 'as yet unclassified' stamp: 'crl 1/12/2015 03:32'!sideEffect	session stop! !!DAVSessionSuspend class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!SqNumberParser methodsFor: 'as yet unclassified' stamp: 'crl 8/8/2017 10:51'!nextNumber	"main method for reading a number.	This one can read Float Integer and ScaledDecimal"		| numberOfTrailingZeroInIntegerPart |	base := 10.	neg := self peekSignIsMinus.	integerPart := self nextUnsignedIntegerOrNilBase: base.	integerPart ifNil: [		"This is not a regular number beginning with a digit		It is time to check for exceptional condition NaN and Infinity"		^self readNamedFloatOrFail].	numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero.	(sourceStream peekFor: $r)		ifTrue: [			(sourceStream peekFor: $d)				ifTrue: [sourceStream skip: -2]				ifFalse: [					"<base>r<integer>"					(base := integerPart) < 2 ifTrue: [						sourceStream skip: -1.						^self expected: 'an integer greater than 1 as valid radix'].					self peekSignIsMinus ifTrue: [neg := neg not].					integerPart := self nextUnsignedIntegerBase: base.					numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero]].	^ (sourceStream peekFor: $.)		ifTrue: [self readNumberWithFractionPartNumberOfTrailingZeroInIntegerPart: numberOfTrailingZeroInIntegerPart]		ifFalse: [self makeIntegerOrScaledInteger]! !!IconicButton class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 1/4/2015 13:52'!addClass: aClass	^self addSubdirectory: (DAVClass for: aClass)! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 8/11/2016 21:45'!addFile: aDAVFile	^files		detect: [:file | file name = aDAVFile name]		ifNone: [			aDAVFile container: self.			files add: aDAVFile]! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 1/4/2015 01:58'!addFileNamed: filename	^self addFileNamed: filename withContents: ''! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 8/11/2016 21:44'!addFileNamed: filename withContents: aString	^self addFile: (DAVFile named: filename withContents: aString)! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 1/4/2015 13:52'!addSubdirectory: aDAVDirectory	"Remove any previous subdirectory with the same name."	(subdirectories select: [:subdirectory | subdirectory name = aDAVDirectory name]) do: [:subdirectory | self removeSubdirectory: subdirectory].	aDAVDirectory parent ifNotNil: [aDAVDirectory parent removeSubdirectory: aDAVDirectory].	aDAVDirectory parent: self.	subdirectories add: aDAVDirectory.	^aDAVDirectory! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 8/4/2016 22:08'!addSubdirectory: aDAVDirectory updateWith: block	"Remove any previous subdirectory with the same name."	(subdirectories select: [:subdirectory | subdirectory name = aDAVDirectory name]) do: [:subdirectory | self removeSubdirectory: subdirectory].	aDAVDirectory parent ifNotNil: [aDAVDirectory parent removeSubdirectory: aDAVDirectory].	aDAVDirectory		parent: self;		update: block.	subdirectories add: aDAVDirectory.	^aDAVDirectory! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 8/5/2016 11:31'!addSubdirectoryNamed: subdirectoryName	^self addSubdirectoryOfClass: DAVDirectory named: subdirectoryName! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 8/5/2016 11:31'!addSubdirectoryOfClass: class named: subdirectoryName	^self addSubdirectory: (class named: subdirectoryName)! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 1/10/2015 15:27'!allDescendantSubdirectoriesDo: aBlockClosure	subdirectories do: [:subdirectory |		aBlockClosure value: subdirectory.		subdirectory allDescendantSubdirectoriesDo: aBlockClosure]! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 1/11/2015 02:41'!at: resourceNameStream put: aPUT	^(self subdirectoryNamed: (resourceNameStream upTo: $/) ifNone: [^false]) at: resourceNameStream put: aPUT! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 8/9/2016 21:28'!container	^parent! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 8/2/2016 12:05'!contents	super contents.	^(OrderedCollection withAll: subdirectories)		addAll: files;		yourself! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 1/9/2015 16:29'!createDirectoryNamed: resourceNameStream	^(		self			subdirectoryNamed: (resourceNameStream upTo: $/)			ifNone: [^false]	)		createDirectoryNamed: resourceNameStream! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 1/9/2015 16:25'!createFileNamed: resourceNameStream	(		self			subdirectoryNamed: (resourceNameStream upTo: $/)			ifNone: [^self]	)		createFileNamed: resourceNameStream! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 1/4/2015 13:55'!delete: aDAVResource	subdirectories		remove: aDAVResource		ifAbsent: [			files				remove: aDAVResource				ifAbsent: []]! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 1/11/2015 17:23'!deleteBackupFiles	files _ files reject: [:file | file name last = $~].	subdirectories do: [:subdirectory | subdirectory deleteBackupFiles]! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 1/10/2015 15:27'!descendantSubdirectoryNamed: descendantName	self allDescendantSubdirectoriesDo: [:descendant |		(descendant name = descendantName) ifTrue: [^descendant]].	^nil! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 1/4/2015 13:55'!elementNamed: resourceName	^subdirectories		detect: [:subdirectory | subdirectory name = resourceName]		ifNone: [			files				detect: [:file | file name = resourceName]				ifNone: [nil]]! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 1/10/2015 20:12'!fileNamed: resourceName	^self fileNamed: resourceName ifNone: [nil]! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 1/4/2015 01:27'!fileNamed: resourceName ifNone: aBlockClosure	^files		detect: [:file | file name = resourceName]		ifNone: aBlockClosure! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 8/11/2016 14:22'!files	^files! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 8/6/2016 00:01'!initialize	super initialize.	self initializeContents! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 8/11/2016 11:18'!initializeContents	subdirectories _ OrderedCollection new.	files _ (		files			ifNil: [OrderedCollection new]			ifNotNil: [				files select: [:file | file name = '.update']])! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 7/13/2017 11:45'!isDirectory	^true! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 8/12/2016 10:12'!newFileNamed: filename	^DAVFile named: filename! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 1/3/2015 23:07'!parent	^parent! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 1/3/2015 23:07'!parent: aDAVResource	parent _ aDAVResource! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 1/4/2015 13:55'!postCopy	subdirectories _ subdirectories collect: [:subdirectory |		(subdirectory copy)			parent: self;			yourself].	files _ files collect: [:file |		(file copy)			container: self;			yourself].	self parent: nil! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 1/4/2015 13:51'!removeSubdirectory: subdirectory	subdirectory parent: nil.	^subdirectories remove: subdirectory! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 1/4/2015 01:16'!resourceType	^DAVResourceTypeCollection new! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 7/14/2017 12:19'!responsePayload	| contents |	files do: [:file |		file name = 'index.html' ifTrue: [^file responsePayload]].		contents := (String new: 128) writeStream.	contents		nextPutAll: '<html><pre><b>';		nextPutAll: name;		nextPutAll: '</b>';		cr: 2.	(subdirectories isEmpty)		ifTrue: [contents nextPutAll: '<i>no subdirectories</i>']		ifFalse: [			contents nextPutAll: '<i>directories</i>:'.			subdirectories do: [:subdirectory |				contents					crtab;					nextPutAll: '<b>';					nextPutAll: subdirectory name;					nextPutAll: '</b>']].	contents cr: 2.	(files isEmpty)		ifTrue: [contents nextPutAll: '<i>no files</i>']		ifFalse: [			contents				nextPutAll: '<i>files</i>:'.				files do: [:file |				contents					crtab;					nextPutAll: file name]].	^contents		nextPutAll: '</pre></html>';		contents! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 1/4/2015 01:09'!statusForResponseProperty: property forResource: resource	^DAVStatus notFound! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 1/4/2015 13:49'!subdirectories	^subdirectories! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 8/5/2016 11:45'!subdirectoryNamed: subdirectoryName	^self subdirectorySuchThat: [:subdirectory | subdirectory name = subdirectoryName]! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 8/5/2016 11:43'!subdirectoryNamed: subdirectoryName ifNone: failBlock	^self		subdirectorySuchThat: [:subdirectory | subdirectory name = subdirectoryName]		ifNone: failBlock! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 8/5/2016 11:44'!subdirectorySuchThat: searchBlock	^self subdirectorySuchThat: searchBlock ifNone: [nil]! !!DAVDirectory methodsFor: 'as yet unclassified' stamp: 'crl 8/5/2016 12:03'!subdirectorySuchThat: searchBlock ifNone: failBlock	subdirectories do: [:subdirectory |		(searchBlock value: subdirectory)			ifTrue: [^subdirectory]			ifFalse: [				| hit |				hit _ subdirectory subdirectorySuchThat: searchBlock ifNone: [nil].				hit ifNotNil: [^hit]]].	^failBlock value! !!DAVDirectory class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!ISO88592TextConverter methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:55'!foo! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 16:31'!addHeader: key value: value	"Adds an ADDITIONAL header for the given key"	headers add: key -> value.! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 09:02'!asString	"Prints the receiver"	^String streamContents:[:s| self writeOn: s].! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 2/2/2012 15:55'!chunkFrom: srcStream to: dstStream progress: progressBlock	"Stream the content of srcStream to dstStream.	Use chunked transfer-encoding."	| chunkSize firstLine buffer totalRead |	totalRead := 0.	buffer := (srcStream isBinary ifTrue:[ByteArray] ifFalse:[String]) new.	[firstLine := srcStream nextLine asString.	chunkSize := ('16r',firstLine asUppercase) asNumber.	chunkSize = 0] whileFalse:[		progressBlock ifNotNil:[progressBlock value: nil value: totalRead].		buffer size = chunkSize ifFalse:[buffer := buffer class new: chunkSize].		buffer := srcStream next: chunkSize into: buffer startingAt: 1.		dstStream nextPutAll: buffer.		srcStream skip: 2. "CRLF"		totalRead := totalRead + chunkSize.	].	srcStream skip: 2. "CRLF"	dstStream flush.	progressBlock ifNotNil:[progressBlock value: nil value: totalRead].! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 5/4/2010 20:02'!close	"Always closes regardless of connection header"	stream ifNotNil:[stream close].! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 5/6/2010 20:47'!closeIfTransient	"Close the underlying connection if it's not persistent"	self isPersistent ifFalse:[self close].! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 6/18/2010 23:52'!content	"Reads and caches available content and returns it."	^content ifNil:[content := self getContent].! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 3/30/2010 22:05'!content: aString	"Sets content for a response"	content := aString.! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 10:37'!contentLength	"Answers the numeric value of the Content-Length header, or nil if no header exist"	^(self headerAt: 'Content-Length' ifAbsent:[^nil]) asInteger! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 5/4/2010 21:04'!contentLength: aNumber	"Sets the numeric value of the Content-Length header"	^self headerAt: 'Content-Length' put: aNumber! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 11:01'!contentStream	"Answers a stream for the conent."	^stream! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 11:02'!contentType	"Answer the content type for the receiver"	^self headerAt: 'Content-Type' ifAbsent:['application/octet-stream']! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 3/30/2010 21:58'!contentType: aString	"Sets the content type for the receiver"	^self headerAt: 'Content-Type' put: aString! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ul 4/21/2015 06:40'!contentWithProgress: progressBlock	"Reads and caches available content and returns it."	^content ifNil: [ content := self getContentWithProgress: progressBlock ]! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 5/4/2010 20:02'!destroy	"Destroys the underlying stream"	stream ifNotNil:[stream destroy].! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ul 4/21/2015 06:31'!getContent	"Reads available content and returns it."	^self getContentWithProgress: nil! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ul 4/21/2015 06:42'!getContentWithProgress: progressBlockOrNil	"Reads available content and returns it."	| length result |	length := self contentLength.	result := (stream isBinary ifTrue:[ ByteArray ] ifFalse: [ ByteString ]) 		new: (length ifNil: [ 1000 ])		streamContents: [ :outputStream | 			self 				streamFrom: stream				to: outputStream				size: length				progress: progressBlockOrNil ].	(self headerAt: 'content-encoding') = 'gzip' ifFalse: [ ^result ].	^(GZipReadStream on: result) upToEnd! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 11:02'!headerAt: key	"Answers a single value for the given http header. 	Do not use for headers that may appear multiple times, such at www-authenticate."	^self headerAt: key ifAbsent:[''].! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 11:03'!headerAt: key ifAbsent: aBlock	"Answers a single value for the given http header. 	Do not use for headers that may appear multiple times, such at www-authenticate."	self headersAt: key do:[:value| ^value].	^aBlock value! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 12:18'!headerAt: key put: value	"Sets the value of a header, adding if necessary"	headers do:[:assoc|		(assoc key sameAs: key) ifTrue:[			assoc value: value.			^self		].	].	self addHeader: key value: value.! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 11:03'!headersAt: key	"Answers a collection of values for the given http header. 	Use for headers that may appear multiple times, such at www-authenticate."	^self headersAt: key ifAbsent:[#()].! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 11:03'!headersAt: aKey do: aBlock	"Evaluate aBlock with all the headers matching aKey"	self headersDo:[:key :value|		(aKey sameAs: key) ifTrue:[ aBlock value: value].	].! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 11:03'!headersAt: key ifAbsent: aBlock	"Answers a collection of values for the given http header. 	Use for headers that may appear multiple times, such at www-authenticate."	| hdrs |	hdrs := OrderedCollection new.	self headersAt: key do:[:value| hdrs add: value].	^hdrs asArray ifEmpty:[aBlock value]! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 11:03'!headersDo: aBlock	"Evaluate aBlock with all of the headers key-value pairs"	headers do:[:assoc|		aBlock value: assoc key value: assoc value.	].! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'pmm 6/19/2010 08:05'!isPersistent	"Return true if this is a persistent connection"	"Check for explicit connection headers"	((self headerAt:'Connection') sameAs: 'close') ifTrue:[^false].	((self headerAt:'Connection') sameAs: 'keep-alive') ifTrue:[^true].	"Defaults for various versions"	(self protocol = 'HTTP/1.0') ifTrue:[^false].	(self protocol = 'HTTP/1.1') ifTrue:[^true].	"Assume that later HTTP versions are compatible with 1.1"	^true! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 7/20/2010 20:09'!multipartBoundary	"Answer the boundary of a multipart/form-data message"	| header |	header := self headerAt: 'Content-Type' ifAbsent:[^nil].	(header beginsWith: 'multipart/form-data') ifFalse:[^nil].	^(header copyFrom: (header findString: 'boundary=') + 9 to: header size)! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 1/31/2012 20:34'!nextChunk	"Answer the next chunk from a message using chunked transfer encoding."	| chunkSize chunk |	chunkSize := Integer readFrom: (stream upToAll: String crlf) asString base: 16.	chunkSize = 0 ifFalse:[chunk := stream next: chunkSize].	stream skip: 2. "CrLf"	^chunk! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 8/31/2010 22:57'!nextChunkPut: chunk	"Send the next chunk of a message using chunked transfer encoding.	Note: This method does not allow to send empty chunks to avoid accidentally	terminating the chunked transfer. Ending the transfer is part of the chunked	request/response protocol (see #httpPostChunked:encoded:content:type:do:	as well as #sendResponse:chunked:do:)"	chunk ifNotEmpty:[		stream nextPutAll: (chunk size printStringBase: 16); crlf.		stream nextPutAll: chunk; crlf; flush.	].! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 11:05'!printOn: aStream	"Prints the receiver"	aStream nextPutAll: self class name.	aStream nextPut: $(.	self writeOn: aStream.	aStream nextPut: $).! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 16:31'!protocol	"Returns the requested protocol"	^protocol! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 16:31'!protocol: aString	"Returns the requested protocol"	protocol := aString! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'dtl 7/17/2012 18:59'!remoteHost	"Return the name of the remote host"	| remote |	(stream isKindOf: SocketStream) ifFalse:[^nil]. "don't have it"	remote := stream socket remoteAddress.	^ NetNameResolver stringFromAddress: remote.! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 3/26/2010 19:02'!removeHeader: key	"Removes ALL headers with the given key"	headers := headers reject:[:assoc| assoc key sameAs: key].! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 11:01'!stream	"Answers the underlying TCP stream"	^stream! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 11:01'!stream: aStream	"Sets the underlying TCP stream"	stream := aStream! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 5/4/2010 15:44'!streamFrom: srcStream size: size progress: aBlock	"Stream the given source stream to the message's socket stream.	Outbound. Can be used on both request/response depending on	whether it is utilized by WebClient or WebServer."	^self streamFrom: srcStream to: stream size: size progress: aBlock! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 7/10/2010 13:51'!streamFrom: srcStream to: dstStream size: sizeOrNil progress: progressBlock	"Stream the content of srcStream to dstStream.	If a size is given, stream that many elements, otherwise stream up to the end."	| buffer totalRead remaining size |	(self headerAt: 'transfer-encoding') ifNotEmpty:[:encoding|		encoding = 'chunked' 			ifTrue:[^self chunkFrom: srcStream to: dstStream progress: progressBlock]			ifFalse:[self error: 'Unknown transfer-encoding: ', encoding]].	sizeOrNil = 0 ifTrue:[^self].	buffer := (srcStream isBinary ifTrue:[ByteArray] ifFalse:[String]) new: 4096.	totalRead := 0.	size := sizeOrNil ifNil:[0].	[(sizeOrNil == nil and:[stream atEnd not]) or:[totalRead < size]] whileTrue:[		progressBlock ifNotNil:[progressBlock value: sizeOrNil value: totalRead].		remaining := sizeOrNil ifNil:[99999] ifNotNil:[sizeOrNil - totalRead].		remaining > buffer size ifTrue:[remaining := buffer size].		buffer := srcStream next: remaining into: buffer startingAt: 1.		dstStream nextPutAll: (remaining < buffer size  			ifTrue:[(buffer copyFrom: 1 to: remaining)]			ifFalse:[buffer]).		totalRead := totalRead + buffer size.	].	dstStream flush.	progressBlock ifNotNil:[progressBlock value: sizeOrNil value: totalRead].! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 5/4/2010 15:46'!streamTo: dstStream size: size progress: aBlock	"Stream from the receiver's socket stream to the given destination stream.	Inbound. Can be used on both request/response depending on	whether it is utilized by WebClient or WebServer."	content ifNil:[		self streamFrom: stream to: dstStream size: size progress: aBlock	] ifNotNil:[		self streamFrom: content readStream to: dstStream size: size progress: aBlock	].! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'SvenVanCaekenberghe 6/14/2010 15:48'!writeHeadersOn: aStream	"Write the request"	self headersDo:[:key :value| aStream nextPutAll: key, ': ', value asString; crlf].! !!WebMessage methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 16:34'!writeOn: aStream	"Write the request"	self writeHeadersOn: aStream.	aStream crlf.! !!WebMessage class methodsFor: 'as yet unclassified' stamp: 'ar 2/21/2010 09:55'!initialize	"self initialize"	StatusCodes := Dictionary newFromPairs:{		"1xx: Meta status codes"		100. 	'Continue'.		101. 	'Switching Protocols'.		102.	'Processing'.		"2xx: Success status codes"		200.	'OK'.		201.	'Created'.		202.	'Accepted'.		203. 	'Non-Authoritative Information'.		204.	'No Content'.		205. 	'Reset Content'.		206.	'Partial Content'.		207.	'Multi-Status'. 				"WebDav RFC: 2518"		"3xx: Redirection status codes"		300.	'Multiple Choices'.		301.	'Moved Permanently'.		302.	'Moved Temporarily'.		303.	'See Other'.		304.	'Not Modified'.		305.	'Use Proxy'.		307.	'Temporary Redirect'.		"4xx: Client-Side Error status code"		400.	'Bad Request'.		401.	'Unauthorized'.		402.	'Payment Required'.		403.	'Forbidden'.		404.	'Not Found'.		405.	'Method Not Allowed'.		406.	'Not Acceptable'.		407.	'Proxy Authentication Required'.		408.	'Request Timeout'.		409.	'Conflict'.		410.	'Gone'.		411.	'Lenght Required'.		412.	'Precondition Failed'.		413.	'Request Entity Too Large'.		414.	'Request-URI Too Long'.		415.	'Unsupported Media Type'.		416.	'Requested Range Not Satisfiable'.		417.	'Expectation Failed'.		422.	'Unprocessable Entity'. 		"WebDav RFC: 2518"		423.	'Locked'. 					"WebDav RFC: 2518"		424.	'Failed Dependency'. 		"WebDav RFC: 2518"		"5xx: Server-Side Error status codes"		500.	'Internal Server Error'.		501.	'Not Implemented'.		502.	'Bad Gateway'.		503.	'Service Unavailable'.		504.	'Gateway Timeout'.		505.	'HTTP Version Not Supported'.		507.	'Insufficient Storage'. 		"WebDav RFC: 2518"	}.! !!WebMessage class methodsFor: 'as yet unclassified' stamp: 'klub 1/14/2014 22:09'!statusCodeAt: code	"Return the textual description of a status code"	^StatusCodes at: code ifAbsent: [ 'Unknown error' ]! !!TraitExclusion methodsFor: 'as yet unclassified' stamp: 'ar 12/29/2009 18:22'!- anArrayOfSelectors	^TraitExclusion		with: subject		exclusions: (anArrayOfSelectors, exclusions asArray)! !!TraitExclusion methodsFor: 'as yet unclassified' stamp: 'ar 12/29/2009 18:21'!@ anArrayOfAssociations 	TraitCompositionException signal: 'Invalid trait exclusion. Aliases have to be specified before exclusions.'! !!TraitExclusion methodsFor: 'as yet unclassified' stamp: 'ar 12/29/2009 18:22'!copyTraitExpression	"Copy all except the actual traits"	^TraitExclusion 		with: subject		exclusions: exclusions asArray! !!TraitExclusion methodsFor: 'as yet unclassified' stamp: 'ar 12/29/2009 18:11'!exclusions	^exclusions! !!TraitExclusion methodsFor: 'as yet unclassified' stamp: 'ar 12/29/2009 18:11'!exclusions: aCollection	exclusions := Set withAll: aCollection! !!TraitExclusion methodsFor: 'as yet unclassified' stamp: 'ar 12/29/2009 18:11'!includesSelector: selector	"Answers true if the receiver provides the selector"	^(subject includesSelector: selector) and:[(exclusions includes: selector) not]! !!TraitExclusion methodsFor: 'as yet unclassified' stamp: 'ar 12/29/2009 18:11'!initialize	super initialize.	exclusions := Set new.! !!TraitExclusion methodsFor: 'as yet unclassified' stamp: 'ar 12/29/2009 18:11'!printOn: aStream	"Answer the trait composition string (used for class definitions)"	aStream nextPutAll: subject asString.	aStream nextPutAll: ' - {'.	exclusions asArray sort do:[:exc| aStream store: exc] separatedBy:[aStream nextPutAll: '. '].	aStream nextPutAll: '}'.! !!TraitExclusion methodsFor: 'as yet unclassified' stamp: 'ar 12/29/2009 18:11'!selectorsAndMethodsDo: aBlock	"enumerates all selectors and methods in a trait composition"	^subject selectorsAndMethodsDo:[:sel :meth|		(exclusions includes: sel) ifFalse:[aBlock value: sel value: meth].	].! !!TraitExclusion class methodsFor: 'as yet unclassified' stamp: 'ar 12/29/2009 18:11'!with: aTraitComposition exclusions: anArrayOfSelectors	^self new		subject: aTraitComposition;		exclusions: anArrayOfSelectors;		yourself! !!MethodChangeRecord class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!AssertionFailure methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!AssertionFailure class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!NegativeManifest methodsFor: 'as yet unclassified'!generalDescription	"Answer a general description of myself, in textual form."	^'lack'! !!NegativeManifest methodsFor: 'as yet unclassified'!indices	"Answer the indices I record."	^self! !!NegativeManifest methodsFor: 'as yet unclassified'!indicesOfMissingProvisions	"Answer the indices of the missing provisions."	^self! !!NegativeManifest methodsFor: 'as yet unclassified'!missingItemsFrom: aCollection	"Answer the missing items I represent from aCollection."	^self indices asArray collect: [:index | aCollection at: index]! !!NegativeManifest methodsFor: 'as yet unclassified' stamp: 'crl 10/1/2016 13:44'!tag	"Answer my transmission tag."	^NegativeManifestTag! !!NegativeManifest class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!WrappedWebSocket methodsFor: 'as yet unclassified' stamp: 'crl 7/12/2017 23:07'!isConnected	^[self readyState = 1] on: Error do: [:exception | false]! !!WrappedWebSocket class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!LeafNode class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!FMClarinetSound class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!SystemNavigation methodsFor: 'as yet unclassified' stamp: 'crl 4/2/2019 16:53'!browseAllObjectReferencesTo: anObject except: objectsToExclude ifNone: aBlock 	"Bring up a list inspector on the objects that point to anObject.	If there are none, then evaluate aBlock on anObject.  "	| aList shortName |	aList := Utilities pointersTo: anObject except: objectsToExclude.	aList size > 0 ifFalse: [^aBlock value: anObject].	shortName := [(anObject name ifNil: [anObject printString]) contractTo: 20] on: Error do: [:exception | anObject class name article, ' ', anObject class name].	aList inspectWithLabel: 'Objects pointing to ' , shortName! !!PluggableMultiSelectionListSpec class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!ACamera methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!ACamera class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSSliderButtonMorph methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSSliderButtonMorph class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!SequentialSound class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!UpdatingMenuItemMorph class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!TraitTransformation class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!JSr methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSr class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!SHTextStyler class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!CharacterBlockScanner class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!JSListMorph methodsFor: 'as yet unclassified' stamp: 'crl 6/7/2017 11:24'!setElements: elements	self		at: #elements		put: elements;		buildListContents! !!JSListMorph class methodsFor: 'as yet unclassified' stamp: 'crl 5/30/2017 15:21'!action: action	^(self new)		action: action;		yourself! !!JSListMorph class methodsFor: 'as yet unclassified' stamp: 'crl 5/29/2017 23:15'!elements: elements	^self newWithParameters: {elements}! !!JSListMorph class methodsFor: 'as yet unclassified' stamp: 'crl 5/30/2017 15:25'!elements: elements action: action	^(self elements: elements)		action: action;		yourself! !!JSAnimation methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSAnimation class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!WindowColorRegistry methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!CannotDeleteFileException methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!CannotDeleteFileException class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!DAVResults methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!DAVResults class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!FTPConnectionException class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!ChromeConsoleAPI methodsFor: 'as yet unclassified' stamp: 'crl 8/22/2016 03:37'!initialize	super initialize.	log := OrderedCollection new! !!ChromeConsoleAPI methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 13:21'!messageAdded: parameters	<parseParameters: #parseConsoleMessageFrom:>		((parameters at: 'type') = 'log') ifTrue: [log add: parameters]! !!ChromeConsoleAPI methodsFor: 'as yet unclassified' stamp: 'crl 7/31/2016 00:16'!parseConsoleMessageFrom: dictionary	^ChromeConsoleMessage fromDictionary: (dictionary at: 'message')! !!ChromeConsoleAPI class methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 12:39'!domain	^'Console'! !!HTMLHeadingElement methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!HTMLHeadingElement class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!MimeConverter methodsFor: 'as yet unclassified' stamp: 'tk 12/9/97 13:55'!dataStream	^dataStream! !!MimeConverter methodsFor: 'as yet unclassified' stamp: 'tk 12/9/97 13:51'!dataStream: anObject	dataStream := anObject! !!MimeConverter methodsFor: 'as yet unclassified' stamp: 'bf 11/12/1998 13:30'!mimeDecode	"Do conversion reading from mimeStream writing to dataStream"	self subclassResponsibility! !!MimeConverter methodsFor: 'as yet unclassified' stamp: 'bf 11/12/1998 13:31'!mimeEncode	"Do conversion reading from dataStream writing to mimeStream"	self subclassResponsibility! !!MimeConverter methodsFor: 'as yet unclassified' stamp: 'tk 12/9/97 13:53'!mimeStream	^mimeStream! !!MimeConverter methodsFor: 'as yet unclassified' stamp: 'tk 12/9/97 13:51'!mimeStream: anObject	mimeStream := anObject! !!MimeConverter class methodsFor: 'as yet unclassified' stamp: 'bf 3/10/2000 14:47'!forEncoding: encodingString	"Answer a converter class for the given encoding or nil if unknown"	encodingString ifNil: [^nil].	^ encodingString asLowercase caseOf: 		{ ['base64'] -> [Base64MimeConverter].		  ['quoted-printable'] -> [QuotedPrintableMimeConverter]}		otherwise: [].! !!MimeConverter class methodsFor: 'as yet unclassified' stamp: 'bf 3/10/2000 14:43'!mimeDecode: aStringOrStream as: contentsClass	^ contentsClass streamContents: [:out |		self mimeDecode: aStringOrStream to: out]! !!MimeConverter class methodsFor: 'as yet unclassified' stamp: 'bf 3/10/2000 14:40'!mimeDecode: aStringOrStream to: outStream	self new		mimeStream: (aStringOrStream isStream			ifTrue: [aStringOrStream]			ifFalse: [ReadStream on: aStringOrStream]);		dataStream: outStream;		mimeDecode! !!MimeConverter class methodsFor: 'as yet unclassified' stamp: 'bf 3/10/2000 14:40'!mimeEncode: aCollectionOrStream	^ String streamContents: [:out |		self mimeEncode: aCollectionOrStream to: out]! !!MimeConverter class methodsFor: 'as yet unclassified' stamp: 'bf 3/10/2000 14:40'!mimeEncode: aCollectionOrStream to: outStream	self new		dataStream: (aCollectionOrStream isStream			ifTrue: [aCollectionOrStream]			ifFalse: [ReadStream on: aCollectionOrStream]);		mimeStream: outStream;		mimeEncode! !!Class methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 17:40'!classPoolKeys	^(classPool == nil)		ifTrue: [#()]		ifFalse: [classPool keys asArray]! !!Class methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 17:33'!remember	super remember.	self baseID class == UUID ifTrue: [	EditHistory		associateActiveProtoclass: self		withActiveMetaclass: self class]! !!Class methodsFor: 'as yet unclassified' stamp: 'crl 3/26/2019 20:12'!removeFromSystem	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."	self removeFromSystem: false.! !!Class methodsFor: 'as yet unclassified' stamp: 'crl 3/26/2019 20:14'!removeFromSystem: logged	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."		"keep the class name and category for triggering the system change message. If we wait to long, then we get obsolete information which is not what we want."	"tell class to deactivate and unload itself-- two separate events in the module system"	self deactivate"; unload".	self superclass ifNotNil:		["If we have no superclass there's nothing to be remembered"		self superclass addObsoleteSubclass: self].	self environment forgetClass: self logged: logged.	self obsolete.! !!RemoteMessageAnswer methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2016 19:37'!object: anObject id: aUUID	"Set my object and id."	object := anObject.	id := aUUID! !!RemoteMessageAnswer methodsFor: 'as yet unclassified' stamp: 'crl 5/20/2018 23:24'!storeOnTether: tether
	tether
		nextWordPut: AnswerTag;
		store: id;
		store: object! !!RemoteMessageAnswer class methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2016 19:36'!conveying: anObject under: id	"Answer an instance of me which conveys anObject to the remote exchange with id."	^(self new) object: anObject id: id! !!RemoteMessageAnswer class methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2016 19:38'!handleEventFrom: tether	| id |	id := tether next.	tether		deliver: tether next		under: id! !!AbstractSound class methodsFor: 'as yet unclassified' stamp: 'crl 9/13/2019 02:00'!testFMInteractively	"Experiment with different settings of the FM modulation and multiplier settings interactively by moving the mouse. The top-left corner of the screen is 0 for both parameters. Stop when the mouse is pressed."	"AbstractSound testFMInteractively"	| s mousePt lastVal status mod ratio |	SoundPlayer startPlayerProcessBufferSize: 8000 rate: 11025 stereo: false.	s := FMSound pitch: 440.0 dur: 200.0 loudness: 0.2.	SoundPlayer playSound: s.	lastVal := nil.	[Sensor anyButtonPressed] whileFalse: [		mousePt := Sensor cursorPoint.		mousePt ~= lastVal ifTrue: [			mod := mousePt x asFloat / 20.0.			ratio := mousePt y asFloat / 20.0.			s modulation: mod ratio: ratio.			lastVal := mousePt.			"status :='mod: ', mod printString, 'ratio: ', ratio printString.			status displayOn: Display at: 10@10"]].	SoundPlayer shutDown.! !!PragmaPreference class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!InternetConfiguration methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!InternetConfiguration class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 14:54'!shutDown! !!LiteralNode methodsFor: 'as yet unclassified' stamp: 'crl 5/29/2017 17:44'!printJavaScriptOn: stream indent: level	(key isVariableBinding)		ifTrue: [self noJavaScriptSupport]		ifFalse: [key storeJavaScriptOn: stream]! !!LiteralNode class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!ColorArray class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!Version methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!Version class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!DAVProcess methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!DAVProcess class methodsFor: 'as yet unclassified' stamp: 'crl 1/4/2015 01:55'!canRepresentAnInstanceOf: aClass	^aClass == Process! !!DAVProcess class methodsFor: 'as yet unclassified' stamp: 'crl 7/23/2017 22:07'!nameForProcess: aProcess 	"Answer the nickname for aProcess."	Smalltalk garbageCollectMost.	^(aProcess priority = ProcessorScheduler current timingPriority and: [aProcess suspendedContext receiver == Delay])		ifTrue: ['the timer interrupt watcher']		ifFalse: [			(				(IdentityDictionary new)					at: Smalltalk lowSpaceWatcherProcess					put: 'the low space watcher';					at: WeakArray runningFinalizationProcess					put: 'the finalization process';					at: ProcessorScheduler current backgroundProcess					put: 'the idle process';					yourself			)				at: aProcess				ifAbsent: [aProcess suspendedContext asString]]! !!GlobalLiteralMarker methodsFor: 'as yet unclassified'!key: aSymbol	"Set my key to aSymbol."	key _ aSymbol! !!GlobalLiteralMarker methodsFor: 'as yet unclassified'!literal	"Answer the method literal I represent."	^Smalltalk associationAt: key! !!GlobalLiteralMarker methodsFor: 'as yet unclassified'!marks: literal 	^ (Smalltalk		associationAt: key		ifAbsent: [^ false])		== literal! !!GlobalLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2016 15:16'!storeOnTether: tether	"Store a copy of myself on tether, suitable for re-animation in a remote system."	super storeOnTether: tether.	key storeOnTether: tether! !!GlobalLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2016 15:07'!tag	"Answer my transmission tag."	^GlobalLiteralMarkerTag! !!GlobalLiteralMarker class methodsFor: 'as yet unclassified' stamp: 'crl 3/20/2019 05:10'!canRepresent: literal inMethod: aCompiledMethod of: aClass	^(literal isKindOf: LookupKey) and: [(Smalltalk associationAt: literal key ifAbsent: [^false]) == literal and: [literal value isBehavior not]]! !!GlobalLiteralMarker class methodsFor: 'as yet unclassified' stamp: 'crl 3/20/2019 17:07'!forLiteral: literal inMethod: aCompiledMethod ofClass: aClass	"Answer an instance of myself to represent literal when transferring aCompiledMethod from aClass."	^((Smalltalk associationAt: literal key) == literal)		ifTrue: [self new key: literal key]		ifFalse: [nil]! !!GlobalLiteralMarker class methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 18:51'!fromTether: tether	"Answer an instance of myself composed from bytes supplied by aStream, and objects supplied by anObjectTransferCorrespondent."	^(self new) key: tether next! !!FixedFaceFont class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!KoreanEnvironment methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!SoundService methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!PluggableSystemWindow class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!DomainError methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!DomainError class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!Cursor methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2017 18:44'!show	"Make the hardware's mouse cursor look like the receiver"	JS ifConnected: [		Webpage current ifNotNilDo: [:webpage | webpage setHardwareCursorFor: self]].			Cursor currentCursor: self! !!BottomGripMorph class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!UnknownSelector class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!GB2312 methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!ChangeRecord methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 23:18'!fileIn: anEnvironment	"File the receiver in.  If I represent a method or a class-comment, file the method in and make a note of it in the recent-submissions list; if I represent a do-it, then, well, do it; if I represent a reorganization then get organized!!"	Cursor read showWhile:		[| s cls aSelector |		type == #doIt			ifTrue:				[((s := self string) beginsWith: '----') ifFalse: [Compiler evaluate: s]]			ifFalse:				[cls := self methodClass: anEnvironment.				 type == #method ifTrue:					[cls compile: self text classified: category withStamp: stamp notifying: nil.					(aSelector := self methodSelector) ifNotNil:						[RecentMessages default recordSelector: aSelector forClass: cls inEnvironment: anEnvironment]].				 type == #classComment ifTrue:					[cls comment: self text stamp: stamp.					RecentMessages default recordSelector: #Comment forClass: cls inEnvironment: anEnvironment].				 type == #reorganize ifTrue:					[cls organization changeFromString: self text]]]! !!ChangeRecord class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!HaloSpec class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!NaNError class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!ChromeProfilerAPI class methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 12:41'!domain	^'Profiler'! !!PluggableButtonSpec class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!Caffeine methodsFor: 'as yet unclassified' stamp: 'crl 9/17/2017 15:58'!document	^TopDocument! !!Caffeine methodsFor: 'as yet unclassified' stamp: 'crl 9/3/2019 23:03'!initialize	super initialize.		Top ifNotNil: [		self			status: 'starting window system...';			windowize;			"modifySummary;"			finishProgress.						ContainingDiv			styleAt: #pointerEvents put: 'all';			beVisible.					(window top document getElementById: 'sqSpinner') beOpaque]! !!Caffeine methodsFor: 'as yet unclassified' stamp: 'crl 6/12/2018 18:02'!modifySummary	(TopDocument getElementById: 'future-canvas') innerHTML: 'the canvas'! !!Caffeine methodsFor: 'as yet unclassified' stamp: 'crl 9/17/2017 15:58'!window	^Top! !!Caffeine methodsFor: 'as yet unclassified' stamp: 'crl 8/26/2019 06:05'!windowize	| moveButton |		self		progress: 85;		shortWindowizeElementAt: #banner;		progress: 90;		windowizeElementAt: #summary;		windowizeElementAt: #movie;		progress: 97.						(self elementAt: #logo) ifNotNilDo: [:logo | logo onClick: [:event | FrontendServerConnectionDialog open]].		moveButton := (		(			self				windowizeElementAt: #embeddedSqueak				closingWith: [Smalltalk quitPrimitive]		)			moveButton).						"Make the containing frame ignore pointer events while the move button is in use."		"Give newcomers a sane way to discover the 'pointerEvents' CSS attribute, its possible values, and their meanings. Merely using that attribute here is ponderous."		moveButton			onMouseDown: [:event | ContainingFrame styleAt: #pointerEvents put: 'none'];			onMouseUp: [:event | ContainingFrame styleAt: #pointerEvents put: ''].					ContainingDiv beResizable! !!Caffeine class methodsFor: 'as yet unclassified' stamp: 'crl 6/14/2017 22:26'!appID	^'4599d316-a13e-46ef-92be-c7337899038c'! !!ChromeDOMChildNodes methodsFor: 'as yet unclassified' stamp: 'crl 7/21/2017 17:39'!nodes	^nodes! !!ChromeDOMChildNodes methodsFor: 'as yet unclassified' stamp: 'crl 7/21/2017 17:39'!parentId	^parentId! !!False methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 19:46'!storeOnTether: tether
	tether nextWordPut: FalseTag! !!False methodsFor: 'as yet unclassified' stamp: 'crl 8/20/2017 13:45'!yourselfIfTrueDoFirst: aBlockClosure	^self! !!BorderedMorph class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!ThirtyTwoBitRegister methodsFor: 'as yet unclassified' stamp: 'ul 4/11/2015 02:24'!*= aThirtTwoBitRegister	"Replace my contents with the product of the given register and my current contents."	| otherLow otherHi mul newLow newHi |	otherLow := aThirtTwoBitRegister low.	otherHi := aThirtTwoBitRegister hi.	"Multiply low with otherLow. Process the two highest bits of low separately if necessary to avoid LargeInteger operations."	(low bitShift: -8) * (otherLow bitShift: -8) > 16r3FFF		ifTrue: [ 			mul := (low bitAnd: 16r3FFF) * otherLow. "Without the two most significant bits of low."			newLow := (mul bitAnd: 16rFFFF).			newHi := (mul bitShift: -16).			mul := (low bitShift: -14) * otherLow. "The two most significant bits of low"			newLow := newLow + ((mul bitAnd: 16r3) bitShift: 14).			newHi := newHi + (mul bitShift: -2) + (newLow bitShift: -16) "Carry from newLow" ]		ifFalse: [			newLow := low * otherLow. "We'll trim newLow at the end of the method."			newHi := newLow bitShift: -16 ].	"Multiply hi with otherLow."	(hi bitShift: -8) * (otherLow bitShift: -8) > 16r3FFF		ifTrue: [			newHi := newHi + 				((hi bitAnd: 16r3FFF) * otherLow bitAnd: 16rFFFF) +				(((hi bitShift: -14) * otherLow bitAnd: 16r3) bitShift: 14) ]		ifFalse: [ newHi := newHi + (hi * otherLow bitAnd: 16rFFFF) ].	"Multiply low with otherHi."	(low bitShift: -8) * (otherHi bitShift: -8) > 16r3FFF		ifTrue: [			newHi := newHi + 				((low bitAnd: 16r3FFF) * otherHi bitAnd: 16rFFFF) +				(((low bitShift: -14) * otherHi bitAnd: 16r3) bitShift: 14) ]		ifFalse: [ newHi := newHi + (low * otherHi bitAnd: 16rFFFF) ].	"Truncate and store the results."	hi := newHi bitAnd: 16rFFFF.	low := newLow bitAnd: 16rFFFF ! !!ThirtyTwoBitRegister methodsFor: 'as yet unclassified' stamp: 'jm 12/7/1999 15:36'!+= aThirtTwoBitRegister	"Replace my contents with the sum of the given register and my current contents."	| lowSum |	lowSum := low + aThirtTwoBitRegister low.	hi := (hi + aThirtTwoBitRegister hi + (lowSum bitShift: -16)) bitAnd: 16rFFFF.	low := lowSum bitAnd: 16rFFFF.! !!ThirtyTwoBitRegister methodsFor: 'as yet unclassified' stamp: 'ul 4/11/2015 04:50'!< aThirtyTwoBitRegister	^hi < aThirtyTwoBitRegister hi or: [		hi = aThirtyTwoBitRegister hi and: [			low < aThirtyTwoBitRegister low ] ]! !!ThirtyTwoBitRegister methodsFor: 'as yet unclassified' stamp: 'ul 4/11/2015 04:39'!<< anInteger	"Unsigned left shift."	| bitCount |	bitCount := anInteger.	bitCount >= 32 ifTrue: [		hi := low := 0.		^self ].	bitCount >= 16 ifTrue: [		hi := low.		low := 0.		bitCount := bitCount - 16 ].	bitCount >= 15 ifTrue: [		hi := ((hi bitAnd: 1) bitShift: 15) bitOr: (low bitShift: -1).		low := (low bitAnd: 1) bitShift: 15.		^self ].	bitCount >= 1 ifTrue: [		hi := ((hi bitShift: bitCount) bitAnd: 16rFFFF) bitOr: (low bitShift: bitCount - 16).		low := (low bitShift: bitCount) bitAnd: 16rFFFF ]! !!ThirtyTwoBitRegister methodsFor: 'as yet unclassified' stamp: 'ul 4/11/2015 04:51'!<= aThirtyTwoBitRegister	^hi < aThirtyTwoBitRegister hi or: [		hi = aThirtyTwoBitRegister hi and: [			low <= aThirtyTwoBitRegister low ] ]! !!ThirtyTwoBitRegister methodsFor: 'as yet unclassified' stamp: 'ul 4/6/2015 02:30'!= anObject	^self class == anObject class		and: [ anObject low = low		and: [ anObject hi = hi ] ]! !!ThirtyTwoBitRegister methodsFor: 'as yet unclassified' stamp: 'ul 4/11/2015 04:51'!> aThirtyTwoBitRegister	^hi > aThirtyTwoBitRegister hi or: [		hi = aThirtyTwoBitRegister hi and: [			low > aThirtyTwoBitRegister low ] ]! !!ThirtyTwoBitRegister methodsFor: 'as yet unclassified' stamp: 'ul 4/11/2015 04:51'!>= aThirtyTwoBitRegister	^hi > aThirtyTwoBitRegister hi or: [		hi = aThirtyTwoBitRegister hi and: [			low >= aThirtyTwoBitRegister low ] ]! !!ThirtyTwoBitRegister methodsFor: 'as yet unclassified' stamp: 'ul 4/10/2015 20:54'!>> anInteger	"Unsigned right shift."	| bitCount shift |	bitCount := anInteger.	bitCount >= 32 ifTrue: [		hi := low := 0.		^self ].	bitCount >= 16 ifTrue: [		low := hi.		hi := 0.		bitCount := bitCount - 16 ].	bitCount >= 2 ifTrue: [		shift := 0 - bitCount.		low := (low bitShift: shift) bitOr: ((hi bitShift: shift + 16) bitAnd: 16rFFFF).		hi := hi bitShift: shift.		^self ].	bitCount >= 1 ifTrue: [		low := (low bitShift: -1) bitOr: ((hi bitAnd: 16r1) bitShift: 15).		hi := hi bitShift: -1 ]! !!ThirtyTwoBitRegister methodsFor: 'as yet unclassified' stamp: 'jm 12/14/1999 16:03'!asInteger	"Answer the integer value of my current contents."	^ (hi bitShift: 16) + low! !!ThirtyTwoBitRegister methodsFor: 'as yet unclassified' stamp: 'ul 4/10/2015 20:52'!asSignedInteger	"Answer the signed integer value of my current contents."	hi >= 16r8000 ifFalse: [ ^(hi bitShift: 16) + low ].	^-1 - (low bitXor: 16rFFFF) - ((hi bitXor: 16rFFFF) bitShift: 16)! !!ThirtyTwoBitRegister methodsFor: 'as yet unclassified' stamp: 'jm 12/7/1999 15:41'!bitAnd: aThirtTwoBitRegister	"Replace my contents with the bitwise AND of the given register and my current contents."	hi := hi bitAnd: aThirtTwoBitRegister hi.	low := low bitAnd: aThirtTwoBitRegister low.! !!ThirtyTwoBitRegister methodsFor: 'as yet unclassified' stamp: 'jm 12/7/1999 15:40'!bitInvert	"Replace my contents with the bitwise inverse my current contents."	hi := hi bitXor: 16rFFFF.	low := low bitXor: 16rFFFF.! !!ThirtyTwoBitRegister methodsFor: 'as yet unclassified' stamp: 'jm 12/7/1999 15:40'!bitOr: aThirtTwoBitRegister	"Replace my contents with the bitwise OR of the given register and my current contents."	hi := hi bitOr: aThirtTwoBitRegister hi.	low := low bitOr: aThirtTwoBitRegister low.! !!ThirtyTwoBitRegister methodsFor: 'as yet unclassified' stamp: 'jm 12/7/1999 15:38'!bitXor: aThirtTwoBitRegister	"Replace my contents with the bitwise exclusive OR of the given register and my current contents."	hi := hi bitXor: aThirtTwoBitRegister hi.	low := low bitXor: aThirtTwoBitRegister low.! !!ThirtyTwoBitRegister methodsFor: 'as yet unclassified' stamp: 'jm 12/7/1999 15:26'!copy	"Use the clone primitive for speed."	<primitive: 148>	^ super copy! !!ThirtyTwoBitRegister methodsFor: 'as yet unclassified' stamp: 'ul 4/6/2015 03:06'!hash	^((hi bitShift: 14) bitXor: low) hashMultiply! !!ThirtyTwoBitRegister methodsFor: 'as yet unclassified' stamp: 'jm 12/7/1999 15:26'!hi	^ hi! !!ThirtyTwoBitRegister methodsFor: 'as yet unclassified' stamp: 'ul 3/6/2015 02:50'!leftRotateBy: bits	"Rotate my contents left by the given number of bits, retaining exactly 32 bits."	"Details: Perform this operation with no LargeInteger arithmetic."	| bitCount newHi |	bitCount := bits.	bitCount >= 32 ifTrue: [ bitCount := bitCount \\ 32 ].	bitCount >= 16 ifTrue: [		newHi := low.		low := hi.		hi := newHi.		bitCount := bitCount - 16 ].	bitCount >= 15 ifTrue: [		newHi := ((hi bitAnd: 16r1) bitShift: 15) bitOr: (low bitShift: -1).		low := ((low bitAnd: 16r1) bitShift: 15) bitOr: (hi bitShift: -1).		hi := newHi.		^self ].	bitCount >= 1 ifTrue: [		| shift |		shift := bitCount - 16.		newHi := ((hi bitShift: bitCount) bitAnd: 16rFFFF) bitOr: (low bitShift: shift).		low := ((low bitShift: bitCount) bitAnd: 16rFFFF) bitOr: (hi bitShift: shift).		hi := newHi ]! !!ThirtyTwoBitRegister methodsFor: 'as yet unclassified' stamp: 'nice 8/28/2010 22:34'!load: anInteger	"Set my contents to the value of given integer."	(anInteger positive and: [anInteger digitLength <= 4])		ifFalse: [self error: 'out of range: ', anInteger printString].	low := anInteger bitAnd: 16rFFFF.	hi := (anInteger bitShift: -16) bitAnd: 16rFFFF! !!ThirtyTwoBitRegister methodsFor: 'as yet unclassified' stamp: 'ul 4/11/2015 04:01'!loadFrom: aThirtyTwoBitRegister	"Set my contents from the given ThirtyTwoBitRegister."	hi := aThirtyTwoBitRegister hi.	low := aThirtyTwoBitRegister low! !!ThirtyTwoBitRegister methodsFor: 'as yet unclassified' stamp: 'jm 12/14/1999 16:07'!loadFrom: aByteArray at: index	"Load my 32-bit value from the four bytes of the given ByteArray starting at the given index. Consider the first byte to contain the most significant bits of the word (i.e., use big-endian byte ordering)."	hi := ((aByteArray at: index) bitShift: 8) + ( aByteArray at: index + 1).	low := ((aByteArray at: index + 2) bitShift: 8) + ( aByteArray at: index + 3).! !!ThirtyTwoBitRegister methodsFor: 'as yet unclassified' stamp: 'jm 12/7/1999 15:26'!low	^ low! !!ThirtyTwoBitRegister methodsFor: 'as yet unclassified' stamp: 'laza 3/29/2004 12:22'!printOn: aStream	"Print my contents in hex with a leading 'R' to show that it is a register object being printed."	aStream nextPutAll: 'R:'.	self asInteger storeOn: aStream base: 16.! !!ThirtyTwoBitRegister class methodsFor: 'as yet unclassified' stamp: 'nice 8/28/2010 22:42'!fromByteArray: aByteArray at: startIndex	"Answer a new instance whose initial contents is copied from next four bytes from aByteArray starting at startIndex..	Convention is Most Significant Byte first (aka big endian)."	^ self basicNew loadFrom: aByteArray at: startIndex! !!ThirtyTwoBitRegister class methodsFor: 'as yet unclassified' stamp: 'nice 8/28/2010 22:38'!fromInteger: aPositiveInteger	"Answer a new instance whose initial contents is copied from aPositiveInteger.	It is required that aPositiveInteger has no more than 32 bits."	^ self basicNew load: aPositiveInteger! !!ThirtyTwoBitRegister class methodsFor: 'as yet unclassified' stamp: 'jm 12/14/1999 16:05'!new	"Answer a new instance whose initial contents is zero."	^ super new load: 0! !!Process methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 20:57'!terminate 	"Stop the process that the receiver represents forever.  Unwind to execute pending ensure:/ifCurtailed: blocks before terminating."	| ctxt unwindBlock oldList |	self isActiveProcess ifTrue: [		ctxt := thisContext.		[	ctxt := ctxt findNextUnwindContextUpTo: nil.			ctxt isNil		] whileFalse: [			(ctxt tempAt: 2) ifNil:[				ctxt tempAt: 2 put: nil.				unwindBlock := ctxt tempAt: 1.				thisContext terminateTo: ctxt.				unwindBlock value].		].		thisContext terminateTo: nil.		self suspend.	] ifFalse:[		"Always suspend the process first so it doesn't accidentally get woken up"		oldList := self suspend.		suspendedContext ifNotNil:[			"Figure out if we are terminating the process while waiting in Semaphore>>critical:			In this case, pop the suspendedContext so that we leave the ensure: block inside			Semaphore>>critical: without signaling the semaphore."			(oldList class == Semaphore and:[				suspendedContext method == (Semaphore compiledMethodAt: #critical:)]) ifTrue:[					suspendedContext := suspendedContext home.			].			"If we are terminating a process halfways through an unwind, try			to complete that unwind block first."			(suspendedContext findNextUnwindContextUpTo: nil) ifNotNil:[:outer|				(suspendedContext findContextSuchThat:[:c| c closure == (outer tempAt: 1)]) ifNotNil:[:inner|					"This is an unwind block currently under evaluation"					suspendedContext runUntilErrorOrReturnFrom: inner.				].			].			ctxt := self popTo: suspendedContext bottomContext.			ctxt == suspendedContext bottomContext ifFalse: [				self debug: ctxt title: 'Unwind error during termination'].						suspendedContext := nil].	].! !!JSMouseEvent methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSMouseEvent class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!GPL3 methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!GPL3 class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!OrientedFillStyle class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!AlphaBlendingCanvas class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:55'!foo! !!HtmlReadWriter methodsFor: 'as yet unclassified' stamp: 'mt 5/3/2015 22:28'!ignoredTags	"Because we cannot process all of them."	^ #(body script table tr td ul ol li form select option input)! !!HtmlReadWriter methodsFor: 'as yet unclassified' stamp: 'mt 5/3/2015 21:32'!isTagIgnored: aTag	| space t |	space := aTag indexOf: Character space.	t := space > 0		ifTrue: [aTag copyFrom: 2 to: space - 1]		ifFalse: [aTag copyFrom: 2 to: aTag size - 1].	^ self ignoredTags includes: t! !!HtmlReadWriter methodsFor: 'as yet unclassified' stamp: 'mt 5/10/2015 13:53'!mapATag: aTag	| result startIndex stopIndex attribute |	result := OrderedCollection new.		"<a href=""http://google.de"">"	attribute := 'href'.	startIndex := aTag findString: attribute.	startIndex > 0 ifTrue: [		startIndex := aTag findString: '=' startingAt: startIndex+attribute size.		stopIndex := aTag findString: ' ' startingAt: startIndex+1.		stopIndex = 0 ifTrue: [			stopIndex := aTag findString: '>' startingAt: startIndex+1].				(aTag at: startIndex + 1) = $"			ifTrue: [startIndex := startIndex + 1].		(aTag at: stopIndex - 1) = $"			ifTrue: [stopIndex := stopIndex - 1].		result add: (TextURL new url: (aTag copyFrom: startIndex+1 to: stopIndex-1))].		^ result! !!HtmlReadWriter methodsFor: 'as yet unclassified' stamp: 'mt 5/3/2015 17:17'!mapFontTag: aTag	| result colorStartIndex colorStopIndex attribute |	result := OrderedCollection new.		"<font color=""#00FFCC"">"	attribute := 'color'.	colorStartIndex := aTag findString: attribute.	colorStartIndex > 0 ifTrue: [		colorStartIndex := aTag findString: '#' startingAt: colorStartIndex+attribute size.		colorStopIndex := aTag findString: '"' startingAt: colorStartIndex+1.		result add: (TextColor color:			(Color fromString: (aTag copyFrom: colorStartIndex to: colorStopIndex-1)))].		^ result! !!HtmlReadWriter methodsFor: 'as yet unclassified' stamp: 'mt 5/3/2015 22:05'!mapTagToAttribute: aTag	aTag = '<b>' ifTrue: [^ {TextEmphasis bold}].	aTag = '<i>' ifTrue: [^ {TextEmphasis italic}].	aTag = '<u>' ifTrue: [^ {TextEmphasis underlined}].	"aTag = '<code>' ifTrue: [^ {TextFontReference toFont: Preferences standardCodeFont}]."	(aTag beginsWith: '<font') ifTrue: [^ self mapFontTag: aTag].	(aTag beginsWith: '<a') ifTrue: [^ self mapATag: aTag].	"h1, h2, h3, ..."	(aTag second = $h and: [aTag third isDigit])		ifTrue: [^ {TextEmphasis bold}].	^ {}! !!HtmlReadWriter methodsFor: 'as yet unclassified' stamp: 'mt 5/3/2015 16:35'!nextPutText: aText	aText runs		withStartStopAndValueDo: [:start :stop :attributes | 			| att str | 			att := aText attributesAt: start.			str := aText string copyFrom: start to: stop.						att do: [:each | self writeStartTagFor: each].			self writeContent: str.			att reverse do: [:each | self writeEndTagFor: each]]! !!HtmlReadWriter methodsFor: 'as yet unclassified' stamp: 'mt 5/3/2015 22:00'!nextText	count := 0.	offset := 0. "To ignore characters in the input string that are used by tags."		runStack := Stack new.		runArray := RunArray new.	string := OrderedCollection new.		"{text attributes. start index. end index. number of open tags}"	runStack push: {OrderedCollection new. 1. nil. 0}.	[stream atEnd] whileFalse: [self processNextTag].	self processRunStackTop. "Add last run."	string := String withAll: string.	runArray coalesce.		^ Text		string: string		runs: runArray! !!HtmlReadWriter methodsFor: 'as yet unclassified' stamp: 'mt 5/3/2015 22:37'!processComment: aComment! !!HtmlReadWriter methodsFor: 'as yet unclassified' stamp: 'mt 5/3/2015 21:26'!processEmptyTag: aTag	(aTag beginsWith: '<br') ifTrue: [		string add: Character cr.		count := count + 1.		^ self].		(self ignoredTags includes: (aTag copyFrom: 2 to: aTag size - 3))		ifTrue: [^ self].			"TODO..."! !!HtmlReadWriter methodsFor: 'as yet unclassified' stamp: 'mt 5/3/2015 22:24'!processEndTag: aTag	| index |	index := count - offset.		(self ignoredTags includes: (aTag copyFrom: 3 to: aTag size -1))		ifTrue: [^ self].	"De-Accumulate adjacent tags."	runStack top at: 4 put: runStack top fourth - 1.	runStack top fourth > 0		ifTrue: [^ self "not yet"].			self processRunStackTop.	runStack pop.	runStack top at: 2 put: index + 1.! !!HtmlReadWriter methodsFor: 'as yet unclassified' stamp: 'mt 5/3/2015 20:35'!processHtmlEscape: aString	(String htmlEntities at: (aString copyFrom: 2 to: aString size - 1) ifAbsent: [])		ifNotNil: [:char | 			string add: char.			count := count + 1].! !!HtmlReadWriter methodsFor: 'as yet unclassified' stamp: 'mt 5/3/2015 22:25'!processNextTag	| tag htmlEscape lookForNewTag lookForHtmlEscape tagFound valid inComment |	lookForNewTag := true.	lookForHtmlEscape := false.	tagFound := false.	tag := OrderedCollection new.	htmlEscape := OrderedCollection new.	inComment := false.		[stream atEnd not and: [tagFound not]] whileTrue: [		| character |		character := stream next.		valid := (#(10 13) includes: character asciiValue) not.		count := count + 1.			character = $< ifTrue: [lookForNewTag := false].		character = $& ifTrue: [			inComment ifFalse: [lookForHtmlEscape := true]].				lookForNewTag			ifTrue: [				lookForHtmlEscape					ifFalse: [valid ifTrue: [string add: character] ifFalse: [offset := offset + 1]]					ifTrue: [valid ifTrue: [htmlEscape add: character]. offset := offset + 1]]			ifFalse: [valid ifTrue: [tag add: character]. offset := offset + 1].		inComment := ((lookForNewTag not and: [tag size >= 4])			and: [tag beginsWith: '<!!--'])			and: [(tag endsWith: '-->') not].		((character = $> and: [inComment not]) and: [lookForNewTag not]) ifTrue: [			lookForNewTag := true.			(tag beginsWith: '<!!--')				ifTrue: [self processComment: (String withAll: tag)]				ifFalse: [tag second ~= $/					ifTrue: [						(tag atLast: 2) == $/							ifTrue: [self processEmptyTag: (String withAll: tag)]							ifFalse: [self processStartTag: (String withAll: tag)]]					ifFalse: [self processEndTag: (String withAll: tag)]].						tagFound := true].		(((character = $; and: [lookForNewTag])			and: [htmlEscape notEmpty]) and: [htmlEscape first = $&]) ifTrue: [				lookForHtmlEscape := false.				self processHtmlEscape: (String withAll: htmlEscape).				htmlEscape := OrderedCollection new]].! !!HtmlReadWriter methodsFor: 'as yet unclassified' stamp: 'mt 5/3/2015 17:35'!processRunStackTop	"Write accumulated attributes to run array."		| index start end attrs |	index := count - offset.		"Set end index."	runStack top at: 3 put: index.	"Write to run array."	start := runStack top second.	end := runStack top third.	attrs := runStack top first.	runArray		addLast: attrs asArray		times: end - start + 1.! !!HtmlReadWriter methodsFor: 'as yet unclassified' stamp: 'mt 5/3/2015 22:24'!processStartTag: aTag	| index |	(self isTagIgnored: aTag) ifTrue: [^ self].	index := count - offset.	aTag = '<br>' ifTrue: [		string add: Character cr.		count := count + 1.		^ self].	(aTag beginsWith: '<img') ifTrue: [		string addAll: '[image]'.		count := count + 7.		^ self].		"Accumulate adjacent tags."	(runStack size > 1 and: [runStack top second = (index + 1) "= adjacent start tags"])		ifTrue: [			runStack top at: 1 put: (runStack top first copy addAll: (self mapTagToAttribute: aTag); yourself).			runStack top at: 4 put: (runStack top fourth + 1). "increase number of open tags"			^self].		self processRunStackTop.	"Remove start/end info to reuse attributes later."	runStack top at: 2 put: nil.	runStack top at: 3 put: nil.	"Copy attr list and add new attr."	runStack push: ({runStack top first copy addAll: (self mapTagToAttribute: aTag); yourself. index + 1. nil. 1}).! !!HtmlReadWriter methodsFor: 'as yet unclassified' stamp: 'mt 5/3/2015 20:47'!writeContent: aString	aString do: [:char |		(#(10 13) includes: char asciiValue)			ifTrue: [stream nextPutAll: '<br>'; cr]			ifFalse: [char = Character tab				ifTrue: [stream nextPutAll: '&nbsp;&nbsp;&nbsp;&nbsp;']				ifFalse: [(String htmlEntities keyAtValue: char ifAbsent: [])					ifNil: [stream nextPut: char]					ifNotNil: [:escapeSequence |						stream							nextPut: $&;							nextPutAll: escapeSequence;							nextPut: $;]]]].! !!HtmlReadWriter methodsFor: 'as yet unclassified' stamp: 'mt 5/3/2015 19:22'!writeEndTagFor: aTextAttribute	[aTextAttribute closeHtmlOn: stream]		on: MessageNotUnderstood do: []! !!HtmlReadWriter methodsFor: 'as yet unclassified' stamp: 'mt 5/3/2015 19:22'!writeStartTagFor: aTextAttribute	[aTextAttribute openHtmlOn: stream]		on: MessageNotUnderstood do: [].! !!UndefinedVariable class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'ul 5/5/2015 01:04'!aboutToStyle: aStyler	aStyler		classOrMetaClass: self object class;		parseAMethod: false.	^true	! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'topa 5/5/2015 00:13'!buildWith: builder	| windowSpec treeSpec textSpec buttonSpec buttonOffset tool |	windowSpec := builder pluggableWindowSpec new.	windowSpec		model: self;		children: OrderedCollection new;		label: #label;		extent: self initialExtent.		treeSpec := builder pluggableTreeSpec new.	treeSpec		model: self;		nodeClass: self class nodeClass;		roots: #getList;		keyPress: #explorerKey:from:event:;		getSelected: #currentSelection;		setSelected: #currentSelection:;		setSelectedParent: #currentParent:;		menu: #genericMenu:;		autoDeselect: false;		columns: (ObjectExplorerWrapper showContentsInColumns			ifTrue: [{				[:listMorph | (listMorph filteredItems collect: [:item |					item preferredWidthOfColumn: 1]) max].				nil "take all the space"}]);		frame: (0@0 corner: 1@0.71).	windowSpec children add: treeSpec.	buttonOffset := (Preferences standardButtonFont widthOfString: 'inspect') * 3/2.	textSpec := builder pluggableCodePaneSpec new.	textSpec		model: self;		getText: #expression;		editText: #expression:;		menu: #codePaneMenu:shifted:;		help: 'Evaluate expressions for the current tree selection...' translated;		frame: (LayoutFrame fractions: (0@0.71 corner: 1@1) offsets: (0@0 corner: buttonOffset negated@0)).	windowSpec children add: textSpec.	buttonSpec := builder pluggableButtonSpec new		model: self;		label: 'inspect';		action: #inspectObject;		help: 'Switch to an inspector tool';		frame: (LayoutFrame fractions: (1@0.71 corner: 1@1) offsets: (buttonOffset negated@0 corner: 0 @ 0)).	windowSpec children add: buttonSpec.		tool := builder build: windowSpec.	self changed: #expandRootsRequested.	^ tool! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'topa 3/18/2015 09:10'!codePaneMenu: aMenu shifted: shifted	"Note that unless we override perform:orSendTo:, PluggableTextController will respond to all menu items"	^ StringHolder codePaneMenu: aMenu shifted: shifted! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'mt 3/7/2015 09:32'!currentParent	^ currentParent! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'mt 3/7/2015 09:33'!currentParent: anObject	currentParent := anObject.! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'mt 3/7/2015 08:26'!currentSelection	^ currentSelection! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'mt 5/5/2015 15:22'!currentSelection: anObject	self currentSelection == anObject ifTrue: [^ self].	currentSelection := anObject.		self changed: #currentSelection.	self changed: #style.! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'RAA 9/23/1999 13:15'!doItContext	"Answer the context in which a text selection can be evaluated."	^nil! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'mt 3/7/2015 10:21'!doItReceiver	"Answer the object that should be informed of the result of evaluating a	text selection."	^ self object! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'mt 4/2/2015 11:00'!explore: anObject	self rootObject: anObject.! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'mt 3/30/2015 10:55'!explorerKey: aChar from: view event: event	event anyModifierKeyPressed ifFalse: [^ false].	currentSelection ifNotNil: [		self updateInspectorForSelection.		aChar == $i ifTrue: [self inspector inspectSelection. ^ true].		aChar == $I ifTrue: [self inspector exploreSelection. ^ true].		aChar == $b ifTrue:	[self inspector browseMethodFull. ^ true].		aChar == $h ifTrue:	[self inspector classHierarchy. ^ true].		aChar == $c ifTrue: [Clipboard clipboardText: self currentSelection key. ^ true].		aChar == $p ifTrue: [self inspector browseFullProtocol. ^ true].		aChar == $N ifTrue: [self inspector browseClassRefs. ^ true].		aChar == $t ifTrue: [self inspector tearOffTile. ^ true].		aChar == $v ifTrue: [self inspector viewerForValue. ^ true]].	^ false! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'mt 4/12/2015 16:46'!expression	^ expression! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'mt 4/12/2015 16:46'!expression: aString	expression := aString.! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'mt 3/30/2015 10:54'!genericMenu: aMenu 	"Borrow a menu from my inspector"	currentSelection		ifNil: [			aMenu				add: '*nothing selected*'				target: self				selector: #yourself]		ifNotNil: [			self updateInspectorForSelection.					aMenu defaultTarget: self inspector.			self inspector fieldListMenu: aMenu.			aMenu addLine;				add: 'monitor changes'				target: self				selector: #monitor:				argument: currentSelection].	monitorList isEmptyOrNil		ifFalse: [aMenu addLine;				add: 'stop monitoring all'				target: self				selector: #stopMonitoring].	^ aMenu! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'mt 3/7/2015 12:01'!getList	"This explorer shows bindings in a tree structure. Create the root binding here."		^ {self root}! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'mt 4/12/2015 16:09'!initialExtent	^350@250! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'mt 4/12/2015 21:28'!inspectObject	"Switch to an inspector tool."		| window model |	window := self rootObject inspect.	model := window model.		model setExpression: self expression.	window bounds: self containingWindow bounds.	self changed: #close.! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'mt 3/30/2015 10:54'!inspector		^ inspector ifNil: [inspector := Inspector new]! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'mt 3/7/2015 08:27'!label	^ self rootObject printStringLimitedTo: 32! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'mt 3/7/2015 11:22'!monitor: aBinding	"Start stepping and watching the given binding for changes."	aBinding ifNil: [ ^self ].	self world ifNil: [ ^self ].	self monitorList add: aBinding.		self world startStepping: self at: Time millisecondClockValue selector: #step arguments: #() stepTime: 2000.! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'mt 3/7/2015 10:48'!monitorList	^monitorList ifNil: [ monitorList := WeakOrderedCollection new ].! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'mt 3/7/2015 10:21'!object	^ self currentSelection value! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'mt 3/7/2015 10:21'!parentObject	^ self currentParent value! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'nk 7/31/2004 15:01'!release	self world ifNotNil: [ self world stopStepping: self selector: #step ].	super release.! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'cmm 2/13/2010 19:55'!representsSameBrowseeAs: anotherObjectExplorer	^ self rootObject == anotherObjectExplorer rootObject! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'mt 3/7/2015 12:00'!root	^ root ifNil: [root := 'root' -> nil]! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'mt 3/7/2015 12:01'!rootObject	^ self root value! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'mt 3/7/2015 12:01'!rootObject: anObject	self root value: anObject.	self changed: #label.	self changed: #getList.	self changed: #expandRootsRequested.	self currentSelection: self getList first.! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'RAA 9/23/1999 13:19'!selectedClass	"Answer the class of the receiver's current selection"	^self doItReceiver class! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'mt 3/7/2015 10:24'!selector	self flag: #deprecated. "mt: Who uses this? And why?"	self parentObject ifNil: [^ nil].	(self parentObject class allInstVarNames includes: self currentSelection key)		ifTrue: [^ self currentSelection key asSymbol].	^ nil! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'mt 4/12/2015 16:51'!setExpression: aString	self expression: aString.	self changed: #expression.! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'nk 7/12/2003 17:55'!shouldGetStepsFrom: aWorld	^self monitorList notEmpty! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'mt 3/7/2015 10:52'!step	"Let all views know that some of my objects need to be updated."	self monitorList do: [ :object |		object ifNotNil: [self changed: #objectChanged with: object]].	self monitorList ifEmpty: [ 		ActiveWorld stopStepping: self selector: #step ].! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'nk 7/31/2004 15:01'!stopMonitoring	monitorList := nil.	self world stopStepping: self selector: #step! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'mt 3/30/2015 11:00'!updateInspectorForSelection 	"Reuse the inspector for some callbacks."		self inspector inspect: (self parentObject ifNil: [self object]).	self parentObject		ifNil: [self inspector toggleIndex: 1. "self"]		ifNotNil: [			self inspector toggleIndex: (self inspector fieldList indexOf: self currentSelection key)].	self assert: self inspector selection == self object.! !!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'nk 7/31/2004 15:01'!world	^ActiveWorld! !!ObjectExplorer class methodsFor: 'as yet unclassified' stamp: 'RAA 6/21/1999 15:55'!about	StringHolder new textContents: self comment; openLabel: 'about ',self asString! !!ObjectExplorer class methodsFor: 'as yet unclassified' stamp: 'mt 4/2/2015 11:00'!explore: anObject	^ self new explore: anObject! !!ObjectExplorer class methodsFor: 'as yet unclassified' stamp: 'mt 3/6/2015 17:05'!nodeClass	^ ObjectExplorerWrapper! !!ObjectExplorer class methodsFor: 'as yet unclassified' stamp: 'mt 4/2/2015 11:42'!openOn: anObject	^ ToolBuilder open: (self explore: anObject)! !!ObjectExplorer class methodsFor: 'as yet unclassified' stamp: 'mt 4/2/2015 11:01'!openOn: anObject withLabel: label      "ObjectExplorer openOn: Smalltalk withLabel: 'Smalltalk'"	^ ToolBuilder open: (self explore: anObject) label: label! !!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'crl 7/13/2017 01:59'!copyTo: index	"Answer a copy of myself from the beginning to index."	^self copyFrom: 1 to: index! !!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'crl 6/5/2001 18:36'!emptyWritableStream	"Answer a writable stream on me which assumes that I have nothing to read initially."	^WritableStream emptyOn: self! !!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'crl 8/20/2017 00:50'!writableStream	"Answer a writable stream on me."	^WritableStream on: self! !!DuplicateVariableError class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!HTMLSmalltalkDevtool methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 17:08'!connect	super connect.	(self descendantAt: 'close-button') ifNotNilDo: [:image |		image onClick: [			self okayToClose ifTrue: [				app beTransparent.				[					(Delay forMilliseconds: 500) wait.					self remove				]					fork]]]! !!HTMLSmalltalkDevtool methodsFor: 'as yet unclassified' stamp: 'crl 8/15/2018 14:01'!element: anHTMLElement	super element: anHTMLElement.	self connect! !!HTMLSmalltalkDevtool methodsFor: 'as yet unclassified' stamp: 'crl 8/13/2018 11:46'!okayToClose	^true! !!HTMLSmalltalkDevtool methodsFor: 'as yet unclassified' stamp: 'crl 8/24/2018 16:58'!selectUsingMenuWithBlocks: blocks for: activeElement at: point	^HTMLPopupMenu		selectFromBlocks: blocks		for: activeElement		at: point! !!Association methodsFor: 'as yet unclassified' stamp: 'crl 5/18/2017 00:03'!asJSArgument	^key asJSArgument -> value asJSArgument! !!Association methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 19:46'!storeOnTether: tether
	tether
		nextWordPut: AssociationTag;
		store: key;
		store: value! !!Association class methodsFor: 'as yet unclassified'!fromTether: tether	^self		key: tether next		value: tether next! !!PluggableRadioButtonSpec class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!LayoutProperties class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!MenuLineMorph class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!HTMLSmalltalkClassesBrowser methodsFor: 'as yet unclassified' stamp: 'crl 9/10/2019 00:16'!connect	super connect.		classCategories := self descendantAt: 'class-categories'.	classes := self descendantAt: 'classes'.	methodCategories := self descendantAt: 'method-categories'.	methods := self descendantAt: 'methods'.	instanceSideButton := self descendantAt: 'instance-side-button'.	classSideButton := self descendantAt: 'class-side-button'.	classCommentButton := self descendantAt: 'class-comment-button'.		webpage document at: #oncontextmenu put: (JS Function new: 'return false').	classCategories		setOptions: SystemOrganization categories;		onChange: [			self clearText ifTrue: [				classes setOptions: (SystemOrganization listAtCategoryNamed: (classCategories selectedOptions first value)).				methodCategories removeChildren.				methods removeChildren]];		onContextMenu: [:event |			self				selectUsingMenuWithBlocks: (					(Dictionary new)						at: 'find class...'						put: [self findClass];						yourself)				for: self activeElement				at: event screenX @ event screenY].			classes		removeChildren;		onChange: [			self updateMethodCategories ifTrue: [.			showingClassComment				ifTrue: [self showClassComment]				ifFalse: [self showClassDefinition]]].			methodCategories		removeChildren;		onChange: [self showMethods].		methods		removeChildren;		onChange: [self showMethod].			"text onInput: [self beDirty]."			instanceSideButton onClick: [self showInstanceSide].	classSideButton onClick: [self showClassSide].	classCommentButton onClick: [self showClassComment].		self		beClean;		showInstanceSide;		showClassComment! !!HTMLSmalltalkClassesBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/25/2017 19:05'!findClass	3 halt! !!HTMLSmalltalkClassesBrowser methodsFor: 'as yet unclassified' stamp: 'crl 4/1/2019 01:20'!saveText	(methods selectedOptions length = 1) ifTrue: [		"Compile a method."				| class |				class := Smalltalk at: classes selection text asSymbol.				instanceSideSelected ifFalse: [class := class class].		class			compile: (				(					((HtmlReadWriter on: text innerHTML readStream) nextText asString allButFirst)						copyReplaceAll: #[160] asString						with: (String with: Character space)				)					copyReplaceAll: '    '					with: (String with: Character tab))			classified: methodCategories selection text asString.				self showMethods]! !!HTMLSmalltalkClassesBrowser methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2017 08:12'!selectedClass	^(self selectedElementIn: classes)		ifNil: [nil]		ifNotNilDo: [:className |			| protoclass |						protoclass := Smalltalk at: className asSymbol.			instanceSideSelected				ifTrue: [protoclass]				ifFalse: [protoclass class]]! !!HTMLSmalltalkClassesBrowser methodsFor: 'as yet unclassified' stamp: 'crl 9/18/2017 15:11'!selectedMethodCategory	^self selectedElementIn: methodCategories! !!HTMLSmalltalkClassesBrowser methodsFor: 'as yet unclassified' stamp: 'crl 9/18/2017 17:47'!selectedMethodSelector	^(self selectedElementIn: methods) asSymbol! !!HTMLSmalltalkClassesBrowser methodsFor: 'as yet unclassified' stamp: 'crl 3/30/2019 13:49'!showClassComment	showingClassComment := true.	(classes selectedIndex >= 0) ifTrue: [		classCommentButton styleAt: #background put: 'lightBlue'.		{instanceSideButton. classSideButton} do: [:button | button styleAt: #background put: 'lightGray'].		self showText: self selectedClass comment]! !!HTMLSmalltalkClassesBrowser methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 18:09'!showClassDefinition	^self clearText yourselfIfTrueDoFirst: [		self selectedClass ifNotNil: [:class |			showingClassComment := false.			styler parseAMethod: false.			self showHTML: "(styler styledTextFor: "class definition" asText) printHtmlString"]]! !!HTMLSmalltalkClassesBrowser methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2017 17:07'!showClassSide	classSideButton styleAt: #background put: 'lightBlue'.	{instanceSideButton. classCommentButton} do: [:button | button styleAt: #background put: 'lightGray'].	instanceSideSelected := false.	self		updateMethodCategories;		showClassDefinition! !!HTMLSmalltalkClassesBrowser methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2017 11:58'!showInstanceSide	^self clearText yourselfIfTrueDoFirst: [		instanceSideButton styleAt: #background put: 'lightBlue'.		{classSideButton. classCommentButton} do: [:button | button styleAt: #background put: 'lightGray'].		instanceSideSelected := true.		self			updateMethodCategories;			showClassDefinition]! !!HTMLSmalltalkClassesBrowser methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 17:48'!showMethod	styler		parseAMethod: true;		classOrMetaClass: self selectedClass.			self clearText ifTrue: [self showHTML: ("styler styledTextFor: ("self selectedClass sourceCodeAt: self selectedMethodSelector)") printHtmlString" asString]! !!HTMLSmalltalkClassesBrowser methodsFor: 'as yet unclassified' stamp: 'crl 3/30/2019 19:19'!showMethods	self clearText ifTrue: [methods setOptions: (self selectedClass organization listAtCategoryNamed: self selectedMethodCategory)]! !!HTMLSmalltalkClassesBrowser methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2017 11:33'!updateMethodCategories	^self clearText yourselfIfTrueDoFirst: [		self selectedClass ifNotNilDo: [:class | methodCategories setOptions: class organization categories.		methods removeChildren]]! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'kph 11/6/2008 16:43'!<< items 	items putOn: self.		^ self! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/9/2005 22:44'!adjustInBuffer: bytesRead	"Adjust markers and possibly grow inBuffer or move data down.	Currently grows through doubling when less than 1024 bytes are left.	Never shrinks. Returns the position in the buffer where any new	data can be found."	| old |	bytesRead = 0 ifTrue: [^inNextToWrite].	old := inNextToWrite.	inNextToWrite := inNextToWrite + bytesRead.	(inBuffer size - inNextToWrite) < 1024		ifTrue: [			"Hit the roof, move data down (if enough has been read) or do we grow?"			(lastRead > 512)				ifTrue: [^old - self moveInBufferDown]				ifFalse: [self growInBuffer]].	^old! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/9/2005 22:42'!adjustOutBuffer: bytesToWrite	"Possibly grow outBuffer to accommodate the new data.	Currently grows through doubling when less	than 1024 bytes are left. If bytesToWrite is even	larger we double that instead. Never shrinks."	(outBuffer size - outNextToWrite - bytesToWrite) < 1024 ifTrue: [		outBuffer := (self streamBuffer: ((outBuffer size max: bytesToWrite) * 2))						replaceFrom: 1 to: outBuffer size with: outBuffer startingAt: 1]! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'nice 3/16/2010 22:34'!ascii	"Tell the SocketStream to send data	as Strings instead of ByteArrays.	This is default."	binary := false.	inBuffer		ifNil: [self resetBuffers]		ifNotNil:			[inBuffer := inBuffer asString.			outBuffer := outBuffer asString]! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/25/2005 14:23'!atEnd	"There is nothing more to read when	there is no more data in our inBuffer, the socket	is disconnected and there is none available on the socket.	Note that we need to check isConnected before isDataAvailable,	otherwise data may sneak in in the meantime. But we check the	buffer first, because it is faster."	self isInBufferEmpty ifFalse: [^false].	^self isConnected not		and: [self isDataAvailable not]! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/9/2005 22:26'!autoFlush	"If autoFlush is enabled data will be sent through	the socket (flushed) when the bufferSize is reached	or the SocketStream is closed. Otherwise the user	will have to send #flush manually.	Close will always flush. Default is false."	^autoFlush! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/9/2005 22:27'!autoFlush: aBoolean	"If autoFlush is enabled data will be sent through	the socket (flushed) when the bufferSize is reached	or the SocketStream is closed. Otherwise the user	will have to send #flush manually.	Close will always flush. Default is false."	autoFlush := aBoolean! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'ar 11/22/2010 23:48'!beSignalingWhile: aBlock	"Temporarily turn a non-signaling SocketStream into a signaling one.	Required for some of operations that will catch ConnectionClosed in 	order to find out that an operation completed"	| signaling |	signaling := shouldSignal.	shouldSignal := true.	^aBlock ensure:[shouldSignal := signaling]! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'nice 3/16/2010 22:35'!binary	"Tell the SocketStream to send data	as ByteArrays instead of Strings.	Default is ascii."	binary := true.	inBuffer		ifNil: [self resetBuffers]		ifNotNil:			[inBuffer := inBuffer asByteArray.			outBuffer := outBuffer asByteArray]! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/9/2005 22:28'!bufferSize	"Default buffer size is 4kb.	increased from earlier 2000 bytes."		^bufferSize! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/9/2005 22:28'!bufferSize: anInt	"Default buffer size is 4kb.	increased from earlier 2000 bytes."	bufferSize := anInt! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/7/2005 13:09'!checkFlush	"If autoFlush is true we flush if	we have reached the bufferSize	of data in the outBuffer."	(autoFlush and: [outNextToWrite > bufferSize])		ifTrue: [self flush]! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'cmm 9/22/2014 16:13'!close	"Flush any data still not sent	and take care of the socket."	self flush.	socket closeAndDestroy: 30.	"Reclaim memory consumed by possibly very large buffers."	self resetBuffers! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'bolot 12/27/1999 12:17'!cr	self nextPutAll: String cr! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'bolot 8/11/1999 22:13'!crlf	self nextPutAll: String crlf! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/25/2005 14:19'!debug	"Display debug info."	| data |	data := self inBufferSize.	^String streamContents: [:s |		s			nextPutAll: 'Buffer size: ', inBuffer size asString;cr;			nextPutAll: 'InBuffer data size: ', data asString; cr;			nextPutAll: 'In data (20):', (inBuffer copyFrom: lastRead + 1 to: lastRead + (data min: 20)); cr;			nextPutAll: 'OutBuffer data size: ', (outNextToWrite - 1) asString; cr;			nextPutAll: 'Out data (20):', (outBuffer copyFrom: 1 to: ((outNextToWrite - 1) min: 20)); cr]! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'ar 7/24/2010 15:13'!destroy	"Destroy the receiver and its underlying socket. Does not attempt to flush the output buffers. For a graceful close use SocketStream>>close instead."	socket ifNotNil:[socket destroy]! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'cmm 1/28/2011 15:15'!flush	"If the other end is connected and we have something	to send, then we send it and reset the outBuffer."	(outNextToWrite > 1 and: [ socket isOtherEndClosed not ]) ifTrue:		[ [ self			sendData: outBuffer			count: outNextToWrite - 1 ]			on: ConnectionTimedOut			do: [ : ex | shouldSignal ifTrue: [ ex pass ] ].		outNextToWrite := 1 ]! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/7/2005 23:05'!growInBuffer	"Grows through doubling."	self resizeInBuffer: inBuffer size * 2! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/10/2005 17:58'!inBufferSize	"Answers the current size of data in the inBuffer."	^inNextToWrite - lastRead - 1! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/25/2005 14:20'!initialize	autoFlush := true.	shouldSignal := true.	recentlyRead := 0.	bufferSize := 4096.	self ascii! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'mir 12/22/2003 15:38'!isBinary	^binary! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/7/2005 12:24'!isConnected	"The stream is connected if the socket is."	^socket isConnected! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'ar 11/23/2010 00:04'!isDataAvailable	"Answer if more data can be read. It the inbuffer is empty, we read more data.	Note: It is important not to rely on 'socket dataAvailable' here since this will	not work for subclasses such as SecureSocketStream (which can contain	undecrypted contents that has been read from the socket)." 	self isInBufferEmpty ifFalse: [^true].	^self receiveAvailableData < inNextToWrite! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/7/2005 13:02'!isEmpty	"Test if there are more data to read."	^self isInBufferEmpty and: [self isDataAvailable not]! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/7/2005 13:02'!isInBufferEmpty	"Any data in the buffer?" 	^lastRead + 1 = inNextToWrite! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/7/2005 08:59'!isOtherEndConnected	^socket isOtherEndClosed not! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/8/2005 22:15'!moveInBufferDown	"Move down contents of inBuffer to the start.	Return distance moved."	| sz distanceMoved |	sz := inNextToWrite - lastRead - 1.	inBuffer replaceFrom: 1 to: sz with: inBuffer startingAt: lastRead + 1.	distanceMoved := lastRead.	lastRead := 0.	inNextToWrite := sz + 1.	^distanceMoved! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/7/2005 13:33'!next	"Return next byte, if inBuffer is empty	we recieve some more data and try again."	self atEnd ifTrue: [^nil].	self isInBufferEmpty ifTrue:		[self receiveData.		self atEnd ifTrue: [^nil]].	lastRead := lastRead + 1.	^inBuffer at: lastRead! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/15/2005 14:17'!next: anInteger	"Answer anInteger bytes of data.	NOTE: This method doesn't honor timeouts if shouldSignal is false!!"	| start |	self receiveData: anInteger.	start := lastRead + 1.	lastRead := (lastRead + anInteger) min: inNextToWrite - 1.	^inBuffer copyFrom: start to: lastRead! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 13:06'!next: n into: aCollection	"Read n objects into the given collection.	Return aCollection or a partial copy if less than	n elements have been read."	^self next: n into: aCollection startingAt: 1! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'ar 11/22/2010 23:50'!next: anInteger into: aCollection startingAt: startIndex	"Read n objects into the given collection. 	Return aCollection or a partial copy if less than	n elements have been read."	"Implementation note: This method DOES signal timeout if not 	enough elements are received. It does NOT signal	ConnectionClosed as closing the connection is the only way by	which partial data can be read."	| start amount |	[self beSignalingWhile:[self receiveData: anInteger]] 		on: ConnectionClosed do:[:ex| ex return].	"Inlined version of nextInBuffer: to avoid copying the contents"	amount := anInteger min: (inNextToWrite - lastRead - 1).	start := lastRead + 1.	lastRead := lastRead + amount.	aCollection 		replaceFrom: startIndex 		to: startIndex + amount-1 		with: inBuffer 		startingAt: start.	^amount < anInteger 		ifTrue:[aCollection copyFrom: 1 to:  startIndex + amount-1]		ifFalse:[aCollection]! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'nice 3/17/2010 20:27'!next: n putAll: aCollection startingAt: startIndex	"Put a String or a ByteArray onto the stream.	Currently a large collection will allocate a large buffer.	Warning: this does not work with WideString: they have to be converted first."	self adjustOutBuffer: n.	outBuffer replaceFrom: outNextToWrite to: outNextToWrite + n - 1 with: aCollection startingAt: startIndex.	outNextToWrite := outNextToWrite + n.	self checkFlush.	^aCollection! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/7/2005 21:26'!nextAllInBuffer	"Return all data currently in the inBuffer,"	^self nextInBuffer: inNextToWrite - lastRead - 1! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/7/2005 13:47'!nextAvailable	"Answer all the data currently available,	in buffer or in socket."	self isInBufferEmpty ifFalse: [^self nextAllInBuffer].	self isDataAvailable ifTrue: [self receiveData].	^self nextAllInBuffer! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/7/2005 13:02'!nextAvailable: howMany	"Answer all the data currently available,	in buffer or in socket - but limited to <howMany>."	self isInBufferEmpty ifFalse: [^self nextInBuffer: howMany].	self isDataAvailable ifTrue: [self receiveData].	^self nextInBuffer: howMany! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/7/2005 12:51'!nextInBuffer: anInteger	"Answer anInteger bytes of data at most,	but only from the inBuffer."	| start amount |	amount := anInteger min: (inNextToWrite - lastRead - 1).	start := lastRead + 1.	lastRead := lastRead + amount.	^inBuffer copyFrom: start to: lastRead! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 13:06'!nextInto: aCollection	"Read the next elements of the receiver into aCollection.	Return aCollection or a partial copy if less than aCollection	size elements have been read."	^self next: aCollection size into: aCollection startingAt: 1.! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 13:06'!nextInto: aCollection startingAt: startIndex	"Read the next elements of the receiver into aCollection.	Return aCollection or a partial copy if less than aCollection	size elements have been read."	^self next: (aCollection size - startIndex+1) into: aCollection startingAt: startIndex.! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'mir 2/21/2002 18:46'!nextLine	^self nextLineCrLf! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/24/2005 12:01'!nextLineCrLf	^self upToAll: String crlf! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'mir 5/12/2003 16:28'!nextLineLf	| nextLine |	nextLine := self upToAll: String lf.	^nextLine! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'md 2/24/2006 19:51'!nextPut: char	"Put a single Character or byte onto the stream."	| toPut |	toPut := binary ifTrue: [char asInteger] ifFalse: [char asCharacter].	self adjustOutBuffer: 1.	outBuffer at: outNextToWrite put: toPut.	outNextToWrite := outNextToWrite + 1.	self checkFlush.	"return the argument - added by kwl"	^ char! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'nice 3/19/2010 19:14'!nextPutAll: aCollection	"Put a String or a ByteArray onto the stream.	Currently a large collection will allocate a large buffer."	| toPut |	toPut := binary ifTrue: [aCollection asByteArray] ifFalse: [aCollection asString].	self adjustOutBuffer: toPut size.	outBuffer replaceFrom: outNextToWrite to: outNextToWrite + toPut size - 1 with: toPut startingAt: 1.	outNextToWrite := outNextToWrite + toPut size.	self checkFlush.	^aCollection! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'cmm 1/28/2011 15:15'!nextPutAllFlush: aCollection 	"Put a String or a ByteArray onto the stream.	You can use this if you have very large data - it avoids	copying into the buffer (and avoids buffer growing)	and also flushes any other pending data first."	| toPut |	toPut := binary		ifTrue: [ aCollection asByteArray ]		ifFalse: [ aCollection asString ].	self flush.	"first flush pending stuff, then directly send"	socket isOtherEndClosed ifFalse:		[ [ self			sendData: toPut			count: toPut size ]			on: ConnectionTimedOut			do: [ : ex | shouldSignal ifTrue: [ ex pass ] ] ]! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/10/2005 17:59'!noTimeout	"Do not use timeout."	timeout := 0! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/10/2005 17:59'!outBufferSize	"Answers the current size of data in the outBuffer."	^outNextToWrite - 1! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'ar 1/13/2010 22:30'!peek	"Return next byte, if inBuffer is empty	we recieve some more data and try again.	Do not consume the byte."	self atEnd ifTrue: [^nil].	self isInBufferEmpty ifTrue:		[self receiveData.		self atEnd ifTrue: [^nil]].	^inBuffer at: lastRead+1! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/15/2005 14:16'!peek: anInteger	"Answer anInteger bytes of data.	Do not consume data.	NOTE: This method doesn't honor timeouts if shouldSignal is false!!"	| start |	self receiveData: anInteger.	start := lastRead + 1.	^inBuffer copyFrom: start to: ((lastRead + anInteger) min: inNextToWrite - 1).! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'nice 1/13/2010 23:16'!peekFor: aCharacterOrByte	"Read and return next character or byte	if it is equal to the argument.	Otherwise return false."	| nextObject |	self atEnd ifTrue: [^false].	self isInBufferEmpty ifTrue: 		[self receiveData.		self atEnd ifTrue: [^false]].	nextObject := inBuffer at: lastRead + 1.	nextObject = aCharacterOrByte ifTrue: [		lastRead := lastRead + 1.		^true].	^false! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/15/2005 14:16'!peekForAll: aString	"Answer whether or not the next string of characters in the receiver	matches aString. If a match is made, advance over that string in the receiver and	answer true. If no match, then leave the receiver alone and answer false.	We use findString:startingAt: to avoid copying.	NOTE: This method doesn't honor timeouts if shouldSignal is false!!"	| sz start |	sz := aString size.	self receiveData: sz.	(inNextToWrite - lastRead - 1) < sz ifTrue: [^false].	start := lastRead + 1.	(inBuffer findString: aString startingAt: start) = start		ifFalse: [^false].	lastRead := lastRead + sz.	^true! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'md 7/14/2006 12:28'!print: anObject	anObject printOn: self! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/10/2005 11:44'!printOn: aStream	"Display buffer sizes."	aStream nextPutAll: self class name.	inBuffer ifNotNil: [		aStream nextPutAll: '[inbuf:',		(inBuffer size / 1024) rounded asString, 'kb/outbuf:',		(outBuffer size / 1024) rounded asString, 'kb]']! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'ar 11/22/2010 23:52'!readInto: aCollection startingAt: startIndex count: anInteger	"Read n objects into the given collection starting at startIndex. 	Return number of elements that have been read."	"Implementation note: This method DOES signal timeout if not 	enough elements are received. It does NOT signal	ConnectionClosed as closing the connection is the only way by	which partial data can be read."	| start amount |	[self beSignalingWhile:[self receiveData: anInteger]]		on: ConnectionClosed do:[:ex| ex return].	"Inlined version of nextInBuffer: to avoid copying the contents"	amount := anInteger min: (inNextToWrite - lastRead - 1).	start := lastRead + 1.	lastRead := lastRead + amount.	aCollection 		replaceFrom: startIndex 		to: startIndex + amount-1 		with: inBuffer 		startingAt: start.	^amount! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'ar 7/24/2010 15:07'!receiveAvailableData	"Receive available data (as much as fits in the inBuffer) but not waiting for more to arrive. Return the position in the buffer where the new data starts, regardless if anything was read, see #adjustInBuffer."		recentlyRead := self receiveDataInto: inBuffer startingAt: inNextToWrite.	^self adjustInBuffer: recentlyRead! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'mtf 1/15/2011 20:15'!receiveData	self waitForData.	^self receiveAvailableData! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 4/14/2005 09:49'!receiveData: nBytes	"Keep reading the socket until we have nBytes	in the inBuffer or we reach the end. This method	does not return data, but can be used to make sure	data has been read into the buffer from the Socket	before actually reading it from the FastSocketStream.	Mainly used internally. We could also adjust the buffer	to the expected amount of data and avoiding several	incremental grow operations.	NOTE: This method doesn't honor timeouts if shouldSignal	is false!! And frankly, I am not sure how to handle that	case or if I care - I think we should always signal."	[self atEnd not and: [nBytes > self inBufferSize]]		whileTrue: [self receiveData]! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'ar 7/24/2010 14:50'!receiveDataIfAvailable	"Deprecated. Use #receiveAvailableData instead"	^self receiveAvailableData! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'ar 7/24/2010 15:07'!receiveDataInto: buffer startingAt: index.	"Read data from the underlying socket. This method may be overridden by subclasses wanting to control incoming traffic for other purposes like encryption or statistics."	^socket  receiveAvailableDataInto: buffer startingAt: index.! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/9/2005 23:08'!recentlyRead	"Return the number of bytes read	during the last socket operation."		^recentlyRead! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/9/2005 22:36'!resetBuffers	"Recreate the buffers with default start sizes."	inBuffer := self streamBuffer: bufferSize.	lastRead := 0.	inNextToWrite := 1.	outBuffer := self streamBuffer: bufferSize.	outNextToWrite := 1! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 9/9/2005 02:29'!resizeInBuffer: newSize	"Resize the inBuffer by recreating it.	This also has the effect of getting rid of	dead data above inNextToWrite.	<newSize> must >= inBuffer size!!"	inBuffer := (self streamBuffer: newSize)					replaceFrom: 1 to: inNextToWrite - 1 with: inBuffer startingAt: 1! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 9/9/2005 09:32'!sendCommand: aString	"Sends a String ending it with CR LF and then flush	causing it to block until sent."	self nextPutAll: aString, String crlf; flush! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'ar 7/24/2010 14:50'!sendData: buffer count: n	"Sends outgoing data directly on the underlying socket."	^socket sendData: buffer count: n! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/10/2005 18:00'!shouldSignal	"If shouldSignal is enabled the Socket Exceptions	ConnectionClosed and ConnectionTimedOut	will not be swallowed. Default is true.	For more info, see #shouldSignal:"	^shouldSignal! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/10/2005 18:03'!shouldSignal: aBoolean	"If shouldSignal is enabled the Socket Exceptions	ConnectionClosed and ConnectionTimedOut will not be swallowed.	Default is true. And please - don't set it to false - it is better to	use an exception handler (see below)  and several methods	in this class will not honour timeouts (says so in their method comments).	Also, it is quite hard to understand what for example #upToEnd	should return to indicate a timeout.		Wrap your use of SocketStream with a handler like:		[stuff := mySocketStream next: 10]		on: ConnectionClosed, ConnectionTimedOut		do: [:ex |			Transcript show: 'Oops!! Did not get my ten bytes!!;cr]	"	shouldSignal := aBoolean! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'dvf 6/11/2003 18:21'!shouldTimeout	^self timeout > 0! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'mtf 1/15/2011 20:09'!signalClosed	self shouldSignal ifFalse: [^ self]. 	ConnectionClosed signal: 'Connection closed while waiting for data.'! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'mtf 1/15/2011 20:10'!signalTimeout	self shouldSignal ifFalse: [^ self]. 	ConnectionTimedOut signal: 'Data receive timed out.'! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/15/2005 14:15'!skip: anInteger	"Skip a number of bytes.	This is faster than #next: since it does not	have to copy and return a new String or ByteArray.	NOTE: This method doesn't honor timeouts if shouldSignal is false!!"	self receiveData: anInteger.	lastRead := (lastRead + anInteger) min: inNextToWrite - 1! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'mir 10/31/2000 12:50'!socket	^socket! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'mir 10/30/2000 18:59'!socket: aSocket	socket := aSocket! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'mir 5/8/2003 18:23'!space	self nextPut: Character space! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/9/2005 22:35'!streamBuffer: size	"Create a buffer of the correct class and given size."	^(self isBinary		ifTrue: [ByteArray]		ifFalse: [String]) new: size! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/7/2005 08:41'!timeout	"Lazily initialized unless it has been set explicitly."	timeout ifNil: [timeout := Socket standardTimeout].	^timeout! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'gk 2/3/2005 20:35'!timeout: seconds	timeout := seconds! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'ul 12/5/2011 01:46'!upTo: aCharacterOrByte	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of anObject in the receiver. If anObject is not in the collection, answer the entire rest of the receiver."	^self upTo: aCharacterOrByte limit: nil! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'ar 8/22/2010 13:27'!upTo: aCharacterOrByte limit: nBytes	"Return data up to, but not including given character or byte. If the character is not in the stream, or not found within nBytes answer the available contents of the stream"	| target index result searchedSoFar |	"Deal with ascii vs. binary"	self isBinary 		ifTrue:[target := aCharacterOrByte asInteger] 		ifFalse:[target := aCharacterOrByte asCharacter].	"Look in the current inBuffer first"	index := inBuffer indexOf: target startingAt: lastRead + 1 ifAbsent:[0].	(index > 0 and: [(index + 1) <= inNextToWrite]) ifTrue: ["found it"		result := self nextInBuffer: index - lastRead - 1.		self skip: 1.		^ result	].	[searchedSoFar :=  self inBufferSize.	"Receive more data"	self receiveData.	"We only get recentlyRead = 0 in the case of a non-signaling socket close."	recentlyRead > 0] whileTrue:[		"Data begins at lastRead + 1, we add searchedSoFar as offset."		index := inBuffer indexOf: target						startingAt: (lastRead + searchedSoFar + 1)						ifAbsent:[0].		(index > 0 and: [(index + 1) <= inNextToWrite]) ifTrue: ["found it"			result := self nextInBuffer: index - lastRead - 1.			self skip: 1.			^ result		].		"Check if we've exceeded the max. amount"		(nBytes notNil and:[inNextToWrite - lastRead > nBytes]) 			ifTrue:[^self nextAllInBuffer].	].	"not found and (non-signaling) connection was closed"	^self nextAllInBuffer! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'ar 8/2/2010 18:48'!upToAll: aStringOrByteArray	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of aCollection. If aCollection is not in the stream, answer the entire rest of the stream."	"Note: The 100k limit below is compatible with the previous version though arguably incorrect. If you need unbounded behavior either up the argument or provide nil in which case we'll read until we get it or run out of memory"	^self upToAll: aStringOrByteArray limit: 100000! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'ar 8/22/2010 13:32'!upToAll: aStringOrByteArray limit: nBytes	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of aStringOrByteArray. If aCollection is not in the stream, or not found within nBytes answer the available contents of the stream"	| index sz result searchedSoFar target |	"Deal with ascii vs. binary"	self isBinary		ifTrue:[target := aStringOrByteArray asByteArray]		ifFalse:[target := aStringOrByteArray asString].	sz := target size.	"Look in the current inBuffer first"	index := inBuffer indexOfSubCollection: target						startingAt: lastRead - sz + 2.	(index > 0 and: [(index + sz) <= inNextToWrite]) ifTrue: ["found it"		result := self nextInBuffer: index - lastRead - 1.		self skip: sz.		^ result	].	[searchedSoFar :=  self inBufferSize.	"Receive more data"	self receiveData.	recentlyRead > 0] whileTrue:[		"Data begins at lastRead + 1, we add searchedSoFar as offset and 		backs up sz - 1 so that we can catch any borderline hits."		index := inBuffer indexOfSubCollection: target						startingAt: (lastRead + searchedSoFar - sz + 2 max: 1).		(index > 0 and: [(index + sz) <= inNextToWrite]) ifTrue: ["found it"			result := self nextInBuffer: index - lastRead - 1.			self skip: sz.			^ result		].		"Check if we've exceeded the max. amount"		(nBytes notNil and:[inNextToWrite - lastRead > nBytes]) 			ifTrue:[^self nextAllInBuffer].	].	"not found and (non-signaling) connection was closed"	^self nextAllInBuffer! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'ar 11/22/2010 23:49'!upToEnd	"Answer all data coming in on the socket until the socket	is closed by the other end, or we get a timeout.	This means this method catches ConnectionClosed by itself."	[[self atEnd] whileFalse: [self beSignalingWhile:[self receiveData]]]		on: ConnectionClosed		do: [:ex | "swallow it"]. 	^self nextAllInBuffer! !!SocketStream methodsFor: 'as yet unclassified' stamp: 'mtf 1/15/2011 20:16'!waitForData	"Wait for data. If shouldTimeout, we will time out if nothing arrives, otherwise we wait indefinitely"	self shouldTimeout		ifTrue: [socket waitForDataFor: self timeout			ifClosed: [self signalClosed]			ifTimedOut: [self signalTimeout]]		ifFalse: [socket waitForDataIfClosed: [self signalClosed]]! !!SocketStream class methodsFor: 'as yet unclassified' stamp: 'fbs 12/7/2013 11:14'!finger: userName	self error: 'Use SocketStream >> #finger:at:'.! !!SocketStream class methodsFor: 'as yet unclassified' stamp: 'fbs 12/7/2013 11:09'!finger: userName at: aHostnameOrAddressString	"SocketStream finger: 'stp' at: 'example.com'"	| s |	s := SocketStream openConnectionToHost: aHostnameOrAddressString port: 79.  "finger port number"	Transcript show: '---------- Connecting ----------'; cr.	s sendCommand: userName.	Transcript show: s getLine.	s close.	Transcript show: '---------- Connection Closed ----------'; cr; endEntry.! !!SocketStream class methodsFor: 'as yet unclassified' stamp: 'gk 2/3/2005 22:19'!on: socket	"Create a socket stream on a connected server socket."	^self basicNew initialize socket: socket! !!SocketStream class methodsFor: 'as yet unclassified' stamp: 'mir 5/15/2003 18:13'!openConnectionToHost: hostIP port: portNumber	| socket |	socket := Socket new.	socket connectTo: hostIP port: portNumber.	^self on: socket! !!SocketStream class methodsFor: 'as yet unclassified' stamp: 'kph 9/23/2008 00:30'!openConnectionToHost: hostIP port: portNumber timeout: timeout	| socket |	socket := Socket new.	socket connectTo: hostIP port: portNumber waitForConnectionFor: timeout.	^self on: socket! !!SocketStream class methodsFor: 'as yet unclassified' stamp: 'fbs 3/1/2013 10:32'!openConnectionToHostNamed: hostName port: portNumber	| hostIP |	hostIP := NetNameResolver addressForName: hostName timeout: 20.	hostIP ifNil: [NetworkError signal: ('Cannot resolve {1}.' format: {hostName})].	^self openConnectionToHost: hostIP port: portNumber! !!AFramePage methodsFor: 'as yet unclassified' stamp: 'crl 8/13/2019 00:02'!camera	^camera! !!AFramePage methodsFor: 'as yet unclassified' stamp: 'crl 8/14/2019 19:17'!initialize	"Initialize myself."		| vrButton |		super initialize.		scene := (document getElementById: 'scene') counterpart.	camera := (document getElementById: 'camera-wrapper') counterpart.		scene		addEventListener: 'oscEvent'		with: [:event | OSCEventHandler handle: (OSCEvent from: event detail)]		with: false.			vrButton := (document getElementsByClassName: 'a-enter-vr') at: 0.		(document isMobile)		ifTrue: [			vrButton				at: #onclick				put: [					JS home style at: #opacity put: 0.					(JS document getElementById: 'camera') appendChild: (JS document createElement: 'a-cursor')]]		ifFalse: [			vrButton				styleAt: #transition put: 'opacity 500ms';				styleAt: #opacity put: 0.							"(scene components at: 'keyboard-shortcuts')				at: #enterVREnabled				put: false."			(Delay forSeconds: 1) wait.			vrButton remove]! !!AFramePage methodsFor: 'as yet unclassified' stamp: 'crl 8/13/2019 00:42'!moveCameraInXBy: delta	| position |		position := camera object3D position.		position		at: #x		put: position x + delta! !!AFramePage methodsFor: 'as yet unclassified' stamp: 'crl 8/13/2019 00:43'!moveCameraInYBy: delta	| position |		position := camera object3D position.		position		at: #y		put: position y + delta! !!AFramePage methodsFor: 'as yet unclassified' stamp: 'crl 8/13/2019 00:07'!moveCameraInZBy: delta	| position |		position := camera object3D position.		position		at: #z		put: position z + delta! !!AFramePage methodsFor: 'as yet unclassified' stamp: 'crl 8/13/2019 00:02'!scene	^scene! !!AFramePage class methodsFor: 'as yet unclassified' stamp: 'crl 8/13/2019 00:02'!appID	^''! !!LeftGripMorph class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!Fraction methodsFor: 'as yet unclassified' stamp: 'crl 7/23/2017 14:18'!asChromeRemoteCallArgument	^{#value -> self asFloat}! !!Fraction methodsFor: 'as yet unclassified' stamp: 'crl 6/18/2017 20:34'!asJSArgument	^self asFloat asJSArgument! !!Fraction methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 19:47'!storeOnTether: tether
	tether
		nextWordPut: FractionTag;
		store: numerator;
		store: denominator! !!Fraction class methodsFor: 'as yet unclassified'!fromTether: tether	^tether next / tether next! !!RightGripMorph class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!ChromeDebuggingAPI methodsFor: 'as yet unclassified' stamp: 'crl 8/7/2016 16:08'!deliver: object	result := JSONObject on: object.	resultAvailable signal! !!ChromeDebuggingAPI methodsFor: 'as yet unclassified' stamp: 'crl 8/2/2016 19:44'!doesNotUnderstand: aMessage	tab		invokeSelector: (aMessage selector readStream upTo: $:) asSymbol		withParameters: (			(aMessage arguments size = 0)				ifTrue: [#()]				ifFalse: [					(aMessage arguments size = 1)						ifTrue: [aMessage arguments onlyOne]						ifFalse: [super doesNotUnderstand: aMessage]])		ofAPI: self! !!ChromeDebuggingAPI methodsFor: 'as yet unclassified' stamp: 'crl 7/30/2016 22:37'!domain	^self class domain! !!ChromeDebuggingAPI methodsFor: 'as yet unclassified' stamp: 'crl 8/7/2016 15:52'!initialize	resultAvailable := Semaphore new! !!ChromeDebuggingAPI methodsFor: 'as yet unclassified' stamp: 'crl 8/7/2016 15:50'!resultOf: block	block value.	resultAvailable wait.	^result! !!ChromeDebuggingAPI methodsFor: 'as yet unclassified' stamp: 'crl 7/28/2016 16:33'!tab: aChromeTab	tab := aChromeTab! !!ChromeDebuggingAPI methodsFor: 'as yet unclassified' stamp: 'crl 7/22/2017 02:48'!waitForResult	resultAvailable wait! !!ChromeDebuggingAPI class methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 12:39'!domain	^self subclassResponsibility! !!ChromeDebuggingAPI class methodsFor: 'as yet unclassified' stamp: 'crl 7/28/2016 16:09'!for: aChromeTab	^self new tab: aChromeTab! !!WeakOrderedCollection methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!MultiCanvas methodsFor: 'as yet unclassified' stamp: 'crl 5/15/2017 15:28'!forceDamageToScreen: rectangles	canvases do: [:canvas | canvas forceDamageToScreen: rectangles]! !!MultiCanvas class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:55'!foo! !!InstallRemoteModule methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!InstallRemoteModule class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!ChannelMessage methodsFor: 'as yet unclassified' stamp: 'crl 2/17/2006 17:54'!addUninitializedAspectsTo: aspects	channel ifNil: [aspects add: 'channel']! !!ChannelMessage methodsFor: 'as yet unclassified' stamp: 'crl 2/17/2006 17:54'!applyChannel: aMIDIChannel	"Answer myself after applying aMIDIChannel."	self channel: aMIDIChannel! !!ChannelMessage methodsFor: 'as yet unclassified' stamp: 'crl 2/17/2006 17:54'!channel	"Answer my channel."	^channel! !!ChannelMessage methodsFor: 'as yet unclassified' stamp: 'crl 2/17/2006 17:53'!channel: aMIDIChannel	"Set my channel to aMIDIChannel."	channel _ aMIDIChannel! !!ChannelMessage methodsFor: 'as yet unclassified' stamp: 'crl 8/24/2017 13:45'!channelIsOverridden	^false! !!ChannelMessage methodsFor: 'as yet unclassified' stamp: 'crl 8/24/2017 13:45'!printOn: aStream	"Print a textual representation of myself on aStream."	self channelIsOverridden ifFalse: [		aStream nextPutAll: ', on '.		(channel == nil)			ifTrue: [aStream nextPutAll: 'an unspecified channel']			ifFalse: [aStream print: channel]]! !!ChannelMessage methodsFor: 'as yet unclassified' stamp: 'crl 2/21/2006 23:47'!renderOnMIDIRecorder: aMIDIRecorder	aMIDIRecorder record: self! !!ChannelMessage class methodsFor: 'as yet unclassified' stamp: 'crl 9/7/2008 22:31'!initialize	"Initialize myself."	tagMinimum _ 16r80.	tagMaximum _ 16rEF! !!ChannelMessage class methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2008 01:35'!withTag: tag from: aMIDIStream	^(self new channel: ((tag bitAnd: 16r0F) + 1)th channel) initializeFrom: aMIDIStream! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 8/22/2016 03:37'!initialize	super initialize.	scripts := OrderedCollection new! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 5/12/2017 23:06'!parsePauseParameters: dictionary	^dictionary ! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/16/2019 22:03'!parseResumeParameters: dictionary	^dictionary ! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 7/31/2016 00:17'!parseScriptFrom: dictionary	^ChromeScript fromDictionary: dictionary! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 5/13/2017 12:36'!paused: pauseParameters	<parseParameters: #parsePauseParameters:>		3 halt.	tab resume! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/16/2019 22:03'!resumed: resumeParameters	<parseParameters: #parseResumeParameters:>		3 halt! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 7/21/2017 14:17'!scriptFailedToParse: script	<parseParameters: #parseScriptFrom:>! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 5/12/2017 21:12'!scriptParsed: script	<parseParameters: #parseScriptFrom:>		| url oldScript |		url := script url.	oldScript := scripts detect: [:each | each url = url] ifNone: [nil].	oldScript ifNotNil: [scripts remove: oldScript].	scripts add: script! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 8/5/2016 21:26'!scriptURLs	| urls |		urls := OrderedCollection new.		scripts do: [:script | (script url notNil and: [script url isEmpty not]) ifTrue: [urls add: script url]].	^Array withAll: urls! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 5/12/2017 16:43'!scripts	^scripts! !!ChromeDebuggerAPI class methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 12:40'!domain	^'Debugger'! !!ClipboardInterpreter class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!FunctionDeclaration methodsFor: 'as yet unclassified' stamp: 'crl 5/7/2017 13:49'!printSmalltalkOn: stream	"Print myself as a Smalltalk block closure."		stream nextPut: $[.	params do: [:parameter | parameter printSmalltalkOn: stream].	body printSmalltalkOn: stream.	stream nextPut: $]! !!FunctionDeclaration class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!ChromeExtensionUrl methodsFor: 'as yet unclassified' stamp: 'crl 8/3/2016 15:48'!printOn: aStream	aStream		nextPutAll: self schemeName;		nextPutAll: '://';		nextPutAll: fragment! !!ChromeExtensionUrl methodsFor: 'as yet unclassified' stamp: 'crl 8/3/2016 15:39'!privateFragment: ignored! !!ChromeExtensionUrl methodsFor: 'as yet unclassified' stamp: 'crl 8/3/2016 15:46'!privateInitializeFromText: text	fragment := text readStream upToAll: '//'; upToEnd! !!ChromeExtensionUrl methodsFor: 'as yet unclassified' stamp: 'crl 8/3/2016 15:30'!schemeName	^'chrome-extension'! !!ChromeExtensionUrl class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!JSArrayBuffer methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSArrayBuffer class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!ExceptionMarker methodsFor: 'as yet unclassified' stamp: 'crl 10/4/2016 14:33'!bridgeContext	^self signalerContext firstLocalContext! !!ExceptionMarker methodsFor: 'as yet unclassified' stamp: 'crl 10/4/2016 15:06'!handleEventFrom: aTether	tether := aTether.	id := tether next.	message := tether next.	tether deliver: self under: id! !!ExceptionMarker methodsFor: 'as yet unclassified' stamp: 'crl 10/4/2016 15:22'!label	^message printString! !!ExceptionMarker methodsFor: 'as yet unclassified' stamp: 'crl 10/14/2016 14:56'!printOn: stream	stream nextPutAll: 'an exception marker'! !!ExceptionMarker methodsFor: 'as yet unclassified' stamp: 'crl 10/4/2016 15:15'!remoteExceptionMarker	^message! !!ExceptionMarker methodsFor: 'as yet unclassified' stamp: 'crl 10/4/2016 14:28'!signalerContext	^message signalerContext! !!ExceptionMarker methodsFor: 'as yet unclassified' stamp: 'crl 10/4/2016 14:59'!storeOnTether: tether	tether		nextWordPut: ExceptionMarkerTag;		store: id.			(self otherVia: tether) storeOnTether: tether! !!ExceptionMarker methodsFor: 'as yet unclassified' stamp: 'crl 10/4/2016 12:02'!validateResult: result	^result! !!ExceptionMarker class methodsFor: 'as yet unclassified' stamp: 'crl 10/4/2016 15:07'!forward: exception over: tether under: remoteExchangeID	^(self new)		id: remoteExchangeID;		forward: exception		over: tether! !!ExceptionMarker class methodsFor: 'as yet unclassified' stamp: 'crl 10/4/2016 12:50'!handleEventFrom: tether	self new handleEventFrom: tether! !!XMLMalformedException methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!XMLMalformedException class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!JQuery methodsFor: 'as yet unclassified' stamp: 'crl 6/15/2017 10:31'!draggable	proxy draggable! !!JQuery methodsFor: 'as yet unclassified' stamp: 'crl 6/15/2017 09:45'!element	^self first! !!JQuery methodsFor: 'as yet unclassified' stamp: 'crl 7/24/2017 13:54'!find: className	^(proxy find: className) at: '0'! !!JQuery methodsFor: 'as yet unclassified' stamp: 'crl 6/15/2017 00:40'!first	^(proxy at: 0) counterpart! !!JQuery methodsFor: 'as yet unclassified' stamp: 'crl 6/15/2017 00:39'!printOn: stream	stream nextPutAll: 'a jQuery object'! !!JQuery class methodsFor: 'as yet unclassified' stamp: 'crl 7/23/2017 14:55'!at: selector inIFrameWithID: id	^self at: selector inIFrameWithID: id in: Webpage! !!JQuery class methodsFor: 'as yet unclassified' stamp: 'crl 7/27/2017 14:15'!at: selector inIFrameWithID: id in: webpage	^self forProxy: (((self elementAt: id in: webpage)) proxy contents find: ('#', selector))! !!JQuery class methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2017 12:59'!call: block	^self function call: nil with: block! !!JQuery class methodsFor: 'as yet unclassified' stamp: 'crl 9/2/2017 16:00'!createDragHandleFromElementNamed: handleID forElementNamed: windowID	| windowWrapper |		windowWrapper := self elementAt: windowID in: Webpage current.	(windowWrapper proxy at: #draggable)		call: windowWrapper proxy		with: (			(JS Object new)				at: #handle				put: (self elementAt: handleID in: Webpage current) element;				yourself).! !!JQuery class methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2017 13:01'!elementAt: selector	^self elementAt: selector in: Webpage current! !!JQuery class methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2017 18:32'!elementAt: selector in: webpage	^[		self forProxy: (			(webpage window proxy at: '$')				call: nil				with: ('#', selector))	]		on: Error		do: [:exception | nil]! !!JQuery class methodsFor: 'as yet unclassified' stamp: 'crl 7/27/2017 14:17'!fadeElementAt: id in: webpage into: block	| element |		element := (self elementAt: id in: webpage) element.		element beTransparent.	(Delay forMilliseconds: 500) wait.	block value: element.	element beOpaque! !!JQuery class methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2017 12:58'!function	^self functionIn: Webpage current! !!JQuery class methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2017 12:58'!functionIn: webpage	^webpage window proxy at: '$'! !!JQuery class methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2017 18:35'!initialize	Smalltalk addToStartUpList: self! !!JQuery class methodsFor: 'as yet unclassified' stamp: 'crl 7/23/2017 22:15'!load	self loadInto: Webpage current! !!JQuery class methodsFor: 'as yet unclassified' stamp: 'crl 9/10/2018 14:55'!loadInto: webpage	self loadInto: webpage then: []! !!JQuery class methodsFor: 'as yet unclassified' stamp: 'crl 9/10/2018 14:55'!loadInto: webpage then: block	webpage		loadStylesheetFrom: 'css/jquery/ui/jquery-ui.min.css';		loadScriptFrom: 'js/jquery/jquery-3.2.1.min.js'		then: [			webpage				loadScriptFrom: 'js/jquery/ui/jquery-ui.min.js'				then: block]! !!JQuery class methodsFor: 'as yet unclassified' stamp: 'crl 7/24/2017 15:16'!loadRotatable	self loadRotatableInto: Webpage current! !!JQuery class methodsFor: 'as yet unclassified' stamp: 'crl 7/24/2017 15:20'!loadRotatableInto: webpage	webpage		loadStylesheetFrom: 'https://caffeine.js.org/js/jquery/ui/rotatable/jquery.ui.rotatable.css';		loadScriptFrom: 'https://caffeine.js.org/js/jquery/ui/rotatable/jquery.ui.rotatable.js'! !!DictionaryInspector class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!ClassBuilder methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2019 00:47'!name: className inEnvironment: env subclassOf: newSuper type: type instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolString category: category unsafe: unsafe	"Define a new class in the given environment.	If unsafe is true do not run any validation checks.	This facility is provided to implement important system changes."	| oldClass instVars classVars copyOfOldClass newClass | 	environ := env.	instVars := Scanner new scanFieldNames: instVarString.	classVars := (Scanner new scanFieldNames: classVarString) collect: [:x | x asSymbol].	"Validate the proposed name"	unsafe ifFalse:[(self validateClassName: className) ifFalse:[^nil]].	oldClass := env at: className ifAbsent:[nil].	oldClass isBehavior 		ifFalse: [oldClass := nil]  "Already checked in #validateClassName:"		ifTrue: [			copyOfOldClass := oldClass copy.			copyOfOldClass superclass addSubclass: copyOfOldClass].			[ | newCategory needNew force organization oldCategory |	unsafe ifFalse:[		"Run validation checks so we know that we have a good chance for recompilation"		(self validateSuperclass: newSuper forSubclass: oldClass) ifFalse:[^nil].		(self validateInstvars: instVars from: oldClass forSuper: newSuper) ifFalse:[^nil].		(self validateClassvars: classVars from: oldClass forSuper: newSuper) ifFalse:[^nil].		(self validateSubclassFormat: type from: oldClass forSuper: newSuper extra: instVars size) ifFalse:[^nil]].	"See if we need a new subclass"	needNew := self needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass.	needNew == nil ifTrue:[^nil]. "some error"	(needNew and:[unsafe not]) ifTrue:[		"Make sure we don't redefine any dangerous classes"		(self tooDangerousClasses includes: oldClass name) ifTrue:[			self error: oldClass name, ' cannot be changed'.		].		"Check if the receiver should not be redefined"		(oldClass ~~ nil and:[oldClass shouldNotBeRedefined]) ifTrue:[			self notify: oldClass name asText allBold, 						' should not be redefined. \Proceed to store over it.' withCRs]].	needNew ifTrue:[		"Create the new class"		newClass := self 			newSubclassOf: newSuper 			type: type 			instanceVariables: instVars			from: oldClass.		newClass == nil ifTrue:[^nil]. "Some error"		newClass setName: className.		newClass environment: environ.	] ifFalse:[		"Reuse the old class"		newClass := oldClass.	].	"Install the class variables and pool dictionaries... "	force := (newClass declare: classVarString) | (newClass sharing: poolString).	"... classify ..."	newCategory := category asSymbol.	organization := environ ifNotNil:[environ organization].	oldClass isNil ifFalse: [oldCategory := (organization categoryOfElement: oldClass name) asSymbol].	organization classify: newClass name under: newCategory suppressIfDefault: true.		"... recompile ..."	newClass := self recompile: force from: oldClass to: newClass mutate: false.	"... export if not yet done ..."	(environ at: newClass name ifAbsent:[nil]) == newClass ifFalse:[		[environ at: newClass name put: newClass]			on: AttemptToWriteReadOnlyGlobal do:[:ex| ex resume: true].		environ flushClassNameCache.	].	newClass doneCompiling.	"... notify interested clients ..."	oldClass isNil ifTrue: [		SystemChangeNotifier uniqueInstance classAdded: newClass inCategory: newCategory.		^ newClass].	newCategory ~= oldCategory 		ifTrue: [SystemChangeNotifier uniqueInstance class: newClass recategorizedFrom: oldCategory to: category]		ifFalse: [SystemChangeNotifier uniqueInstance classDefinitionChangedFrom: copyOfOldClass to: newClass.].] ensure: 		[copyOfOldClass ifNotNil: [copyOfOldClass superclass removeSubclass: copyOfOldClass].		Behavior flushObsoleteSubclasses.		].	^newClass! !!ClassBuilder methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 23:51'!superclass: newSuper	subclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat 	"This is the standard initialization message for creating a new class as a 	subclass of an existing class."	^self 		name: t		inEnvironment: Environment default		subclassOf: newSuper		type: newSuper typeOfClass		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!ClassBuilder methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 23:19'!superclass: aClass	variableByteSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class in which the subclass is to 	have indexable byte-sized nonpointer variables."	| oldClassOrNil actualType |	(aClass instSize > 0)		ifTrue: [^self error: 'cannot make a byte subclass of a class with named fields'].	(aClass isVariable and: [aClass isWords])		ifTrue: [^self error: 'cannot make a byte subclass of a class with word fields'].	(aClass isVariable and: [aClass isPointers])		ifTrue: [^self error: 'cannot make a byte subclass of a class with pointer fields'].	oldClassOrNil := aClass environment at: t ifAbsent:[nil].	actualType := (oldClassOrNil notNil				   and: [oldClassOrNil typeOfClass == #compiledMethod])					ifTrue: [#compiledMethod]					ifFalse: [#bytes].	^self 		name: t		inEnvironment: aClass environment		subclassOf: aClass		type: actualType		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!ClassBuilder methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 23:19'!superclass: aClass	variableSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class in which the subclass is to 	have indexable pointer variables."		aClass isBits ifTrue: 		[^self error: 'cannot make a pointer subclass of a class with non-pointer fields'].	^self 		name: t		inEnvironment: aClass environment		subclassOf: aClass		type: #variable		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!ClassBuilder methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 23:20'!superclass: aClass	variableWordSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class in which the subclass is to 	have indexable word-sized nonpointer variables."	(aClass instSize > 0)		ifTrue: [^self error: 'cannot make a word subclass of a class with named fields'].	(aClass isVariable and: [aClass isBytes])		ifTrue: [^self error: 'cannot make a word subclass of a class with byte fields'].	(aClass isVariable and: [aClass isPointers])		ifTrue: [^self error: 'cannot make a word subclass of a class with pointer fields'].	^self 		name: t		inEnvironment: aClass environment		subclassOf: aClass		type: #words		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!ClassBuilder methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 23:20'!superclass: aClass	weakSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have weak indexable pointer variables."	aClass isBits 		ifTrue: [^self error: 'cannot make a pointer subclass of a class with non-pointer fields'].	^self 		name: t		inEnvironment: aClass environment		subclassOf: aClass		type: #weak		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!HTMLBRElement methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!HTMLBRElement class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!String methodsFor: 'as yet unclassified' stamp: 'crl 5/18/2017 23:00'!article	"Answer an article appropriate for me."	^(		(('aeiou' includes: self first asLowercase) and: [(self first = $U) not and: [('uni*' match: self) not]]) or: [			('fhlmnrsx' includes: self first asLowercase) and: [self second isUppercase and: [('aeiou' includes: self second asLowercase) not]]]	)		ifTrue: ['an']		ifFalse: ['a']! !!String methodsFor: 'as yet unclassified' stamp: 'crl 7/23/2017 14:11'!asChromeRemoteCallArgument	^{#value -> self}! !!String methodsFor: 'as yet unclassified' stamp: 'bf 11/25/2014 18:12'!asJSArgument	"converted to JS string by plugin"	self class isBytes ifTrue: [^self].	^super asJSArgument! !!String methodsFor: 'as yet unclassified' stamp: 'crl 6/5/2017 10:10'!filledToWidth: width	| stream filled separators size whitespace |	separators := ' |''	'.	whitespace := ' 	'.	stream := self readStream.	filled := (String new: self size) writeStream.	size := self size.	[stream atEnd] whileFalse: [		| index max |		"Skip leading whitespace."		"[whitespace includes: stream peek] whileTrue: [stream next]."		index := stream position + 1.			max := index + width.		"Find the next line-end."		[((self at: index) = Character cr) or: [index = max or: [index = size]]] whileFalse: [index := index + 1].		(index = size)			ifTrue: [				"We've reached the end."				filled nextPutAll: stream upToEnd]			ifFalse: [				| chunk |								((index - stream position) > width) ifTrue: [					"Find the end of the previous word."									[whitespace includes: (self at: index)] whileFalse: [index := index - 1].					"[separators includes: (self at: index)] whileTrue: [index := index - 1]"].								chunk := stream next: (index - stream position).				filled nextPutAll: chunk.				(chunk last = Character cr) ifFalse: [filled cr]]].	^filled contents! !!String methodsFor: 'as yet unclassified' stamp: 'crl 6/3/2017 21:13'!formattedForMorphicJS	^((self filledToWidth: 80) copyReplaceAll: (String with: Character cr) with: (String with: Character lf)) copyReplaceAll: (String with: Character tab) with: '    '! !!String methodsFor: 'as yet unclassified' stamp: 'crl 6/3/2017 21:14'!formattedForZebkit	^self formattedForMorphicJS! !!String methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 20:03'!simplifiedForJSON	"Answer a literal populated with my contents, suitable for JSON encoding."	^self! !!String methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 03:46'!storeElementsOnTether: tether	tether nextPutAll: self asByteArray! !!String methodsFor: 'as yet unclassified' stamp: 'crl 5/30/2017 19:00'!storeJavaScriptOn: aStream 	"Print inside string quotes, escaping embedded quotes."	| x |	aStream nextPut: $'.	1 to: self size do:		[:i |		x := self at: i.		(x = $' or: [x = Character cr]) ifTrue: [aStream nextPut: $\].		aStream nextPut: x].	aStream nextPut: $'! !!String methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 03:50'!tag	"Answer my proxy tag."	^StringTag! !!String methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 21:39'!translated	"answer the receiver translated to the default language"	| translation |	translation := self		translatedTo: LocaleID current		inDomain: (TextDomainManager domainOfMethod: thisContext sender method).	^translation! !!String methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 21:40'!translatedInDomain: aDomainName	| translation |	translation := self translatedTo: LocaleID current inDomain: aDomainName.	^translation! !!String class methodsFor: 'as yet unclassified'!fromTether: tether	^(tether next: tether nextWord) asString! !!String class methodsFor: 'as yet unclassified' stamp: 'crl 6/13/2017 14:58'!randomOfLength: length	| random string |		random := Random new.	string := (self new: length) writeStream.		length timesRepeat: [string nextPut: (Character value: (random nextInt: 26) + 96)].	^string contents! !!OrderedCollection methodsFor: 'as yet unclassified' stamp: 'crl 5/20/2018 23:23'!storeOnTether: tether
	self asArray storeOnTether: tether! !!MouseButtonEvent class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!SqueakSSLCertificateError class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!FileUrl methodsFor: 'as yet unclassified' stamp: 'gk 2/10/2004 13:06'!default	"Use the default local Squeak file directory."		| local |	local := self class pathParts: (FileDirectory default pathParts), #('') isAbsolute: true.	self privateInitializeFromText: self pathString relativeTo: local.		"sets absolute also"! !!FileUrl methodsFor: 'as yet unclassified' stamp: 'gk 10/21/2005 10:21'!directoryUrl	"The path always has at least one element so this works."	^self copy path: (path copyFrom: 1 to: path size - 1)! !!FileUrl methodsFor: 'as yet unclassified' stamp: 'gk 10/21/2005 11:14'!fileName	"Return the last part of the path,	most often a filename but can also be a directory."	^self path last! !!FileUrl methodsFor: 'as yet unclassified' stamp: 'gk 2/9/2004 20:32'!firstPartIsDriveLetter	"Return true if the first part of the path is a letter	followed by a $: like 'C:' "		| firstPart |	path isEmpty ifTrue: [^false].	firstPart := path first.	^firstPart size = 2 and: [		firstPart first isLetter			and: [firstPart last = $:]]! !!FileUrl methodsFor: 'as yet unclassified' stamp: 'ls 8/4/1998 20:42'!hasContents	^true! !!FileUrl methodsFor: 'as yet unclassified' stamp: 'gk 2/10/2004 10:16'!host	"Return the host name, either 'localhost', '', or a fully qualified domain name."		^host ifNil: ['']! !!FileUrl methodsFor: 'as yet unclassified' stamp: 'gk 2/12/2004 16:22'!host: hostName	"Set the host name, either 'localhost', '', or a fully qualified domain name."		host := hostName! !!FileUrl methodsFor: 'as yet unclassified' stamp: 'gk 2/10/2004 13:05'!host: aHostString pathParts: aCollection isAbsolute: aBoolean	host := aHostString.	path := aCollection.	isAbsolute := aBoolean! !!FileUrl methodsFor: 'as yet unclassified' stamp: 'gk 2/12/2004 16:01'!initializeFromPathString: aPathString	"<aPathString> is a file path as a String.	We construct a path collection using various heuristics."	| pathString hasDriveLetter |	pathString := aPathString.	pathString isEmpty ifTrue: [pathString := '/'].	path := (pathString findTokens: '/') collect: [:token | token unescapePercents].	"A path like 'C:' refers in practice to 'c:/'"	((pathString endsWith: '/') or:		[(hasDriveLetter := self firstPartIsDriveLetter) and: [path size = 1]])			ifTrue: [path add: ''].	"Decide if we are absolute by checking for leading $/ or	beginning with drive letter. Smarts for other OSes?"	self isAbsolute: ((pathString beginsWith: '/')						or: [hasDriveLetter ifNil: [self firstPartIsDriveLetter]])! !!FileUrl methodsFor: 'as yet unclassified' stamp: 'gk 10/21/2005 11:12'!isAbsolute	"Should the path be considered absolute to	the filesystem instead of relative to the default directory?" 	^isAbsolute! !!FileUrl methodsFor: 'as yet unclassified' stamp: 'gk 10/21/2005 11:13'!isAbsolute: aBoolean	"Set if the path should be considered absolute to	the filesystem instead of relative to the default directory."	isAbsolute := aBoolean! !!FileUrl methodsFor: 'as yet unclassified' stamp: 'gk 2/10/2004 00:15'!path	"Return an ordered collection of the path elements."		^path! !!FileUrl methodsFor: 'as yet unclassified' stamp: 'gk 10/21/2005 11:11'!path: aCollection	"Set the collection of path elements."	path := aCollection! !!FileUrl methodsFor: 'as yet unclassified' stamp: 'gk 2/10/2004 00:19'!pathDirString	"Path to directory as url, using slash as delimiter.	Filename is left out."	^String streamContents: [ :s |		isAbsolute ifTrue: [ s nextPut: $/ ].		1 to: self path size - 1 do: [ :ii |			s nextPutAll: (path at: ii); nextPut: $/]]! !!FileUrl methodsFor: 'as yet unclassified' stamp: 'gk 10/21/2005 10:01'!pathForDirectory	"Path using local file system's pathname delimiter.	DOS paths with drive letters should not	be prepended with a delimiter even though	they are absolute. Filename is left out."	| delimiter |	delimiter :=  FileDirectory default pathNameDelimiter.	^String streamContents: [ :s |		(self isAbsolute and: [self firstPartIsDriveLetter not])			ifTrue: [ s nextPut: delimiter ].		1 to: self path size - 1 do: [ :ii |			s nextPutAll: (path at: ii); nextPut: delimiter]]! !!FileUrl methodsFor: 'as yet unclassified' stamp: 'ar 10/13/2004 17:54'!pathForFile	"Path using local file system's delimiter.  $\ or $:"	^FileDirectory default pathFromUrl: self! !!FileUrl methodsFor: 'as yet unclassified' stamp: 'gk 2/10/2004 13:04'!pathParts: aCollection isAbsolute: aBoolean	^self host: nil pathParts: aCollection isAbsolute: aBoolean! !!FileUrl methodsFor: 'as yet unclassified' stamp: 'nice 10/12/2010 20:58'!pathString	"Path as it appears in a URL with $/ as delimiter."		^String streamContents: [ :s |		"isAbsolute ifTrue:[ s nextPut: $/ ]."		self path			do: [ :p | s nextPutAll: p encodeForHTTP ]			separatedBy: [ s nextPut: $/]]! !!FileUrl methodsFor: 'as yet unclassified' stamp: 'nice 10/2/2010 00:49'!postCopy	"Be sure not to share the path with the copy."	super postCopy.	path := path copy! !!FileUrl methodsFor: 'as yet unclassified' stamp: 'fbs 2/2/2005 13:09'!printOn: aStream	"Return the FileUrl according to RFC1738 plus supporting fragments:		'file://<host>/<path>#<fragment>'	Note that <host> being '' is equivalent to 'localhost'.	Note: The pathString can not start with a leading $/	to indicate an 'absolute' file path.	This is not according to RFC1738 where the path should have	no leading or trailing slashes, and always	be considered absolute relative to the filesystem."	aStream nextPutAll: self schemeName, '://'.	host ifNotNil: [aStream nextPutAll: host].	aStream		nextPut: $/;		nextPutAll: self pathString.	fragment ifNotNil:		[aStream			nextPut: $#;			nextPutAll: fragment encodeForHTTP].! !!FileUrl methodsFor: 'as yet unclassified' stamp: 'gk 2/12/2004 16:11'!privateInitializeFromText: aString	"Calculate host and path from a file URL in String format.	Some malformed formats are allowed and interpreted by guessing."	| schemeName pathString bare hasDriveLetter stream char i |	bare := aString withBlanksTrimmed.	schemeName := Url schemeNameForString: bare.	(schemeName isNil or: [schemeName ~= self schemeName])		ifTrue: [			host := ''.			pathString := bare]		ifFalse: [			"First remove schemeName and colon"			bare := bare copyFrom: (schemeName size + 2) to: bare size.			"A proper file URL then has two slashes before host,			A malformed URL is interpreted as using syntax file:<path>."			(bare beginsWith: '//')				ifTrue: [i := bare indexOf: $/ startingAt: 3.						i=0 ifTrue: [								host := bare copyFrom: 3 to: bare size.								pathString := '']							ifFalse: [								host := bare copyFrom: 3 to: i-1.								pathString := bare copyFrom: host size + 3 to: bare size]]				ifFalse: [host := ''.						pathString := bare]].	self initializeFromPathString: pathString! !!FileUrl methodsFor: 'as yet unclassified' stamp: 'gk 2/12/2004 16:29'!privateInitializeFromText: pathString relativeTo: aUrl	"<pathString> should be a filesystem path.	This url is adjusted to be aUrl + the path."	| bare newPath |	self host: aUrl host.	self initializeFromPathString: pathString.	self isAbsolute: aUrl isAbsolute.	newPath := aUrl path copy.	newPath removeLast.	"empty string that says its a directory"	path do: [ :token |		((token ~= '..') and: [token ~= '.']) ifTrue: [ 			newPath addLast: token unescapePercents ].		token = '..' ifTrue: [ 			newPath isEmpty ifFalse: [ 				newPath last = '..' ifFalse: [ newPath removeLast ] ] ].		"token = '.' do nothing" ].	path := newPath	! !!FileUrl methodsFor: 'as yet unclassified' stamp: 'ASF 4/30/2005 16:37'!retrieveContents	| file pathString s type entries |	pathString := self pathForFile.	file := [FileStream readOnlyFileNamed: pathString] 			on: FileDoesNotExistException do:[:ex| ex return: nil].	file ifNotNil: [		type := file mimeTypes.		type ifNotNil:[type := type first].		type ifNil:[type := MIMEDocument guessTypeFromName: self path last].		^MIMELocalFileDocument 			contentType: type			contentStream: file].	"see if it's a directory..."	entries := [(FileDirectory on: pathString) entries] 				on: InvalidDirectoryError do:[:ex| ex return: nil].	entries ifNil:[^nil].	s := WriteStream on: String new.	(pathString endsWith: '/') ifFalse: [ pathString := pathString, '/' ].	s nextPutAll: '<title>Directory Listing for ', pathString, '</title>'.	s nextPutAll: '<h1>Directory Listing for ', pathString, '</h1>'.	s nextPutAll: '<ul>'.	s cr.	entries do: [ :entry |		s nextPutAll: '<li><a href="'.		s nextPutAll: entry name.		s nextPutAll: '">'.		s nextPutAll: entry name.		s nextPutAll: '</a>'.		s cr. ].	s nextPutAll: '</ul>'.	^MIMEDocument  contentType: 'text/html'  content: s contents  url: ('file://', pathString)! !!FileUrl methodsFor: 'as yet unclassified' stamp: 'gk 2/10/2004 10:34'!scheme	^self class schemeName! !!FileUrl methodsFor: 'as yet unclassified' stamp: 'gk 2/10/2004 10:34'!schemeName	^self class schemeName! !!FileUrl class methodsFor: 'as yet unclassified' stamp: 'gk 2/10/2004 12:16'!absoluteFromText: aString	"Method that can be called explicitly to create a FileUrl."	^self new privateInitializeFromText: aString! !!FileUrl class methodsFor: 'as yet unclassified' stamp: 'gk 2/10/2004 13:04'!host: aHost pathParts: aCollectionOfPathParts isAbsolute: aBoolean	"Create a FileUrl."	^self new host: aHost pathParts: aCollectionOfPathParts isAbsolute: aBoolean! !!FileUrl class methodsFor: 'as yet unclassified' stamp: 'gk 2/10/2004 13:10'!pathParts: aCollectionOfPathParts	"Create a FileUrl."	^self host: nil pathParts: aCollectionOfPathParts isAbsolute: true! !!FileUrl class methodsFor: 'as yet unclassified' stamp: 'gk 2/10/2004 13:06'!pathParts: aCollectionOfPathParts isAbsolute: aBoolean	"Create a FileUrl."	^self host: nil pathParts: aCollectionOfPathParts isAbsolute: aBoolean! !!FileUrl class methodsFor: 'as yet unclassified' stamp: 'gk 2/10/2004 10:33'!schemeName	^'file'! !!WebSocket00 class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!Preferences methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!Preferences class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 20:45'!fastDragWindowForMorphic	^ self		valueOfFlag: #fastDragWindowForMorphic		ifAbsent: [ true ]! !!Preferences class methodsFor: 'as yet unclassified'!logDebuggerStackToFile	^ self		valueOfFlag: #logDebuggerStackToFile		ifAbsent: [ true ]! !!ProgressTargetRequestNotification class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!DisplayMedium class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:55'!foo! !!UserInputEvent methodsFor: 'as yet unclassified' stamp: 'crl 6/5/2018 14:45'!initialize	wasHandled := false.	position := 0@0! !!UserInputEvent methodsFor: 'as yet unclassified' stamp: 'crl 6/29/2016 00:14'!modifiers	| modifiers |		modifiers := 0.	self shiftPressed ifTrue: [modifiers := 1].	self controlKeyPressed ifTrue: [modifiers := modifiers bitOr: 2].	(buttons anyMask: 32) ifTrue: [modifiers := modifiers bitOr: 4].	self commandKeyPressed ifTrue: [modifiers := modifiers bitOr: 8].	^modifiers! !!UserInputEvent methodsFor: 'as yet unclassified' stamp: 'crl 8/29/2019 17:17'!setCommandKeyPressed	"Answer true if the command key on the keyboard was being held down when this event occurred."	buttons := buttons bitOr: 64! !!UserInputEvent class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!CompositionScanner class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!MIDIStream methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2008 22:09'!close	"Close myself."	devices do: [:device | device close].	self unregister; initialize.	self suspend! !!MIDIStream methodsFor: 'as yet unclassified' stamp: 'crl 12/29/2003 01:16'!consumingNetworkName	"Answer my consuming network name."	^resource consumingNetworkName! !!MIDIStream methodsFor: 'as yet unclassified' stamp: 'crl 1/24/2003 01:46'!currentTime	"Answer the current MIDI time."	^resource currentTime! !!MIDIStream methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2008 13:51'!devices	^devices! !!MIDIStream methodsFor: 'as yet unclassified' stamp: 'crl 9/4/2008 15:57'!fetchNextIncomingPacket	nextIncomingPacket _ incomingPackets next.	nextIncomingTimestamp _ nextIncomingPacket timestamp.	nextIncomingPacket _ nextIncomingPacket message stream! !!MIDIStream methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2008 22:28'!initialize	"Initialize myself."	devices _ Set new.	self beBinary! !!MIDIStream methodsFor: 'as yet unclassified' stamp: 'crl 1/20/2003 23:59'!networkName	"Answer my network name."	^resource networkName! !!MIDIStream methodsFor: 'as yet unclassified' stamp: 'crl 9/4/2008 15:56'!next	"Answer the next incoming byte."	nextIncomingPacket atEnd ifTrue: [self fetchNextIncomingPacket].	^nextIncomingPacket next! !!MIDIStream methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2008 16:34'!nextEvent	| event |	self fetchNextIncomingPacket.	event _ MusicalEvent from: self.	ShowDebugOutput ifTrue: [Transcript cr; nextPutAll: 'collected '; print: event; endEntry].	^event! !!MIDIStream methodsFor: 'as yet unclassified' stamp: 'crl 8/20/2017 13:17'!open	"Ensure that I'm open. Answer whether I was closed before."	^self resume yourselfIfTrueDoFirst: [self register]! !!MIDIStream methodsFor: 'as yet unclassified' stamp: 'crl 9/3/2008 18:18'!register	Streams add: self! !!MIDIStream methodsFor: 'as yet unclassified' stamp: 'crl 9/6/2008 20:44'!registerDevice: aMIDIDevice	devices do: [:device | (device includes: aMIDIDevice) ifTrue: [^self]].	devices add: aMIDIDevice! !!MIDIStream methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 00:21'!resume	^super open yourselfIfTrueDoFirst: [		"one seconds' worth, at a maximum of 1 kHz and four bytes per message"		collection := ByteArray new: 4096.		incomingPackets := SharedQueue new: 1024.				(resource input)			addListener: 'midimessage'			with: 'all'			with: [:event | 				incomingPackets nextPut: (					MIDIPacket						withMessage: event data						andTimestamp: event timestamp)].		messageDispatcher := (			[				[devices consumed: self nextEvent] repeat			]				forkAt: Processor timingPriority)]! !!MIDIStream methodsFor: 'as yet unclassified' stamp: 'crl 12/29/2007 21:01'!schedule: aMusicalEvent	"Schedule the MIDI data in aSequenceableCollection for immediate rendering. Answer how many bytes were processed."	^aMusicalEvent scheduleOn: self! !!MIDIStream methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 01:06'!schedule: aMusicalEvent forNowPlus: numberOfMilliseconds	"Schedule the MIDI data in aSequenceableCollection for immediate rendering after numberOfMilliseconds. Answer how many bytes were processed."	ShowDebugOutput ifTrue: [Transcript cr; nextPutAll: 'scheduling '; print: aMusicalEvent; nextPutAll: ' for now plus '; print: numberOfMilliseconds; endEntry].	^resource schedule: aMusicalEvent forNowPlus: numberOfMilliseconds! !!MIDIStream methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2008 18:17'!scheduleFrom: aStream	"Schedule the MIDI events in aStream for immediate rendering."	aStream resetAndRetainContents.	[aStream atEnd] whileFalse: [(aStream next) scheduleOn: self]! !!MIDIStream methodsFor: 'as yet unclassified' stamp: 'crl 12/29/2003 01:15'!supplyingNetworkName	"Answer my supplying network name."	^resource supplyingNetworkName! !!MIDIStream methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 00:37'!suspend	"Unnecessary?"		self isOpen ifTrue: [		messageDispatcher terminate.		super close]! !!MIDIStream methodsFor: 'as yet unclassified' stamp: 'crl 9/6/2008 12:32'!unregister	Streams remove: self ifAbsent: []! !!MIDIStream methodsFor: 'as yet unclassified' stamp: 'crl 9/3/2008 22:29'!unregisterDevice: aMIDIDevice	devices remove: aMIDIDevice! !!MIDIStream class methodsFor: 'as yet unclassified' stamp: 'crl 9/4/2008 16:34'!allPortNames	^MIDIPort allPortNames! !!MIDIStream class methodsFor: 'as yet unclassified' stamp: 'crl 11/3/2016 17:15'!default	^Streams first! !!MIDIStream class methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 00:37'!initialize	"Initialize myself."	Streams := OrderedCollection new.	Smalltalk addToStartUpList: self.	ShowDebugOutput := false! !!MIDIStream class methodsFor: 'as yet unclassified' stamp: 'crl 1/24/2003 01:34'!on: aMIDIPort	"Answer a new initialized instance of myself on aMIDIPort."	^(super on: aMIDIPort) initialize! !!MIDIStream class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2008 15:47'!onNetworkNamed: networkName	"Answer a new instance of myself for communicating with the MIDI network named networkName."	^Streams		detect: [:stream | stream networkName = networkName]		ifNone: [			(self on: (self resourceClass named: networkName))				open;				yourself]! !!MIDIStream class methodsFor: 'as yet unclassified' stamp: 'crl 9/4/2008 16:35'!resourceClass	^MIDIPort! !!MIDIStream class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2008 16:35'!showDebugOutput	^ShowDebugOutput! !!MIDIStream class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2008 16:35'!showDebugOutput: aBoolean	ShowDebugOutput _ aBoolean! !!MIDIStream class methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 20:12'!startUp: resuming	resuming ifTrue: [Streams do: [:stream | stream resume]]! !!MIDIStream class methodsFor: 'as yet unclassified' stamp: 'crl 9/6/2008 13:56'!streams	^Streams! !!MIDIStream class methodsFor: 'as yet unclassified' stamp: 'crl 8/22/2017 11:15'!testNetworkNamed: networkName	"Test connectivity with the given network."	| stream |	[		stream _ self onNetworkNamed: networkName.		(Note kickdrum, 100 percent loudness, 1 second) scheduleOn: stream	]		ensure: [stream close]! !!DropEvent class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!Edit methodsFor: 'as yet unclassified' stamp: 'crl 1/13/2011 21:53'!edition	^edition! !!Edit methodsFor: 'as yet unclassified' stamp: 'crl 1/10/2011 09:25'!edition: anEdition previousEdit: anEdit	edition := anEdition.	self previousEdition: anEdit.	anEdit ifNotNil: [anEdit nextEdition: self]! !!Edit methodsFor: 'as yet unclassified' stamp: 'crl 7/6/2008 17:05'!nextEditConveying: anEdition	^(self class) conveying: anEdition following: self! !!Edit methodsFor: 'as yet unclassified' stamp: 'crl 6/19/2011 00:33'!printOn: aStream	aStream		nextPutAll: 'an edit at ';		print: timestamp;		nextPutAll: ', by ';		print: author;		nextPutAll: ', conveying '.	edition printOn: aStream forEdit: self! !!Edit methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 15:47'!storeOnTether: tether	super storeOnTether: tether.	tether store: edition! !!Edit methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 16:45'!tag	^EditTag! !!Edit class methodsFor: 'as yet unclassified' stamp: 'crl 7/6/2008 17:02'!conveying: anEdition following: anEdit	^(self new) edition: anEdition previousEdit: anEdit! !!Edit class methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 18:50'!fromTether: tether	^(super fromTether: tether)		edition: tether next		previousEdit: nil! !!DropFilesEvent class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!ContextInspector class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!PluggablePanelSpec class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!Object methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2019 01:43'!adaptToInteger: rcvr andCompare: selector 	"If I am involved in comparison with an Integer.	Default behaviour is to process comparison as any other selectors."	^ self adaptToInteger: rcvr andSend: selector! !!Object methodsFor: 'as yet unclassified' stamp: 'rbb 3/1/2005 09:26'!confirm: queryString	"Put up a yes/no menu with caption queryString. Answer true if the 	response is yes, false if no. This is a modal question--the user must 	respond yes or no."	"nil confirm: 'Are you hungry?'"	^ UIManager default confirm: queryString! !!Object methodsFor: 'as yet unclassified' stamp: 'crl 7/25/2017 20:19'!counterpart	^(self = 'forbidden JavaScript object')		ifTrue: [self error: 'forbidden JavaScript object']		ifFalse: [self]! !!Object methodsFor: 'as yet unclassified' stamp: 'crl 3/27/2019 11:20'!doesNotUnderstand: aMessage 	 "Handle the fact that there was an attempt to send the given	  message to the receiver but the receiver does not understand	  this message (typically sent from the machine when a message	 is sent to the receiver and no method is defined for that selector)."	"Testing: (3 activeProcess)"	| exception resumeValue |		(exception := MessageNotUnderstood new)		message: aMessage;		receiver: self.			"thisContext sender selector = #stop ifFalse: [JS break: self printString, ' ', exception printString]."	resumeValue := exception signal.		^exception reachedDefaultHandler		ifTrue: [aMessage sentTo: self]		ifFalse: [resumeValue]! !!Object methodsFor: 'as yet unclassified' stamp: 'panda 4/28/2000 16:11'!dragTransferType	^nil! !!Object methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 03:35'!exposureHash	^UUIDGenerator default generateRandomBitsOfLength: 28! !!Object methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 18:21'!halt	"This is the typical message to use for inserting breakpoints during 	debugging. It behaves like halt:, but does not call on halt: in order to 	avoid putting this message on the stack. Halt is especially useful when 	the breakpoint message is an arbitrary one."	Halt signal! !!Object methodsFor: 'as yet unclassified' stamp: 'nk 1/23/2004 14:35'!hasModelYellowButtonMenuItems	^Preferences cmdGesturesEnabled! !!Object methodsFor: 'as yet unclassified' stamp: 'hg 11/23/1999 13:43'!initialDeepCopierSize	"default value is 4096; other classes may override this, esp. for smaller (=faster) sizes"	^4096! !!Object methodsFor: 'as yet unclassified'!instVarAt: index 	"Primitive. Answer a fixed variable in an object. The numbering of the 	variables corresponds to the named instance variables. Fail if the index 	is not an Integer or is not the index of a fixed variable. Essential. See 	Object documentation whatIsAPrimitive."	<primitive: 73>	"Access beyond fixed variables."	^self basicAt: index - self class instSize		! !!Object methodsFor: 'as yet unclassified' stamp: 'eem 5/14/2008 13:20'!instVarNamed: aString put: aValue	"Store into the value of the instance variable in me of that name.  Slow and unclean, but very useful. "	^self		instVarAt: (self class						instVarIndexFor: aString asString						ifAbsent: [self error: 'no such inst var'])		put: aValue! !!Object methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 03:34'!otherVia: tether	^OtherMarker exposing: self via: tether! !!Object methodsFor: 'as yet unclassified' stamp: 'ar 3/2/2001 01:34'!primitiveChangeClassTo: anObject	"Primitive. Change the class of the receiver into the class of the argument given that the format of the receiver matches the format of the argument's class. Fail if receiver or argument are SmallIntegers, or the receiver is an instance of a compact class and the argument isn't, or when the argument's class is compact and the receiver isn't, or when the format of the receiver is different from the format of the argument's class, or when the arguments class is fixed and the receiver's size differs from the size that an instance of the argument's class should have.	Note: The primitive will fail in most cases that you think might work. This is mostly because of a) the difference between compact and non-compact classes, and b) because of differences in the format. As an example, '(Array new: 3) primitiveChangeClassTo: Morph basicNew' would fail for three of the reasons mentioned above. Array is compact, Morph is not (failure #1). Array is variable and Morph is fixed (different format - failure #2). Morph is a fixed-field-only object and the array is too short (failure #3).	The facility is really provided for certain, very specific applications (mostly related to classes changing shape) and not for casual use."	<primitive: 115>	self primitiveFailed! !!Object methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 00:46'!primitiveFailed: selector	"Announce that a primitive has failed and there is no appropriate 	Smalltalk code to run."	self error: 'primitive ''', selector asString, ''' failed'! !!Object methodsFor: 'as yet unclassified' stamp: 'crl 6/5/2003 19:34'!printString	"Answer a String whose characters are a description of the receiver."	| aStream |	aStream _ (String new: 100) emptyWritableStream.	self printOn: aStream.	^aStream contents! !!Object methodsFor: 'as yet unclassified'!readFromString: aString	"Create an object based on the contents of aString."	^self readFrom: (ReadStream on: aString)! !!Object methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 03:28'!recyclingHash	^0! !!Object methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2019 00:01'!requestor	^Requestor default! !!Object methodsFor: 'as yet unclassified' stamp: 'crl 7/21/2017 16:32'!simplestRepresentation	^self! !!Object methodsFor: 'as yet unclassified' stamp: 'crl 5/20/2018 23:23'!storeOnTether: tether
	(self otherVia: tether) storeOnTether: tether! !!Object methodsFor: 'as yet unclassified' stamp: 'tk 3/11/2003 13:58'!veryDeepCopy	"Do a complete tree copy using a dictionary.  An object in the tree twice is only copied once.  All references to the object in the copy of the tree will point to the new copy."	| copier new |	copier := DeepCopier new initialize: self initialDeepCopierSize.	new := self veryDeepCopyWith: copier.	copier mapUniClasses.	copier references associationsDo: [:assoc | 		assoc value veryDeepFixupWith: copier].	copier fixDependents.	^ new! !!Object class methodsFor: 'as yet unclassified' stamp: 'crl 3/24/2019 23:58'!fromTether: tether	^self subclassResponsibility! !!JSMenuItemMorph methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSMenuItemMorph class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!HydraSource methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 21:21'!blendWith: source	^(proxy mult: source proxy) counterpart! !!HydraSource methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 21:21'!blendWith: source amount: amount	^(proxy mult: source with: amount) counterpart! !!HydraSource methodsFor: 'as yet unclassified' stamp: 'crl 9/16/2019 00:04'!brightness: function	^(proxy brightness: function proxy) counterpart! !!HydraSource methodsFor: 'as yet unclassified' stamp: 'crl 9/16/2019 00:05'!contrast: function	^(proxy contrast: function proxy) counterpart! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2019 14:42'!addWindowButtonCalled: buttonName fromImage: path evaluating: block	| button tray numberOfChildren id |		tray := self tray.	numberOfChildren := tray children length.	id := (self id reverse copyUpTo: $-) reverse.		button := Webpage current createButtonFromPictureAt: path evaluating: block.	buttonName = 'caffeineButton' ifTrue: [button styleAt: #opacity put: 0.7].		button		at: #id put: buttonName, '-', id;		styleAt: #transition put: 'opacity 500ms';		styleAt: #position put: 'absolute';		styleAt: #top put: ((numberOfChildren * 21 + 1) printString, 'px');		styleAt: #left put: '2px'.			tray		at: buttonName put: button;		appendChild: button;		styleAt: #height put: (numberOfChildren + 1 * 21 + 2).			button beVisible.	^button! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 8/1/2017 18:49'!attributeAt: name	^self attributes attributeAt: name! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 8/1/2017 19:45'!attributeAt: name put: value	^self attributes attributeAt: name put: value! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 8/1/2017 20:10'!attributeNames	^self attributes attributeNames! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 9/2/2019 21:49'!beAlmostOpaque	self styleAt: #opacity put: 0.9! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2019 15:59'!beDraggable	| handle |		handle := self at: #handle.		(Webpage current)		createDragHandleFromElement: (			handle				ifNil: [self]				ifNotNil: [handle])		forElement: self! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 6/17/2017 23:04'!beHidden	self styleAt: #visibility put: 'hidden'! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 6/18/2017 15:42'!beOpaque	self styleAt: #opacity put: 1! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 3/27/2019 16:05'!beResizable	(Webpage current top at: #resizeElement) call: nil with: proxy.	proxy		at: #onresizestart		put: [:event |			self				styleAt: #pointerEvents put: 'none';				startResize];		at: #onresize		put: [:event | self resize];		at: #onresizeend		put: [:event |			self				endResize;				styleAt: #pointerEvents put: 'all'.							Webpage focus]! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 6/17/2017 23:04'!beTransparent	self styleAt: #opacity put: 0! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 9/6/2017 23:04'!beVisible	self		styleAt: #visibility put: 'visible';		beOpaque! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 3/28/2019 17:40'!body	| selection |		selection := self.		[selection class == HTMLBodyElement or: [selection class == nil]] whileFalse: [selection := selection parentNode].	^selection! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 4/10/2018 17:56'!dimensionAt: dimension put: number	self styleAt: dimension put: number asString, 'px'! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 6/24/2017 16:33'!dragWith: element	{self. element. self canvas} do: [:thing | thing beVisible; beOpaque].	JQuery		createDragHandleFromElementNamed: element id		forElementNamed: self id! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2019 14:42'!dragWithMoveButton	self dragWith: self tray moveButton! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 3/27/2019 16:34'!endResize	[		(Delay forMilliseconds: 500) wait.		Webpage containingFrame beOpaque	]		fork! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 3/30/2019 14:53'!eventHandlerAt: eventName put: block	self at: eventName put: block! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2019 14:42'!hideTray	self tray beTransparent! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2019 14:03'!id: id	self at: #id put: id! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 9/18/2017 15:14'!innerHTML: string	self at: #innerHTML put: string! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2019 14:08'!innerText: string	self at: #innerText put: string! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 4/14/2018 00:24'!isVisible	^(self styleAt: #visibility) = 'visible'! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 6/21/2017 14:37'!left	^((self styleAt: #left) asString copyWithout: 'px') asNumber! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 4/10/2018 17:58'!left: left	self dimensionAt: #left put: left! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2019 14:43'!moveButton	^self tray proxy moveButton counterpart! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 4/13/2018 14:46'!offset: offset	self position: (self position + offset)! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 3/30/2019 14:54'!onClick: block	^self eventHandlerAt: #onclick put: block! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 3/30/2019 14:54'!onClose: oneParameterBlock	self eventHandlerAt: #onclose put: oneParameterBlock! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 3/30/2019 14:54'!onContextMenu: oneParameterBlock	self eventHandlerAt: #oncontextmenu put: oneParameterBlock! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 9/10/2019 23:53'!onKeyDown: block	^self addEventListener: 'keydown' with: block! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 9/10/2019 23:53'!onKeyPress: block	^self addEventListener: 'keypress' with: block! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 3/30/2019 14:55'!onMouseDown: oneParameterBlock	self eventHandlerAt: #onmousedown put: oneParameterBlock! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 3/30/2019 14:55'!onMouseEnter: oneParameterBlock	self eventHandlerAt: #onmouseenter put: oneParameterBlock! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 3/30/2019 14:56'!onMouseLeave: oneParameterBlock	self eventHandlerAt: #onmouseleave put: oneParameterBlock! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 3/30/2019 14:56'!onMouseMove: oneParameterBlock	self eventHandlerAt: #onmousemove put: oneParameterBlock! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 3/30/2019 14:56'!onMouseUp: oneParameterBlock	self eventHandlerAt: #onmouseup put: oneParameterBlock! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 8/12/2017 17:11'!opacity: opacity	self styleAt: #opacity put: opacity! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 6/21/2017 14:34'!position	^self left @ self top! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 4/10/2018 18:05'!position: point	self		beHidden;		left: point x;		top: point y;		beVisible! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 3/28/2019 17:41'!raise	self body children do: [:child | child styleAt: #zIndex put: 0].	self styleAt: #zIndex put: 1! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 8/18/2017 14:27'!remove	self parentNode ifNotNilDo: [:parent | parent removeChild: self]! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 3/27/2019 14:59'!resize	Webpage resize! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2019 14:43'!showTray	self tray beVisible! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 3/27/2019 17:06'!startResize	[		| containingFrame transition |		containingFrame := Webpage containingFrame.	transition := containingFrame styleAt: #transition.		containingFrame		styleAt: #transition put: '';		beTransparent.			(Delay forMilliseconds: 500) wait.		containingFrame styleAt: #transition put: transition	]		fork! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 6/21/2017 14:38'!styleAt: key	^self style at: key! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 4/1/2019 16:46'!styleAt: key put: value	self style ifNotNilDo: [:it | it at: key put: value]! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 6/21/2017 14:34'!top	^((self styleAt: #top) copyWithout: 'px') asNumber! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 4/10/2018 17:59'!top: top	self dimensionAt: #top put: top! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2019 13:57'!tray	| tray |		tray := proxy at: #tray.	tray ifNil: [		tray := (			(Webpage current createDiv)				at: #id put: 'Morphic-tray-', (self id reversed readStream upTo: $-) reversed;				styleAt: #transition put: 'opacity 500ms';				styleAt: #userSelect put: 'none';				styleAt: #userDrag put: 'none';				styleAt: #borderRadius put: '10px';				styleAt: #position put: 'absolute';				styleAt: #backgroundColor put: 'rgba(200, 200, 200, 0.7)';				styleAt: #width put: 23;				styleAt: #top put: '0px';				styleAt: #left put: '-28px';				styleAt: #right put: '0px';				yourself).			self at: #tray put: tray.		self appendChild: tray].		^tray counterpart! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 16:49'!windowize	Webpage current windowizeElement: self closingWith: []! !!HTMLElement methodsFor: 'as yet unclassified' stamp: 'crl 4/2/2019 12:06'!windowizeClosingWith: block	(Webpage current)		windowizeElement: self		closingWith: block! !!HTMLElement methodsFor: 'events' stamp: 'crl 9/10/2019 23:54'!onKeyUp: block	^self addEventListener: 'keyup' with: block! !!HTMLElement class methodsFor: 'as yet unclassified' stamp: 'crl 9/18/2017 16:39'!new	^Webpage current createElement: self tag! !!HTMLElement class methodsFor: 'as yet unclassified' stamp: 'crl 9/18/2017 16:38'!tag	^self subclassResponsibility! !!HTMLSpanElement methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!HTMLSpanElement class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!ThreadSafeRandom class methodsFor: 'as yet unclassified' stamp: 'ul 12/11/2014 02:46'!default	^self value: Random new! !!ThreadSafeRandom class methodsFor: 'as yet unclassified' stamp: 'ul 12/11/2014 02:44'!next	^self value next! !!ThreadSafeRandom class methodsFor: 'as yet unclassified' stamp: 'ul 12/11/2014 02:45'!next: anInteger	^self value next: anInteger! !!ThreadSafeRandom class methodsFor: 'as yet unclassified' stamp: 'ul 12/11/2014 02:45'!next: anInteger into: anArray	^self value next: anInteger into: anArray! !!ThreadSafeRandom class methodsFor: 'as yet unclassified' stamp: 'ul 12/11/2014 02:45'!nextInt: anInteger	^self value nextInt: anInteger! !!ExtendedNumberParser class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!AbsoluteDuration methodsFor: 'as yet unclassified' stamp: 'crl 3/5/2006 23:32'!* aNumber	"Answer the result of multiplying myself by aNumber."	^self class fromSubframes: ((self totalSubframes) * aNumber)! !!AbsoluteDuration methodsFor: 'as yet unclassified' stamp: 'crl 3/5/2006 23:07'!+ aSMPTEDuration	^self applyAbsoluteDuration: aSMPTEDuration! !!AbsoluteDuration methodsFor: 'as yet unclassified' stamp: 'crl 3/5/2006 23:07'!, anObject	^anObject applyAbsoluteDuration: self! !!AbsoluteDuration methodsFor: 'as yet unclassified' stamp: 'crl 3/10/2006 15:16'!- anAbsoluteDuration	"Answer the difference between myself and anAbsoluteDuration, in subframes."	^self totalSubframes - anAbsoluteDuration totalSubframes! !!AbsoluteDuration methodsFor: 'as yet unclassified' stamp: 'crl 8/28/2017 20:59'!/ object	"Answer the result of dividing myself by object."	^object dividing: self! !!AbsoluteDuration methodsFor: 'as yet unclassified' stamp: 'crl 8/29/2017 10:37'!< duration	^self totalSubframes < duration totalSubframes! !!AbsoluteDuration methodsFor: 'as yet unclassified' stamp: 'crl 1/10/2008 00:26'!= anObject	^self asSeconds = anObject asSeconds! !!AbsoluteDuration methodsFor: 'as yet unclassified' stamp: 'crl 7/23/2003 13:22'!adaptToFloat: aFloat andSend: selector	"Answer the result of performing selector with aFloat."	^aFloat perform: selector with: seconds! !!AbsoluteDuration methodsFor: 'as yet unclassified' stamp: 'crl 7/23/2003 13:22'!adaptToInteger: anInteger andSend: selector	"Answer the result of performing selector with anInteger."	^anInteger perform: selector with: seconds! !!AbsoluteDuration methodsFor: 'as yet unclassified' stamp: 'crl 3/5/2006 23:15'!addSubframes: numberOfSubframes	subframes _ subframes + numberOfSubframes.	self normalize! !!AbsoluteDuration methodsFor: 'as yet unclassified' stamp: 'crl 7/28/2003 16:43'!appliedTo: anObject	"Answer anObject after applying myself to it."	^anObject applyAbsoluteDuration: self! !!AbsoluteDuration methodsFor: 'as yet unclassified' stamp: 'crl 6/7/2011 02:53'!applyAbsoluteDuration: anAbsoluteDuration	^(self class) fromSeconds: (self asSeconds + anAbsoluteDuration asSeconds)! !!AbsoluteDuration methodsFor: 'as yet unclassified' stamp: 'crl 9/17/2005 02:04'!applyScaleDegree: aScaleDegree	^(Note withDegree: aScaleDegree), self! !!AbsoluteDuration methodsFor: 'as yet unclassified' stamp: 'crl 6/18/2006 01:18'!asSeconds	^seconds + (frames / 30) + (subframes / 3000)! !!AbsoluteDuration methodsFor: 'as yet unclassified' stamp: 'crl 8/28/2017 20:57'!dividedByNumber: number	^self class fromSubframes: ((self totalSubframes) // number)! !!AbsoluteDuration methodsFor: 'as yet unclassified' stamp: 'crl 8/28/2017 21:03'!dividing: absoluteDuration	^absoluteDuration totalSubframes / self totalSubframes! !!AbsoluteDuration methodsFor: 'as yet unclassified' stamp: 'crl 3/5/2006 23:14'!frames	^frames! !!AbsoluteDuration methodsFor: 'as yet unclassified' stamp: 'crl 3/5/2006 23:15'!frames: twentyNineOrLess subframes: ninetyNineOrLess	frames _ twentyNineOrLess.	subframes _ ninetyNineOrLess! !!AbsoluteDuration methodsFor: 'as yet unclassified' stamp: 'crl 3/6/2006 00:19'!in	"Answer a timepoint with my magnitude."	^AbsoluteTimepoint		fromSeconds: seconds		andFrames: frames		andSubframes: subframes! !!AbsoluteDuration methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2017 15:28'!isAbsolute	^true! !!AbsoluteDuration methodsFor: 'as yet unclassified' stamp: 'crl 12/18/2007 23:59'!normalize	((seconds > 0) and: [seconds < 1]) ifTrue: [		subframes _ (subframes + (seconds * 3000)) rounded.		seconds _ 0].	frames _ frames + (subframes // 100).	seconds _ seconds + (frames // 30).	frames _ frames \\ 30.	subframes _ subframes \\ 100! !!AbsoluteDuration methodsFor: 'as yet unclassified' stamp: 'crl 8/29/2017 19:01'!printOn: stream	| hasFractionalSeconds |	hasFractionalSeconds _ seconds isInteger not or: [(frames > 0) or: [subframes > 0]].	(seconds > 0)		ifTrue: [self printIntervalOn: stream]		ifFalse: [hasFractionalSeconds ifFalse: [^stream nextPutAll: 'no time at all']].	hasFractionalSeconds ifTrue: [		| milliseconds |		milliseconds _ seconds - seconds truncated + ((frames / 30) + (subframes / 3000)) * 1000.		(seconds > 0) ifTrue: [stream nextPutAll: ', '].		stream			print: milliseconds rounded;			nextPutAll: ' milliseconds']! !!AbsoluteDuration methodsFor: 'as yet unclassified' stamp: 'crl 3/6/2006 00:21'!printWithSMPTETermsOn: aStream	(seconds > 0) ifTrue: [self printIntervalOn: aStream].	(frames > 0) ifTrue: [		(seconds > 0) ifTrue: [aStream nextPutAll: ', '].		aStream			print: frames;			nextPutAll: ' frame'.		frames = 1 ifFalse: [aStream nextPut: $s]].	(subframes > 0) ifTrue: [		((seconds > 0) or: [frames > 0]) ifTrue: [aStream nextPutAll: ', '].		aStream			print: subframes;			nextPutAll: ' subframe'.		subframes = 1 ifFalse: [aStream nextPut: $s]]! !!AbsoluteDuration methodsFor: 'as yet unclassified' stamp: 'crl 3/5/2006 23:36'!storeOn: aStream	| totalSubframes |	totalSubframes _ self totalSubframes.	aStream		print: totalSubframes;		nextPutAll: ' subframe'.	totalSubframes > 1 ifTrue: [aStream nextPut: $s]! !!AbsoluteDuration methodsFor: 'as yet unclassified' stamp: 'crl 3/5/2006 23:15'!subframes	^subframes! !!AbsoluteDuration methodsFor: 'as yet unclassified' stamp: 'crl 8/29/2017 12:37'!totalMilliseconds	^(seconds * 1000) + (((frames / 30) + (subframes / 3000)) * 1000)! !!AbsoluteDuration methodsFor: 'as yet unclassified' stamp: 'crl 3/5/2006 23:15'!totalSubframes	^(seconds * 3000) + (frames * 100) + subframes! !!AbsoluteDuration methodsFor: 'as yet unclassified' stamp: 'crl 9/13/2012 19:28'!wait	(Delay forMilliseconds: self totalMilliseconds) wait! !!AbsoluteDuration class methodsFor: 'as yet unclassified' stamp: 'crl 3/5/2006 23:28'!fromSeconds: seconds	^self		fromSeconds: seconds		andFrames: 0		andSubframes:0! !!AbsoluteDuration class methodsFor: 'as yet unclassified' stamp: 'crl 3/5/2006 23:05'!fromSeconds: seconds andFrames: frames andSubframes: subframes	^(		(super fromSeconds: seconds)			frames: frames			subframes: subframes	)		normalize! !!AbsoluteDuration class methodsFor: 'as yet unclassified' stamp: 'crl 3/5/2006 23:32'!fromSubframes: subframes	^self		fromSeconds: 0		andFrames: 0		andSubframes: subframes! !!Point methodsFor: 'as yet unclassified' stamp: 'crl 5/31/2017 18:50'!asJSPoint	^JSPoint fromPoint: self! !!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'crl 3/13/2019 22:08'!defuse	<primitive: 'defuseMethod' module: 'Flow'>	^self primitiveFailed! !!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'crl 3/20/2019 16:23'!edition	^self id edition! !!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'crl 3/26/2019 11:09'!fuse	<primitive: 'fuseMethod' module: 'Flow'>	JS ifConnected: [		"This primitive is not available on non-JS platforms yet."		self primitiveFailed]! !!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'crl 3/20/2019 13:53'!id	^MethodID		forMethodAt: self selector		inActiveClass: self methodClass! !!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'crl 3/13/2019 22:09'!isFused	<primitive: 'isMethodFused' module: 'Flow'>	^self primitiveFailed! !!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'crl 3/26/2019 15:33'!selectors	^self literals select: [:literal | literal class == ByteSymbol]! !!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 15:10'!setAsReloadingMethod	<primitive: 'setReloadingMethodHeader' module: 'Flow'>	"This primitive is not available on non-JS platforms yet."	self primitiveFailed! !!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'crl 5/20/2018 23:22'!storeOnTether: tether
	"Store myself on tether in such a way that I may be reconstructed by the peer connected to tether."
	"Override ByteArray."

	(self selector = #DoIt)
		ifTrue: [tether store: nil]
		ifFalse: [
			tether nextWordPut: MethodTag.
			(tether resumeComposingMessageAfter: [self edition]) storeOnTether: tether]! !!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'crl 3/20/2019 14:07'!version	^self		propertyValueAt: #version		ifAbsent: [self propertyValueAt: #version put: 1]! !!CompiledMethod class methodsFor: 'as yet unclassified'!fromTether: tether 	| edition |		edition := tether next.	^edition		ifNil: [self error: 'No edition for that method.']		ifNotNil: [edition method]! !!LayoutCell class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!PluggableSystemWindowWithLabelButton class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!NoNetworkError methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!NoNetworkError class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!BlockContext methodsFor: 'as yet unclassified' stamp: 'bf 11/25/2014 18:12'!asJSArgument	"converted to JS function by plugin"	^self! !!BlockContext class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!TextRequestor class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!SocketAddressInformation methodsFor: 'as yet unclassified' stamp: 'ikp 6/8/2007 18:20'!addressFamilyName	^#(unspecified local inet4 inet6) at: addressFamily + 1! !!SocketAddressInformation methodsFor: 'as yet unclassified' stamp: 'dtl 6/13/2012 21:31'!connect	| sock |	socketType == SocketTypeStream ifFalse: [^nil].	sock := Socket newTCP: addressFamily.	sock connectTo: socketAddress.	sock waitForConnectionFor: Socket standardTimeout		ifTimedOut: [ConnectionTimedOut signal: 'Cannot connect to ', self printString]		ifRefused: [ConnectionRefused signal: 'Cannot connect to ', self printString].	^sock! !!SocketAddressInformation methodsFor: 'as yet unclassified' stamp: 'ikp 6/8/2007 18:11'!initSocketAddress: aSocketAddress family: familyInteger type: typeInteger protocol: protocolInteger	socketAddress := aSocketAddress.	addressFamily := familyInteger.	socketType := typeInteger.	protocol := protocolInteger.! !!SocketAddressInformation methodsFor: 'as yet unclassified' stamp: 'ikp 6/9/2007 09:52'!listenWithBacklog: backlog	| sock |	(socketType == SocketTypeStream and: [protocol == ProtocolTCP]) ifFalse: [self error: 'cannot listen'].	sock := Socket newTCP: addressFamily.	sock bindTo: socketAddress.	sock listenWithBacklog: 5.	^sock! !!SocketAddressInformation methodsFor: 'as yet unclassified' stamp: 'ikp 6/8/2007 21:54'!printOn: aStream	aStream		print: socketAddress;		nextPut: $-; nextPutAll: self addressFamilyName;		nextPut: $-; nextPutAll: self socketTypeName;		nextPut: $-; nextPutAll: self protocolName! !!SocketAddressInformation methodsFor: 'as yet unclassified' stamp: 'ikp 6/8/2007 18:20'!protocolName	^#(unspecified tcp udp) at: socketType + 1! !!SocketAddressInformation methodsFor: 'as yet unclassified' stamp: 'ikp 6/9/2007 08:35'!socketAddress	^socketAddress! !!SocketAddressInformation methodsFor: 'as yet unclassified' stamp: 'ikp 6/8/2007 18:20'!socketTypeName	^#(unspecified stream dgram) at: socketType + 1! !!SocketAddressInformation class methodsFor: 'as yet unclassified' stamp: 'ikp 6/8/2007 22:02'!addressFamilyINET4	^AddressFamilyINET4! !!SocketAddressInformation class methodsFor: 'as yet unclassified' stamp: 'ikp 6/8/2007 22:02'!addressFamilyINET6	^AddressFamilyINET6! !!SocketAddressInformation class methodsFor: 'as yet unclassified' stamp: 'ikp 6/8/2007 22:02'!addressFamilyLocal	^AddressFamilyLocal! !!SocketAddressInformation class methodsFor: 'as yet unclassified' stamp: 'ikp 6/8/2007 22:01'!addressFamilyUnspecified	^AddressFamilyUnspecified! !!SocketAddressInformation class methodsFor: 'as yet unclassified' stamp: 'dtl 6/13/2012 22:14'!forHost: hostName service: servName flags: flags addressFamily: family socketType: type protocol: protocol	| result addr |	PrimitiveAccessProtect critical: [		NetNameResolver initializeNetwork.			NetNameResolver				primGetAddressInfoHost: hostName				service: servName				flags: flags				family: family				type: type				protocol: protocol.			result := OrderedCollection new.			[(addr := NetNameResolver nextSocketAddressInformation) notNil]				whileTrue: [result add: addr]].	^ result! !!SocketAddressInformation class methodsFor: 'as yet unclassified' stamp: 'dtl 6/13/2012 22:15'!initialize	"SocketAddressInformation initialize"	NumericFlag := 1.	PassiveFlag := 2.	AddressFamilyUnspecified := 0.	AddressFamilyLocal := 1.	AddressFamilyINET4 := 2.	AddressFamilyINET6 := 3.	SocketTypeUnspecified := 0.	SocketTypeStream := 1.	SocketTypeDGram := 2.	ProtocolUnspecified := 0.	ProtocolTCP := 1.	ProtocolUDP := 2.	"SocketPlugin maintains internal state across primitive calls, so methods that rely	on the result of sequential primitive calls require concurrency control."	PrimitiveAccessProtect := Semaphore forMutualExclusion.! !!SocketAddressInformation class methodsFor: 'as yet unclassified' stamp: 'ikp 6/9/2007 09:13'!numericFlag	^NumericFlag! !!SocketAddressInformation class methodsFor: 'as yet unclassified' stamp: 'ikp 6/9/2007 09:12'!passiveFlag	^PassiveFlag! !!SocketAddressInformation class methodsFor: 'as yet unclassified' stamp: 'ikp 6/8/2007 22:02'!protocolTCP	^ProtocolTCP! !!SocketAddressInformation class methodsFor: 'as yet unclassified' stamp: 'ikp 6/8/2007 22:02'!protocolUDP	^ProtocolUDP! !!SocketAddressInformation class methodsFor: 'as yet unclassified' stamp: 'ikp 6/8/2007 22:02'!protocolUnspecified	^ProtocolUnspecified! !!SocketAddressInformation class methodsFor: 'as yet unclassified' stamp: 'ikp 6/8/2007 22:02'!socketTypeDGram	^SocketTypeDGram! !!SocketAddressInformation class methodsFor: 'as yet unclassified' stamp: 'ikp 6/8/2007 22:02'!socketTypeStream	^SocketTypeStream! !!SocketAddressInformation class methodsFor: 'as yet unclassified' stamp: 'ikp 6/8/2007 22:02'!socketTypeUnspecified	^SocketTypeUnspecified! !!SocketAddressInformation class methodsFor: 'as yet unclassified' stamp: 'ikp 6/8/2007 18:11'!withSocketAddress: socketAddress family: family type: type protocol: protocol	^self new initSocketAddress: socketAddress family: family type: type protocol: protocol! !!StreamingError methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!StreamingError class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!ChromeServiceWorkerAPI class methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 12:41'!domain	^'ServiceWorker'! !!JSWorldMorph methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSWorldMorph class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!Latin1Environment methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!StaticForm class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:55'!foo! !!Random methodsFor: 'as yet unclassified' stamp: 'sma 5/12/2000 13:42'!check: nDice	"Roll some dice, WoD-style."	^ self check: nDice difficulty: 6! !!Random methodsFor: 'as yet unclassified' stamp: 'sma 5/12/2000 13:47'!check: nAttack against: nDefend	"Roll some dice, WoD-style."	^ self check: nAttack against: nDefend difficulty: 6! !!Random methodsFor: 'as yet unclassified' stamp: 'sma 5/12/2000 13:46'!check: nAttack against: nDefend difficulty: diff	"Roll some dice, WoD-style."	| attacks defends |	attacks := self check: nAttack difficulty: diff.	attacks < 0 ifTrue: [^ attacks].	defends := self check: nDefend difficulty: diff.	^ attacks - defends min: 0! !!Random methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 05:08'!check: nDice difficulty: diff	"Roll some dice, WoD-style."	| result |	result := 0.	nDice timesRepeat: 		[ | die |		(die := self nextInt: 10) = 1			ifTrue: [result := result - 1]			ifFalse: [die >= diff ifTrue: [result := result + 1]]].	^ result! !!Random methodsFor: 'as yet unclassified' stamp: 'sma 5/12/2000 13:48'!diceToken: stream	"Private. Mini scanner, see #roll:"	stream atEnd ifTrue: [^ nil].	stream peek isDigit ifTrue: [^ Number readFrom: stream].	^ stream next asLowercase! !!Random methodsFor: 'as yet unclassified' stamp: 'ul 2/26/2015 21:02'!generateStates	"Generate untempered numbers into the states variable. Split up the operation into three parts to avoid the use of #atWrap: for accessing the states array. Optimized for SmallInteger operations."	| i limit y offset |	"Part 1"	i := 0.	offset := MTm.	limit := MTn - offset.	[ (i := i + 1) <= limit ] whileTrue: [		y := (MTupperMask bitAnd: (states at: i)) bitOr: (MTlowerMask bitAnd: (states at: i + 1)).		states			at: i			put: ((y bitAnd: 1) * MTa bitXor: ((states at: i + offset) bitXor: (y bitShift: -1))) ].	"Part 2"	limit := MTn - 1.	offset := MTm - MTn.	i := i - 1.	[ (i := i + 1) <= limit ] whileTrue: [		y := (MTupperMask bitAnd: (states at: i)) bitOr: (MTlowerMask bitAnd: (states at: i + 1)).		states			at: i			put: ((y bitAnd: 1) * MTa bitXor: ((states at: i + offset) bitXor: (y bitShift: -1))) ].	"Part 3"	y := (MTupperMask bitAnd: (states at: MTn)) bitOr: (MTlowerMask bitAnd: (states at: 1)).	states		at: MTn		put: ((y bitAnd: 1) * MTa bitXor: ((states at: MTm) bitXor: (y bitShift: -1))).	index := 1	! !!Random methodsFor: 'as yet unclassified' stamp: 'ul 2/17/2015 22:56'!hashSeed: anInteger	"Use the 32-bit version of the FNV-1a algorithm to hash the seed, and return a 32-bit unsigned integer."	| fnvPrime hash |	fnvPrime := 16777619 " 32-bit FVN prime ".	hash := anInteger negative		ifTrue: [  3490449840 "  mix in the sign as (2166136261 bitXor: 2r1010101) * 16777619 bitAnd: 16rFFFFFFFF "]		ifFalse: [ 2166136261 " 32-bit FVN offset basis "].	1 to: anInteger digitLength do: [ :index |		hash := 16rFFFFFFFF bitAnd: (hash bitXor: (anInteger digitAt: index)) * fnvPrime ].	^hash! !!Random methodsFor: 'as yet unclassified' stamp: 'ul 2/20/2015 09:41'!initialize		self seed: nil! !!Random methodsFor: 'as yet unclassified' stamp: 'ul 2/20/2015 09:39'!initializeStatesWith: anInteger	"Initialize the states array with the seed."	| seed |	states := Array new: MTn.	seed := anInteger.	1 to: MTn do: [ :i | 		states at: i put: (MTwordMask bitAnd: seed).		seed := 16rFFFFFFFF bitAnd: (16r6C078965 * (seed bitXor: seed //  16r40000000 "bitShift: -30") + i) ]! !!Random methodsFor: 'as yet unclassified' stamp: 'ul 2/20/2015 09:36'!next	"Answer a random 53-bit Float from the [0, 1) interval. The implementation assumes that the MTw parameter is between 27 and 53."		^self nextValue asFloat * MTwFloatMultiplier + (self nextValue bitAnd: MTwFloatMultiplier - 1) / 9.007199254740992e15 "(1 << 53) asFloat"! !!Random methodsFor: 'as yet unclassified' stamp: 'sma 5/12/2000 12:45'!next: anInteger	^ self next: anInteger into: (Array new: anInteger)! !!Random methodsFor: 'as yet unclassified' stamp: 'sma 5/12/2000 12:46'!next: anInteger into: anArray	1 to: anInteger do: [:index | anArray at: index put: self next].	^ anArray! !!Random methodsFor: 'as yet unclassified' stamp: 'ul 2/20/2015 09:35'!nextInt: anInteger	"Answer a random integer value from the interval [1, anInteger]"	| bucketSize retriesLeft |	anInteger strictlyPositive ifFalse: [ self error: 'Range must be positive' ].	(anInteger isLarge 		or: [ anInteger > MTwordMask "In case SmallIntegers have more than MTw-bits, but the generator hasn't been updated accordingly." ]) 		ifTrue: [ ^self nextLargeInt: anInteger ].	"Split the MTw-bit(currently 30-bit) integer range up to the equal sized buckets. Generate an MTw-bit random number, and see which bucket it's in. If it doesn't fit in any bucket, then try again."	bucketSize := MTwordMask // anInteger. "The optimal bucket size would be MTwordMask + 1 // anInteger, but calculating it would involve LargeInteger arithmetic. The MTwordMask // anInteger expression is suboptimal only when anInteger is a power of two. These cases are rare, and the effect is negligible for small values. We could handle these cases separately, but testing if anInteger is a power of two costs more in general."	retriesLeft := 10. "Based on measurements with various seeds, 10 retries is about optimal for the worst case, when anInteger = MTwordMask // 2 + 1."	[ (retriesLeft := retriesLeft - 1) >= 0 ] whileTrue: [		| bucket |		bucket := self nextValue // bucketSize.		bucket < anInteger ifTrue: [ ^bucket + 1 ] ].	"Fall back to the floating point method, which is slower, but when we get here, then we've already spent enough resources on trying to generate the number. Using this fallback also ensures that the method doesn't run for indefinitely long."	^(self next * anInteger) truncated + 1! !!Random methodsFor: 'as yet unclassified' stamp: 'ul 2/20/2015 10:09'!nextLargeInt: anInteger	"Answer a random integer value from the interval [1, anInteger]. This method works for arbitrarily large integers."	| byteCount bigRandom remainder remainingBits i result firstDigit |	byteCount := anInteger digitLength + 4. "Extend the space with at least 32 bits for a fairer distribution."	bigRandom := LargePositiveInteger new: byteCount.	remainder := remainingBits := 0.	i := 1.	[ i <= byteCount ] whileTrue: [		remainingBits >= 8			ifTrue: [				bigRandom digitAt: i put: (remainder bitAnd: 16rFF).				remainder := remainder bitShift: -8.				remainingBits := remainingBits - 8.				i := i + 1 ]			ifFalse: [				remainingBits = 0					ifTrue: [ remainder := self nextValue ]					ifFalse: [						| newRandom |						newRandom := self nextValue.						bigRandom digitAt: i put: (remainder bitShift: 8 - remainingBits) + 							(newRandom bitAnd: (1 bitShift: 8 - remainingBits) - 1).						i := i + 1.						remainder := newRandom bitShift: 0 - remainingBits ].				remainingBits := MTw - remainingBits ] ].	result := anInteger * bigRandom bitShift: -8 * byteCount.	"Avoid using LargeInteger arithmetic for +1 in most cases."	result isLarge ifFalse: [ ^result + 1 ].	(firstDigit := result digitAt: 1) = 255 ifTrue: [ ^result + 1 ].	result digitAt: 1 put: firstDigit + 1.	^result	! !!Random methodsFor: 'as yet unclassified' stamp: 'ul 2/20/2015 09:36'!nextValue	"Answer an MTw-bit random integer between 0 and wordMask, and increment the index."	| y |	y := states at: index.	(index := index + 1) > MTn ifTrue: [ self generateStates ].	y := y bitXor: (y bitShift: MTu).	y := ((y bitAnd: MTbShifted) bitShift: MTs) bitXor: y.	y := ((y bitAnd: MTcShifted) bitShift: MTt) bitXor: y.	y := (y bitShift: MTl) bitXor: y.	^y! !!Random methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 05:08'!roll: diceString	"Roll some dice, DnD-style, according to this mini-grammar:		dice := epxr {pm expr}		pm := '+' | '-'		expr := num | num dD | dD numP | num dD numP		dD := 'd' | 'D'		num := digit+		numP := num | '%'"	| stream op result |	stream := diceString readStream.	result := 0.	op := #+.	[ | res range dice token |	token := self diceToken: stream.	token isNumber		ifTrue: [dice := token.				token := self diceToken: stream]		ifFalse: [token == $d			ifTrue: [dice := 1]			ifFalse: [res := 0]].	token == $d		ifTrue: [token := self diceToken: stream.				token isNumber					ifTrue: [range := token.							token := self diceToken: stream]					ifFalse: [token == $%						ifTrue: [range := 100.								token := self diceToken: stream]						ifFalse: [range := 6]].				res := 0.				dice timesRepeat: [res := res + (self nextInt: range)]].	result := result perform: op with: res.	token ifNil: [^ result].	(token == $+ or: [token == $-])		ifFalse: [self error: 'unknown token ' , token].	op := token asSymbol] repeat! !!Random methodsFor: 'as yet unclassified' stamp: 'ul 2/20/2015 09:39'!seed: anIntegerOrNil	" Use the given integer as seed, or generate one if it's nil. "	| newSeed |	newSeed := anIntegerOrNil ifNil: [		| now |		now := Time primUTCMicrosecondClock.		now = 0 ifTrue: [ now := Time millisecondClockValue ].		(now bitShift: 28) bitXor: self hash hashMultiply ].	(newSeed between: 0 and: 16rFFFFFFFF) ifFalse: [ 		newSeed := self hashSeed: newSeed ].	self 		initializeStatesWith: newSeed;		generateStates! !!Random class methodsFor: 'as yet unclassified' stamp: 'ul 2/17/2015 23:20'!bucketTest: randy	"Execute this:   Random bucketTest: Random new"	" A quick-and-dirty bucket test. Prints nbuckets values on theTranscript.	  Each should be 'near' the value of ntries. Any run with any value'far' from ntries	  indicates something is very wrong. Each run generates differentvalues.	  For a slightly better test, try values of nbuckets of 200-1000 ormore; go get coffee.	  This is a poor test; see Knuth.   Some 'OK' runs:		1000 1023 998 969 997 1018 1030 1019 1054 985 1003		1011 987 982 980 982 974 968 1044 976		1029 1011 1025 1016 997 1019 991 954 968 999 991		978 1035 995 988 1038 1009 988 993 976"	| nbuckets buckets ntrys |	nbuckets := 200.	buckets := Array new: nbuckets.	buckets atAllPut: 0.	ntrys :=  10000.	ntrys*nbuckets timesRepeat: [ | slot |		slot := randy nextInt: nbuckets.		buckets at: slot put: (buckets at: slot) + 1 ].	Transcript cr.	1 to: nbuckets do: [ :nb |		Transcript print: (buckets at: nb); space ].	Transcript flush! !!Random class methodsFor: 'as yet unclassified' stamp: 'ul 2/26/2015 21:23'!initialize	"30-bit MT521 parameters. generated with a modified version of dcmt with ID=1. http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/DC/dc.html"	"Base parameters"	"MTp := 521. Not used directly."	MTw := 30.	MTm := 9.	MTa := 16r3235DEE2.	"MTb := 16r39BB2B00. Not used directly."	"MTc := 16r3EFD0000. Not used directly."	MTl := -18.	MTu := -12.	MTs := 7.	MTt := 15.	"Calculated parameters"	MTn := 18.	"MTr := 19. Not used directly."	MTupperMask := 16r3FF80000.	MTlowerMask := 16r7FFFF.	MTwordMask := 16r3FFFFFFF.	MTbShifted := 7566934.	MTcShifted := 32250.	MTwFloatMultiplier := 8388608! !!Random class methodsFor: 'as yet unclassified' stamp: 'ul 2/19/2015 18:40'!seed: anInteger	^self basicNew seed: anInteger! !!BottomRightGripMorph class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!PluggableListSpec class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!ChangeSetBrowser class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!LargePositiveInteger methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 19:47'!storeOnTether: tether
	| remainder |
	
	remainder := self.
	
	tether
		nextWordPut: LargePositiveIntegerTag;
		nextPutByte: self size.
		
	[remainder > 0] whileTrue: [
		tether nextPut: (remainder bitAnd: 255).
		remainder := remainder bitShift: -8]! !!LargePositiveInteger class methodsFor: 'as yet unclassified' stamp: 'crl 3/19/2019 12:46'!fromTether: tether	| answer shift |		answer := shift := 0.	tether nextByte timesRepeat: [		answer := answer + (tether nextByte bitShift: shift).		shift := shift + 8].		^ answer! !!WebSocket07 methodsFor: 'as yet unclassified' stamp: 'ar 10/5/2011 19:46'!readFrameFrom: aStream	"Reads one frame worth of data"	| byte length final mask opcode payload |	byte := (aStream next ifNil:[^nil]) asInteger.	final := byte anyMask: 128.	opcode := byte bitAnd: 15.	byte := (aStream next ifNil:[^nil]) asInteger.	mask := byte anyMask: 128.	length := byte bitAnd: 127.	length = 126 ifTrue:[		length := self nextNumber: 2 from: aStream.	] ifFalse:[		length = 127 ifTrue:[length := self nextNumber: 8 from: aStream].	].	mask 		ifTrue:[mask := aStream next: 4] 		ifFalse:[mask := nil].	payload := ByteArray new: length.	aStream next: length into: payload.	"Unmask payload"	mask ifNotNil:[self xor: payload with: mask].	"First see if this is a control frame which can be inserted into fragmented messages."	opcode >= 8 ifTrue:[^self handleControl: payload type: opcode].	"Now see if this is a fragmented message"	frameType ifNil:[		frameType := opcode.		frameData := Array with: payload.	] ifNotNil:[		frameData := frameData copyWith: payload.	].	final ifTrue:[		"This was the final fragment"		frameData size = 1 ifTrue:[			payload := frameData first		] ifFalse:[			payload := frameData allButFirst 							inject: frameData first 							into:[:each :next| each, next].		].		frameType = 1 ifTrue:[payload := payload asString utf8ToSqueak].		self handleMessage: payload type: frameType.		frameType := frameData := nil.	].! !!WebSocket07 methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 13:50'!run	"Run the WebSocket's input process."	[		[			[stream isConnected] whileTrue: [self readFrame]		]			on: Error			do: [:exception | self handleError: exception]	]		ensure: [			[stream socket destroy]				on: Error				do: [:exception | ].						self handleClose]! !!WebSocket07 class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!SnowglobeDemo methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!SnowglobeDemo class methodsFor: 'as yet unclassified' stamp: 'crl 1/2/2018 21:57'!appID	^'f5720a3b-b933-41eb-a063-fc61d6294ea1'! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/14/2016 20:50'!= aMethodEdition
	^super = aMethodEdition and: [instructions = aMethodEdition instructions and: [literalMarkers = aMethodEdition literalMarkers]]! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/9/2016 23:53'!abstractPCForConcretePC: concretePC	"Answer the abstractPC matching concretePC."	| abstractPC scanner client endPC |	self flag: 'belongs in DebuggerMethodMap?'.	abstractPC := 1.	scanner := InstructionStream on: self.	client := InstructionClient new.	"cache endPC for methods with embedded source; finding out the endPC is very slow in this case..."	endPC := self endPC.	[(scanner pc > endPC	  or: [scanner pc >= concretePC]) ifTrue:		[^abstractPC].	 abstractPC := abstractPC + 1.	 scanner interpretNextInstructionFor: client] repeat! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 6/23/2008 14:40'!activeClass	"Answer the class to which I refer, or nil if it's not currently active."	^classEdition activeClass! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/12/2016 14:35'!activeClassObject	"Answer the class to which I refer, or nil if it's not currently active."	^classEdition activeClassObject! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/30/2008 15:24'!adds	^instructions ~~ nil! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 19:06'!allLiterals	^literalMarkers collect: [:marker | marker literal]! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 16:45'!at: pc	^(self instructionsFrom: instructions forVersion: headerVersion) at: pc - initialPC + 1! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 1/17/2008 23:21'!authorID	^self methodAuthorID! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2016 18:01'!basicHeader	^(largeFrameNeeded bitShift: 17) + (numberOfTemporaries bitShift: 18) + (numberOfParameters bitShift: 24)! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2008 18:29'!classEdition	"Answer the edition for the class indicated in my ID."	^classEdition! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2008 18:29'!classEdition: aClassEdition	classEdition := aClassEdition! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/3/2008 16:59'!classID	"Answer the class ID part of my ID."	^id classID! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/1/2016 22:11'!className	^self classID edition name! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/9/2016 23:24'!debuggerMap	^DebuggerMethodMap forMethod: self! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/31/2008 14:25'!editionWithID: aMethodID	^(id = aMethodID)		ifTrue: [self]		ifFalse: [			previousEdition				ifNil: [nil]				ifNotNil: [previousEdition editionWithID: aMethodID]]! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/9/2016 23:34'!encoderClass	"Answer the encoder class that encoded the bytecodes in this method.	 The sign flag bit is used by the VM to select a bytecode set.  This formulation	 may seem odd but this has to be fast, so no property probe unless needed."	^self header >= 0		ifTrue: 			[EncoderForV3PlusClosures]		ifFalse:			[EncoderForV3PlusClosures == EncoderForV3PlusClosures				ifTrue: "Support for testing prior to installing another set"					[(self propertyValueAt: #encoderClass) ifNil: [EncoderForV3PlusClosures]]				ifFalse:					[EncoderForV3PlusClosures]]! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 15:15'!endPC	^endPC! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/12/2016 14:35'!flushCache	| activeClass |		activeClass := self activeClassObject.	activeClass ifNotNil: [		| method |				method := activeClass compiledMethodAt: self selector ifAbsent: [nil].		method ifNotNil: [method flushCache]]! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 17:23'!getSourceFor: selector in: self	^source! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 19:23'!hasLiteralThorough: literal	"Answer true if any literal in this method is literal,	even if embedded in array structure."	(self penultimateLiteral isMethodProperties	 and: [self penultimateLiteral hasLiteralThorough: literal]) ifTrue:[^true].	2 to: self numLiterals - 1 "exclude superclass + selector/properties"	   do:[:index | | lit |		(((lit := self objectAt: index) literalEqual: literal)		 or: [(lit isVariableBinding and: [lit key == literal])		 or: [lit isArray and: [lit hasLiteral: literal]]]) ifTrue:			[^ true]].	^ false ! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 16:43'!header	^self headerForVersion: headerVersion! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2016 18:05'!headerForVersion11	^(primitive bitAnd: 2r111111111) + (numberOfLiterals bitShift: 9) + ((primitive bitAt: 10) bitShift: 28) + self basicHeader! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2016 18:06'!headerForVersion12	^numberOfLiterals + (((primitive > 0) ifTrue: [1] ifFalse: [0]) bitShift: 16) + self basicHeader! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2016 18:03'!headerForVersion: desiredVersion	^(desiredVersion = 11)		ifTrue: [self headerForVersion11]		ifFalse: [			(desiredVersion = 12)				ifTrue: [self headerForVersion12]				ifFalse: [self error: 'unsupported method header version']]! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2016 17:48'!headerVersion	^self class headerVersion! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2016 18:14'!headerVersion: headerVersionInteger instructions: aByteArray literalMarkers: anArray header: headerWord primitive: primitiveInteger initialPC: initialPCSixteenBits endPC: endPCSixteenBits source: aString classEdition: aClassEdition	headerVersion := headerVersionInteger.	instructions := aByteArray.	literalMarkers := anArray.	initialPC := initialPCSixteenBits.	endPC := endPCSixteenBits.	primitive := primitiveInteger.	largeFrameNeeded := (headerWord bitShift: -17) bitAnd: 1.	numberOfTemporaries := (headerWord bitShift: -18) bitAnd: 2r111111.	numberOfParameters := (headerWord bitShift: -24) bitAnd: 16rF.	numberOfLiterals := (		(headerVersion = 11)			ifTrue: [(headerWord bitShift: -9) bitAnd: 16rFF]			ifFalse: [headerWord bitAnd: 2r111111111111111]).	source := aString.	classEdition := aClassEdition! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 15:15'!initialPC	^initialPC! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/14/2016 20:53'!initialize
	super initialize.
	numberOfLiterals := 0! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/26/2019 21:42'!install	"Install the method I prescribe in the local system, installing additional prerequisite editions if necessary."	| class selector protoclass |	selector := self selector.	"If I have no class edition, then there's no way to to check if my instructions are compatible with the format of a class in which we'd like to install them. That's very dangerous, of course."	class := classEdition activeClassObject.	(class == nil) ifTrue: [		JS break: 'missing class: ', classEdition name.		"The exact version of the class for which I'm intended is not installed locally. There might be no version of it installed at all, a wildly different one, or a very similar one. In the future we'll probably have behavior for taking different actions in each of those situations. For now, just install the precise class edition regardless of what was installed before."		classEdition install.		class := classEdition activeClass		class == nil ifTrue: [self error: 'class not found']].	"Ensure that every object mentioned by my literals is installed."	literalMarkers do: [:marker | marker attach].	protoclass := class theNonMetaClass.	class		addSelector: selector		withMethod: (			(self method)				literalAt: (numberOfLiterals - 1)				put: selector;				literalAt: numberOfLiterals				put: (					(class isMeta)						ifTrue: [nil -> class]						ifFalse: [Smalltalk associationAt: class name]);				yourself).	"class organization classify: selector under: #unclassified logged: false.	EditHistory activateMethodEdition: self"! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/14/2016 20:50'!instructions
	^instructions! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 22:37'!instructionsFrom: instructions forVersion: desiredVersion	^(headerVersion = desiredVersion)		ifTrue: [instructions]		ifFalse: [			(desiredVersion = 11)				ifTrue: [					(primitive > 0)						ifTrue: [instructions copyFrom: 4 to: instructions size]						ifFalse: [instructions]]				ifFalse: [					(desiredVersion = 12)						ifTrue: [							| localInstructions |														localInstructions := (ByteArray new) writeStream.							(primitive > 0) ifTrue: [								localInstructions									nextPut: 139;									nextPut: (primitive bitAnd: 16rFF);									nextPut: (primitive bitShift: -8)].							localInstructions								nextPutAll: instructions;								contents]						ifFalse: [self error: 'unsupported method header format']]]! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/9/2016 23:52'!isBlueBookCompiled	"Answer whether the receiver was compiled using the old Smalltalk-80 blocks	 compiler.  This is used to help DebuggerMethodMap choose which mechanisms	 to use to inspect (debug) activations of the receiver."	^self encoderClass supportsClosures not! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 15:15'!isQuick	"Answer whether the receiver is a quick return (of self or of an instance 	variable)."	^ self primitive between: 256 and: 519! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 16:55'!isReturnField	"Answer whether the receiver is a quick return of an instance variable."	^ self primitive between: 264 and: 519! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 19:08'!literalAt: index	^(literalMarkers at: index) literal! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/1/2016 10:37'!literalMarkers	^literalMarkers! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2016 18:04'!localHeaderVersion	^self class localHeaderVersion! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 19:08'!messages	"Answer a Set of all the message selectors sent by this method."	| scanner aSet |	aSet := Set new.	scanner := InstructionStream on: self.	scanner			scanFor: 			[:x | 			scanner addSelectorTo: aSet.			false	"keep scanning"].	^aSet! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/14/2016 19:46'!method	"Answer the method I prescribe in the local system."	| method localInstructions |	localInstructions := self instructionsFrom: instructions forVersion: self localHeaderVersion.	method := (		CompiledMethod			newMethod: (localInstructions size + 1)			header: (self headerForVersion: self localHeaderVersion)).	1		to: literalMarkers size		do: [:literalIndex |			method				literalAt: literalIndex				put: (literalMarkers at: literalIndex) literal].	^method		selector: self selector;		methodClass: self activeClass;		replaceFrom: initialPC		to: initialPC + localInstructions size - 1		with: localInstructions;		yourself! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 11/5/2014 11:36'!methodAuthor: anAuthorEdition	author := anAuthorEdition.	id methodAuthorID: anAuthorEdition id! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 1/17/2008 23:20'!methodAuthorID	^id methodAuthorID! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 17:44'!methodClass	^classEdition! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/9/2016 23:34'!methodNode	"Return the parse tree that represents self. If parsing fails, decompile the method."	| aClass |	aClass := self methodClass.	^[(Parser new		encoderClass: self encoderClass;		parse: source class: aClass)			sourceText: source;			yourself]		on: SyntaxErrorNotification		do: [:ex | ex return: self decompileWithTemps]! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 18:57'!methodReference	| class selector |	class := self methodClass ifNil: [^nil].	selector := self selector ifNil: [^nil].	^MethodReference		class: classEdition		selector: selector		environment: EditHistory local! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 6/1/2007 00:24'!methodVersion	^id methodVersion! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/31/2008 12:55'!methodVersion: sixteenBits	^id methodVersion: sixteenBits! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 19:26'!numLiterals	^numberOfLiterals! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 19:26'!objectAt: index	^(literalMarkers at: index - 1) literal! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/9/2016 23:53'!pcPreviousTo: thePC	"Answer the pc of the bytecode before the bytecode at thePC."	| pc prevPc byte encoderClass |	self flag: 'belongs in DebuggerMethodMap?'.	thePC > self endPC ifTrue: [^self endPC].	pc := self initialPC.	encoderClass := self encoderClass.	[pc < thePC] whileTrue:		[byte := self at: (prevPc := pc).		 [pc := pc + (encoderClass bytecodeSize: byte).		  encoderClass isExtension: byte] whileTrue:			[byte := self at: pc]].	^prevPc! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 19:25'!penultimateLiteral	^self selector! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 19:07'!pragmas	^#()! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/31/2008 00:04'!previousAddingEditionWithID: aMethodID	^previousEdition		ifNil: [nil]		ifNotNil: [			(previousEdition adds and: [previousEdition id = aMethodID])				ifTrue: [previousEdition]				ifFalse: [previousEdition previousAddingEditionWithID: aMethodID]]! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 15:15'!primitive	^primitive! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/16/2011 01:26'!printComponentNameOn: aStream withOuterAuthor: anAuthorEdition	| outerAuthor |	outerAuthor := (		anAuthorEdition			ifNil: [author]			ifNotNil: [anAuthorEdition]).	(self adds)		ifTrue: [			aStream				nextPutAll: 'method "';				nextPutAll: self selector;				nextPutAll: '", version ';				print: self version;				nextPutAll: ' by ';				print: author.			aStream nextPutAll: ', in '.			classEdition printComponentNameOn: aStream withOuterAuthor: outerAuthor]		ifFalse: [			(self removes)				ifTrue: [					aStream nextPutAll: 'the removal of '.					previousEdition printComponentNameOn: aStream withOuterAuthor: outerAuthor]				ifFalse: [					aStream nextPutAll: 'the reinstatement of '.					(self previousAddingEditionWithID: id) printComponentNameOn: aStream withOuterAuthor: outerAuthor]]! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 15:14'!readsField: varIndex 	"Answer whether the receiver loads the instance variable indexed by the  argument."	| varIndexCode scanner |	varIndexCode := varIndex - 1.	self isQuick ifTrue:		[^self isReturnField and: [self returnField = varIndexCode]].	scanner := InstructionStream on: self.	^scanner scanFor:(self encoderClass instVarReadScanBlockFor: varIndexCode using: scanner)! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/31/2008 14:21'!removes	^self adds not! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 16:55'!returnField	"Answer the index of the instance variable returned by a quick return 	method."	| prim |	prim := self primitive.	prim < 264		ifTrue: [self error: 'only meaningful for quick-return']		ifFalse: [^ prim - 264]! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 5/31/2007 17:18'!selector	^id selector! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 11/10/2007 23:52'!source	^source! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/12/2016 00:42'!source: aString	source := aString! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 15:51'!storeOnTether: tether	super storeOnTether: tether.	(self adds)		ifTrue: [			tether				store: instructions;				store: classEdition;				nextPutByte: headerVersion;				store: literalMarkers;				nextWordPut: (self headerForVersion: headerVersion);				next16BitsPut: primitive;				next16BitsPut: initialPC;				next16BitsPut: endPC;				store: source]		ifFalse: [tether store: nil]! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 16:15'!tag	^MethodEditionTag! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 18:57'!theNonMetaClass	^classEdition theNonMetaClass! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/10/2016 11:53'!timeStamp	| stamp authorStream |		stamp := (String new: 18) writeStream.	authorStream := self author name readStream.		[authorStream atEnd] whileFalse: [		stamp nextPut: authorStream next.		authorStream upTo: Character space].		^stamp		space;		print: (TimeStamp fromSeconds: timestamp);		contents! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 6/1/2007 00:24'!version	^self methodVersion! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/31/2008 17:47'!version: sixteenBits	^self methodVersion: sixteenBits! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 18:23'!writesField: varIndex	"Answer whether the receiver stores into the instance variable indexed	 by the argument."	| scanner |	self isQuick ifTrue: [^false].	scanner := InstructionStream on: self.	^scanner scanFor: (self encoderClass instVarWriteScanBlockFor: varIndex - 1 using: scanner)! !!MethodEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/30/2008 16:32'!yourselfAndAllPriorEditions	| editions edition |	editions := OrderedCollection new.	edition := self.	[edition == nil] whileFalse: [		edition removes ifFalse: [editions add: edition].		edition := edition previousEdition].	^editions asArray reversed	! !!MethodEdition class methodsFor: 'as yet unclassified' stamp: 'crl 9/30/2016 09:36'!fromTether: tether	| edition instructions |	edition := super fromTether: tether.	instructions := tether next.	instructions ifNotNil: [		| classEdition |		classEdition := tether next.		EditHistory residesLocally ifTrue: [			"If I'm in a history memory, fix the class edition to be the equivalent instance we already have, if any."			| existingClassEdition |			existingClassEdition := EditHistory classEditionWithID: classEdition id.			existingClassEdition ifNotNil: [classEdition := existingClassEdition]].		edition			headerVersion: tether nextByte			instructions: instructions						literalMarkers: tether next			header: tether nextWord			primitive: tether next16Bits			initialPC: tether next16Bits			endPC: tether next16Bits			source: tether next			classEdition: classEdition].	^edition! !!MethodEdition class methodsFor: 'as yet unclassified' stamp: 'crl 10/13/2016 16:17'!initialize    "CompiledMethod initialize"	"Initialize class variables specifying the size of the temporary frame	needed to run instances of me."	SmallFrame := 16.	"Context range for temps+stack"	LargeFrame := 56.	PrimaryBytecodeSetEncoderClass ifNil:		[PrimaryBytecodeSetEncoderClass := EncoderForV3PlusClosures].	SecondaryBytecodeSetEncoderClass ifNil:		[SecondaryBytecodeSetEncoderClass := EncoderForV3PlusClosures]! !!MethodEdition class methodsFor: 'as yet unclassified' stamp: 'crl 3/20/2019 17:29'!localHeaderVersion	^11! !!MorphicToolBuilder methodsFor: 'as yet unclassified' stamp: 'crl 6/13/2017 19:06'!open: anObject label: aString	^self open: anObject label: aString world: World! !!MorphicToolBuilder class methodsFor: 'as yet unclassified' stamp: 'ar 2/11/2005 15:24'!isActiveBuilder	"Answer whether I am the currently active builder"	^Smalltalk isMorphic! !!NamedNodeMap methodsFor: 'as yet unclassified' stamp: 'crl 8/1/2017 21:34'!attributeAt: name	^(self getNamedItem: name) value! !!NamedNodeMap methodsFor: 'as yet unclassified' stamp: 'crl 9/6/2017 18:48'!attributeAt: name put: value	^self setNamedItem: ((JS top document counterpart createAttribute: name) value: value; yourself)! !!NamedNodeMap methodsFor: 'as yet unclassified' stamp: 'crl 8/1/2017 20:11'!attributeNames	^self properties collect: [:name | (self at: name) name asString]! !!NamedNodeMap class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!Interval methodsFor: 'as yet unclassified' stamp: 'crl 5/20/2018 23:23'!storeOnTether: tether
	"My start, stop, and step could each be very large, requiring encoding support."

	tether
		nextWordPut: IntervalTag;
		store: start;
		store: stop;
		store: step! !!Interval class methodsFor: 'as yet unclassified'!fromTether: tether	^self		from: tether next		to: tether next		by: tether next! !!HTMLSelectElement methodsFor: 'as yet unclassified' stamp: 'crl 9/18/2017 10:48'!children	| children |		children := OrderedCollection new.		0		to: self length - 1		do: [:index | children add: (self at: index)].			^children! !!HTMLSelectElement methodsFor: 'as yet unclassified' stamp: 'crl 9/18/2017 17:54'!removeChildren	self setOptions: #()! !!HTMLSelectElement methodsFor: 'as yet unclassified' stamp: 'crl 3/30/2019 18:45'!selection	"Answer my sole selection. If I have no selection or multiple selections, complain."		^self selectedOptions onlyOne! !!HTMLSelectElement methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2017 10:42'!setOptions: options	<primitive: 'htmlSelectElementSetOptions' module: 'Flow'>	self primitiveFailed! !!HTMLSelectElement class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!IncomingMessageExchange methodsFor: 'as yet unclassified' stamp: 'crl 3/19/2019 03:58'!send: selector withParameters: parameters to: receiver over: aTether under: remoteExchangeID	"Send the message with selector and parameters to receiver, using session's connection, for the remote exchange with ID remoteExchangeID."	tether := aTether.	id := remoteExchangeID.		[		tether addPendingIncomingExchange: self.		((selector = #resume) and: [(receiver recyclingHash = 0) and: [receiver class == Process]])			ifTrue: [receiver perform: selector withArguments: parameters]			ifFalse: [				process := (					[						tether push: (							RemoteMessageAnswer								conveying: (									[receiver perform: selector withArguments: parameters]										on: Exception										do: [:exception |											(PassedExceptions includes: exception class)												ifTrue: [exception pass]												ifFalse: [													3 halt.													ExceptionMarker														forward: exception														over: tether														under: remoteExchangeID]])								under: id)					]						"Performing this message might result in more remote messages. That's why it's done in a distinct process."						fork)]	]		ensure: [tether removePendingIncomingExchange: self]! !!IncomingMessageExchange class methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 15:14'!send: selector withParameters: parameters to: receiver over: session under: id	"Answer an instance of myself which sends the message with selector and parameters to receiver, using session's connection, for the remote exchange with ID remoteExchangeID."	^(self new)		send: selector		withParameters: parameters		to: receiver		over: session		under: id! !!Game methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!Game class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!BehavioralEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/7/2008 22:33'!= aBehaviorRelatedRecord	^id = aBehaviorRelatedRecord id! !!BehavioralEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 20:06'!author	author ifNil: [author := id author].	^author! !!BehavioralEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/6/2008 17:50'!author: anAuthorEdition	super author: anAuthorEdition.	self authorID: anAuthorEdition id! !!BehavioralEdition methodsFor: 'as yet unclassified' stamp: 'crl 1/19/2011 13:20'!authorID: aUUID	id ifNotNil: [id classAuthorID: aUUID]! !!BehavioralEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/9/2008 19:20'!classAuthorID	^id classAuthorID! !!BehavioralEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/9/2008 20:08'!classBaseID	^id classBaseID! !!BehavioralEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/9/2008 19:38'!classVersion	^id classVersion! !!BehavioralEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/31/2008 17:47'!classVersion: sixteenBits	^id classVersion: sixteenBits! !!BehavioralEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/3/2012 17:00'!edition	^self subclassResponsibility! !!BehavioralEdition methodsFor: 'as yet unclassified' stamp: 'crl 11/17/2007 21:57'!hash	^super hash + id hash! !!BehavioralEdition methodsFor: 'as yet unclassified' stamp: 'crl 5/26/2007 14:32'!id	^id! !!BehavioralEdition methodsFor: 'as yet unclassified' stamp: 'crl 10/13/2016 11:50'!id: behavioralID	id := behavioralID! !!BehavioralEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2008 16:18'!isActive	^self subclassResponsibility! !!BehavioralEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 15:45'!storeOnTether: tether	super storeOnTether: tether.	tether store: id! !!BehavioralEdition methodsFor: 'as yet unclassified' stamp: 'crl 3/9/2008 19:59'!version	^self subclassResponsibility! !!BehavioralEdition class methodsFor: 'as yet unclassified' stamp: 'crl 6/7/2007 17:55'!forObjectWithID: id	^self new id: id! !!BehavioralEdition class methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 18:50'!fromTether: tether	^(super fromTether: tether)			id: tether next! !!JSNode methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSNode class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!MetaSuperSendLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 10/29/2008 21:44'!literal	"Answer the method literal I represent."	^(nil -> (self activeClass))! !!MetaSuperSendLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2016 15:07'!tag	"Answer my transmission tag."	^MetaSuperSendLiteralMarkerTag! !!MetaSuperSendLiteralMarker class methodsFor: 'as yet unclassified' stamp: 'crl 11/2/2008 15:21'!canRepresent: literal inMethod: aCompiledMethod of: aClass	^aCompiledMethod sendsToSuper and: [		(literal == aCompiledMethod literals last) and: [literal key == nil]]! !!MetaSuperSendLiteralMarker class methodsFor: 'as yet unclassified' stamp: 'crl 11/2/2008 15:21'!forLiteral: literal inMethod: aCompiledMethod ofClass: aClass	"Answer an instance of myself to represent literal when transferring aCompiledMethod from aClass."	^self forLiteralDefinedByClass: literal value! !!ContextVariablesInspector class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!UndefinedObject methodsFor: 'as yet unclassified' stamp: 'crl 7/23/2017 14:19'!asChromeRemoteCallArgument	^{#value -> self}! !!UndefinedObject methodsFor: 'as yet unclassified' stamp: 'bf 11/25/2014 18:12'!asJSArgument	"converted to JS null by plugin"	^self! !!UndefinedObject methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 20:03'!simplifiedForJSON	"Answer a literal populated with my contents, suitable for JSON encoding."	^self! !!UndefinedObject methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 19:47'!storeOnTether: tether
	tether nextWordPut: NilTag! !!UndefinedObject methodsFor: 'as yet unclassified' stamp: 'crl 7/13/2017 01:40'!yourselfUnlessNil: aBlockClosure	"Answer myself, unless I'm nil, in which case answer the result of evaluating aBlockClosure."	^aBlockClosure value! !!PluggableWindowSpec class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!Encoder class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!CascadeNode methodsFor: 'as yet unclassified' stamp: 'crl 5/6/2017 17:42'!printJavaScriptOn: aStream indent: level	self noJavaScriptSupport! !!CascadeNode methodsFor: 'as yet unclassified' stamp: 'crl 4/30/2017 18:32'!printJavaScriptOn: aStream indent: level precedence: p 	self noJavaScriptSupport! !!CascadeNode class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!ExternalStructureInspector class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!PluggableDropDownListSpec class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!JSGenerator methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 21:46'!render	^self renderOn: Hydra firstOutput! !!JSGenerator methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 21:24'!renderOn: output	^(proxy out: output proxy) counterpart! !!RecentMessageSet class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!ColorPatchCanvas class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!NetMessage methodsFor: 'as yet unclassified' stamp: 'crl 7/21/2016 13:52'!at: key	^self at: key ifAbsent: [#()]! !!NetMessage methodsFor: 'as yet unclassified' stamp: 'crl 6/8/2011 12:34'!at: key put: value	(headerKeys includes: key) ifFalse: [		headerKeys add: key.		headers			at: key			put: OrderedCollection new].	^(headers at: key) add: value! !!NetMessage class methodsFor: 'as yet unclassified' stamp: 'crl 7/25/2016 15:54'!new	^self on: (String new: 64)! !!Deprecation methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!ChromeExecutionContext methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 19:45'!initializeFrom: dictionary	super initializeFrom: dictionary.	origin := Url absoluteFromText: origin! !!PitchEnvelope class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!VolumeEnvelope class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!Event methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!Event class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!BasicRequestor class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!ProjectPasswordNotification class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!RussianEnvironment methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!EventHandler class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!NameStringInHalo methodsFor: 'as yet unclassified' stamp: 'sw 9/17/1999 13:41'!cancelEdits	self interimContents: target externalName.	super cancelEdits! !!NameStringInHalo methodsFor: 'as yet unclassified' stamp: 'sw 9/7/1999 21:27'!drawOn: aCanvas	aCanvas fillRectangle: self bounds color: Color white.	super drawOn: aCanvas.! !!NameStringInHalo methodsFor: 'as yet unclassified' stamp: 'sw 9/17/1999 13:17'!interimContents: aString	self contents: aString.	self placeContents! !!NameStringInHalo methodsFor: 'as yet unclassified' stamp: 'di 11/25/1999 23:40'!placeContents	| namePosition |	(owner notNil and: [owner isInWorld]) ifTrue:		[namePosition := owner basicBox bottomCenter -			((self width // 2) @ (owner handleSize negated // 2 - 1)).		namePosition := namePosition min: self world viewBox bottomRight - self extent y + 2.		self bounds: (namePosition extent: self extent)]! !!JSSliderMorph methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSSliderMorph class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!BreakPoint methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!BreakPoint class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!IdentityLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 11/10/2007 23:45'!literal	^literal! !!IdentityLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 5/23/2007 19:27'!literal: anObject	literal _ anObject! !!IdentityLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 5/23/2007 19:30'!marks: anObject	^literal == anObject! !!IdentityLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 5/25/2007 15:13'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: ' for ';		print: literal! !!IdentityLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 15:47'!storeOnTether: tether	super storeOnTether: tether.	tether store: literal! !!IdentityLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2016 15:07'!tag	^IdentityLiteralMarkerTag! !!IdentityLiteralMarker class methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 19:48'!canRepresent: literal inMethod: aCompiledMethod of: aClass	^{		SmallInteger.		LargePositiveInteger.		LargeNegativeInteger.		Symbol.		ByteSymbol.		ByteString.		Character.		String.		Array.		ByteArray.		Float.		"BoxedFloat64.		SmallFloat64."		Fraction.		ScaledDecimal.		WideString.		WideSymbol	}		includes: literal class! !!IdentityLiteralMarker class methodsFor: 'as yet unclassified' stamp: 'crl 11/2/2008 15:24'!forLiteral: literal inMethod: aCompiledMethod ofClass: aClass	^self new literal: literal! !!IdentityLiteralMarker class methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 18:51'!fromTether: tether	"Answer an instance of myself composed from bytes supplied by aStream, and objects supplied by aMessagingSession."	^self new literal: tether next! !!MessageSet methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 21:30'!filterMessageList	"Allow the user to refine the list of messages."	| builder menuSpec |	builder := ToolBuilder default.	menuSpec := builder pluggableMenuSpec new		model: self;		yourself.	menuSpec addList:		#(		('unsent messages' filterToUnsentMessages 'filter to show only messages that have no senders')		-		('messages that send...' filterToSendersOf 'filter to show only messages that send a selector I specify')		('messages that do not send...' filterToNotSendersOf 'filter to show only messages that do not send a selector I specify')		-		('messages whose selector is...' filterToImplementorsOf 'filter to show only messages with a given selector I specify')		('messages whose selector is NOT...' filterToNotImplementorsOf 'filter to show only messages whose selector is NOT a seletor I specify')		-		('messages in current change set' filterToCurrentChangeSet 'filter to show only messages that are in the current change set')		('messages not in current change set' filterToNotCurrentChangeSet 'filter to show only messages that are not in the current change set')		-		('messages in any change set' filterToAnyChangeSet 'filter to show only messages that occur in at least one change set')		('messages not in any change set' filterToNotAnyChangeSet 'filter to show only messages that do not occur in any change set in the system')		-		('messages authored by me' filterToCurrentAuthor 'filter to show only messages whose authoring stamp has my initials')		('messages not authored by me' filterToNotCurrentAuthor 'filter to show only messages whose authoring stamp does not have my initials')		-		('messages logged in .changes file' filterToMessagesInChangesFile 'filter to show only messages whose latest source code is logged in the .changes file')		('messages only in .sources file' filterToMessagesInSourcesFile 'filter to show only messages whose latest source code is logged in the .sources file')		-		('messages with prior versions'	 filterToMessagesWithPriorVersions 'filter to show only messages that have at least one prior version')		('messages without prior versions' filterToMessagesWithoutPriorVersions 'filter to show only messages that have no prior versions')		-		('uncommented messages' filterToUncommentedMethods 'filter to show only messages that do not have comments at the beginning')		('commented messages' filterToCommentedMethods 'filter to show only messages that have comments at the beginning')		-		('messages in hardened classes' filterToMessagesWithHardenedClasses 'filter to show only messages of established classes (as opposed to Uniclasses such as Player23)')		-		('methods in classes with matching names' filterToMatchingClassesNames 'filter to show only methods of classes with names that match the given criteria (wildcards are allowed)')		-		('messages that...' filterToMessagesThat 'let me type in a block taking a class and a selector, which will specify yea or nay concerning which elements should remain in the list')).	builder runModal: (builder open: menuSpec).! !!Literal methodsFor: 'as yet unclassified' stamp: 'crl 5/7/2017 00:29'!printSmalltalkOn: stream	stream print: value! !!Literal methodsFor: 'as yet unclassified' stamp: 'crl 5/6/2017 16:09'!raw	^raw! !!Literal class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!LazyListMorph methodsFor: 'as yet unclassified' stamp: 'crl 5/14/2017 21:57'!bottomVisibleRowForCanvas: aCanvas        "return the bottom visible row in aCanvas's clip rectangle"        ^self		rowAtLocation: aCanvas clipRect bottomLeft		forFontHeight: (aCanvas fontHeightIn: self) ! !!LazyListMorph methodsFor: 'as yet unclassified' stamp: 'crl 5/14/2017 21:56'!rowAtLocation: aPoint forFontHeight: height	"return the number of the row at aPoint"	| y |	y := aPoint y.	y < self top ifTrue: [ ^ 1 min: listItems size ].	^((y - self top // height) + 1) min: listItems size max: 0! !!LazyListMorph methodsFor: 'as yet unclassified' stamp: 'crl 5/14/2017 21:56'!topVisibleRowForCanvas: aCanvas        "return the top visible row in aCanvas's clip rectangle"        ^self		rowAtLocation: aCanvas clipRect topLeft		forFontHeight: (aCanvas fontHeightIn: self)! !!AssignmentExpression methodsFor: 'as yet unclassified' stamp: 'crl 5/7/2017 14:20'!printSmalltalkOn: stream	left accesses		ifTrue: [left printSmalltalkAtPutOn: stream]		ifFalse: [			left printSmalltalkOn: stream.			stream nextPutAll: ' := '].	right printSmalltalkOn: stream! !!AssignmentExpression class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!Time methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2005 18:47'!days	"Answer the number of days the receiver represents."	^seconds // 86400 \\ 7! !!Time methodsFor: 'as yet unclassified' stamp: 'crl 8/29/2017 18:52'!printIntervalOn: aStream	"Print a textual description of myself as a time interval, on aStream."	seconds = 0		ifTrue: [aStream nextPutAll: 'no time at all']		ifFalse: [			(OrderedCollection new)				add: (self weeks -> 'week');				add: (self days -> 'day');				add: (self hours -> 'hour');				add: (self minutes -> 'minute');				add: (self seconds -> 'second');				do: [:association |					association key > 0 ifTrue: [						aStream							print: association key;							space;							nextPutAll: association value.						association key > 1 ifTrue: [aStream nextPut: $s].						aStream nextPutAll: ', ']].			aStream previousTake: 2]! !!Time methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2005 18:47'!weeks	"Answer the number of weeks the receiver represents."	^seconds // 604800 \\ 4! !!ChromeCSSAPI class methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 12:39'!domain	^'CSS'! !!BraceNode methodsFor: 'as yet unclassified' stamp: 'crl 5/4/2017 22:29'!printJavaScriptOn: stream indent: level	stream nextPut: $[.	elements		do: [:element | element printJavaScriptOn: stream indent: level]		separatedBy: [stream nextPutAll: ', '].	stream nextPut: $]! !!Apache methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!Apache class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!TableLayout class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!SocketPrimitiveFailed methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!SocketPrimitiveFailed class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!ChromeInspectorAPI methodsFor: 'as yet unclassified' stamp: 'crl 7/24/2017 15:48'!detached: object	<parseParameters: #parseDetachedFrom:>! !!ChromeInspectorAPI methodsFor: 'as yet unclassified' stamp: 'crl 7/24/2017 15:49'!parseDetachedFrom: dictionary! !!ChromeInspectorAPI class methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 12:40'!domain	^'Inspector'! !!MIDIController methodsFor: 'as yet unclassified' stamp: 'crl 1/31/2003 23:48'!appliedTo: anObject	"Answer anObject, after applying myself to it."	^anObject applyMIDIController: self! !!MIDIController methodsFor: 'as yet unclassified' stamp: 'crl 1/21/2003 10:34'!applyInteger: anInteger	"Answer myself after applying anInteger."	^ControlChange changing: self to: anInteger! !!MIDIController methodsFor: 'as yet unclassified' stamp: 'crl 1/21/2003 10:01'!name	"Answer a String describing me in general."	^'controller'! !!POP3LoginError methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!POP3LoginError class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!AssignmentNode methodsFor: 'as yet unclassified' stamp: 'crl 5/4/2017 22:28'!printJavaScriptOn: stream indent: level 	variable printJavaScriptOn: stream indent: level.	stream nextPutAll: ' = '.	value printJavaScriptOn: stream indent: level + 2! !!AssignmentNode methodsFor: 'as yet unclassified' stamp: 'crl 4/30/2017 18:31'!printJavaScriptOn: aStream indent: level precedence: p	aStream nextPut: $(.	self printJavaScriptOn: aStream indent: level.	aStream nextPut: $)! !!AssignmentNode class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!TranslucentColor class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:55'!foo! !!HTMLScriptElement methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!HTMLScriptElement class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!PluggableMenuItemSpec class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!SharedPool methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!SharedPool class methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2019 16:07'!at: key	^classPool at: key! !!Integer methodsFor: 'as yet unclassified' stamp: 'crl 8/8/2017 10:44'!nd	"Answer the Rank to which I correspond."	^self rank! !!Integer methodsFor: 'as yet unclassified' stamp: 'crl 7/28/2003 15:31'!quarters	"Answer a quarter-note duration in a quantity of me."	^self relativeDurationOfMagnitude: 1/4 inQuantity: self! !!Integer methodsFor: 'as yet unclassified' stamp: 'crl 8/8/2017 10:43'!rank	^Rank for: self! !!Integer methodsFor: 'as yet unclassified' stamp: 'crl 8/8/2017 10:44'!rd	"Answer the Rank to which I correspond."	^self rank! !!Integer methodsFor: 'as yet unclassified' stamp: 'crl 8/14/2004 01:21'!relativeDurationFractionName	^(		[			#(				whole				half				third				quarter				fifth				sixth				seventh				eighth			)				at: self		]			ifError: [				self printString, (					(self between: 11 and: 13)						ifTrue: ['th']						ifFalse: [[#(st nd rd) at: self abs \\ 10] ifError: ['th']])])! !!Integer methodsFor: 'as yet unclassified' stamp: 'crl 7/28/2003 15:27'!relativeDurationOfMagnitude: aFraction inQuantity: anInteger	"Answer a RelativeDuration for anInteger."	^RelativeDuration ofMagnitude: aFraction inQuantity: anInteger! !!Integer methodsFor: 'as yet unclassified' stamp: 'crl 8/8/2017 10:44'!st	"Answer the Rank to which I correspond."	^self rank! !!Integer methodsFor: 'as yet unclassified' stamp: 'crl 8/8/2017 10:44'!th	"Answer the Rank to which I correspond."	^self rank! !!AttemptToWriteReadOnlyGlobal class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!SimpleBorder class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!Checkpoint methodsFor: 'as yet unclassified' stamp: 'crl 1/11/2011 22:15'!name: aString	name := aString! !!Checkpoint methodsFor: 'as yet unclassified' stamp: 'crl 1/13/2011 17:29'!name: aString previousEdition: checkpoint	name := aString.	previousEdition := checkpoint.	checkpoint ifNotNil: [checkpoint nextEdition: self]! !!Checkpoint methodsFor: 'as yet unclassified' stamp: 'crl 7/6/2008 16:00'!nextCheckpointNamed: aString	^(self class) named: aString following: self! !!Checkpoint methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2008 22:33'!printComponentNameOn: aStream withOuterAuthor: anAuthorEdition	name		ifNil: [aStream nextPutAll: 'an unnamed checkpoint']		ifNotNil: [			aStream				nextPutAll: 'a checkpoint named ''';				nextPutAll: name;				nextPut: $'].	self printAuthorOn: aStream withOuterAuthor: anAuthorEdition! !!Checkpoint methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 15:46'!storeOnTether: tether	super storeOnTether: tether.	tether store: name! !!Checkpoint methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 16:45'!tag	^CheckpointTag! !!Checkpoint class methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 18:50'!fromTether: tether	^(super fromTether: tether)		name: tether next;		yourself! !!Checkpoint class methodsFor: 'as yet unclassified' stamp: 'crl 7/6/2008 15:52'!named: aString following: checkpoint	^(self new)		name: aString		previousEdition: checkpoint! !!DAVMemory methodsFor: 'as yet unclassified' stamp: 'crl 1/5/2015 16:07'!isConnected	^memory isConnected! !!DAVMemory methodsFor: 'as yet unclassified' stamp: 'crl 1/4/2015 13:53'!memory: aMemoryProfile	memory _ aMemoryProfile.	session _ self addSubdirectory: (DAVSession withMemory: self).	classes _ (		self addSubdirectory: (			(DAVDirectory named: 'classes')				addClass: Object;				yourself)).	processes _ self addSubdirectory: (DAVDirectory named: 'processes').	self refreshProcesses.	workspaces _ (		self addSubdirectory: (			(DAVDirectory named: 'workspaces')				addSubdirectory: DAVWorkspace new;				yourself)).! !!DAVMemory methodsFor: 'as yet unclassified' stamp: 'crl 1/5/2015 03:43'!name	^memory id printString! !!DAVMemory methodsFor: 'as yet unclassified' stamp: 'crl 1/6/2015 01:51'!names	^memory names! !!DAVMemory methodsFor: 'as yet unclassified' stamp: 'crl 1/5/2015 03:29'!refreshProcesses! !!DAVMemory methodsFor: 'as yet unclassified' stamp: 'crl 1/9/2015 14:05'!resume	memory _ memory resume! !!DAVMemory methodsFor: 'as yet unclassified' stamp: 'crl 1/11/2015 02:40'!session	^session! !!DAVMemory methodsFor: 'as yet unclassified' stamp: 'crl 1/10/2015 19:50'!stop	memory stop! !!DAVMemory class methodsFor: 'as yet unclassified' stamp: 'crl 1/2/2015 17:29'!for: aMemoryProfile	^self new memory: aMemoryProfile! !!MessageNotUnderstood class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!ABox methodsFor: 'as yet unclassified' stamp: 'crl 8/15/2017 18:14'!beHidden! !!ABox methodsFor: 'as yet unclassified' stamp: 'crl 8/15/2017 18:13'!beTransparent! !!ABox methodsFor: 'as yet unclassified' stamp: 'crl 8/18/2017 10:43'!initialize	super initialize.	self		at: #width put: 2;		at: #height put: 2;		at: #depth put: 2! !!ABox class methodsFor: 'as yet unclassified' stamp: 'crl 8/18/2017 20:19'!tag	^'a-box'! !!AbstractSoundSystem class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!DAVSessionFile methodsFor: 'as yet unclassified' stamp: 'crl 1/12/2015 00:10'!initialName	^self subclassResponsibility! !!DAVSessionFile methodsFor: 'as yet unclassified' stamp: 'crl 1/12/2015 00:10'!initialize	super initialize.	self name: self initialName! !!DAVSessionFile methodsFor: 'as yet unclassified' stamp: 'crl 7/13/2017 10:47'!moveTo: resourceName	| tail existingFile |	tail _ ((resourceName reversed readStream) upTo: $/) reversed.	existingFile _ container fileNamed: tail.	existingFile ifNotNil: [existingFile delete].	self touch.	name _ tail.	^true! !!DAVSessionFile methodsFor: 'as yet unclassified' stamp: 'crl 1/12/2015 03:41'!progressMessage	^self subclassResponsibility! !!DAVSessionFile methodsFor: 'as yet unclassified' stamp: 'crl 7/14/2017 00:03'!responsePayload	[self sideEffect] fork.	^((String new: 120) writeStream)		nextPutAll: '<html><head><meta http-equiv="refresh" content="4;URL=''/README.html''"/></head><body>';		nextPutAll: self progressMessage;		nextPutAll: '</body></html>';		contents! !!DAVSessionFile methodsFor: 'as yet unclassified' stamp: 'crl 1/11/2015 02:45'!session: aDAVSession	session _ aDAVSession.	self container: session! !!DAVSessionFile methodsFor: 'as yet unclassified' stamp: 'crl 1/12/2015 02:31'!sideEffect	self subclassResponsibility! !!DAVSessionFile class methodsFor: 'as yet unclassified' stamp: 'crl 1/11/2015 02:45'!withSession: aDAVSession	^self new session: aDAVSession! !!Latin2Environment methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!HardwareStream class methodsFor: 'as yet unclassified' stamp: 'crl 11/28/2000 16:23'!onPortAt: portNumber	"Answer a new instance of myself, on the resource at the port indicated by portNumber."	^self on: (self resourceClass at: portNumber)! !!HardwareStream class methodsFor: 'as yet unclassified' stamp: 'crl 11/28/2000 16:22'!resourceClass	"Answer the Class of the objects with which my instances operate."	^self subclassResponsibility! !!SecureHashAlgorithm methodsFor: 'as yet unclassified' stamp: 'jm 12/7/1999 23:25'!constantForStep: i	"Answer the constant for the i-th step of the block hash loop. We number our steps 1-80, versus the 0-79 of the standard."	i <= 20 ifTrue: [^ K1].	i <= 40 ifTrue: [^ K2].	i <= 60 ifTrue: [^ K3].	^ K4! !!SecureHashAlgorithm methodsFor: 'as yet unclassified' stamp: 'nice 8/28/2010 22:43'!expandedBlock: aByteArray	"Convert the given 64 byte buffer into 80 32-bit registers and answer the result." 	| out src v |	out := Array new: 80.	src := 1.	1 to: 16 do: [:i |		out at: i put: (ThirtyTwoBitRegister fromByteArray: aByteArray at: src).		src := src + 4].	17 to: 80 do: [:i |		v := (out at: i - 3) copy.		v	bitXor: (out at: i - 8);			bitXor: (out at: i - 14);			bitXor: (out at: i - 16);			leftRotateBy: 1.		out at: i put: v].	^ out! !!SecureHashAlgorithm methodsFor: 'as yet unclassified' stamp: 'jm 12/21/1999 20:02'!finalHash	"Concatenate the final totals to build the 160-bit integer result."	"Details: If the primitives are supported, the results are in the totals array. Otherwise, they are in the instance variables totalA through totalE."	| r |	totals ifNil: [  "compute final hash when not using primitives"		^ (totalA asInteger bitShift: 128) +		  (totalB asInteger bitShift:  96) +		  (totalC asInteger bitShift:  64) +		  (totalD asInteger bitShift:  32) +		  (totalE asInteger)].	"compute final hash when using primitives"	r := 0.	1 to: 5 do: [:i |		r := r bitOr: ((totals at: i) bitShift: (32 * (5 - i)))].	^ r! !!SecureHashAlgorithm methodsFor: 'as yet unclassified' stamp: 'jm 12/7/1999 22:15'!hashFunction: i of: x with: y with: z	"Compute the hash function for the i-th step of the block hash loop. We number our steps 1-80, versus the 0-79 of the standard."	"Details: There are four functions, one for each 20 iterations. The second and fourth are the same."	i <= 20 ifTrue: [^ x copy bitAnd: y; bitOr: (x copy bitInvert; bitAnd: z)].	i <= 40 ifTrue: [^ x copy bitXor: y; bitXor: z].	i <= 60 ifTrue: [^ x copy bitAnd: y; bitOr: (x copy bitAnd: z); bitOr: (y copy bitAnd: z)].	^ x copy bitXor: y; bitXor: z! !!SecureHashAlgorithm methodsFor: 'as yet unclassified' stamp: 'jm 12/14/1999 11:56'!hashInteger: aPositiveInteger	"Hash the given positive integer. The integer to be hashed should have 512 or fewer bits. This entry point is used in key generation."	| buffer dstIndex |	self initializeTotals.	"pad integer with zeros"	aPositiveInteger highBit <= 512		ifFalse: [self error: 'integer cannot exceed 512 bits'].	buffer := ByteArray new: 64.	dstIndex := 0.	aPositiveInteger digitLength to: 1 by: -1 do: [:i |		buffer at: (dstIndex := dstIndex + 1) put: (aPositiveInteger digitAt: i)].	"process that one block"	self processBuffer: buffer.	^ self finalHash! !!SecureHashAlgorithm methodsFor: 'as yet unclassified' stamp: 'nice 8/28/2010 22:40'!hashInteger: aPositiveInteger seed: seedInteger	"Hash the given positive integer. The integer to be hashed should have 512 or fewer bits. This entry point is used in the production of random numbers"	| buffer dstIndex |	"Initialize totalA through totalE to their seed values."	totalA := ThirtyTwoBitRegister		fromInteger: ((seedInteger bitShift: -128) bitAnd: 16rFFFFFFFF).	totalB := ThirtyTwoBitRegister		fromInteger: ((seedInteger bitShift: -96) bitAnd: 16rFFFFFFFF).	totalC := ThirtyTwoBitRegister		fromInteger: ((seedInteger bitShift: -64) bitAnd: 16rFFFFFFFF).	totalD := ThirtyTwoBitRegister		fromInteger: ((seedInteger bitShift: -32) bitAnd: 16rFFFFFFFF).	totalE := ThirtyTwoBitRegister		fromInteger: (seedInteger bitAnd: 16rFFFFFFFF).	self initializeTotalsArray.	"pad integer with zeros"	buffer := ByteArray new: 64.	dstIndex := 0.	aPositiveInteger digitLength to: 1 by: -1 do: [:i |		buffer at: (dstIndex := dstIndex + 1) put: (aPositiveInteger digitAt: i)].	"process that one block"	self processBuffer: buffer.	^ self finalHash! !!SecureHashAlgorithm methodsFor: 'as yet unclassified' stamp: 'jm 12/14/1999 11:28'!hashMessage: aStringOrByteArray	"Hash the given message using the Secure Hash Algorithm."	^ self hashStream: (ReadStream on: aStringOrByteArray asByteArray)! !!SecureHashAlgorithm methodsFor: 'as yet unclassified' stamp: 'ar 2/25/2010 23:40'!hashStream: aPositionableStream	"Hash the contents of the given stream from the current position to the end using the Secure Hash Algorithm. The SHA algorithm is defined in FIPS PUB 180-1. It is also described on p. 442 of 'Applied Cryptography: Protocols, Algorithms, and Source Code in C' by Bruce Scheier, Wiley, 1996."	"SecureHashAlgorithm new hashStream: (ReadStream on: 'foo')"	| startPosition buf bitLength |	self initializeTotals.	"(SecureHashAlgorithm new hashMessage: '') radix: 16 		=> 'DA39A3EE5E6B4B0D3255BFEF95601890AFD80709'"	aPositionableStream atEnd ifTrue: [self processFinalBuffer: #() bitLength: 0].	startPosition := aPositionableStream position.	[aPositionableStream atEnd] whileFalse: [		buf := aPositionableStream next: 64.		(aPositionableStream atEnd not and: [buf size = 64])			ifTrue: [self processBuffer: buf]			ifFalse: [				bitLength := (aPositionableStream position - startPosition) * 8.				self processFinalBuffer: buf bitLength: bitLength]].	^ self finalHash! !!SecureHashAlgorithm methodsFor: 'as yet unclassified' stamp: 'nice 8/28/2010 22:39'!initializeTotals	"Initialize totalA through totalE to their seed values."	"total registers for use when primitives are absent"	totalA := ThirtyTwoBitRegister fromInteger: 16r67452301.	totalB := ThirtyTwoBitRegister fromInteger: 16rEFCDAB89.	totalC := ThirtyTwoBitRegister fromInteger: 16r98BADCFE.	totalD := ThirtyTwoBitRegister fromInteger: 16r10325476.	totalE := ThirtyTwoBitRegister fromInteger: 16rC3D2E1F0.	self initializeTotalsArray.! !!SecureHashAlgorithm methodsFor: 'as yet unclassified' stamp: 'jm 12/21/1999 19:38'!initializeTotalsArray	"Initialize the totals array from the registers for use with the primitives."	totals := Bitmap new: 5.	totals at: 1 put: totalA asInteger.	totals at: 2 put: totalB asInteger.	totals at: 3 put: totalC asInteger.	totals at: 4 put: totalD asInteger.	totals at: 5 put: totalE asInteger.! !!SecureHashAlgorithm methodsFor: 'as yet unclassified' stamp: 'jm 12/21/1999 20:11'!primExpandBlock: aByteArray into: wordBitmap	"Expand the given 64-byte buffer into the given Bitmap of length 80."	<primitive: 'primitiveExpandBlock' module: 'DSAPrims'>	^ self primitiveFailed! !!SecureHashAlgorithm methodsFor: 'as yet unclassified' stamp: 'jm 12/21/1999 22:58'!primHasSecureHashPrimitive	"Answer true if this platform has primitive support for the Secure Hash Algorithm."	<primitive: 'primitiveHasSecureHashPrimitive' module: 'DSAPrims'>	^ false! !!SecureHashAlgorithm methodsFor: 'as yet unclassified' stamp: 'jm 12/21/1999 20:13'!primHashBlock: blockBitmap using: workingTotalsBitmap	"Hash the given block (a Bitmap) of 80 32-bit words, using the given workingTotals."	<primitive: 'primitiveHashBlock' module: 'DSAPrims'>	^ self primitiveFailed! !!SecureHashAlgorithm methodsFor: 'as yet unclassified' stamp: 'nice 8/28/2010 22:28'!processBuffer: aByteArray	"Process given 64-byte buffer, accumulating the results in totalA through totalE."	| a b c d e w tmp |	self primHasSecureHashPrimitive		ifTrue: [^ self processBufferUsingPrimitives: aByteArray]		ifFalse: [totals := nil].	"initialize registers a through e from the current totals" 	a := totalA copy.	b := totalB copy.	c := totalC copy.	d := totalD copy.	e := totalE copy.	"expand and process the buffer"	w := self expandedBlock: aByteArray.	1 to: 80 do: [:i |		tmp := (a copy leftRotateBy: 5)			+= (self hashFunction: i of: b with: c with: d);			+= e;			+= (w at: i);			+= (self constantForStep: i).		e := d.		d := c.		c := b leftRotateBy: 30.		b := a.		a := tmp].	"add a through e into total accumulators"	totalA += a.	totalB += b.	totalC += c.	totalD += d.	totalE += e.! !!SecureHashAlgorithm methodsFor: 'as yet unclassified' stamp: 'jm 12/21/1999 23:32'!processBufferUsingPrimitives: aByteArray	"Process given 64-byte buffer using the primitives, accumulating the results in totals."	| w |	"expand and process the buffer"	w := Bitmap new: 80.	self primExpandBlock: aByteArray into: w.	self primHashBlock: w using: totals.! !!SecureHashAlgorithm methodsFor: 'as yet unclassified' stamp: 'jm 12/14/1999 11:40'!processFinalBuffer: buffer bitLength: bitLength	"Process given buffer, whose length may be <= 64 bytes, accumulating the results in totalA through totalE. Also process the final padding bits and length."	| out |	out := ByteArray new: 64.	out replaceFrom: 1 to: buffer size with: buffer startingAt: 1.	buffer size < 56 ifTrue: [  "padding and length fit in last data block"		out at: buffer size + 1 put: 128.  "trailing one bit"		self storeLength: bitLength in: out.  "end with length"		self processBuffer: out.		^ self].	"process the final data block"	buffer size < 64 ifTrue: [		out at: buffer size + 1 put: 128].  "trailing one bit"	self processBuffer: out.	"process one additional block of padding ending with the length"	out := ByteArray new: 64.  "filled with zeros"	buffer size = 64 ifTrue: [		"add trailing one bit that didn't fit in final data block"		out at: 1 put: 128].	self storeLength: bitLength in: out.	self processBuffer: out.! !!SecureHashAlgorithm methodsFor: 'as yet unclassified' stamp: 'jm 12/14/1999 11:10'!storeLength: bitLength in: aByteArray	"Fill in the final 8 bytes of the given ByteArray with a 64-bit big-endian representation of the original message length in bits."	| n i |	n := bitLength.	i := aByteArray size.	[n > 0] whileTrue: [		aByteArray at: i put: (n bitAnd: 16rFF).		n := n bitShift: -8.		i := i - 1].! !!SecureHashAlgorithm class methodsFor: 'as yet unclassified' stamp: 'nice 8/28/2010 22:39'!initialize	"SecureHashAlgorithm initialize"	"For the curious, here's where these constants come from:	  #(2 3 5 10) collect: [:x | ((x sqrt / 4.0) * (2.0 raisedTo: 32)) truncated hex]"	K1 := ThirtyTwoBitRegister fromInteger: 16r5A827999.	K2 := ThirtyTwoBitRegister fromInteger: 16r6ED9EBA1.	K3 := ThirtyTwoBitRegister fromInteger: 16r8F1BBCDC.	K4 := ThirtyTwoBitRegister fromInteger: 16rCA62C1D6.! !!SelectorNode methodsFor: 'as yet unclassified' stamp: 'crl 5/4/2017 22:25'!printJavaScriptOn: stream indent: level 	stream nextPutAll: (		key			ifNil: [3 halt]			ifNotNil: [key])! !!SelectorNode class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!BrowserRequestor class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!PluggableCheckBoxSpec class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!HandMorph methodsFor: 'as yet unclassified' stamp: 'crl 6/27/2016 16:26'!generateKeyboardEvent: evtBuf	"Generate the appropriate mouse event for the given raw event buffer"	| buttons modifiers type pressType stamp keyValue |	stamp := evtBuf second.	stamp = 0 ifTrue: [stamp := Time millisecondClockValue].	pressType := evtBuf fourth.	pressType = EventKeyDown ifTrue: [type := #keyDown].	pressType = EventKeyUp ifTrue: [type := #keyUp].	pressType = EventKeyChar ifTrue: [type := #keystroke].	modifiers := evtBuf fifth.	buttons := (modifiers bitShift: 3) bitOr: (lastMouseEvent buttons bitAnd: 7).	type = #keystroke		ifTrue: [			keyValue := (self keyboardInterpreter nextCharFrom: Sensor firstEvt: evtBuf) asInteger.			(keyValue = evtBuf third) ifFalse: [buttons := (buttons bitOr: 16) bitClear: 64]]		ifFalse: [keyValue := evtBuf third].	^ KeyboardEvent new		setType: type		buttons: buttons		position: self position		keyValue: keyValue		hand: self		stamp: stamp! !!HandMorph methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2019 13:45'!handleEvent: anEvent	| evt ofs |	owner ifNil:[^self].	evt := anEvent.	EventStats ifNil:[EventStats := IdentityDictionary new].	EventStats at: #count put: (EventStats at: #count ifAbsent:[0]) + 1.	EventStats at: evt type put: (EventStats at: evt type ifAbsent:[0]) + 1.	evt isMouseOver ifTrue:[^self sendMouseEvent: evt].ShowEvents == true ifTrue:[	Display fill: (0@0 extent: 250@120) rule: Form over fillColor: Color white.	ofs := (owner hands indexOf: self) - 1 * 60.	evt printString displayAt: (0@ofs) + (evt isKeyboard ifTrue:[0@30] ifFalse:[0@0]).	self keyboardFocus printString displayAt: (0@ofs)+(0@45).].	"Notify listeners"	self sendListenEvent: evt to: self eventListeners.	evt isWindowEvent ifTrue: [		self sendEvent: evt focus: nil.		^self mouseOverHandler processMouseOver: lastMouseEvent].	evt isKeyboard ifTrue:[		| keyValue |				keyValue := evt keyValue.				"Transcript cr; print: evt keyValue; endEntry."		"Immediately handle keybindings for world menu invocation (backtick), snapshotting (backslash), 2D and 3D camera movement (control-shift A/D/W/S/Q/Z), and various metakeys via emojii."		keyValue = 55357 ifTrue: [			"Coerce the printer emoji to cmd-p (print-it).."			evt				setCommandKeyPressed;				keyValue: 112].		keyValue = 55358 ifTrue: [			"Coerce the bull-horns emoji to cmd-d (do-it)."			evt				setCommandKeyPressed;				keyValue: 100].		keyValue = 92 ifTrue: [			Smalltalk snapshot: true andQuit: false.			Webpage fullscreenOn.			^self].				(keyValue = 95) ifTrue: [			ActiveWorld findWindow: nil.			^self].					(keyValue = 96)			ifTrue: [evt keyValue: 27]			ifFalse: [				(evt controlKeyPressed and: [evt shiftPressed and: [#(23 19 1 4 17 26 5) includes: keyValue]]) ifTrue: [					^keyValue						caseOf: {							[23] -> [Webpage current moveCameraInZBy: -0.1].							[19] -> [Webpage current moveCameraInZBy: 0.1].							[1] -> [Webpage current moveCameraInXBy: -0.1].							[4] -> [Webpage current moveCameraInXBy: 0.1].							[17] -> [Webpage current moveCameraInYBy: 0.1].							[26] -> [Webpage current moveCameraInYBy: -0.1]}]].			self sendListenEvent: evt to: self keyboardListeners.		self sendKeyboardEvent: evt.		^self mouseOverHandler processMouseOver: lastMouseEvent].	evt isDropEvent ifTrue:[		self sendEvent: evt focus: nil.		^self mouseOverHandler processMouseOver: lastMouseEvent].	evt isMouse ifTrue:[		JS ifConnected: [Webpage current ifNotNil: [Cursor currentCursor == Cursor normal ifTrue: [Webpage current cursorCanvas beHidden]]].		self sendListenEvent: evt to: self mouseListeners.		lastMouseEvent := evt].	"Check for pending drag or double click operations."	mouseClickState ifNotNil:[		(mouseClickState handleEvent: evt from: self) ifFalse:[			"Possibly dispatched #click: or something and will not re-establish otherwise"			^self mouseOverHandler processMouseOver: lastMouseEvent]].	evt isMove ifTrue:[		self position: evt position.		self sendMouseEvent: evt.	] ifFalse:[		"Issue a synthetic move event if we're not at the position of the event"		(evt position = self position) ifFalse:[self moveToEvent: evt].		"Drop submorphs on button events"		(self hasSubmorphs) 			ifTrue:[self dropMorphs: evt]			ifFalse:[self sendMouseEvent: evt].	].	ShowEvents == true ifTrue:[self mouseFocus printString displayAt: (0@ofs) + (0@15)].	self mouseOverHandler processMouseOver: lastMouseEvent.	"self handleDragOutside: anEvent."! !!HandMorph methodsFor: 'as yet unclassified' stamp: 'tk 8/9/2001 16:55'!initForEvents	mouseOverHandler := nil.	lastMouseEvent := MouseEvent new setType: #mouseMove position: 0@0 buttons: 0 hand: self.	lastEventBuffer := {1. 0. 0. 0. 0. 0. nil. nil}.	self resetClickState.! !!HandMorph methodsFor: 'as yet unclassified' stamp: 'crl 6/13/2017 10:47'!processEvent: event	| evt type |		evt := nil.	"for unknown event types"	type := event first.	type = EventTypeMouse ifTrue: [evt := self generateMouseEvent: event].	type = EventTypeKeyboard 		ifTrue: [evt := self generateKeyboardEvent: event].	type = EventTypeDragDropFiles 		ifTrue: [evt := self generateDropFilesEvent: event].	type = EventTypeWindow		ifTrue:[evt := self generateWindowEvent: event].	"All other events are ignored"	(type ~= EventTypeDragDropFiles and: [evt isNil]) ifTrue: [^self].	evt isNil 		ifFalse: 			["Finally, handle it"			self handleEvent: evt.			"For better user feedback, return immediately after a mouse event has been processed."			evt isMouse ifTrue: [^self]]! !!HandMorph methodsFor: 'as yet unclassified' stamp: 'ar 1/2/2010 15:22'!sendKeyboardEvent: anEvent 	"Send the event to the morph currently holding the focus, or if none to	the owner of the hand."	^ self		sendEvent: anEvent		focus: self keyboardFocus		clear: [self keyboardFocus: nil]! !!HandMorph methodsFor: 'as yet unclassified' stamp: 'nk 10/24/2003 22:12'!visible: aBoolean	self needsToBeDrawn ifFalse: [ ^self ].	super visible: aBoolean! !!FileContentsBrowser methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 21:33'!contents	self updateInfoView.	editSelection == #editClass		ifTrue:[^self modifiedClassDefinition].	^super contents! !!UndeclaredLiteralMarker methodsFor: 'as yet unclassified'!literal	"Answer the method literal I represent."	Undeclared at: key put: nil.	^Undeclared associationAt: key! !!UndeclaredLiteralMarker methodsFor: 'as yet unclassified'!marks: literal 	^ (Undeclared		associationAt: key		ifAbsent: [^ false])		== literal! !!UndeclaredLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2016 15:07'!tag	"Answer my transmission tag."	^UndeclaredLiteralMarkerTag! !!UndeclaredLiteralMarker class methodsFor: 'as yet unclassified' stamp: 'crl 10/1/2016 01:21'!canRepresent: literal inMethod: aCompiledMethod of: aClass	^(literal isKindOf: Association) and: [Undeclared includesAssociation: literal]! !!UndeclaredLiteralMarker class methodsFor: 'as yet unclassified' stamp: 'crl 3/3/2008 17:11'!forLiteral: literal inMethod: aCompiledMethod inClass: aClass	^(Undeclared includesAssociation: literal)		ifTrue: [self new key: literal key]		ifFalse: [nil]! !!UndeclaredLiteralMarker class methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2016 00:03'!forLiteral: literal inMethod: aCompiledMethod ofClass: aClass	^(Undeclared includesAssociation: literal)		ifTrue: [self new key: literal key]		ifFalse: [nil]! !!JSText methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSText class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!SmalltalkEditor class methodsFor: 'as yet unclassified' stamp: 'crl 6/18/2018 15:32'!initializeCmdKeyShortcuts	"Initialize the (unshifted) command-key (or alt-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"SmalltalkEditor initialize"	| cmds |	super initializeCmdKeyShortcuts.	cmds := #($d #doIt: $i #inspectIt: $j #doAgainOnce: $l #cancel: $m #implementorsOfIt: $n #sendersOfIt: $o #spawnIt: $p #printIt: $q #querySymbol: $r #browseIt: $s #save:).	1 to: cmds size		by: 2		do: [ : i | cmdActions at: (cmds at: i) asciiValue + 1 put: (cmds at: i + 1)].	"Set up type-method argument hot keys, 1-4.."	'1234' do:		[ : eachKeyboardChar |		cmdActions 			at: eachKeyboardChar asciiValue + 1			put: #typeMethodArgument: ]! !!SmalltalkEditor class methodsFor: 'as yet unclassified' stamp: 'crl 6/20/2018 14:14'!initializeShiftCmdKeyShortcuts 	"Initialize the shift-command-key (or control-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"wod 11/3/1998: Fix setting of cmdMap for shifted keys to actually use the 	capitalized versions of the letters.	TPR 2/18/99: add the plain ascii values back in for those VMs that don't return the shifted values."	"SmalltalkEditor initialize"	| commands |	super initializeShiftCmdKeyShortcuts.		commands := #(		$a	cursorBeginningOfLine:		$b	cursorLeft:		$f	cursorRight:		$n	cursorDown:		$p	cursorUp:		$d	forwardDelete:		$e	cursorEndOfLine:		$s	find:		$k	cutToEndOfLine:		$y	paste:		$t	swapChars:		$v cursorPageDown:		$w	cut:	).		1		to: commands size		by: 2		do: [ :i |			#(				"plain keys"				0							"shifted keys"				32							"control keys"				96			)				do: [:delta |					shiftCmdActions						at: ((commands at: i) asciiValue - delta + 1)						put: (commands at: i + 1)]].					"Add a few more shift-control keys for VR navigation."		shiftCmdActions			at: ($w asciiValue - 96 + 1) put: #cameraForward:;			at: ($s asciiValue - 96 + 1) put: #cameraBackward:;			at: ($a asciiValue - 96 + 1) put: #cameraLeft:;			at: ($d asciiValue - 96 + 1) put: #cameraRight:;			at: ($q asciiValue - 96 + 1) put: #cameraUp:;			at: ($z asciiValue - 96 + 1) put: #cameraDown:;			at: ($e asciiValue - 96 + 1) put: #cameraHome:! !!CaffeineInstructions methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!CaffeineInstructions class methodsFor: 'as yet unclassified' stamp: 'crl 8/19/2016 12:27'!initialize	"Initialize myself."	self initializeInstructions: #(listTabs tabList getResourcesForTab tabResources getResourcesForObject objectResources getValueOfObject objectValue putValueOfObject putOuterHTML outerHTML)! !!MIT methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!MIT class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!MethodNode methodsFor: 'as yet unclassified' stamp: 'crl 4/29/2017 00:43'!javaScript	 | stream |		stream := (String new: 256) writeStream.	self printJavaScriptOn: stream.	^stream contents! !!MethodNode methodsFor: 'as yet unclassified' stamp: 'crl 5/6/2017 17:52'!printJavaScriptOn: stream	| selectorNode |	selectorNode := self selectorNode.		stream nextPutAll: 'function '.		(precedence = 1)		ifTrue: [			selectorNode isForFFICall				ifTrue: [					selectorNode						halt;						printAsFFICallWithArguments: arguments						on: stream						indent: 0]				ifFalse: [					stream						nextPutAll: selectorNode key;						nextPut: $(]]		ifFalse: [			selectorNode key keywords do: [:keyword | stream nextPutAll: keyword allButLast capitalized].			stream nextPut: $(.			arguments				do: [:argument | stream nextPut: argument key]				separatedBy: [stream nextPutAll: ', ']].		stream nextPutAll: ') {'.							comment ifNotNil: [		stream crtab: 1.		self printJavaScriptCommentOn: stream indent: 1].		block		printJavaScriptTemporaries: temporaries		on: stream		doPrior: [stream crtab: 1].			stream crtab: 1.	block printJavaScriptStatementsOn: stream indent: 0.	stream nextPut: $}! !!MethodNode class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!XMLMessage methodsFor: 'as yet unclassified' stamp: 'crl 9/13/2012 18:29'!size	^self printString size! !!XMLMessage class methodsFor: 'as yet unclassified' stamp: 'crl 6/6/2011 00:29'!new	^(super new)		add: XMLProcessingDirective new;		yourself! !!MessageAsTempNode class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!TraitBehavior methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!TraitBehavior class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!EventSensorConstants methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!WebGLRenderer methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!WebGLRenderer class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!GZipConstants methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!AbstractLauncher class methodsFor: 'as yet unclassified' stamp: 'crl 9/3/2019 16:36'!deactivate	"Unregister this launcher with the auto start class"	[self autoStarter removeLauncher: self]		on: Error		do: [:exception | ]! !!PositionableStream methodsFor: 'as yet unclassified' stamp: 'crl 6/22/2016 15:30'!collection	^collection! !!PositionableStream methodsFor: 'as yet unclassified' stamp: 'crl 9/18/2019 00:47'!copyMethodChunkFrom: aStream at: pos	"Copy the next chunk from aStream (must be different from the receiver)."	| chunk |	aStream position: pos.	chunk := aStream nextChunkText.	('*swapInThisMethod*' match: chunk) ifTrue: [3 halt].	chunk runs values size = 1 "Optimize for unembellished text"		ifTrue: [self nextChunkPut: chunk asString]		ifFalse: [self nextChunkPutWithStyle: chunk]! !!PositionableStream methodsFor: 'as yet unclassified' stamp: 'crl 8/20/2017 00:52'!emptyCollection: aCollection	"Set my collection to aCollection, which is empty as far as readers are concerned."	collection := aCollection.	position := readLimit := 0! !!PositionableStream methodsFor: 'as yet unclassified' stamp: 'crl 7/7/2017 23:39'!peek: anInteger	"Answer the next anInteger elements without changing position."	| elements oldPosition |	oldPosition := self position.	elements := self next: anInteger.	self position: oldPosition.	^elements! !!PositionableStream class methodsFor: 'as yet unclassified' stamp: 'crl 8/20/2017 00:51'!emptyOn: aCollection	"Answer a new instance of myself on aCollection, which is functionally empty."	^self basicNew emptyCollection: aCollection! !!IdentityDictionary class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/16/2019 19:41'!asDictionary	| dictionary |		dictionary := Dictionary new.		self properties do: [:property |		dictionary			at: property			put: (self at: property)].			^dictionary! !!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 4/27/2017 19:22'!asJSArgument	^proxy! !!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 10/22/2017 18:15'!at: propertyName	^(proxy at: propertyName) counterpart simplestRepresentation! !!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 5/11/2017 22:46'!at: propertyName ifAbsent: block	^[(proxy perform: propertyName asSymbol) counterpart simplestRepresentation]		on: Error		do: [:exception | block value]! !!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 5/13/2017 21:56'!at: propertyName put: propertyValue	proxy at: propertyName put: propertyValue.	^propertyValue! !!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 5/5/2017 16:14'!cacheProperties	| instanceVariableNames |		instanceVariableNames := self class allInstVarNames.	self properties do: [:propertyName |		(instanceVariableNames includes: propertyName) ifTrue: [			self				instVarNamed: propertyName				put: (proxy at: propertyName) counterpart]]! !!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 6/18/2017 20:18'!counterpart	^self! !!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 5/12/2017 23:10'!doesNotUnderstand: message	| jsSelector selector |		jsSelector := (String new: 16) writeStream.	selector := message selector.		jsSelector nextPutAll: selector keywords first.	(selector numArgs - 1) timesRepeat: [jsSelector nextPutAll: 'with:'].				^(		proxy			perform: jsSelector contents asSymbol			withArguments: (message arguments collect: [:argument | argument asJSArgument])	)		counterpart simplestRepresentation! !!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 8/19/2017 12:50'!explorerContents	^self keysSortedSafely replace: [:key |		ObjectExplorerWrapper			with: (self at: key)			name: (key printString contractTo: 32)			model: self]! !!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 4/27/2017 22:42'!forward	| jsSelector selector context |		jsSelector := (String new: 16) writeStream.	context := thisContext sender.	selector := context selector.		jsSelector nextPutAll: selector keywords first.	(selector numArgs - 1) timesRepeat: [jsSelector nextPutAll: 'with:'].				^(		proxy			perform: jsSelector contents asSymbol			withArguments: (context arguments collect: [:argument | argument asJSArgument])	)		counterpart! !!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 5/5/2017 16:03'!functions	^((JS Object keys: proxy) asArray select: [:key | (proxy evaluate: 'try {return typeof this.', key, '} catch (e) {''string''}') asString = 'function']) collect: [:proxy | proxy asString]! !!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 3/28/2019 16:21'!includesKey: key	self at: key ifAbsent: [^false].	^true! !!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 8/18/2017 19:56'!isDictionary	^true! !!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 8/18/2017 19:56'!keys	^self properties! !!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 8/19/2017 12:51'!keysSortedSafely	"Answer a sorted Array containing the receiver's keys."		^self keys sort: [:x :y | x compareSafely: y]! !!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 5/20/2017 13:01'!primitiveSqueakAsJSObject: object	<primitive: 117> #(JavaScriptPlugin primitiveSqueakAsJSObject 0 0) at: 1.	^ self primitiveFailed! !!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 7/21/2017 16:52'!printOn: stream	| properties |		properties := self properties.	super printOn: stream.	properties ifNotEmpty: [		stream			nextPutAll: ' with properties: ';			print: properties]! !!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2019 22:26'!properties	^(		(JS Object keys: proxy) asArray select: [:key |			| source keyString number |					source := (String new: 32) writeStream.			source nextPutAll: 'try {return typeof this'.			keyString := key asString.					number := [keyString asNumber] on: Error do: [:exception | nil].			number				ifNil: [					source						nextPut: $.;						nextPutAll: keyString]				ifNotNil: [					source						nextPut: $[;						nextPutAll: keyString;						nextPut: $]].							source nextPutAll: ';} catch (e) {''string''}'.			[(proxy evaluate: source contents) asString ~= 'function'] on: Error do: [:exception | false]]	)		collect: [:proxy | proxy asString]! !!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2017 17:11'!proxy	^proxy! !!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 4/16/2017 23:29'!proxy: aJSObjectProxy	proxy := aJSObjectProxy! !!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 5/6/2017 15:49'!simplestRepresentation	^self! !!JSObject class methodsFor: 'as yet unclassified' stamp: 'crl 4/17/2017 02:28'!counterpart	^JS perform: (self name copyWithout: 'JS')! !!JSObject class methodsFor: 'as yet unclassified' stamp: 'crl 6/26/2017 15:00'!counterpartFor: proxy	^(self subclassCorrespondingToConstructorName: ((proxy at: 'constructor') name asString reverse readStream upTo: Character space) reverse) forProxy: proxy! !!JSObject class methodsFor: 'as yet unclassified' stamp: 'crl 4/17/2017 01:31'!exemplar	^(JS Function new: 'return new Object') call! !!JSObject class methodsFor: 'as yet unclassified' stamp: 'crl 5/18/2017 19:07'!forProxy: proxy	^self basicNew proxy: proxy! !!JSObject class methodsFor: 'as yet unclassified' stamp: 'crl 8/18/2017 20:41'!from: dictionary	| proxy |		proxy := JS Object new.		dictionary keysAndValuesDo: [:key :value | proxy at: key put: value].	^self forProxy: proxy! !!JSObject class methodsFor: 'as yet unclassified' stamp: 'crl 3/31/2019 10:12'!fromJSObject: jsObject	^self forProxy: jsObject proxy! !!JSObject class methodsFor: 'as yet unclassified' stamp: 'crl 4/17/2017 02:37'!functions	| prototype |		prototype := self prototype.		^((JS Object keys: prototype) asArray select: [:key | (prototype evaluate: 'try {return typeof this.', key, '} catch (e) {''string''}') asString = 'function']) collect: [:proxy | proxy asString asSymbol]! !!JSObject class methodsFor: 'as yet unclassified' stamp: 'crl 8/18/2017 10:19'!newWithParameters: parameters	| constructorName constructor |		constructorName := (		('JS*' match: name)			ifTrue: [name copyFrom: 3 to: name size]			ifFalse: [name]).				constructor := JS at: constructorName.	constructor ifNil: [constructor := JS top at: constructorName].	constructor ifNil: [constructor := (JS top at: 'THREE') ifNotNilDo: [:three | three at: constructorName]].	constructor ifNil: [self error: 'No matching constructor.'].		^constructor newWithParameters: parameters! !!JSObject class methodsFor: 'as yet unclassified' stamp: 'crl 4/17/2017 02:33'!prototype	^self counterpart prototype! !!JSObject class methodsFor: 'as yet unclassified' stamp: 'crl 8/1/2017 10:31'!subclassCorrespondingToConstructorName: constructorName	| pattern patternSource |		pattern := (String new: constructorName size) writeStream.	patternSource := constructorName readStream.	[patternSource atEnd] whileFalse: [		(patternSource peek = $-)			ifTrue: [				[patternSource peek = $-] whileTrue: [patternSource next].				patternSource atEnd ifFalse: [pattern nextPut: patternSource next asUppercase]]			ifFalse: [pattern nextPut: patternSource next]].			pattern := pattern contents.		self withAllSubclassesDo: [:class |		| className |				className := class name.				(			(				('JS*' match: className)					ifTrue: [className copyFrom: 3 to: className size]					ifFalse: [className]			)				match: pattern		)			ifTrue: [^class]].		^(pattern isEmpty)		ifTrue: [JSObject]		ifFalse: [self error: 'No corresponding class for ', pattern, ' yet.']! !!JSPlayer methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSPlayer class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!FillStyle class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!MessageTrace methodsFor: 'as yet unclassified' stamp: 'crl 3/28/2019 11:52'!initialExtent	^693@430! !!XMLProcessingDirective class methodsFor: 'as yet unclassified' stamp: 'crl 6/2/2011 14:04'!new	^(super new)		version: '1.0' encoding: 'utf-8';		yourself! !!TraitMethodState methodsFor: 'as yet unclassified' stamp: 'ar 12/29/2009 18:11'!methodHome	"The behavior (trait/class) this method was originally defined in. 	Derived from the originalTraitMethod if any."	^originalTraitMethod ifNil:[super methodHome] ifNotNil:[:m| m methodHome]! !!TraitMethodState methodsFor: 'as yet unclassified' stamp: 'ar 12/29/2009 18:11'!originalTraitMethod	"The original method from the trait"	^originalTraitMethod! !!TraitMethodState methodsFor: 'as yet unclassified' stamp: 'ar 12/29/2009 18:11'!originalTraitMethod: aCompiledMethod	"The original method from the trait"	originalTraitMethod := aCompiledMethod! !!TraitMethodState methodsFor: 'as yet unclassified' stamp: 'ar 12/29/2009 18:11'!originalTraitOrClass	"The original trait for this method"	^originalTraitMethod originalTraitOrClass! !!ChromeDOMAPI methodsFor: 'as yet unclassified' stamp: 'crl 7/24/2017 14:49'!attributeModified: object	<parseParameters: #parseAttributeModifiedFrom:>! !!ChromeDOMAPI methodsFor: 'as yet unclassified' stamp: 'crl 7/22/2017 14:33'!characterDataModified: object	<parseParameters: #parseCharacterDataModifiedFrom:>! !!ChromeDOMAPI methodsFor: 'as yet unclassified' stamp: 'crl 7/24/2017 15:07'!childNodeCountUpdated: object	<parseParameters: #parseChildNodeCountFrom:>! !!ChromeDOMAPI methodsFor: 'as yet unclassified' stamp: 'crl 7/24/2017 15:13'!childNodeInserted: object	<parseParameters: #parseChildNodeInsertedFrom:>! !!ChromeDOMAPI methodsFor: 'as yet unclassified' stamp: 'crl 7/24/2017 15:12'!childNodeRemoved: object	<parseParameters: #parseChildNodeRemovedFrom:>! !!ChromeDOMAPI methodsFor: 'as yet unclassified' stamp: 'crl 7/22/2017 02:17'!initialize	super initialize.	nodes := IdentityDictionary new! !!ChromeDOMAPI methodsFor: 'as yet unclassified' stamp: 'crl 7/24/2017 15:14'!inlineStyleInvalidated: object	<parseParameters: #parseInlineStyleInvalidatedFrom:>! !!ChromeDOMAPI methodsFor: 'as yet unclassified' stamp: 'crl 7/22/2017 00:29'!noteNode: node	nodes at: node nodeId put: node! !!ChromeDOMAPI methodsFor: 'as yet unclassified' stamp: 'crl 7/24/2017 14:50'!parseAttributeModifiedFrom: dictionary! !!ChromeDOMAPI methodsFor: 'as yet unclassified' stamp: 'crl 7/22/2017 14:33'!parseCharacterDataModifiedFrom: dictionary! !!ChromeDOMAPI methodsFor: 'as yet unclassified' stamp: 'crl 7/24/2017 15:07'!parseChildNodeCountFrom: dictionary! !!ChromeDOMAPI methodsFor: 'as yet unclassified' stamp: 'crl 7/24/2017 15:13'!parseChildNodeInsertedFrom: dictionary! !!ChromeDOMAPI methodsFor: 'as yet unclassified' stamp: 'crl 7/24/2017 15:12'!parseChildNodeRemovedFrom: dictionary! !!ChromeDOMAPI methodsFor: 'as yet unclassified' stamp: 'crl 7/22/2017 12:36'!parseChildNodesFrom: dictionary	| childNodes |		childNodes := ChromeDOMChildNodes fromDictionary: dictionary.	childNodes nodes do: [:node |		self noteNode: (			DOMNodeMirror				forProxy: node proxy				andTab: tab)].	^childNodes! !!ChromeDOMAPI methodsFor: 'as yet unclassified' stamp: 'crl 7/24/2017 15:14'!parseInlineStyleInvalidatedFrom: dictionary! !!ChromeDOMAPI methodsFor: 'as yet unclassified' stamp: 'crl 7/22/2017 23:16'!root	root ifNil: [		tab send: 'DOM.enable'.		root := (			DOMNodeMirror				forProxy: ((tab send: 'DOM.getDocument') root proxy)				andTab: tab).					self noteNode: root].		^root! !!ChromeDOMAPI methodsFor: 'as yet unclassified' stamp: 'crl 7/22/2017 12:15'!setChildNodes: childNodes	<parseParameters: #parseChildNodesFrom:>		(nodes at: childNodes parentId ifAbsent: [^self]) children: childNodes nodes.	resultAvailable signal! !!ChromeDOMAPI class methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 12:39'!domain	^'DOM'! !!WeakSetInspector class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!TopGripMorph class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!BrowseAvailableModules methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!BrowseAvailableModules class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!OrderedDictionary class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!TraitDescription methodsFor: 'as yet unclassified' stamp: 'ar 12/29/2009 18:20'!+ aTrait	"Creates a composition with the receiver and aTrait"	aTrait traitsDo:[:t| self == t ifTrue:[TraitCompositionException			signal: 'Trait ' , self asString, ' already in composition']].	^TraitComposition withAll: {self}, aTrait asTraitComposition! !!TraitDescription methodsFor: 'as yet unclassified' stamp: 'ar 12/29/2009 18:22'!- anArrayOfSelectors	"Creates an exclusion"	^TraitExclusion		with: self		exclusions: anArrayOfSelectors! !!TraitDescription methodsFor: 'as yet unclassified' stamp: 'ar 12/29/2009 18:17'!@ anArrayOfAssociations 	"Creates an alias"	^TraitAlias with: self aliases: anArrayOfAssociations! !!TraitDescription methodsFor: 'as yet unclassified' stamp: 'ar 12/19/2009 23:56'!addSelectorSilently: selector withMethod: compiledMethod	"Overridden to update the users of this trait"	super addSelectorSilently: selector withMethod: compiledMethod.	self users do:[:each| each updateTraits].! !!TraitDescription methodsFor: 'as yet unclassified' stamp: 'ar 12/20/2009 00:42'!addTraitUser: aTrait	users := self users copyWith: aTrait.! !!TraitDescription methodsFor: 'as yet unclassified' stamp: 'ar 11/28/2007 20:57'!allClassVarNames	"Traits have no class var names"	^#()! !!TraitDescription methodsFor: 'as yet unclassified' stamp: 'ar 12/29/2009 18:20'!asTraitComposition	^TraitComposition with: self! !!TraitDescription methodsFor: 'as yet unclassified' stamp: 'ar 11/28/2007 20:58'!classPool	"Traits have no class pool"	^ Dictionary new! !!TraitDescription methodsFor: 'as yet unclassified' stamp: 'ar 11/28/2007 20:55'!copy 	self error: 'Traits cannot be trivially copied'! !!TraitDescription methodsFor: 'as yet unclassified' stamp: 'ar 11/28/2007 20:55'!copyTraitExpression	"Copy all except the actual traits"	^self! !!TraitDescription methodsFor: 'as yet unclassified' stamp: 'ar 12/19/2009 16:09'!fileOut	"Create a file whose name is the name of the receiver with '.st' as the 	extension, and file a description of the receiver onto it."	^ self fileOutAsHtml: false! !!TraitDescription methodsFor: 'as yet unclassified' stamp: 'ar 12/19/2009 16:08'!fileOutAsHtml: useHtml	"File a description of the receiver onto a new file whose base name is the name of the receiver."	| internalStream |	internalStream := WriteStream on: (String new: 100).	internalStream header; timeStamp.	self fileOutOn: internalStream moveSource: false toFile: 0.	internalStream trailer.	FileStream writeSourceCodeFrom: internalStream baseName: self name isSt: true useHtml: useHtml.! !!TraitDescription methodsFor: 'as yet unclassified' stamp: 'ar 12/20/2009 02:35'!includesTrait: aTrait	^self == aTrait or:[super includesTrait: aTrait]! !!TraitDescription methodsFor: 'as yet unclassified' stamp: 'ar 12/19/2009 23:54'!installTraitsFrom: aTraitComposition	super installTraitsFrom: aTraitComposition.	self users do:[:each| each updateTraits].! !!TraitDescription methodsFor: 'as yet unclassified' stamp: 'ar 11/28/2007 21:01'!isBaseTrait	^false! !!TraitDescription methodsFor: 'as yet unclassified' stamp: 'ar 11/28/2007 21:01'!isClassTrait	^false! !!TraitDescription methodsFor: 'as yet unclassified' stamp: 'ar 11/28/2007 20:56'!isTrait	^true! !!TraitDescription methodsFor: 'as yet unclassified' stamp: 'ar 11/28/2007 20:56'!isTraitTransformation	"Polymorphic with TraitTransformation"	^false! !!TraitDescription methodsFor: 'as yet unclassified' stamp: 'ar 12/20/2009 00:52'!notifyOfRecategorizedSelector: element from: oldCategory to: newCategory	super notifyOfRecategorizedSelector: element from: oldCategory to: newCategory.	self users do:[:each| each classify: element under: newCategory from: oldCategory trait: self].! !!TraitDescription methodsFor: 'as yet unclassified' stamp: 'ar 12/27/2009 19:14'!printHierarchy	"For hierarchy view in the browser; print the users of a trait"	^String streamContents:[:s| self printUsersOf: self on: s level: 0].! !!TraitDescription methodsFor: 'as yet unclassified' stamp: 'ar 12/27/2009 19:16'!printUsersOf: aClass on: aStream level: indent	aStream crtab: indent.	aStream nextPutAll: aClass name.	aClass isTrait ifTrue:[		aClass users do:[:each| self printUsersOf: aClass on: aStream level: indent+1].	].! !!TraitDescription methodsFor: 'as yet unclassified' stamp: 'ar 12/20/2009 00:39'!removeTraitUser: aTrait	users := self users copyWithout: aTrait.! !!TraitDescription methodsFor: 'as yet unclassified' stamp: 'ar 11/28/2007 20:58'!sharedPools	"Traits have no shared pools"	^ Dictionary new! !!TraitDescription methodsFor: 'as yet unclassified' stamp: 'ar 12/21/2009 15:13'!trait	^self! !!TraitDescription methodsFor: 'as yet unclassified' stamp: 'ar 11/28/2007 20:59'!traitsDo: aBlock	aBlock value: self.! !!TraitDescription methodsFor: 'as yet unclassified' stamp: 'ar 11/28/2007 20:55'!users	^users ifNil:[#()]! !!TraitDescription methodsFor: 'as yet unclassified' stamp: 'ar 11/28/2007 20:55'!users: aCollection	users := aCollection! !!TraitDescription class methodsFor: 'as yet unclassified' stamp: 'ar 12/19/2009 22:47'!conflict	"This method has a trait conflict"	^self traitConflict! !!TraitDescription class methodsFor: 'as yet unclassified' stamp: 'ar 12/19/2009 22:48'!conflict: arg1	"This method has a trait conflict"	^self traitConflict! !!TraitDescription class methodsFor: 'as yet unclassified' stamp: 'ar 12/19/2009 22:48'!conflict: arg1 with: arg2	"This method has a trait conflict"	^self traitConflict! !!TraitDescription class methodsFor: 'as yet unclassified' stamp: 'ar 12/19/2009 22:48'!conflict: arg1 with: arg2 with: arg3	"This method has a trait conflict"	^self traitConflict! !!TraitDescription class methodsFor: 'as yet unclassified' stamp: 'ar 12/19/2009 22:48'!conflict: arg1 with: arg2 with: arg3 with: arg4	"This method has a trait conflict"	^self traitConflict! !!TraitDescription class methodsFor: 'as yet unclassified' stamp: 'ar 12/19/2009 22:48'!conflict: arg1 with: arg2 with: arg3 with: arg4 with: arg5	"This method has a trait conflict"	^self traitConflict! !!TraitDescription class methodsFor: 'as yet unclassified' stamp: 'ar 12/19/2009 22:48'!conflict: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	"This method has a trait conflict"	^self traitConflict! !!TraitDescription class methodsFor: 'as yet unclassified' stamp: 'ar 12/19/2009 22:48'!conflict: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6 with: arg7	"This method has a trait conflict"	^self traitConflict! !!TraitDescription class methodsFor: 'as yet unclassified' stamp: 'ar 12/19/2009 22:48'!conflict: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6 with: arg7 with: arg8	"This method has a trait conflict"	^self traitConflict! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/2/2001 21:20'!acceptNameEdit	"If the name is currently under edit, accept the changes"	| label |	(label := self findA: NameStringInHalo) ifNotNil:		[label hasFocus ifTrue:			[label lostFocusWithoutAccepting]]! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'nk 6/12/2004 09:24'!addChooseGraphicHandle: haloSpec	"If the target is a sketch morph, and if the governing preference is set, add a halo handle allowing the user to select a new graphic"	(Preferences showChooseGraphicHaloHandle and: [innerTarget isSketchMorph]) ifTrue:		[self addHandle: haloSpec				on: #mouseDown send: #chooseNewGraphicFromHalo to: innerTarget]! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 4/27/2000 13:39'!addCircleHandles	| box |	simpleMode := false.	target isWorldMorph ifTrue: [^ self addHandlesForWorldHalos].	self removeAllMorphs.  "remove old handles, if any"	self bounds: target renderedMorph worldBoundsForHalo.  "update my size"	box := self basicBox.	target addHandlesTo: self box: box.	self addName.	growingOrRotating := false.	self layoutChanged.	self changed.! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 12/13/2001 14:07'!addCollapseHandle: handleSpec	"Add the collapse handle, with all of its event handlers set up, unless the target's owner is not the world or the hand."	| collapseHandle |	(target owner notNil "nil happens, amazingly"			and: [target owner isWorldOrHandMorph])		ifFalse: [^ self].	collapseHandle := self addHandle: handleSpec		on: #mouseDown send: #mouseDownInCollapseHandle:with: to: self.	collapseHandle on: #mouseUp send: #maybeCollapse:with: to: self.	collapseHandle on: #mouseMove send: #setDismissColor:with: to: self! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 1/26/2000 15:51'!addDebugHandle: handleSpec	Preferences debugHaloHandle ifTrue:		[self addHandle: handleSpec			on: #mouseDown send: #doDebug:with: to: self]! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'dgd 4/4/2006 16:56'!addDirectionHandles	| centerHandle d w directionShaft patch patchColor crossHairColor |	self showingDirectionHandles ifFalse: [^ self].	directionArrowAnchor := (target point: target referencePosition in: self world) rounded.	patch := target imageFormForRectangle: (Rectangle center: directionArrowAnchor extent: 3@3).	patchColor := patch colorAt: 1@1.	(directionShaft := LineMorph newSticky makeForwardArrow)		borderWidth: 2; borderColor: (Color green orColorUnlike: patchColor).	self positionDirectionShaft: directionShaft.	self addMorphFront: directionShaft.	directionShaft setCenteredBalloonText: 'Set forward direction' translated;		on: #mouseDown send: #doDirection:with: to: self;		on: #mouseMove send: #trackDirectionArrow:with: to: self;		on: #mouseUp send: #setDirection:with: to: self.	d := 15.  "diameter"  w := 3.  "borderWidth"	crossHairColor := Color red orColorUnlike: patchColor.	(centerHandle := EllipseMorph newBounds: (0@0 extent: d@d) color: Color transparent)			borderWidth: w; borderColor: (Color blue orColorUnlike: patchColor);			addMorph: (LineMorph from: (d//2)@w to: (d//2)@(d-w-1) color: crossHairColor width: 1) lock;			addMorph: (LineMorph from: w@(d//2) to: (d-w-1)@(d//2) color: crossHairColor width: 1) lock;			align: centerHandle bounds center with: directionArrowAnchor.	centerHandle wantsYellowButtonMenu: false.	self addMorph: centerHandle.	centerHandle setCenteredBalloonText: 'Rotation center (hold down the shift key and drag from here to change it)' translated;			on: #mouseDown send: #prepareToTrackCenterOfRotation:with: to: self;			on: #mouseMove send: #trackCenterOfRotation:with: to: self;			on: #mouseUp send: #setCenterOfRotation:with: to: self! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 11/27/2001 11:18'!addDismissHandle: handleSpec	"Add the dismiss handle according to the spec, unless selectiveHalos is on and my target resists dismissal"	| dismissHandle |	(target okayToAddDismissHandle or: [Preferences selectiveHalos not]) ifTrue:		[dismissHandle := self addHandle: handleSpec			on: #mouseDown send: #mouseDownInDimissHandle:with: to: self.		dismissHandle on: #mouseUp send: #maybeDismiss:with: to: self.		dismissHandle on: #mouseDown send: #setDismissColor:with: to: self.		dismissHandle on: #mouseMove send: #setDismissColor:with: to: self]! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/25/2000 17:48'!addDragHandle: haloSpec	(self addHandle: haloSpec on: #mouseDown send: #startDrag:with: to: self)		on: #mouseMove send: #doDrag:with: to: self! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 12/29/2004 22:18'!addDupHandle: haloSpec	"Add the halo that offers duplication, or, when shift is down, make-sibling"	self addHandle: haloSpec on: #mouseDown send: #doDupOrMakeSibling:with: to: self! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 1/28/2000 09:59'!addFewerHandlesHandle: haloSpec	self addHandle: haloSpec on: #mouseDown send: #addSimpleHandles to: self! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'gm 2/22/2003 13:13'!addFontEmphHandle: haloSpec 	(innerTarget isTextMorph) 		ifTrue: 			[self 				addHandle: haloSpec				on: #mouseDown				send: #chooseEmphasisOrAlignment				to: innerTarget]! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'gm 2/22/2003 13:13'!addFontSizeHandle: haloSpec 	(innerTarget isTextMorph) 		ifTrue: 			[self 				addHandle: haloSpec				on: #mouseDown				send: #chooseFont				to: innerTarget]! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'gm 2/22/2003 13:13'!addFontStyleHandle: haloSpec 	(innerTarget isTextMorph) 		ifTrue: 			[self 				addHandle: haloSpec				on: #mouseDown				send: #chooseStyle				to: innerTarget]! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/29/1999 15:31'!addFullHandles	"Later, obey a preference to choose between circle-iconic and solid-circles"	self addCircleHandles! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/27/2000 17:22'!addGrabHandle: haloSpec	"If appropriate, add the black halo handle for picking up the target"	innerTarget okayToAddGrabHandle ifTrue:		[self addHandle: haloSpec on: #mouseDown send: #doGrab:with: to: self]! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'dgd 8/28/2003 15:15'!addGraphicalHandle: formKey at: aPoint on: eventName send: selector to: recipient	"Add the supplied form as a graphical handle centered at the given point, and set it up to respond to the given event by sending the given selector to the given recipient.  Return the handle."	| handle |	handle := self addGraphicalHandleFrom: formKey at: aPoint.	handle on: eventName send: selector to: recipient.	handle setBalloonText: (target balloonHelpTextForHandle: handle) translated.	^ handle! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'dgd 9/18/2004 18:23'!addGraphicalHandleFrom: formKey at: aPoint	"Add the supplied form as a graphical handle centered at the given point.  Return the handle."	| handle aForm |	aForm := (ScriptingSystem formAtKey: formKey) ifNil: [ScriptingSystem formAtKey: #SolidMenu].	handle := ImageMorph new image: aForm; bounds: (Rectangle center: aPoint extent: aForm extent).	handle wantsYellowButtonMenu: false.	self addMorph: handle.	handle on: #mouseUp send: #endInteraction to: self.	^ handle! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'dgd 8/28/2004 18:13'!addGrowHandle: haloSpec	target isFlexMorph ifFalse: 		[(self addHandle: haloSpec				on: #mouseDown send: #startGrow:with: to: self)				on: #mouseMove send: #doGrow:with: to: self]	"This or addScaleHandle:, but not both, will prevail at any one time"! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'dgd 9/26/2004 19:37'!addHandle: handleSpec on: eventName send: selector to: recipient 	"Add a handle within the halo box as per the haloSpec, and set 	it up to respond to the given event by sending the given 	selector to the given recipient. Return the handle."	| handle aPoint |	aPoint := self				positionIn: haloBox				horizontalPlacement: handleSpec horizontalPlacement				verticalPlacement: handleSpec verticalPlacement.	handle := self				addHandleAt: aPoint				color: (Color colorFrom: handleSpec color)				icon: handleSpec iconSymbol				on: eventName				send: selector				to: recipient.	self isMagicHalo		ifTrue: [			handle on: #mouseEnter send: #handleEntered to: self.			handle on: #mouseLeave send: #handleLeft to: self].	^ handle! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'cmm 1/10/2011 14:59'!addHandleAt: aPoint color: aColor icon: iconName on: eventName send: selector to: recipient 	"Add a handle centered at the given point with the given color, 	and set it up to respond to the given event by sending the 	given selector to the given recipient. Return the handle."	| handle |	handle := self createHandleAt: aPoint color: (aColor alpha: 0.8) iconName: iconName.	self addMorph: handle.	handle on: #mouseUp send: #endInteraction to: self.	handle on: eventName send: selector to: recipient.	handle setBalloonText: (target balloonHelpTextForHandle: handle) translated.	^ handle ! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 1/29/2000 18:36'!addHandleAt: aPoint color: aColor on: eventName send: selector to: recipient	^ self addHandleAt: aPoint color: aColor icon: nil on: eventName send: selector to: recipient! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 1/28/2000 09:57'!addHandles	simpleMode == true		ifTrue:			[self addSimpleHandles]		ifFalse:			[self addCircleHandles]! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/4/2000 16:27'!addHandlesForWorldHalos	"Add handles for world halos, like the man said"	| box w |	w := self world ifNil:[target world].	self removeAllMorphs.  "remove old handles, if any"	self bounds: target bounds.	box := w bounds insetBy: 9.	target addWorldHandlesTo: self box: box.	Preferences uniqueNamesInHalos ifTrue:		[innerTarget assureExternalName].	self addNameBeneath: (box insetBy: (0@0 corner: 0@10)) string: innerTarget externalName.	growingOrRotating := false.	self layoutChanged.	self changed.! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 1/26/2000 16:16'!addHelpHandle: haloSpec	target balloonText ifNotNil:		[(self addHandle: haloSpec on: #mouseDown send: #mouseDownOnHelpHandle: to: innerTarget)			on: #mouseUp send: #deleteBalloon to: innerTarget]! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 12/29/2004 22:18'!addMakeSiblingHandle: haloSpec	"Add the halo handle that allows a sibling instance to be torn off, or, if the shift key is down, for a deep-copy duplicate to be made."	self addHandle: haloSpec on: #mouseDown send: #doMakeSiblingOrDup:with: to: self! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 1/26/2000 16:05'!addMenuHandle: haloSpec	self addHandle: haloSpec on: #mouseDown send: #doMenu:with: to: self! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 8/16/2000 17:41'!addName	"Add a name readout at the bottom of the halo."	Preferences uniqueNamesInHalos ifTrue:		[target assureExternalName].	self addNameBeneath: self basicBox string: target externalName! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'dgd 4/4/2006 16:58'!addNameBeneath: outerRectangle string: aString	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."	| nameMorph namePosition w |	w := self world ifNil:[target world].	nameMorph := NameStringInHalo contents: aString font: Preferences standardHaloLabelFont.	nameMorph wantsYellowButtonMenu: false.	nameMorph color: Color black.	nameMorph useStringFormat; target: innerTarget; putSelector: #tryToRenameTo:.	namePosition := outerRectangle bottomCenter -		((nameMorph width // 2) @ (self handleSize negated // 2 - 1)).	nameMorph position: (namePosition min: w viewBox bottomRight - nameMorph extent y + 2).	nameMorph balloonTextSelector: #objectNameInHalo.	self addMorph: nameMorph.	^ nameMorph! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 1/27/2000 16:23'!addPaintBgdHandle: haloSpec	(innerTarget isKindOf: PasteUpMorph) ifTrue:		[self addHandle: haloSpec				on: #mouseDown send: #paintBackground to: innerTarget].! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 11/16/2002 19:24'!addPoohHandle: handleSpec	(innerTarget isKindOf: (Smalltalk at: #WonderlandCameraMorph ifAbsent:[nil])) ifTrue:		[self addHandle: handleSpec on: #mouseDown send: #strokeMode to: innerTarget]! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/15/2001 11:24'!addRecolorHandle: haloSpec	"Add a recolor handle to the receiver, if appropriate"	| recolorHandle |	"since this halo now opens a more general properties panel, allow it in all cases"	"innerTarget canSetColor ifTrue:"	recolorHandle := self addHandle: haloSpec on: #mouseUp send: #doRecolor:with: to: self.	recolorHandle on: #mouseUp send: #doRecolor:with: to: self! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'nk 6/12/2004 09:24'!addRepaintHandle: haloSpec	(innerTarget isSketchMorph) ifTrue:		[self addHandle: haloSpec				on: #mouseDown send: #editDrawing to: innerTarget]! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/25/2000 17:49'!addRotateHandle: haloSpec	(self addHandle: haloSpec on: #mouseDown send: #startRot:with: to: self)		on: #mouseMove send: #doRot:with: to: self! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/25/2000 17:49'!addScaleHandle: haloSpec	target isFlexMorph ifTrue: 		[(self addHandle: haloSpec				on: #mouseDown send: #startScale:with: to: self)				on: #mouseMove send: #doScale:with: to: self].	"This or addGrowHandle:, but not both, will prevail at any one time"! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/9/2000 16:57'!addScriptHandle: haloSpec	"If the halo's innerTarget claims it wants a Script handle, add one to the receiver, forming it as per haloSpec"	innerTarget wantsScriptorHaloHandle ifTrue:		[self addHandle: haloSpec				on: #mouseUp send: #editButtonsScript to: innerTarget]! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 4/27/2000 13:40'!addSimpleHandles	target isWorldMorph ifTrue: [^ self addHandlesForWorldHalos].	self removeAllMorphs.  "remove old handles, if any"	self bounds: target renderedMorph worldBoundsForHalo.  "update my size"	self innerTarget addSimpleHandlesTo: self box: self basicBoxForSimpleHalos! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/28/1999 15:39'!addSimpleHandlesForWorldHalos	"Nothing special at present here -- just use the regular handles.  Cannot rotate or resize world"	self addHandlesForWorldHalos! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'nk 6/12/2004 09:34'!addSimpleHandlesTo: aHaloMorph box: aBox	| aHandle |	simpleMode := true.	target isWorldMorph ifTrue: [^ self addSimpleHandlesForWorldHalos].	self removeAllMorphs.  "remove old handles, if any"		self bounds: target renderedMorph worldBoundsForHalo.  "update my size"		self addHandleAt: (((aBox topLeft + aBox leftCenter) // 2) + self simpleFudgeOffset) color: Color paleBuff icon: 'Halo-MoreHandles'		on: #mouseDown send: #addFullHandles to: self.	aHandle := self addGraphicalHandle: #Rotate at: aBox bottomLeft on: #mouseDown send: #startRot:with: to: self.	aHandle on: #mouseMove send: #doRot:with: to: self.	target isFlexMorph		ifTrue: [(self addGraphicalHandle: #Scale at: aBox bottomRight  on: #mouseDown send: #startScale:with: to: self)				on: #mouseMove send: #doScale:with: to: self]		ifFalse: [(self addGraphicalHandle: #Scale at: aBox bottomRight on: #mouseDown send: #startGrow:with: to: self)				on: #mouseMove send: #doGrow:with: to: self].	innerTarget wantsSimpleSketchMorphHandles ifTrue:		[self addSimpleSketchMorphHandlesInBox: aBox].	growingOrRotating := false.	self layoutChanged.	self changed.! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 1/27/2000 17:37'!addSimpleSketchMorphHandlesInBox: box	self addGraphicalHandle: #PaintTab at: box bottomCenter on: #mouseDown send: #editDrawing to: self innerTarget.	self addDirectionHandles! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/2/2001 22:17'!addTileHandle: haloSpec	"Add the 'tear-off-tile' handle from the spec"	self addHandle: haloSpec on: #mouseDown send: #tearOffTileForTarget:with: to: self! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/2/2001 22:17'!addViewHandle: haloSpec	"Add the 'open viewer' handle from the halo spec"	self addHandle: haloSpec		on: #mouseDown send: #openViewerForTarget:with: to: self! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/23/2000 18:19'!addViewingHandle: haloSpec	"If appropriate, add a special Viewing halo handle to the receiver"	(innerTarget isKindOf: PasteUpMorph) ifTrue:		[self addHandle: haloSpec				on: #mouseDown send: #presentViewMenu to: innerTarget].! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/7/2000 23:36'!basicBox	| aBox minSide anExtent w |	minSide := 4 * self handleSize.	anExtent := ((self width + self handleSize + 8) max: minSide) @				((self height + self handleSize + 8) max: minSide).	aBox := Rectangle center: self center extent: anExtent.	w := self world ifNil:[target outermostWorldMorph].	^ w		ifNil:			[aBox]		ifNotNil:			[aBox intersect: (w viewBox insetBy: 8@8)]! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/7/2000 23:36'!basicBoxForSimpleHalos	| w |	w := self world ifNil:[target outermostWorldMorph].	^ (target topRendererOrSelf worldBoundsForHalo expandBy: self handleAllowanceForIconicHalos)			intersect: (w bounds insetBy: 8@8)! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'mtf 2/20/2011 20:41'!blueButtonDown: event	"Transfer the halo to the next likely recipient"	target ifNil:[^self delete].	event hand obtainHalo: self.	positionOffset := event position - (target point: target position in: owner).	self isMagicHalo ifTrue:[		self isMagicHalo: false.		^self magicAlpha: 1.0].	"wait for drags or transfer"	event hand 		waitForClicksOrDrag: self 		event: event		selectors: { #transferHalo:. nil. nil. #dragTarget:. }		threshold: HandMorph dragThreshold! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'di 11/17/2001 10:56'!changed	"Quicker to invalidate handles individually if target is large (especially the world)"	self extent > (200@200)		ifTrue: [(target notNil and: [target ~~ self world]) ifTrue:					["Invalidate 4 outer strips first, thus subsuming separate damage."					(self fullBounds areasOutside: target bounds) do:						[:r | self invalidRect: r]].				self submorphsDo: [:m | m changed]]		ifFalse: [super changed].! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'jmv 3/2/2010 16:02'!containsPoint: aPoint 	"This method is overridden so that, once up, the handles will stay up as long as the mouse is within the box that encloses all the handles even if it is not over any handle or over its owner."	^target		ifNil: [super containsPoint: aPoint] 		ifNotNil: [false]! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 9/15/2000 16:54'!containsPoint: aPoint event: anEvent	"Blue buttons are handled by the halo"	(anEvent isMouse and:[anEvent isMouseDown and:[anEvent blueButtonPressed]])		ifFalse:[^super containsPoint: aPoint event: anEvent].	^bounds containsPoint: anEvent position! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/20/2000 17:46'!convertToCurrentVersion: varDict refStream: smartRefStrm		simpleMode ifNil: [simpleMode := false].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'cmm 1/10/2011 15:00'!createHandleAt: aPoint color: aColor iconName: iconName 	| bou handle |	bou := Rectangle center: aPoint extent: self handleSize asPoint.	Preferences alternateHandlesLook		ifTrue: [handle := RectangleMorph newBounds: bou color: aColor.			handle useRoundedCorners.			self setColor: aColor toHandle: handle]		ifFalse: [handle := EllipseMorph newBounds: bou color: aColor].	handle borderWidth: 0;		 wantsYellowButtonMenu: false.	""	iconName isNil		ifFalse: [| form |			form := ScriptingSystem formAtKey: iconName.			form isNil				ifFalse: [| image |					image := ImageMorph new.					image image: form.					image color: aColor makeForegroundColor.					image lock.					handle addMorphCentered: image]].	""	^ handle! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'dgd 3/7/2003 14:28'!defaultColor	"answer the default color/fill style for the receiver"	^ Color		r: 0.6		g: 0.8		b: 1.0! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/2/2001 21:23'!delete	"Delete the halo.  Tell the target that it no longer has the halo; accept any pending edits to the name; and then either actually delete myself or start to fade out"	target ifNotNil:		[target hasHalo: false].	self acceptNameEdit.	self isMagicHalo: false.	Preferences haloTransitions		ifTrue:			[self stopStepping; startStepping.			self startSteppingSelector: #fadeOutFinally]		ifFalse:			[super delete]! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'di 9/26/2000 15:16'!directionArrowLength	^ 25! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'tpr 12/31/2013 15:56'!dismiss	"Remove my target from the world Seems to be EToy specific."	| w |	w := self world.	w ifNotNil: [w stopStepping: target].	self delete.	target dismissViaHalo! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/27/2002 09:27'!doDebug: evt with: menuHandle	"Ask hand to invoke the a debugging menu for my inner target.  If shift key is down, immediately put up an inspector on the inner target"	| menu |	self obtainHaloForEvent: evt andRemoveAllHandlesBut: nil.	self world displayWorld.	evt shiftPressed ifTrue: 		[self delete.		^ innerTarget inspectInMorphic: evt].	menu := innerTarget buildDebugMenu: evt hand.	menu addTitle: (innerTarget externalName truncateWithElipsisTo: 40).	menu popUpEvent: evt in: self world! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/24/2000 18:41'!doDirection: anEvent with: directionHandle	anEvent hand obtainHalo: self.	self removeAllHandlesBut: directionHandle! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'tk 7/14/2001 11:04'!doDrag: evt with: dragHandle	| thePoint |	evt hand obtainHalo: self.	thePoint := target point: evt position - positionOffset from: owner.	target setConstrainedPosition:(target griddedPoint: thePoint) hangOut: true.! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'nk 9/4/2004 17:38'!doDup: evt with: dupHandle	"Ask hand to duplicate my target."	(target isSelectionMorph) ifTrue:		[^ target doDup: evt fromHalo: self handle: dupHandle].	self obtainHaloForEvent: evt andRemoveAllHandlesBut: dupHandle.	self setTarget: (target duplicateMorph: evt).	evt hand grabMorph: target.	self step. "update position if necessary"	evt hand addMouseListener: self. "Listen for the drop"! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 3/30/2005 04:26'!doDupOrMakeSibling: evt with: dupHandle	"Ask hand to duplicate my target, if shift key *not* pressed, or make a sibling if shift key *is* pressed"	^ (evt shiftPressed and: [target couldMakeSibling])		ifTrue:			[dupHandle color: Color green muchDarker.			self doMakeSibling: evt with: dupHandle]		ifFalse:			[self doDup: evt with: dupHandle]! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/2/2001 22:35'!doGrab: evt with: grabHandle	"Ask hand to grab my target."	self obtainHaloForEvent: evt andRemoveAllHandlesBut: grabHandle.	evt hand grabMorph: target.	self step. "update position if necessary"	evt hand addMouseListener: self. "Listen for the drop"! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:11'!doGrow: evt with: growHandle	"Called while the mouse is down in the grow handle"	| newExtent extentToUse scale |	evt hand obtainHalo: self.	newExtent := (target pointFromWorld: (target griddedPoint: evt cursorPoint - positionOffset))								- target topLeft.	evt shiftPressed ifTrue: [		scale := (newExtent x / (originalExtent x max: 1)) min:					(newExtent y / (originalExtent y max: 1)).		newExtent := (originalExtent x * scale) asInteger @ (originalExtent y * scale) asInteger	].	(newExtent x < 1 or: [newExtent y < 1 ]) ifTrue: [^ self].	target renderedMorph setExtentFromHalo: (extentToUse := newExtent).	growHandle position: evt cursorPoint - (growHandle extent // 2).	self layoutChanged.	(self valueOfProperty: #commandInProgress) ifNotNil:  		[:cmd | "Update the final extent"			cmd redoTarget: target renderedMorph selector: #setFlexExtentFromHalo: argument: extentToUse]! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 3/30/2005 04:31'!doMakeSibling: evt with: dupHandle	"Ask hand to make a sibling of my target.  Only reachable if target is of a uniclass"	target couldMakeSibling ifFalse: [^ self].	target assuredPlayer assureUniClass.	self obtainHaloForEvent: evt andRemoveAllHandlesBut: dupHandle.	self setTarget: (target makeSiblings: 1) first.	evt hand grabMorph: target.	self step. "update position if necessary"	evt hand addMouseListener: self. "Listen for the drop"! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 3/30/2005 04:28'!doMakeSiblingOrDup: evt with: dupHandle	"Ask hand to duplicate my target, if shift key *is* pressed, or make a sibling if shift key *not* pressed"	^ (evt shiftPressed or: [target couldMakeSibling not])		ifFalse:			[self doMakeSibling: evt with: dupHandle]		ifTrue:			[dupHandle color: Color green.			self doDup: evt with: dupHandle]! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 11/29/2001 20:01'!doMenu: evt with: menuHandle	"Ask hand to invoke the halo menu for my inner target."	| menu |	self obtainHaloForEvent: evt andRemoveAllHandlesBut: nil.	self world displayWorld.	menu := innerTarget buildHandleMenu: evt hand.	innerTarget addTitleForHaloMenu: menu.	menu popUpEvent: evt in: self world.! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 9/20/2001 00:16'!doRecolor: evt with: aHandle	"The mouse went down in the 'recolor' halo handle.  Allow the user to change the color of the innerTarget"	evt hand obtainHalo: self.	(aHandle containsPoint: evt cursorPoint)		ifFalse:  "only do it if mouse still in handle on mouse up"			[self delete.			target addHalo: evt]		ifTrue:			[(Preferences propertySheetFromHalo == evt shiftPressed)				ifFalse:	[innerTarget openAPropertySheet]				ifTrue:	[innerTarget changeColor].			self showingDirectionHandles ifTrue: [self addHandles]]! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:11'!doRot: evt with: rotHandle	"Update the rotation of my target if it is rotatable.  Keep the relevant command object up to date."	| degrees |	evt hand obtainHalo: self.	degrees := (evt cursorPoint - (target pointInWorld: target referencePosition)) degrees.	degrees := degrees - angleOffset degrees.	degrees := degrees detentBy: 10.0 atMultiplesOf: 90.0 snap: false.	degrees = 0.0		ifTrue: [self setColor: Color lightBlue toHandle: rotHandle]		ifFalse: [self setColor: Color blue toHandle: rotHandle].	rotHandle submorphsDo:		[:m | m color: rotHandle color makeForegroundColor].	self removeAllHandlesBut: rotHandle.	self showingDirectionHandles ifFalse:		[self showDirectionHandles: true addHandles: false].	self addDirectionHandles.	target rotationDegrees: degrees.	rotHandle position: evt cursorPoint - (rotHandle extent // 2).	(self valueOfProperty: #commandInProgress) ifNotNil:		[:cmd | "Update the final rotation"		cmd redoTarget: target renderedMorph selector: #heading: argument: degrees].	self layoutChanged! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:11'!doScale: evt with: scaleHandle	"Update the scale of my target if it is scalable."	| newHandlePos colorToUse |	evt hand obtainHalo: self.	newHandlePos := evt cursorPoint - (scaleHandle extent // 2).	target scaleToMatch: newHandlePos.	colorToUse := target scale = 1.0						ifTrue: [Color yellow]						ifFalse: [Color orange].	self setColor: colorToUse toHandle: scaleHandle.	scaleHandle		submorphsDo: [:m | m color: colorToUse makeForegroundColor].	scaleHandle position: newHandlePos.	self layoutChanged.	(self valueOfProperty: #commandInProgress) ifNotNil:[:cmd |		"Update the final extent"		cmd redoTarget: target renderedMorph selector: #setFlexExtentFromHalo: argument: target extent	].! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'bf 6/24/2010 14:56'!dragTarget: event	"Begin dragging the target"	| thePoint |	event controlKeyPressed ifTrue: [^self growTarget: event].	growingOrRotating := false.	thePoint := target point: event position - positionOffset from: owner.	target setConstrainedPosition: thePoint hangOut: true.	event hand newMouseFocus: self.! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'kfr 4/19/2015 12:10'!drawOn: aCanvas 	"Draw this morph only if it has no target."	target isNil		ifTrue: [^ super drawOn: aCanvas].	(Preferences showBoundsInHalo			and: [target isWorldMorph not])		ifTrue: [| boundsColor |			boundsColor := MenuMorph menuSelectionColor						ifNil: [Color blue].			aCanvas				frameAndFillRectangle: self bounds				fillColor: Color transparent				borderWidth: 2				borderColor: 					(boundsColor isTranslucent						ifTrue: [boundsColor]						ifFalse: [boundsColor alpha: 0.8])]! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/8/2001 15:13'!drawSubmorphsOn: aCanvas	| alpha |	((alpha := self magicAlpha) = 1.0)		ifTrue:[^super drawSubmorphsOn: aCanvas].	^super drawSubmorphsOn: (aCanvas asAlphaBlendingCanvas: alpha)! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:10'!endInteraction	"Clean up after a user interaction with the a halo control"	| m |	self isMagicHalo: false.	"no longer"	self magicAlpha: 1.0.	(target isInWorld not or: [owner isNil]) ifTrue: [^self].	[target isFlexMorph and: [target hasNoScaleOrRotation]] whileTrue: 			[m := target firstSubmorph.			target removeFlexShell.			target := m].	self isInWorld 		ifTrue: 			["make sure handles show in front, even if flex shell added"			self comeToFront.			self addHandles].	(self valueOfProperty: #commandInProgress) ifNotNil: 			[:cmd | 			self rememberCommand: cmd.			self removeProperty: #commandInProgress]! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/8/2001 14:56'!fadeIn	self magicAlpha >= 1.0 ifTrue:[self stopSteppingSelector: #fadeIn].	self magicAlpha: ((self magicAlpha + 0.1) min: 1.0)! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/8/2001 15:44'!fadeInInitially	| max |	max := self isMagicHalo ifTrue:[0.3] ifFalse:[1.0].	self magicAlpha >= max ifTrue:[self stopSteppingSelector: #fadeInInitially].	self magicAlpha: ((self magicAlpha + (max * 0.1)) min: max)! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/8/2001 14:57'!fadeOut	self magicAlpha <= 0.3 ifTrue:[self stopSteppingSelector: #fadeOut].	self magicAlpha: ((self magicAlpha - 0.1) max: 0.3)! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/8/2001 15:46'!fadeOutFinally	self magicAlpha <= 0.05 ifTrue:[^super delete].	self magicAlpha <= 0.3 ifTrue:[		^self magicAlpha: (self magicAlpha - 0.03 max: 0.0)].	self magicAlpha: ((self magicAlpha * 0.5) max: 0.0)! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'bf 6/24/2010 14:44'!growTarget: event	"Begin resizing the target"	growingOrRotating := true.	positionOffset := event position.	originalExtent := target extent.	self removeAllHandlesBut: nil.	event hand newMouseFocus: self.	event hand addMouseListener: self. "add handles back on mouse-up"! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 1/26/2000 15:36'!haloBox: aBox	haloBox := aBox! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 1/27/2000 18:42'!handleAllowanceForIconicHalos	^ 12! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/8/2001 15:38'!handleEntered	self isMagicHalo ifFalse:[^self].	self stopStepping; startStepping.	self startSteppingSelector: #fadeIn.! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/8/2001 15:38'!handleLeft	self isMagicHalo ifFalse:[^self].	self stopStepping; startStepping.	self startSteppingSelector: #fadeOut.! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'nk 6/26/2002 07:19'!handleListenEvent: anEvent	"We listen for possible drop events here to add back those handles after a dup/grab operation"	(anEvent isMouse and:[anEvent isMove not]) ifFalse:[^ self]. "not interested"	anEvent hand removeMouseListener: self. "done listening"	(self world ifNil: [target world]) ifNil: [^ self].	self addHandles  "and get those handles back"! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'dgd 5/17/2004 20:18'!handleSize	^ Preferences biggerHandles		ifTrue: [20]		ifFalse: [16]! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 9/15/2000 16:42'!handlerForBlueButtonDown: anEvent	"Blue button was clicked within the receiver"	^self! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'dgd 3/7/2003 14:29'!initialize	"initialize the state of the receiver"	super initialize.	""	growingOrRotating := false.	simpleMode := Preferences simpleHalosInForce ! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'jm 5/22/1998 16:28'!innerTarget	^ innerTarget! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/8/2001 14:35'!isMagicHalo	^self valueOfProperty: #isMagicHalo ifAbsent:[false].! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/8/2001 15:37'!isMagicHalo: aBool	self setProperty: #isMagicHalo toValue: aBool.	aBool ifFalse:[		"Reset everything"		self stopStepping. "get rid of all"		self startStepping. "only those of interest"	].! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'nk 6/27/2003 12:28'!localHaloBoundsFor: aMorph	"aMorph may be in the hand and perhaps not in our world"	| r |	r := aMorph worldBoundsForHalo truncated.	aMorph world = self world ifFalse: [^r].	^((self transformFromOutermostWorld) globalBoundsToLocal: r) truncated! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/8/2001 14:28'!magicAlpha	^self valueOfProperty: #magicAlpha ifAbsent:[1.0]! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/8/2001 14:42'!magicAlpha: alpha	self setProperty: #magicAlpha toValue: alpha.	self changed.! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'aoy 2/15/2003 21:10'!maybeCollapse: evt with: collapseHandle 	"Ask hand to collapse my target if mouse comes up in it."	evt hand obtainHalo: self.	self delete.	(collapseHandle containsPoint: evt cursorPoint) 		ifFalse: 			[			target addHalo: evt]		ifTrue: 			[			target collapse]! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2019 01:48'!maybeDismiss: evt with: dismissHandle	"Ask hand to dismiss my target if mouse comes up in it."	evt hand obtainHalo: self.	(dismissHandle containsPoint: evt cursorPoint)		ifFalse:			[self delete.			target addHalo: evt]		ifTrue:			[target resistsRemoval ifTrue:				[(UIManager default chooseFrom: {					'Yes' translated.					'Um, no, let me reconsider' translated.				} title: 'Really throw this away' translated) = 1 ifFalse: [^ self]].			evt hand removeHalo.			self delete.			target dismissViaHalo]! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/24/2000 18:42'!maybeDoDup: evt with: dupHandle	evt hand obtainHalo: self.	^ target okayToDuplicate ifTrue:		[self doDup: evt with: dupHandle]! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/27/2000 19:12'!morphicLayerNumber	"helpful for insuring some morphs always appear in front of or behind others.	smaller numbers are in front"	^7		"Halos are very front-like things"! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/3/2001 00:21'!mouseDownInCollapseHandle: evt with: collapseHandle	"The mouse went down in the collapse handle; collapse the morph"	self obtainHaloForEvent: evt andRemoveAllHandlesBut: collapseHandle.	self setDismissColor: evt with: collapseHandle! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'HenrikSperreJohansen 1/21/2011 18:34'!mouseDownInDimissHandle: evt with: dismissHandle	evt hand obtainHalo: self.	SoundService soundEnabled ifTrue: [TrashCanMorph playMouseEnterSound].	self removeAllHandlesBut: dismissHandle.	self setColor: Color darkGray toHandle: dismissHandle.! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'cmm 11/7/2011 22:28'!mouseMove: evt	"Drag our target around or resize it"	growingOrRotating		ifTrue: [			| oldExtent newExtent newPosition |			newExtent := originalExtent + (evt position - positionOffset * 2).			(newExtent x > 1 and: [newExtent y > 1])				ifTrue: [					oldExtent := target extent.					target setExtentFromHalo: (newExtent min: owner extent).					newPosition := target position - (target extent - oldExtent // 2).					newPosition := (newPosition x min: owner extent x - newExtent x max: 0) @ (newPosition y min: owner extent y - newExtent y max: 0).					target setConstrainedPosition: newPosition hangOut: true]]		ifFalse: [			| thePoint |			thePoint := target point: (evt position - positionOffset) from: owner.			target setConstrainedPosition: thePoint hangOut: true.		]! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/2/2001 22:16'!obtainHaloForEvent: evt andRemoveAllHandlesBut: aHandle	"Make sure the event's hand correlates with the receiver, and remove all handles except the given one.  If nil is provided as the handles argument, the result is that all handles are removed.  Note that any pending edits to the name-string in the halo are accepted at this time."	evt hand obtainHalo: self.	self acceptNameEdit.	self removeAllHandlesBut: aHandle! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'wiz 3/13/2005 13:53'!openViewerForTarget: evt with: aHandle 	"Open a viewer for my inner target or if shift pressed make a snapshot of morph."	self obtainHaloForEvent: evt andRemoveAllHandlesBut: nil.	evt shiftPressed		ifTrue: [target duplicateMorphImage: evt]		ifFalse: [innerTarget openViewerForArgument]! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'aoy 2/17/2003 01:27'!popUpFor: aMorph event: evt 	"This message is sent by morphs that explicitly request the halo on a button click. Note: anEvent is in aMorphs coordinate frame."	| hand anEvent |	self flag: #workAround.	"We should really have some event/hand here..."	anEvent := evt isNil 				ifTrue: 					[hand := aMorph world activeHand.					hand ifNil: [hand := aMorph world primaryHand]. 					hand lastEvent transformedBy: (aMorph transformedFrom: nil)]				ifFalse: 					[hand := evt hand.					evt].	self target: aMorph.	hand halo: self.	hand world addMorphFront: self.	positionOffset := anEvent position 				- (aMorph point: aMorph position in: owner).	self startStepping.	(Preferences haloTransitions or: [self isMagicHalo]) 		ifTrue: 			[self magicAlpha: 0.0.			self startSteppingSelector: #fadeInInitially]! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/8/2001 15:50'!popUpMagicallyFor: aMorph hand: aHand	"Programatically pop up a halo for a given hand."	Preferences magicHalos ifTrue:[		self isMagicHalo: true.		self magicAlpha: 0.2].	self target: aMorph.	aHand halo: self.	aHand world addMorphFront: self.	Preferences haloTransitions ifTrue:[		self magicAlpha: 0.0.		self startSteppingSelector: #fadeInInitially.	].	positionOffset := aHand position - (aMorph point: aMorph position in: owner).	self startStepping.! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'di 9/26/2000 21:03'!position: pos	"Halos display imprefectly if their coordinates are non-integral		-- especially the direction handles."	^ super position: pos asIntegerPoint! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'di 9/26/2000 15:12'!positionDirectionShaft: shaft	"Position the shaft."	| alphaRadians unitVector |	"Pretty crude and slow approach at present, but a stake in the ground"	alphaRadians := target heading degreesToRadians.	unitVector := alphaRadians sin  @ alphaRadians cos negated.	shaft setVertices: {unitVector * 6 + directionArrowAnchor.  "6 = radius of deadeye circle"					unitVector * self directionArrowLength + directionArrowAnchor}! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 1/30/2001 23:32'!positionIn: aBox horizontalPlacement: horiz verticalPlacement: vert	| xCoord yCoord |	horiz == #left		ifTrue:	[xCoord := aBox left].	horiz == #leftCenter		ifTrue:	[xCoord := aBox left + (aBox width // 4)].	horiz == #center		ifTrue:	[xCoord := (aBox left + aBox right) // 2].	horiz == #rightCenter		ifTrue:	[xCoord := aBox left + ((3 * aBox width) // 4)].	horiz == #right		ifTrue:	[xCoord := aBox right].	vert == #top		ifTrue:	[yCoord := aBox top].	vert == #topCenter		ifTrue:	[yCoord := aBox top + (aBox height // 4)].	vert == #center		ifTrue:	[yCoord := (aBox top + aBox bottom) // 2].	vert == #bottomCenter		ifTrue:	[yCoord := aBox top + ((3 * aBox height) // 4)].	vert == #bottom		ifTrue:	[yCoord := aBox bottom].	^ xCoord asInteger @ yCoord asInteger! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/8/2001 14:35'!prepareToTrackCenterOfRotation: evt with: rotationHandle	evt hand obtainHalo: self.	evt shiftPressed ifTrue:[		self removeAllHandlesBut: rotationHandle.	] ifFalse:[		rotationHandle setProperty: #dragByCenterOfRotation toValue: true.		self startDrag: evt with: rotationHandle	].	evt hand showTemporaryCursor: Cursor blank! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/10/2000 22:00'!rejectsEvent: anEvent	"Return true to reject the given event. Rejecting an event means neither the receiver nor any of it's submorphs will be given any chance to handle it."	(super rejectsEvent: anEvent) ifTrue:[^true].	anEvent isDropEvent ifTrue:[^true]. "never attempt to drop on halos"	^false! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'dgd 9/10/2004 13:38'!removeAllHandlesBut: h	"Remove all handles except h."	(Preferences maintainHalos and:[h isNil])		ifTrue:[self removeHalo]		ifFalse:[			submorphs copy do:				[:m | m == h ifFalse: [m delete]]		].! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/8/2001 14:33'!setCenterOfRotation: evt with: rotationHandle	| localPt |	evt hand obtainHalo: self.	evt hand showTemporaryCursor: nil.	(rotationHandle hasProperty: #dragByCenterOfRotation) ifFalse:[		localPt := innerTarget transformFromWorld globalPointToLocal: rotationHandle center.		innerTarget setRotationCenterFrom: localPt.	].	rotationHandle removeProperty: #dragByCenterOfRotation.	self endInteraction! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'dgd 9/29/2004 19:51'!setColor: aColor toHandle: aHandle 	"private - change the color to the given handle, applying the 	alternate look if corresponds"	aHandle color: aColor.	Preferences alternateHandlesLook		ifTrue: [| fill | 			fill := GradientFillStyle ramp: {0.0 -> aColor muchLighter. 1.0 -> aColor darker}.			fill origin: aHandle topLeft.			fill direction: aHandle extent.			aHandle fillStyle: fill] ! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 6/12/2001 05:24'!setDirection: anEvent with: directionHandle	"The user has let up after having dragged the direction arrow; now set the forward direction of the actual SketchMorph accordingly"	anEvent hand obtainHalo: self.	target setDirectionFrom: directionHandle center.	self endInteraction! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'dgd 9/29/2004 19:56'!setDismissColor: evt with: dismissHandle	"Called on mouseStillDown in the dismiss handle; set the color appropriately."	| colorToUse |	evt hand obtainHalo: self.	colorToUse :=  (dismissHandle containsPoint: evt cursorPoint)		ifFalse:			[Color red muchLighter]		ifTrue:			[Color lightGray].	self setColor: colorToUse toHandle: dismissHandle.! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'nk 6/12/2004 21:56'!setTarget: aMorph	"Private!! Set the target without adding handles."	target := aMorph topRendererOrSelf.	innerTarget := target renderedMorph.	innerTarget wantsDirectionHandles		ifTrue: [self showDirectionHandles: true addHandles: false].	target hasHalo: true.! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'di 9/26/2000 15:25'!showDirectionHandles: wantToShow	self showDirectionHandles: wantToShow addHandles: true  "called from menu"! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'aoy 2/17/2003 01:27'!showDirectionHandles: wantToShow addHandles: needHandles 	directionArrowAnchor := wantToShow 				ifTrue: [target referencePositionInWorld	"not nil means show"]				ifFalse: [nil].	needHandles ifTrue: [self addHandles] ! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'dgd 2/22/2003 19:04'!showingDirectionHandles	^directionArrowAnchor notNil! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 1/27/2000 18:43'!simpleFudgeOffset	"account for the difference in basicBoxes between regular and simple handles"	^ 0@0! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/2/2001 22:09'!startDrag: evt with: dragHandle	"Drag my target without removing it from its owner."	| itsOwner |	self obtainHaloForEvent: evt andRemoveAllHandlesBut: dragHandle.	positionOffset := dragHandle center - (target point: target position in: owner).	 ((itsOwner := target topRendererOrSelf owner) notNil and:			[itsOwner automaticViewing]) ifTrue:				[target openViewerForArgument]! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 2/2/2006 02:46'!startGrow: evt with: growHandle	"Initialize resizing of my target.  Launch a command representing it, to support Undo"	| botRt |	self obtainHaloForEvent: evt andRemoveAllHandlesBut: growHandle.	botRt := target point: target bottomRight in: owner.	positionOffset := (self world viewBox containsPoint: botRt)		ifTrue: [evt cursorPoint - botRt]		ifFalse: [0@0].	self setProperty: #commandInProgress toValue:		(Command new			cmdWording: ('resize ' translated, target nameForUndoWording);			undoTarget: target renderedMorph selector: #setFlexExtentFromHalo: argument: target extent).	originalExtent := target extent! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 2/2/2006 01:31'!startRot: evt with: rotHandle	"Initialize rotation of my target if it is rotatable.  Launch a command object to represent the action"	self obtainHaloForEvent: evt andRemoveAllHandlesBut: rotHandle.	target isFlexMorph ifFalse: 		[target isInWorld ifFalse: [self setTarget: target player costume].		target addFlexShellIfNecessary].	growingOrRotating := true.	self removeAllHandlesBut: rotHandle.  "remove all other handles"	angleOffset := evt cursorPoint - (target pointInWorld: target referencePosition).	angleOffset := Point			r: angleOffset r			degrees: angleOffset degrees - target rotationDegrees.	self setProperty: #commandInProgress toValue:		(Command new			cmdWording: ('rotate ' translated, target nameForUndoWording);			undoTarget: target renderedMorph selector: #heading: argument: target rotationDegrees)! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 2/2/2006 00:28'!startScale: evt with: scaleHandle	"Initialize scaling of my target."	self obtainHaloForEvent: evt andRemoveAllHandlesBut: scaleHandle.	target isFlexMorph ifFalse: [target addFlexShellIfNecessary].	growingOrRotating := true.	positionOffset := 0@0.	self setProperty: #commandInProgress toValue:		(Command new			cmdWording: ('resize ' translated, target nameForUndoWording);			undoTarget: target renderedMorph selector: #setFlexExtentFromHalo: argument: target extent).	originalExtent := target extent! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/4/2000 19:26'!staysUpWhenMouseIsDownIn: aMorph	^ ((aMorph == target) or: [aMorph hasOwner: self])! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'nk 6/27/2003 12:32'!step	| newBounds |	target		ifNil: [^ self].	newBounds := target isWorldMorph				ifTrue: [target bounds]				ifFalse: [self localHaloBoundsFor: target renderedMorph].	newBounds = self bounds		ifTrue: [^ self].	newBounds extent = self bounds extent		ifTrue: [^ self position: newBounds origin].	growingOrRotating		ifFalse: [submorphs size > 1				ifTrue: [self addHandles]].	"adjust halo bounds if appropriate"	self bounds: newBounds! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'jm 7/16/97 06:54'!stepTime	^ 0  "every cycle"! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'jm 7/16/97 06:51'!target	^ target! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'jm 5/7/1998 15:42'!target: aMorph	self setTarget: aMorph.	target ifNotNil: [self addHandles].! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 1/4/2010 00:28'!tearOffTileForTarget: evt with: aHandle	"Tear off a tile representing my inner target.  If shift key is down, open up an instance browser on the morph itself, not the player, with tiles showing, instead"	self obtainHaloForEvent: evt andRemoveAllHandlesBut: nil.	innerTarget tearOffTile! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/8/2001 14:32'!trackCenterOfRotation: anEvent with: rotationHandle	(rotationHandle hasProperty: #dragByCenterOfRotation) 		ifTrue:[^self doDrag: anEvent with: rotationHandle].	anEvent hand obtainHalo: self.	rotationHandle center: anEvent cursorPoint.! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/24/2000 18:43'!trackDirectionArrow: anEvent with: shaft	anEvent hand obtainHalo: self.	shaft setVertices: {directionArrowAnchor. anEvent cursorPoint}.	self layoutChanged! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/10/2000 19:09'!transferHalo: event	"Transfer the halo to the next likely recipient"	target ifNil:[^self delete].	target transferHalo: (event transformedBy: (target transformedFrom: self)) from: target.! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'tk 1/7/1999 17:37'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.target := deepCopier references at: target ifAbsent: [target].innerTarget := deepCopier references at: innerTarget ifAbsent: [innerTarget].! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'st 9/14/2004 13:03'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."	super veryDeepInner: deepCopier.	"target := target.		Weakly copied"	"innerTarget := innerTarget.		Weakly copied"	positionOffset := positionOffset veryDeepCopyWith: deepCopier.	angleOffset := angleOffset veryDeepCopyWith: deepCopier.	growingOrRotating := growingOrRotating veryDeepCopyWith: deepCopier.	directionArrowAnchor := directionArrowAnchor.	simpleMode := simpleMode.	haloBox := haloBox.	originalExtent := originalExtent! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'sw 5/21/1998 15:41'!wantsKeyboardFocusFor: aSubmorph	"to allow the name to be edited in the halo in the old tty way; when we morphic-text-ize the name editing, presumably this method should be removed"	^ true! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'dgd 9/9/2004 22:55'!wantsToBeTopmost	"Answer if the receiver want to be one of the topmost objects in 	its owner"	^ true! !!HaloMorph methodsFor: 'as yet unclassified' stamp: 'dgd 9/20/2004 19:35'!wantsYellowButtonMenu	"Answer true if the receiver wants a yellow button menu"	^ false! !!SAXWarning methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!SAXWarning class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!DAVResource methodsFor: 'as yet unclassified' stamp: 'crl 8/9/2016 22:22'!age	^Time totalSeconds - lastModificationTime! !!DAVResource methodsFor: 'as yet unclassified' stamp: 'crl 1/2/2015 16:42'!contentLength	^self subclassResponsibility! !!DAVResource methodsFor: 'as yet unclassified' stamp: 'crl 8/11/2016 21:30'!contents	self update.	updateFinished wait; initSignals! !!DAVResource methodsFor: 'as yet unclassified' stamp: 'crl 1/2/2015 17:13'!emitBodyOn: response	self subclassResponsibility! !!DAVResource methodsFor: 'as yet unclassified' stamp: 'crl 1/2/2015 17:10'!emitTypeOn: response	(name = 'favicon.ico')		ifTrue: [			response				type: 'image/x-icon';				encoding: 'base64']		ifFalse: [response type: 'text/html']! !!DAVResource methodsFor: 'as yet unclassified' stamp: 'crl 8/2/2016 16:36'!initialize	updateFinished _ Semaphore new.	self		update: [:resource | resource updateFinished];		touch! !!DAVResource methodsFor: 'as yet unclassified' stamp: 'crl 1/11/2015 02:27'!lastModificationTime	^lastModificationTime! !!DAVResource methodsFor: 'as yet unclassified' stamp: 'crl 6/6/2011 10:52'!name	^name! !!DAVResource methodsFor: 'as yet unclassified' stamp: 'crl 2/14/2014 18:26'!name: aString	(aString isKindOf: String) ifFalse: [3 halt].	name _ aString! !!DAVResource methodsFor: 'as yet unclassified' stamp: 'crl 1/5/2015 03:43'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: ' named ''';		nextPutAll: self name;		nextPut: $'! !!DAVResource methodsFor: 'as yet unclassified' stamp: 'crl 1/4/2015 01:16'!resourceType	^nil! !!DAVResource methodsFor: 'as yet unclassified' stamp: 'crl 1/2/2015 17:13'!responseForMethod: aGET	| response |	response _ HTTPMessage for: aGET client.	response ok.	self		emitBodyOn: response;		emitTypeOn: response.	^response! !!DAVResource methodsFor: 'as yet unclassified' stamp: 'crl 1/11/2015 21:52'!responsePayload	^self subclassResponsibility! !!DAVResource methodsFor: 'as yet unclassified' stamp: 'crl 1/4/2015 01:08'!statusForResponseProperty: property forResource: resource	^self subclassResponsibility! !!DAVResource methodsFor: 'as yet unclassified' stamp: 'crl 1/5/2015 16:18'!subject	^self subclassResponsibility! !!DAVResource methodsFor: 'as yet unclassified' stamp: 'crl 1/11/2015 02:18'!touch	lastModificationTime _ Time totalSeconds! !!DAVResource methodsFor: 'as yet unclassified' stamp: 'crl 8/2/2016 16:37'!update	update value: self! !!DAVResource methodsFor: 'as yet unclassified' stamp: 'crl 8/2/2016 12:08'!update: aBlockClosure	update _ aBlockClosure! !!DAVResource methodsFor: 'as yet unclassified' stamp: 'crl 8/19/2016 20:59'!updateBlock	^update! !!DAVResource methodsFor: 'as yet unclassified' stamp: 'crl 8/11/2016 17:39'!updateFinished	updateFinished signal! !!DAVResource class methodsFor: 'as yet unclassified' stamp: 'crl 1/4/2015 01:47'!canRepresentAnInstanceOf: aClass	^false! !!DAVResource class methodsFor: 'as yet unclassified' stamp: 'crl 1/5/2015 03:45'!for: anObject	^(anObject isKindOf: DAVResource)		ifTrue: [anObject]		ifFalse: [			(				(self allSubclasses)					detect: [:subclass | subclass canRepresentAnInstanceOf: anObject class]					ifNone: [self error: 'no appropriate DAV representation']			)				for: anObject]! !!DAVResource class methodsFor: 'as yet unclassified' stamp: 'crl 6/6/2011 10:52'!named: aString	^self new name: aString! !!DAVResource class methodsFor: 'as yet unclassified' stamp: 'crl 1/11/2015 02:29'!new	^super new initialize! !!DOMNodeMirror methodsFor: 'as yet unclassified' stamp: 'crl 7/21/2017 16:25'!childNames	^self children collect: [:child | child nodeName]! !!DOMNodeMirror methodsFor: 'as yet unclassified' stamp: 'crl 7/22/2017 02:48'!children	^(self properties includes: #children)		ifTrue: [			| dom |						dom := tab dom.			children := super children collect: [:child | self class forProxy: child andTab: tab].			children do: [:child | dom noteNode: child]]		ifFalse: [			(self hasChildren)				ifTrue: [					children := nil.					tab						send: 'DOM.requestChildNodes'						withParameters: {#nodeId -> self nodeId}.					tab dom waitForResult.					children]				ifFalse: [#()]]! !!DOMNodeMirror methodsFor: 'as yet unclassified' stamp: 'crl 7/22/2017 02:42'!children: nodes	children := nodes! !!DOMNodeMirror methodsFor: 'as yet unclassified' stamp: 'crl 7/21/2017 16:25'!hasChildren	^self childNodeCount > 0! !!DOMNodeMirror methodsFor: 'as yet unclassified' stamp: 'crl 7/21/2017 17:44'!initialize	children := #()! !!DOMNodeMirror methodsFor: 'as yet unclassified' stamp: 'crl 7/21/2017 23:42'!tab: chromeTab	tab := chromeTab! !!DOMNodeMirror class methodsFor: 'as yet unclassified' stamp: 'crl 7/21/2017 23:44'!forProxy: proxy andTab: chromeTab	^(self forProxy: proxy) tab: chromeTab! !!JSKeyboardEvent methodsFor: 'as yet unclassified' stamp: 'crl 3/31/2019 12:04'!key	^proxy key asString! !!JSKeyboardEvent class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!ClassLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 3/21/2019 01:11'!literal	"Answer the method literal I represent."	| edition |		edition := self classEdition.	^edition name -> edition activeClass! !!ClassLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 10/29/2008 21:27'!marks: literal 	^self literal == literal! !!ClassLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2016 15:07'!tag	"Answer my transmission tag."	^ClassLiteralMarkerTag! !!ClassLiteralMarker class methodsFor: 'as yet unclassified' stamp: 'crl 10/12/2016 00:36'!canRepresent: literal inMethod: aCompiledMethod of: aClass	^(literal isKindOf: LookupKey) and: [literal value isBehavior and: [literal key == literal value name]]! !!ClassLiteralMarker class methodsFor: 'as yet unclassified' stamp: 'crl 11/2/2008 15:21'!forLiteral: literal inMethod: aCompiledMethod ofClass: aClass	"Answer an instance of myself to represent literal when transferring aCompiledMethod from aClass."	^self forLiteralDefinedByClass: literal value! !!BlockArgsNode methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!BlockArgsNode class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!Notification class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!WeakIdentityKeyDictionary class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!DAVWorkspace methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!DAVWorkspace class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!SHTextStylerST80 methodsFor: 'as yet unclassified' stamp: 'tween 8/26/2004 03:14'!privateStyle: aText	| ranges |	ranges := self rangesIn: aText setWorkspace: true.	ranges ifNotNil: [self setAttributesIn: aText fromRanges: ranges]! !!ChronologyConstants methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!PluggableAlternateMultiSelectionListSpec class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!SAXException methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!SAXException class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!GPL methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!GPL class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!ParserRemovedUnusedTemps methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!ParserRemovedUnusedTemps class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!Preference class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!UnloadedSound methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!PluggableScrollPaneSpec class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!ChromePageAPI methodsFor: 'as yet unclassified' stamp: 'crl 8/22/2016 00:52'!getResourceContent: parameters with: result	resourceContent		at: ((Dictionary withAll: parameters) at: #url)		put: (result at: 'content')! !!ChromePageAPI methodsFor: 'as yet unclassified' stamp: 'crl 8/22/2016 01:09'!getResourceTree: parameters with: result	resourceTree := result.	frame := (JSONObject on: resourceTree) frameTree frame.! !!ChromePageAPI methodsFor: 'as yet unclassified' stamp: 'crl 8/22/2016 03:51'!html	self getResourceContent: {#frameId -> frame id. #url -> frame url}.	(Delay forSeconds: 2) wait.	^resourceContent at: frame url! !!ChromePageAPI methodsFor: 'as yet unclassified' stamp: 'crl 8/22/2016 02:07'!html: string	self setDocumentContent: {#frameId -> frame id. #html -> string}! !!ChromePageAPI methodsFor: 'as yet unclassified' stamp: 'crl 8/22/2016 03:37'!initialize	super initialize.	resourceContent := Dictionary new! !!ChromePageAPI methodsFor: 'as yet unclassified' stamp: 'crl 8/2/2016 17:30'!resourceTree	^resourceTree! !!ChromePageAPI methodsFor: 'as yet unclassified' stamp: 'crl 8/5/2016 15:28'!searchInResources: parameters with: result	3 halt! !!ChromePageAPI class methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 12:40'!domain	^'Page'! !!SparseLargeArray class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!PositiveManifest methodsFor: 'as yet unclassified'!generalDescription	"Answer a general description of myself, in textual form."	^'presence'! !!PositiveManifest methodsFor: 'as yet unclassified'!indices	"Answer the indices I record."	^self copyFrom: 1 to: self size - 1! !!PositiveManifest methodsFor: 'as yet unclassified' stamp: 'il prior: 36699412!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'!indicesOfMissingProvisions	"Answer the indices of the missing provisions."	| indices indicesOfMissingProvisions numberOfProvisions |	indices := self indices.	numberOfProvisions := self at: self size.	indicesOfMissingProvisions := (NegativeManifest new: (numberOfProvisions // 2)) writableStream.	1		to: numberOfProvisions		do: [:index |			(indices includes: index) ifFalse: [indicesOfMissingProvisions nextPut: index]].	^indicesOfMissingProvisions contents! !!PositiveManifest methodsFor: 'as yet unclassified'!numberOfProvisions: anInteger	"Record anInteger as the number of provisions."	self at: self size put: anInteger! !!PositiveManifest methodsFor: 'as yet unclassified'!printOn: aStream	"Append a textual representation of myself to aStream."	super printOn: aStream.	aStream		skipBack;		nextPutAll: ' of size ';		print: self last;		nextPut: $)! !!PositiveManifest methodsFor: 'as yet unclassified' stamp: 'crl 10/1/2016 13:44'!tag	"Answer my transmission tag."	^PositiveManifestTag! !!PositiveManifest class methodsFor: 'as yet unclassified'!withAll: provisionIndices forProvisionsInNumber: numberOfProvisions	"Answer a new instance of myself which records the existence of the elements at provisionIndices in some collection of size numberOfProvisions."	^(self new: provisionIndices size + 1)		replaceFrom: 1		to: provisionIndices size		with: provisionIndices;		numberOfProvisions: numberOfProvisions! !!DAVNode class methodsFor: 'as yet unclassified' stamp: 'crl 6/4/2011 11:59'!new	^(super new)		namespace: DefaultNamespace;		yourself! !!PenPointRecorder class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!SimplifiedChineseEnvironment methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!MeshBasicMaterial methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!MeshBasicMaterial class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!Element methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!Element class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!BitMatchingPattern methodsFor: 'as yet unclassified' stamp: 'crl 7/15/2011 21:32'!maskBits: bitPattern atByte: byteIndex	mask		at: byteIndex		put: ((mask at: byteIndex) bitOr: bitPattern)! !!BitMatchingPattern methodsFor: 'as yet unclassified' stamp: 'crl 7/15/2011 21:27'!maskFromByte: startingByteIndex to: endingByteIndex	startingByteIndex		to: endingByteIndex		do: [:index | mask at: index put: 255]! !!BitMatchingPattern methodsFor: 'as yet unclassified' stamp: 'crl 7/16/2011 01:24'!match: input	^(input bitAnd: mask) = (reference bitAnd: mask)! !!BitMatchingPattern methodsFor: 'as yet unclassified' stamp: 'crl 7/15/2011 21:55'!reference: aByteArray	reference := aByteArray.	mask := ByteArray new: reference size! !!BitMatchingPattern class methodsFor: 'as yet unclassified' stamp: 'crl 7/15/2011 21:22'!reference: reference	^self new reference: reference! !!CharacterBlock class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!JSCursorMorph methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSCursorMorph class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JISX0208 methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!JSString methodsFor: 'as yet unclassified' stamp: 'crl 5/5/2017 16:51'!asString	^proxy asString! !!JSString methodsFor: 'as yet unclassified' stamp: 'crl 5/5/2017 16:33'!printOn: stream	super printOn: stream.	stream		nextPutAll: ' for ''';		print: proxy;		nextPut: $'! !!JSString methodsFor: 'as yet unclassified' stamp: 'crl 7/21/2017 16:50'!properties	^#()! !!JSString methodsFor: 'as yet unclassified' stamp: 'crl 5/6/2017 15:49'!simplestRepresentation	^self asString! !!JSString class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!HTMLSmalltalkWorkspace methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2019 16:36'!title	^'a workspace'! !!IdentityBag methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!Exit methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 03:25'!isExit	^true! !!Exit methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2016 16:45'!onClose: aBlockClosure	"Install aBlockClosure as a callback that my websocket should trigger when it closes."	websocket onClose: aBlockClosure! !!Exit methodsFor: 'as yet unclassified' stamp: 'crl 7/6/2016 12:03'!onError: aBlockClosure	"Install aBlockClosure as a callback that my websocket should trigger when it encounters an error."	websocket onError: aBlockClosure! !!Exit methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2016 16:46'!onMessage: aBlockClosure	"Install aBlockClosure as a callback that my websocket should trigger when it receives a message."	websocket onMessage: aBlockClosure! !!Exit methodsFor: 'as yet unclassified' stamp: 'crl 7/6/2016 17:03'!outgoingPayload	"Answer the payload for the next outgoing message."		^String withAll: outgoingMessage contents! !!Exit methodsFor: 'as yet unclassified' stamp: 'crl 7/6/2016 14:58'!payloadForWebSocketMessage: message	"Answer the payload of message, received by my websocket."	^message! !!Exit methodsFor: 'as yet unclassified' stamp: 'crl 7/3/2016 00:00'!run	"Start running my websocket."		websocket run! !!Exit methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2016 16:47'!stringForWebSocketMessage: message	"Answer the String payload of message, received by my websocket."	^message! !!Exit methodsFor: 'as yet unclassified' stamp: 'crl 7/4/2016 01:54'!websocket: aWebSocket	"Set my websocket to aWebSocket, and setup callbacks for events of interest."		super websocket: aWebSocket.	websocket timeout: 600000! !!Exit class methodsFor: 'as yet unclassified' stamp: 'crl 3/20/2019 05:14'!actionWithServiceClass: serviceClass	"Answer an action with which a web server should provide service with serviceClass."		Transcript clear.	^[:request |		| websocket exit client |		websocket := request asWebSocket.		exit := self new websocket: websocket.		client := serviceClass through: exit.		websocket			onMessage: [:message |				exit incomingMessage: message.				client handleEvent].		websocket run]! !!Exit class methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 01:24'!start	"Start providing a set of services with a web server."		| webserver |		webserver := WebServer reset default.		webserver listenOn: 8091.	(Dictionary new)		at: '/tether' put: #Tether;		keysAndValuesDo: [:endpoint :serviceClassName |			Smalltalk				at: serviceClassName				ifPresentAndInMemory: [:class |					webserver						addService: endpoint						action: (self actionWithServiceClass: class)]]! !!CompiledMethodInspector class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!PublishedVariableLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 10/1/2016 11:47'!literal	"Answer the method literal I represent."	^(self activeClass) at: key! !!PublishedVariableLiteralMarker methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2016 15:07'!tag	^PublishedVariableLiteralMarkerTag! !!PublishedVariableLiteralMarker class methodsFor: 'as yet unclassified' stamp: 'crl 10/1/2016 14:34'!canRepresent: literal inMethod: aCompiledMethod of: aClass	| poolReceiver |	poolReceiver := (		(aClass isMeta)			ifTrue: [aClass soleInstance]			ifFalse: [aClass]).
	[poolReceiver == nil] whileFalse: [		poolReceiver sharedPools do: [:pool | pool classPool associationsDo: [:association | literal == association ifTrue: [^true]]].		poolReceiver := poolReceiver superclass].	^false! !!PublishedVariableLiteralMarker class methodsFor: 'as yet unclassified' stamp: 'crl 10/1/2016 14:36'!forLiteral: literal inMethod: aCompiledMethod ofClass: aClass	"Answer an instance of myself to represent literal when transferring aCompiledMethod from aClass."	| receivingClass definingPool |	receivingClass := (		(aClass isMeta)			ifTrue: [aClass soleInstance]			ifFalse: [aClass]).	"Find the defining pool."	[definingPool == nil] whileTrue: [		definingPool := (			(receivingClass sharedPools)				detect: [:pool | pool includesAssociation: literal]				ifNone: [nil]).		receivingClass := receivingClass superclass].			^(self forLiteralDefinedByClass: definingPool) key: literal key! !!HTMLIFrameElement methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!HTMLIFrameElement class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSMorph methodsFor: 'as yet unclassified' stamp: 'crl 6/2/2017 22:17'!addCaffeineWorkspace: workspace	self add: workspace! !!JSMorph methodsFor: 'as yet unclassified' stamp: 'crl 6/5/2017 17:39'!adjustExtentBy: delta	self		adjustWidthBy: delta x;		adjustHeightBy: delta y! !!JSMorph methodsFor: 'as yet unclassified' stamp: 'crl 6/5/2017 17:38'!adjustHeightBy: delta	self setHeight: (self height + delta)! !!JSMorph methodsFor: 'as yet unclassified' stamp: 'crl 6/5/2017 17:38'!adjustWidthBy: delta	self setWidth: (self width + delta)! !!JSMorph methodsFor: 'as yet unclassified' stamp: 'crl 6/6/2017 14:26'!in: widget	widget width < self width ifTrue: [widget setWidth: self width].	widget height < self height ifTrue: [widget setHeight: self height].	widget add: self.	^widget! !!JSMorph methodsFor: 'as yet unclassified' stamp: 'crl 5/27/2017 23:35'!openInWorld	self		at: #isDraggable put: true;		pickUp: MorphicJS world;		yourself! !!JSMorph class methodsFor: 'as yet unclassified' stamp: 'crl 5/26/2017 11:14'!new	^self newWithParameters: #()! !!KeyboardEvent methodsFor: 'as yet unclassified' stamp: 'crl 8/11/2019 22:00'!keyValue: integer	keyValue := integer! !!KeyboardEvent class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!InterpolatedGradientFillStyle class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/16/2017 22:40'!allocateForm: extentPoint	"Allocate a new form which is similar to the receiver"	^Display allocateForm: extentPoint! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/15/2017 22:09'!clearBufferContextbufferContext	beginPath;	rect: 0	with: 0	with: 1000	with: 400;	clip;	clearRect: 0	with: 0	with: 100	with: 100! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/16/2017 14:35'!clipBy: aRectangle during: aBlock	"Set a clipping rectangle active only during the execution of aBlock.	Note: In the future we may want to have more general clip shapes - not just rectangles"	bufferContext save.	^[aBlock value: (self copyClipRect: aRectangle)] ensure: [bufferContext restore]! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/14/2017 23:44'!clipRect	"Return the currently active clipping rectangle"	^ clippingRectangle translateBy: origin negated! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/16/2017 16:49'!contents	^bufferContext contents! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/16/2017 22:35'!contentsOfArea: aRectangle into: aForm	| bb |	self flush.	bb := BitBlt toForm: aForm.	bb sourceForm: Display; combinationRule: Form over;		sourceX: (aRectangle left + origin x); sourceY: (aRectangle top + origin y);		width: aRectangle width; height: aRectangle height;		copyBits.	^aForm! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 6/14/2017 14:11'!context: canvasRenderingContext2D	| bufferCanvas |		context := canvasRenderingContext2D.	bufferCanvas := Webpage current top document createElement: 'canvas'.	totalWidth := context canvas width.	totalHeight := context canvas height.	bufferCanvas		at: #width put: totalWidth;		at: #height put: totalHeight.	bufferContext := bufferCanvas getContext: '2d'.	JS		at: #theContext put: bufferContext;		at: #touchBufferContext		put: (			JS Function new: '				var red = Math.floor(Math.random() * 255);				var green = Math.floor(Math.random() * 255);				var blue = Math.floor(Math.random() * 255);								theContext.beginPath();				theContext.rect(0, 0, theContext.canvas.width, theContext.canvas.height);			 	theContext.clip();				theContext.fillStyle = "rgb(" + red + ", " + green + ", " + blue + ")";				theContext.fillRect(0, 0, theContext.canvas.width, theContext.canvas.height);').! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/14/2017 23:36'!copyClipRect: aRectangle	^ self copyOrigin: origin clipRect: (aRectangle translateBy: origin)! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/16/2017 15:26'!copyOffset: aPoint	^ self copyOrigin: origin + aPoint clipRect: clippingRectangle! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/14/2017 23:33'!copyOffset: aPoint clipRect: sourceClip	"Make a copy of me offset by aPoint, and further clipped	by sourceClip, a rectangle in the un-offset coordinates"	^ self copyOrigin: aPoint + origin		clipRect: ((sourceClip translateBy: origin) intersect: clippingRectangle)! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/14/2017 23:31'!copyOrigin: aPoint clipRect: aRectangle	"Return a copy of this canvas with the given origin. The clipping rectangle of this canvas is the intersection of the given rectangle and the receiver's current clipping rectangle. This allows the clipping rectangles of nested clipping morphs to be composed."	^ self copy		setOrigin: aPoint		clipRect: (clippingRectangle intersect: aRectangle)! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/15/2017 17:58'!draw: something	"(something class == LazyListMorph) ifTrue: [3 halt]."	super draw: something! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/16/2017 20:44'!drawPolygon: vertices color: aColor borderWidth: bw borderColor: bc	bufferContext save.	[		self			setStrokeColor: bc;			setFillColor: aColor;			setLineWidth: bw.					bufferContext			beginPath;			moveTo: vertices first x with: vertices first y.					(vertices copyFrom: 2 to: vertices size) do: [:vertex |			bufferContext				lineTo: vertex x				with: vertex y].		bufferContext fill; stroke	]		ensure: [bufferContext restore]! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/16/2017 22:58'!drawString: string from: firstIndex to: lastIndex in: bounds font: font color: color	self		setFillColor: color;		setFont: font.				bufferContext		fillText: (string copyFrom: firstIndex to: lastIndex)		with: bounds left + origin x		with: bounds top + origin y + 10! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/16/2017 15:38'!expressionForColor: color	^((String new: 18) writeStream)		nextPutAll: 'rgba(';		print: (color red * 255) rounded;		nextPutAll: ', ';		print: (color green * 255) rounded;		nextPutAll: ', ';		print: (color blue * 255) rounded;		nextPutAll: ', ';		print: color alpha;		nextPut: $);		contents! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/16/2017 23:40'!fontHeightIn: morph	^self heightOfCurrentFont - 3! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/15/2017 21:26'!forceDamageToScreen: rectangles	rectangles do: [:rectangle | self forceToScreen: rectangle]! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/16/2017 12:02'!forceDisplayUpdate	self forceToScreen: (0@0 corner: (context canvas width @ context canvas height))! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/16/2017 15:31'!forceToScreen: rectangle	context		putImageData: (			bufferContext				getImageData: rectangle left				with: rectangle top				with: rectangle width				with: rectangle height)		with: rectangle left		with: rectangle top		! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/16/2017 20:45'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth borderColor: borderColor	| rectangle insetRectangle |		rectangle := r translateBy: origin.	insetRectangle := rectangle insetBy: borderWidth.		"Draw the border of the rectangle."	borderColor isTransparent ifFalse: [		self			setFillColor: borderColor;			setStrokeColor: borderColor;			setLineWidth: borderWidth.					bufferContext			strokeRect: rectangle origin x			with: rectangle origin y			with: rectangle width			with: rectangle height].	"Fill the inside."	fillColor isTransparent ifFalse: [		self setFillColor: fillColor.		bufferContext			fillRect: insetRectangle origin x			with: insetRectangle origin y			with: insetRectangle width			with: insetRectangle height]! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/14/2017 20:37'!fullDraw: something	"(something class == SketchMorph) ifTrue: [3 halt]."	super fullDraw: something! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 6/20/2017 15:31'!handle	^self canvas handle! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/15/2017 14:10'!heightOfCurrentFont	| font name size |		font := bufferContext font asString readStream.	size := font upToAll: 'px'.	name := font upTo: ' '; upToEnd.		^self		heightOfFontNamed: name		ofSize: size! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/15/2017 00:52'!heightOfFontNamed: fontName ofSize: fontSize	^(self metricsForFontNamed: fontName ofSize: fontSize) asArray second + 1! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/16/2017 13:10'!image: form at: point sourceRect: rectangle rule: rule 	"Draw the portion of the given Form defined by rectangle at the given point using the given BitBlt combination rule."		"| clipRect |		clipRect := rectangle translateBy: point.	bufferContext save.	[		bufferContext			beginPath;			rect: clipRect left			with: clipRect top			with: clipRect width			with: clipRect height;			clip;			drawImage: (				cachedImages					at: form					ifAbsent: [						| image stream loaded |										image := JS Image new.						stream := (ByteArray new: 1024) writeStream.						loaded := Semaphore new.									PNGReadWriter							putForm: form							onStream: stream.						image							addEventListener: 'load'							with: [loaded signal]							with: false;							at: #src							put: (								((String new: 4096) writeStream)									nextPutAll: 'data:image/png;base64,';									nextPutAll: stream contents base64Encoded;									contents).													loaded wait.										cachedImages							at: form							put: image])			with: point x			with: point y	]		ensure: [bufferContext restore]"! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/16/2017 11:49'!infiniteFillRectangle: rectangle fillStyle: aFillStyle	self setFillColor: aFillStyle asColor.	bufferContext		fillRect: rectangle origin x		with: rectangle origin y		with: rectangle width		with: rectangle height! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/13/2017 23:33'!initialize	self reset! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/16/2017 14:39'!install	(World instVarNamed: 'worldState') canvas: self! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/14/2017 23:50'!isVisible: aRectangle	"Optimization"	(aRectangle right + origin x) < clippingRectangle left	ifTrue: [^ false].	(aRectangle left + origin x) > clippingRectangle right	ifTrue: [^ false].	(aRectangle bottom + origin y) < clippingRectangle top	ifTrue: [^ false].	(aRectangle top + origin y) > clippingRectangle bottom	ifTrue: [^ false].	^ true! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/16/2017 20:46'!line: startPoint to: endPoint width: width color: color	| offset offsetStartPoint offsetEndPoint |		offset := origin - (width // 2) asPoint.	offsetStartPoint := startPoint + offset.	offsetEndPoint := endPoint + offset.		self		setFillColor: color;		setLineWidth: width.	bufferContext		moveTo: offsetStartPoint x with: offsetStartPoint y;		lineTo: offsetEndPoint x with: offsetEndPoint y! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/14/2017 21:27'!metricsForFontNamed: fontName ofSize: fontSize	^((JS Function new: '    return function (fontName, fontSize) {var objOff = function (obj) {        var currleft = currtop = 0;        if( obj.offsetParent )        { do { currleft += obj.offsetLeft; currtop += obj.offsetTop; }          while( obj = obj.offsetParent ); }        else { currleft += obj.offsetLeft; currtop += obj.offsetTop; }        return [currleft,currtop];    };    var text = document.createElement("span");    text.style.fontFamily = fontName;    text.style.fontSize = fontSize + "px";    text.innerHTML = "ABCjgq|";     // if you will use some weird fonts, like handwriting or symbols, then you need to edit this test string for chars that will have most extreme accend/descend values    var block = document.createElement("div");    block.style.display = "inline-block";    block.style.width = "1px";    block.style.height = "0px";    var div = document.createElement("div");    div.appendChild(text);    div.appendChild(block);    // this test div must be visible otherwise offsetLeft/offsetTop will return 0    // but still let''s try to avoid any potential glitches in various browsers    // by making its height 0px, and overflow hidden    div.style.height = "0px";    div.style.overflow = "hidden";    // I tried without adding it to body - won''t work. So we gotta do this one.    document.body.appendChild(div);    block.style.verticalAlign = "baseline";    var bp = objOff(block);    var tp = objOff(text);    var taccent = bp[1] - tp[1];    block.style.verticalAlign = "bottom";    bp = objOff(block);    tp = objOff(text);    var theight = bp[1] - tp[1];    var tdescent = theight - taccent;    // now take it off :-)    document.body.removeChild(div);    // return text accent, descent and total height    return [taccent,theight,tdescent];}') call) call: nil with: fontName with: fontSize! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/15/2017 14:12'!moveto: point! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/14/2017 21:17'!objectOffset: object	^(JS Function new: '    var currleft = currtop = 0;    if( obj.offsetParent )    { do { currleft += obj.offsetLeft; currtop += obj.offsetTop; }      while( obj = obj.offsetParent ); }    else { currleft += obj.offsetLeft; currtop += obj.offsetTop; }    return [currleft,currtop];') call: nil with: object! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/16/2017 15:50'!origin	^origin! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/15/2017 11:24'!paragraph: paragraph bounds: bounds color: color	self preserveStateDuring: [:inner |		paragraph			displayOn: inner			using: (				PostscriptCharacterScanner					scannerWithCanvas: self					paragraph: paragraph					bounds: bounds)			at: bounds topLeft]! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/15/2017 22:11'!removeBufferCanvas	bufferContext canvas remove! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/14/2017 19:43'!reset	"Set my origin and clipRect."		origin := 0@0.	clippingRectangle := 0@0 corner: 10000@10000.	cachedImages := IdentityDictionary new! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/16/2017 15:39'!setFillColor: color	bufferContext at: #fillStyle put: (self expressionForColor: color)! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/16/2017 20:47'!setFont: font	bufferContext		at: #font		put: (font pointSize + 5) printString, 'px sans-serif'! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/16/2017 20:44'!setLineWidth: width	bufferContext at: #lineWidth put: width! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/16/2017 14:34'!setOrigin: aPoint clipRect: aRectangle	(aRectangle top isInteger not or: [aRectangle left isInteger not or: [aRectangle right isInteger not or: [aRectangle bottom isInteger not]]]) ifTrue: [self switchToFormCanvas].	origin := aPoint.	clippingRectangle := aRectangle.	bufferContext		beginPath;		rect: clippingRectangle origin x		with: clippingRectangle origin y		with: clippingRectangle width		with: clippingRectangle height;		clip! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/14/2017 11:06'!setPaintColor: color	self setFillColor: color! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/16/2017 15:39'!setStrokeColor: color	bufferContext at: #strokeStyle put: (self expressionForColor: color)! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/15/2017 20:47'!switchToFormCanvas	(World instVarNamed: 'worldState') canvas: nil.	3 halt! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/16/2017 22:55'!textStyled: string at: offset font: font color: color justified: justified parwidth: width	| renderString |	renderString := string copyReplaceAll: '	' with: '    '.	self		drawString: renderString		from: 1		to: renderString size		in: (offset extent: 300@300)		font: font		color: color.			^(bufferContext measureText: renderString) width! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/15/2017 20:42'!touchBufferContextbufferContext	beginPath;	rect: 0	with: 0	with: 1000	with: 400;	clip;	at: #fillStyle put: 'rgba(255, 0, 0, 1)';	fillRect: 0	with: 0	with: 100	with: 100! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/15/2017 21:02'!touchContextcontext	beginPath;	rect: 0	with: 0	with: 1000	with: 400;	clip;	at: #fillStyle put: 'rgba(255, 0, 0, 1)';	fillRect: 0	with: 0	with: 100	with: 100! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/16/2017 14:35'!transformBy: transform clippingTo: rectangle during: block smoothing: cellSize	"Note: This method has been originally copied from TransformationMorph."		| innerRect patchRect sourceQuad warp start subCanvas |		(transform isPureTranslation) ifTrue: [		bufferContext save.		^[			block value: (				self					copyOffset: transform offset negated truncated					clipRect: rectangle)		]			ensure: [bufferContext restore]].		"Prepare an appropriate warp from patch to innerRect"	innerRect := rectangle.	patchRect := (transform globalBoundsToLocal: innerRect) truncated.	sourceQuad := (transform sourceQuadFor: innerRect)					collect: [:p | p - patchRect topLeft].	warp := self warpFrom: sourceQuad toRect: innerRect.	"Render the submorphs visible in the clipping rectangle, as patchForm"	start := (self depth = 1 and: [self isShadowDrawing not])		"If this is true B&W, then we need a first pass for erasure."		ifTrue: [1] ifFalse: [2].	start to: 2 do:		[:i | "If i=1 we first make a shadow and erase it for opaque whites in B&W"		subCanvas := self class extent: patchRect extent depth: self depth.		i=1	ifTrue: [subCanvas shadowColor: Color black.					warp combinationRule: Form erase]			ifFalse: [self isShadowDrawing ifTrue:					[subCanvas shadowColor: self shadowColor].				warp combinationRule: (self depth = 32					ifTrue: [Form blendAlphaScaled]					ifFalse: [Form paint])].		subCanvas			translateBy: patchRect topLeft negated			during: block.		warp sourceForm: subCanvas form; cellSize: cellSize; warpBits.		warp sourceForm: nil.  subCanvas := nil "release space for next loop"]! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/15/2017 21:34'!translateBy: delta during: aBlock	"Set a translation only during the execution of aBlock."	^aBlock value: (self copyOffset: delta)! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 6/20/2017 15:31'!window	^self canvas window! !!HTML5Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/16/2017 17:40'!writeContents	(FileDirectory default fileNamed: 'script')		nextPutAll: 'var myFunction = function () {';		nextPutAll: self contents;		nextPutAll: '};';		close! !!HTML5Canvas class methodsFor: 'as yet unclassified' stamp: 'crl 5/13/2017 21:03'!on: html5CanvasRenderingContext2D	^self new context: html5CanvasRenderingContext2D! !!SAXMalformedException methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!SAXMalformedException class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!MethodTempsNode methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!MethodTempsNode class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 1/1/2014 12:50'!id	^id! !!MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 12/19/2013 14:00'!new	^super new initialize! !!TextEditor methodsFor: 'as yet unclassified' stamp: 'crl 6/17/2018 19:39'!cursorBeginningOfLine: characterStream 	"Private - Move cursor from position in current line to beginning of	current line. If cursor already at beginning of line, do nothing."	| string left |	string := paragraph text string.	left := pointBlock stringIndex.	[left > 1 and: [(string at: (left - 1)) ~= Character cr]] whileTrue:		[left := left - 1].	pointBlock stringIndex == left		ifFalse: [self selectAt: left].	^true! !!TextEditor methodsFor: 'as yet unclassified' stamp: 'crl 6/17/2018 19:40'!cursorEndOfLine: characterStream 	"Private - Move cursor end of current line. If cursor already at end of	 line, do nothing."	| string right stringSize |	string := paragraph text string.	stringSize := string size.	right := pointBlock stringIndex.	[right <= stringSize and: [(string at: right) ~= Character cr]]		whileTrue: [right := right + 1].	pointBlock stringIndex == right		ifFalse: [self selectAt: right].	^true! !!TextEditor methodsFor: 'as yet unclassified' stamp: 'crl 6/20/2018 13:40'!cutToEndOfLine: characterStream 	"Cut from cursor position to end of line a la emacs CTRL-y. Flushes typeahead."	| string stringSize right |	string := paragraph text string.	stringSize := string size.	right := pointBlock stringIndex.	[right <= stringSize and: [(string at: right) ~= Character cr]]		whileTrue: [right := right + 1].	"Only delete the trailing newline if we're at the end of the line."	"Unfortunately, this doesn't behave as expected--merging consecutive CTRL-y's--so	 I've removed it, as there's less chance of data loss."[	(right > pointBlock stringIndex and: [(string at: right) = Character cr])		ifTrue: [			right := right - 1.		].].	self selectFrom: pointBlock stringIndex to: right.	self cut.	^true! !!TextEditor methodsFor: 'as yet unclassified' stamp: 'crl 4/2/2019 15:53'!dispatchOnKeyboardEvent: aKeyboardEvent 	"Carry out the action associated with this character, if any.  	Type-ahead is passed so some routines can flush or use it."	| honorCommandKeys typedChar |	((typedChar := aKeyboardEvent keyCharacter) == Character cr and: [ morph acceptOnCR ]) ifTrue:		[ self closeTypeIn.		^ true ].	self clearParens.	aKeyboardEvent keyValue = 13 ifTrue:		[ aKeyboardEvent controlKeyPressed ifTrue: [ ^ self normalCharacter: aKeyboardEvent ].		aKeyboardEvent shiftPressed ifTrue: [ ^ self lf: aKeyboardEvent ].		aKeyboardEvent commandKeyPressed ifTrue: [ ^ self crlf: aKeyboardEvent ].		^ self crWithIndent: aKeyboardEvent ].	((honorCommandKeys := Preferences cmdKeysInText) and: [ typedChar = Character enter ]) ifTrue: [ ^ self dispatchOnEnterWith: aKeyboardEvent ].	"Special keys overwrite crtl+key combinations - at least on Windows. To resolve this	conflict, assume that keys other than cursor keys aren't used together with Crtl."	((self class specialShiftCmdKeys includes: aKeyboardEvent keyValue) and: [ aKeyboardEvent keyValue < 27 ]) ifTrue: [ ^ aKeyboardEvent controlKeyPressed			ifTrue:				[ self					perform: (self class shiftCmdActions at: aKeyboardEvent keyValue + 1)					with: aKeyboardEvent ]			ifFalse:				[ self					perform: (self class cmdActions at: aKeyboardEvent keyValue + 1)					with: aKeyboardEvent ] ].	"backspace, and escape keys (ascii 8 and 27) are command keys"	((honorCommandKeys and: [ aKeyboardEvent commandKeyPressed ]) or: [ self class specialShiftCmdKeys includes: aKeyboardEvent keyValue ]) ifTrue: [ ^ aKeyboardEvent shiftPressed			ifTrue:				[ self					perform: (self class shiftCmdActions at: aKeyboardEvent keyValue + 1)					with: aKeyboardEvent ]			ifFalse:				[ self					perform: (self class cmdActions at: aKeyboardEvent keyValue + 1 ifAbsent: [^true])					with: aKeyboardEvent ] ].	"the control key can be used to invoke shift-cmd shortcuts"	(honorCommandKeys and: [ aKeyboardEvent controlKeyPressed ]) ifTrue: [ ^ self			perform: (self class shiftCmdActions at: aKeyboardEvent keyValue + 1)			with: aKeyboardEvent ].	self class autoEnclose		ifTrue: [ (self autoEncloseFor: typedChar) ifFalse: [ self normalCharacter: aKeyboardEvent ] ]		ifFalse: [ self normalCharacter: aKeyboardEvent ].	^ false! !!TextEditor methodsFor: 'as yet unclassified' stamp: 'mt 4/7/2015 13:17'!printIt	self evaluateSelectionAndDo: [:result |		(model respondsTo: #printIt:result:)			ifTrue: [model				perform: #printIt:result:				with: self selection				with: result]			ifFalse: [self afterSelectionInsertAndSelect: result printString]]! !!TextEditor class methodsFor: 'as yet unclassified' stamp: 'crl 6/20/2018 13:24'!initializeCmdKeyShortcuts	"Initialize the (unshifted) command-key (or alt-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"TextEditor initialize"	| cmdMap cmds |	cmdMap := Array new: 256 withAll: #noop:.		"use temp in case of a crash"	cmdMap at: 1 + 1 put: #cursorHome:.				"home key"	cmdMap at: 4 + 1 put: #cursorEnd:.				"end key"	cmdMap at: 8 + 1 put: #backspace:.				"ctrl-H or delete key"	cmdMap at: 11 + 1 put: #cursorPageUp:.			"page up key"	cmdMap at: 12 + 1 put: #cursorPageDown:.		"page down key"	cmdMap at: 13 + 1 put: #crWithIndent:.			"cmd-Return"	cmdMap at: 27 + 1 put: #offerMenuFromEsc:.		"escape key"	cmdMap at: 28 + 1 put: #cursorLeft:.				"left arrow key"	cmdMap at: 29 + 1 put: #cursorRight:.				"right arrow key"	cmdMap at: 30 + 1 put: #cursorUp:.				"up arrow key"	cmdMap at: 31 + 1 put: #cursorDown:.				"down arrow key"	cmdMap at: 32 + 1 put: #selectWord:.				"space bar key"	cmdMap at: 127 + 1 put: #forwardDelete:.		"del key"				'0123456789-=' 		do: [:char | cmdMap at: char asciiValue + 1 put: #changeEmphasis:].			'([<{|"''' do: [:char | cmdMap at: char asciiValue + 1 put: #enclose:].		cmds := #($a #selectAll: $r browseIt: $b #cursorLeft: $c #copySelection: $e #exchange: $f #cursorRight: $g #findAgain: $h #setSearchString: $k #offerFontMenu: $u #align: $v #paste: $w #backWord: $x #cut: $y #swapChars: $z #undo:).	1 to: cmds size		by: 2		do: [:i | cmdMap at: (cmds at: i) asciiValue + 1 put: (cmds at: i + 1)].			cmdActions := cmdMap! !!Program methodsFor: 'as yet unclassified' stamp: 'crl 5/7/2017 13:56'!printSmalltalkOn: stream	| declarators statements |		declarators := OrderedCollection new.	statements := OrderedCollection new.		body do: [:declarationOrStatement |		(declarationOrStatement declares)			ifTrue: [declarators addAll: declarationOrStatement declarators]			ifFalse: [statements add: declarationOrStatement]].		declarators do: [:declarator |		declarator initializes ifTrue: [statements addFirst: declarator]].		"Print variable declarations."	declarators ifNotEmpty: [		stream nextPutAll: '| '.		declarators do: [:declarator |			stream				nextPutAll: declarator id name;				space].		stream			nextPut: $|;			cr].		stream cr.		"Print statements."	statements do: [:statement |		statement printSmalltalkOn: stream.		stream			nextPut: $.;			cr]! !!Program class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!ChromeRemoteObject methodsFor: 'as yet unclassified' stamp: 'crl 7/24/2017 01:08'!at: key put: value	tab		send: 'Runtime.callFunctionOn'		withParameters: {			#objectId -> id.			#functionDeclaration -> 'function (key, value) {this[key] = value}'.			#arguments -> (				[{key. value} collect: [:each | each asChromeRemoteCallArgument]]					on: Error					do: [:exception |						3 halt: exception description.						^self])}.					^value! !!PluggableActionButtonSpec class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!Set methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 03:50'!tag	^SetTag! !!Set class methodsFor: 'as yet unclassified'!fromTether: tether	| counterpart |	counterpart := self new.		1		to: tether nextWord		do: [:index | counterpart add: tether next].			^counterpart! !!IdentitySet class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!RelativeInstructionPrinter class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!MIDIStatusMasks methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!MIDIStatusMasks class methodsFor: 'as yet unclassified' stamp: 'crl 8/22/2017 10:22'!initialize	NoteOn := 16r90.	ControlChange := 16rB0.	ProgramChange := 16rC0.	PitchWheelChange := 16rE0.	SystemExclusive := 16rF0.	SystemReset := 16rFF! !!AbstractHierarchicalList methodsFor: 'as yet unclassified' stamp: 'RAA 6/21/1999 15:22'!genericMenu: aMenu	aMenu add: 'no menu yet' target: self selector: #yourself.	^aMenu! !!AbstractHierarchicalList methodsFor: 'as yet unclassified' stamp: 'RAA 4/7/1999 16:44'!getCurrentSelection	^currentSelection! !!AbstractHierarchicalList methodsFor: 'as yet unclassified' stamp: 'RAA 4/7/1999 16:46'!noteNewSelection: x	currentSelection := x.	self changed: #getCurrentSelection.	currentSelection ifNil: [^self].	currentSelection sendSettingMessageTo: self.! !!AbstractHierarchicalList methodsFor: 'as yet unclassified' stamp: 'RAA 4/7/1999 16:53'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !!AbstractHierarchicalList methodsFor: 'as yet unclassified' stamp: 'RAA 4/7/1999 16:47'!update: aSymbol	aSymbol == #hierarchicalList ifTrue: [		^self changed: #getList	].	super update: aSymbol! !!PickAFileToWriteNotification methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!PickAFileToWriteNotification class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!JSBoxMorph methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSBoxMorph class methodsFor: 'as yet unclassified' stamp: 'crl 5/30/2017 13:35'!with: morph	^(self new)		add: morph;		yourself! !!Browser methodsFor: 'as yet unclassified' stamp: 'crl 3/27/2019 10:28'!initialExtent	^693@430! !!Browser methodsFor: 'as yet unclassified' stamp: 'ar 1/19/2010 20:39'!openMessageCatEditString: aString        "Create a pluggable version of the views for a Browser that just shows one message category."	"Example: 		Preferences browseThemes.	" 	| builder max |	aString ifNotNil:[		"Note: The views aren't actually built yet after we've called buildWindowWith:.		Since we can't send changed: #editString before the views have been built		we just shoot the #changed: message into the #future. This is the easiest		way to solve this issue locally."		self future changed: #editString with: aString].	builder := ToolBuilder default.	max := self wantsOptionalButtons ifTrue:[0.32] ifFalse:[0.4].	^self buildWindowWith: builder specs: {		(0@0 corner: 1.0@0.08) -> [self buildMessageListCatSingletonWith: builder].		(0.0@0.08 corner: 1.0@max) -> [self buildMessageListWith: builder].		(0@max corner: 1@1) -> [self buildCodePaneWith: builder].	}.! !!Browser methodsFor: 'as yet unclassified' stamp: 'crl 6/13/2017 15:53'!spawn: aString 	"Create and schedule a fresh browser and place aString in its code pane.  This method is called when the user issues the #spawn command (cmd-o) in any code pane.  Whatever text was in the original code pane comes in to this method as the aString argument; the changes in the original code pane have already been cancelled by the time this method is called, so aString is the only copy of what the user had in his code pane."	self selectedClassOrMetaClass ifNotNil: [^ super spawn: aString].	self hasSystemCategorySelected ifTrue:		["This choice is slightly useless but is the historical implementation"		^ self buildSystemCategoryBrowserEditString: aString].			^ super spawn: aString  	"This bail-out at least saves the text being spawned, which would otherwise be lost"! !!Browser class methodsFor: 'as yet unclassified' stamp: 'crl 6/18/2017 01:24'!openBrowser	"Create and schedule a BrowserView with default browser label. The	view consists of five subviews, starting with the list view of system	categories of SystemOrganization. The initial text view part is empty."	^self openBrowserInWorld: World! !!Browser class methodsFor: 'as yet unclassified' stamp: 'crl 6/18/2017 01:24'!openBrowserInWorld: world	"Create and schedule a BrowserView with default browser label. The	view consists of five subviews, starting with the list view of system	categories of SystemOrganization. The initial text view part is empty."	| br |	br := self new.	^ self		openBrowserView: (br openEditString: nil)		label: br defaultBrowserTitle		world: world! !!Browser class methodsFor: 'as yet unclassified' stamp: 'crl 6/18/2017 01:23'!openBrowserView: aBrowserView label: aString	^self		openBrowserView: aBrowserView		label: aString		world: World! !!Browser class methodsFor: 'as yet unclassified' stamp: 'crl 9/18/2017 15:41'!openBrowserView: aBrowserView label: aString world: world	"Schedule aBrowserView, labelling the view aString."(aBrowserView isKindOf: ToolBuilderSpec) ifTrue:[	(self canUseMultiWindowBrowsers	 and: [self useMultiWindowBrowsers]) ifTrue:		[aBrowserView multiWindowStyle: #labelButton].	(world ifNil: [HTML5ToolBuilder] ifNotNil: [ToolBuilder]) open: aBrowserView label: aString world: world.] ifFalse:[	aBrowserView isMorph		ifTrue:  [(aBrowserView setLabel: aString) openInWorld: world]		ifFalse: [aBrowserView label: aString.				aBrowserView minimumSize: 300 @ 200.				aBrowserView subViews do: [:each | each controller].				aBrowserView controller open].].	^ aBrowserView model! !!Browser class methodsFor: 'as yet unclassified' stamp: 'crl 9/18/2017 15:43'!openHTMLBrowser	^self openBrowserInWorld: nil! !!Browser class methodsFor: 'as yet unclassified' stamp: 'crl 6/18/2017 01:25'!openInWorld: world	^self openBrowserInWorld: world! !!ImpressSlide methodsFor: 'as yet unclassified' stamp: 'crl 8/1/2017 23:07'!addParagraph	^Webpage current createParagraph! !!ImpressSlide methodsFor: 'as yet unclassified' stamp: 'crl 8/1/2017 21:48'!attributeAt: name put: value	^proxy attributeAt: name put: value asString! !!ImpressSlide methodsFor: 'as yet unclassified' stamp: 'crl 8/2/2017 00:17'!beOpaque	self children do: [:child | child beOpaque]! !!ImpressSlide methodsFor: 'as yet unclassified' stamp: 'crl 8/2/2017 00:17'!beTransparent	self children do: [:child | child beTransparent]! !!ImpressSlide methodsFor: 'as yet unclassified' stamp: 'crl 8/2/2017 00:18'!beVisible	self children do: [:child | child beOpaque; beVisible]! !!ImpressSlide methodsFor: 'as yet unclassified' stamp: 'crl 9/10/2017 21:34'!childWithID: id	^self children detect: [:child | child id = id]! !!ImpressSlide methodsFor: 'as yet unclassified' stamp: 'crl 8/2/2017 00:21'!children	^super children asArray! !!ImpressSlide methodsFor: 'as yet unclassified' stamp: 'crl 8/1/2017 23:35'!go	self class goto: self name! !!ImpressSlide methodsFor: 'as yet unclassified' stamp: 'crl 8/2/2017 00:13'!initialize	self proxy: Webpage current createDiv.		proxy		at: #style put: '';		attributeAt: #class put: 'step'.			self		x: 4000;		y: 2000;		scale: 4! !!ImpressSlide methodsFor: 'as yet unclassified' stamp: 'crl 10/22/2017 17:23'!install	| parent |		parent := (Webpage current elementAt: 'impress') children first.	parent insertBefore: self with: parent firstElementChild.	self beVisible.	self class initializeTransforms! !!ImpressSlide methodsFor: 'as yet unclassified' stamp: 'crl 8/1/2017 23:35'!name	^self attributeAt: #id! !!ImpressSlide methodsFor: 'as yet unclassified' stamp: 'crl 8/1/2017 21:30'!name: name	proxy attributeAt: #id put: name! !!ImpressSlide methodsFor: 'as yet unclassified' stamp: 'crl 8/1/2017 21:36'!printOn: stream	stream		nextPutAll: self class name article;		space;		print: self class;		nextPutAll: ' named ''';		nextPutAll: self name;		nextPut: $'! !!ImpressSlide methodsFor: 'as yet unclassified' stamp: 'crl 8/2/2017 00:13'!proxy: object	proxy := object! !!ImpressSlide methodsFor: 'as yet unclassified' stamp: 'crl 8/1/2017 21:54'!scale	^(self attributeAt: 'data-scale') asNumber! !!ImpressSlide methodsFor: 'as yet unclassified' stamp: 'crl 8/1/2017 22:07'!scale: integer	self attributeAt: 'data-scale' put: integer! !!ImpressSlide methodsFor: 'as yet unclassified' stamp: 'crl 8/2/2017 00:14'!x	^(self attributeAt: 'data-x') asNumber! !!ImpressSlide methodsFor: 'as yet unclassified' stamp: 'crl 8/1/2017 22:07'!x: integer	self attributeAt: 'data-x' put: integer! !!ImpressSlide methodsFor: 'as yet unclassified' stamp: 'crl 8/2/2017 00:15'!y	^(self attributeAt: 'data-y') asNumber! !!ImpressSlide methodsFor: 'as yet unclassified' stamp: 'crl 8/1/2017 22:08'!y: integer	self attributeAt: 'data-y' put: integer! !!ImpressSlide class methodsFor: 'as yet unclassified' stamp: 'crl 9/6/2017 18:07'!blurThen: block	JS top document activeElement blur.	block value! !!ImpressSlide class methodsFor: 'as yet unclassified' stamp: 'crl 10/22/2017 17:24'!existingNamed: slideName	^self new proxy: (Webpage current elementAt: slideName)! !!ImpressSlide class methodsFor: 'as yet unclassified' stamp: 'crl 10/22/2017 17:24'!existingSlideNames	^(Webpage current elementAt: #impress) children first children collect: [:slide | slide id]! !!ImpressSlide class methodsFor: 'as yet unclassified' stamp: 'crl 9/7/2017 19:47'!fodder	#(#innerHTML:)! !!ImpressSlide class methodsFor: 'as yet unclassified' stamp: 'crl 7/26/2017 17:41'!goto: tag	self blurThen: [globalObject goto: tag]! !!ImpressSlide class methodsFor: 'as yet unclassified' stamp: 'crl 7/26/2017 17:48'!initialize	Smalltalk addToStartUpList: self! !!ImpressSlide class methodsFor: 'as yet unclassified' stamp: 'crl 8/1/2017 23:52'!initializeTransforms	globalObject reinit! !!ImpressSlide class methodsFor: 'as yet unclassified' stamp: 'crl 8/2/2017 00:09'!newNamed: slideName	^self new name: slideName! !!ImpressSlide class methodsFor: 'as yet unclassified' stamp: 'crl 7/26/2017 17:40'!next	self blurThen: [globalObject next]! !!ImpressSlide class methodsFor: 'as yet unclassified' stamp: 'crl 7/26/2017 17:40'!previous	self blurThen: [globalObject prev]! !!ImpressSlide class methodsFor: 'as yet unclassified' stamp: 'crl 9/6/2017 17:55'!startUp: resuming	resuming ifTrue: [		JS ifConnected: [			[globalObject := (JS top at: #impress) call]				on: Error				do: [:exception | ]]]! !!OutOfMemory class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!PluggableCanvas class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:55'!foo! !!SpaceTallyItem methodsFor: 'as yet unclassified' stamp: 'sd 6/20/2003 22:59'!analyzedClassName	^ analyzedClassName! !!SpaceTallyItem methodsFor: 'as yet unclassified' stamp: 'sd 6/20/2003 22:59'!analyzedClassName: aClassName	analyzedClassName := aClassName! !!SpaceTallyItem methodsFor: 'as yet unclassified' stamp: 'sd 6/20/2003 22:08'!codeSize	^ codeSize! !!SpaceTallyItem methodsFor: 'as yet unclassified' stamp: 'sd 6/20/2003 22:09'!codeSize: aNumber	codeSize := aNumber! !!SpaceTallyItem methodsFor: 'as yet unclassified' stamp: 'sd 6/20/2003 22:09'!instanceCount	^ instanceCount! !!SpaceTallyItem methodsFor: 'as yet unclassified' stamp: 'sd 6/20/2003 22:09'!instanceCount: aNumber	instanceCount := aNumber! !!SpaceTallyItem methodsFor: 'as yet unclassified' stamp: 'cmm 5/19/2013 12:49'!printOn: aStream	analyzedClassName		ifNotNil: [ aStream nextPutAll: analyzedClassName asString]. 	aStream nextPutAll: ' ('.	codeSize		ifNotNil: [ aStream nextPutAll: 'code size: ' ;  nextPutAll: codeSize asString]. 	instanceCount		ifNotNil: [ aStream nextPutAll: ' instance count: ' ;  nextPutAll: instanceCount asString]. 	spaceForInstances		ifNotNil: [ aStream nextPutAll: ' space for instances: ' ;  nextPutAll: spaceForInstances asBytesDescription]. 	aStream nextPut: $).	! !!SpaceTallyItem methodsFor: 'as yet unclassified' stamp: 'sd 6/20/2003 22:10'!spaceForInstances	^ spaceForInstances! !!SpaceTallyItem methodsFor: 'as yet unclassified' stamp: 'sd 6/20/2003 22:10'!spaceForInstances: aNumber	spaceForInstances := aNumber! !!SpaceTallyItem class methodsFor: 'as yet unclassified' stamp: 'sd 6/20/2003 22:54'!analyzedClassName: aClassName	^ self new		analyzedClassName: aClassName ; yourself		! !!SpaceTallyItem class methodsFor: 'as yet unclassified' stamp: 'sd 6/20/2003 22:54'!analyzedClassName: aClassName codeSize: codeSize instanceCount: instanceCount spaceForInstances: spaceForInstances	^ self new		analyzedClassName: aClassName ;		codeSize: codeSize ;		instanceCount: instanceCount ;		spaceForInstances: spaceForInstances ; yourself! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 8/5/2010 19:51'!acceptsCookie: aCookie from: webClient	"Returns true if this cookie is applicable to this request"	aCookie domain ifNotNil:[:domain|		(webClient serverName endsWith: domain) ifFalse:[^false].	].	aCookie path ifNotNil:[:path|		(self url beginsWith: path) ifFalse:[^false].	].	aCookie secure ifNotNil:[:secure|		secure ifTrue:[webClient scheme = 'https' ifFalse:[^false]].	].	aCookie expiry ifNotNil:[:expiry|		aCookie isExpired ifTrue:[^false].	].	^true! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 9/26/2011 10:25'!asWebSocket	"Convert this request into a WebSocket"	"Figure out the version of the protocol"	| field version |	version := self headerAt: 'Sec-WebSocket-Version' ifAbsent:[nil].	version ifNil:[		field := self headerAt: 'Sec-WebSocket-Key1' ifAbsent:[nil].		field 			ifNil:[^self asWebSocket68] 			ifNotNil:[^self asWebSocket00].	].	"Attempt WebSocket07 conversion"	^self asWebSocket07! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 9/26/2011 10:39'!asWebSocket00	"Convert this request into a WebSocket"	| field key1 key2 bytes resp |	resp := self newResponse protocol: 'HTTP/1.1' code: 101.	resp status: 'HTTP/1.1 101 Web Socket Protocol Handshake'.	"Chrome 4/5 is *VERY* sensitive to the order of the fields"	resp headerAt: 'Upgrade' put: 'WebSocket'.	resp headerAt: 'Connection' put: 'Upgrade'.	field := self headerAt: 'Sec-WebSocket-Key1'.	key1 := WebUtils extractWebSocketKey: field.	field := self headerAt: 'Sec-WebSocket-Key2'.	key2 := WebUtils extractWebSocketKey: field.	bytes := WebUtils webSocketHandshake: key1 with: key2 with: (stream next: 8).	resp headerAt: 'Sec-WebSocket-Origin' put: (self headerAt: 'Origin').	resp headerAt: 'Sec-WebSocket-Location' put: ('ws://', (self headerAt: 'host'), self rawUrl).	(self headerAt: 'Sec-WebSocket-Protocol' ifAbsent:[nil]) ifNotNil:[:hdr|		resp headerAt: 'Sec-WebSocket-Protocol' put: hdr.	].	resp writeOn: stream.	bytes ifNotNil:[stream nextPutAll: bytes].	stream flush.	^WebSocket00 on: stream.! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'klub 6/13/2012 17:00'!asWebSocket07	"Convert this request into a WebSocket"	| resp hash nonce |	resp := self newResponse protocol: 'HTTP/1.1' code: 101.	resp status: 'HTTP/1.1 101 Web Socket Protocol Handshake'.	"Chrome 4/5 is *VERY* sensitive to the order of the fields"	resp headerAt: 'Upgrade' put: 'WebSocket'.	resp headerAt: 'Connection' put: 'Upgrade'.	nonce := self headerAt: 'Sec-WebSocket-Key'.	hash := WebUtils webSocketHash07: nonce.	resp headerAt: 'Sec-WebSocket-Accept' put: hash.	(self headerAt: 'Sec-WebSocket-Origin' ifAbsent: [self headerAt: 'Origin']) 		ifNotNil: [ :origin | resp headerAt: 'Sec-WebSocket-Origin' put: origin ].	resp headerAt: 'Sec-WebSocket-Location' put: ('ws://', (self headerAt: 'host'), self rawUrl).	(self headerAt: 'Sec-WebSocket-Protocol' ifAbsent:[nil]) ifNotNil:[:hdr|		resp headerAt: 'Sec-WebSocket-Protocol' put: hdr.	].	resp writeOn: stream.	stream flush.	^(WebSocket07 on: stream)		masking: false;		yourself.	"http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-07#section-4.1 says:   ''Frames sent from the server to the client are not masked.''	http://tools.ietf.org/html/rfc6455#section-5.1 says:    ''A client MUST close a connection if it detects a masked   frame.''	So not using masking is compatible with the 07 protocol and is required by RFC 6455."! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 9/26/2011 10:40'!asWebSocket68	"Convert this request into a WebSocket"	| resp |	resp := self newResponse protocol: 'HTTP/1.1' code: 101.	resp status: 'HTTP/1.1 101 Web Socket Protocol Handshake'.	"Chrome 4/5 is *VERY* sensitive to the order of the fields"	resp headerAt: 'Upgrade' put: 'WebSocket'.	resp headerAt: 'Connection' put: 'Upgrade'.	resp headerAt: 'WebSocket-Origin' put: (self headerAt: 'Origin').	resp headerAt: 'WebSocket-Location' put: ('ws://', (self headerAt: 'host'), self rawUrl).	(self headerAt: 'WebSocket-Protocol' ifAbsent:[nil]) ifNotNil:[:hdr|		resp headerAt: 'WebSocket-Protocol' put: hdr.	].	resp writeOn: stream.	stream flush.	^WebSocket00 on: stream.! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'klub 7/24/2011 19:25'!closeIfTransient: resp after: aBlock	"Evaluate aBlock. Close the connection if it is transient.	Inserts Connection: close header if needed."	| close |	close := self isPersistent not.	close 		ifTrue: [			"Always be explicit and insert the Connection: close header"			resp headerAt: 'Connection' put: 'close' ]		ifFalse: [			"We should tell the client that we keep this connection alive."			resp headerAt: 'Connection' put: 'Keep-Alive' ].	aBlock value.	stream flush.	close  ifTrue:[self close].! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 19:34'!cookieAt: aString	"Answer the value for a cookie with the given name"	^self cookieAt: aString ifAbsent:['']! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 19:35'!cookieAt: aString ifAbsent: aBlock	"Answer the value for a cookie with the given name"	self cookiesDo:[:name :value| name = aString ifTrue:[^value]].	^aBlock value! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 19:35'!cookies	"Answer all the cookies defined in the request"	| cookies |	cookies := Dictionary new.	self cookiesDo:[:name :value| cookies at: name put: value].	^cookies! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 8/5/2010 19:56'!cookiesDo: aBlock	"Parse the cookie headers and evaluate aBlock with name / value pairs"	self headersAt: 'Cookie' do:[:hdr|		(hdr findTokens: ';,') do:[:token|			aBlock 				value: (token copyUpTo: $=) withBlanksTrimmed 				value: (token copyAfter: $=) withBlanksTrimmed]].! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 7/20/2010 20:08'!fields	"Answer the fields for the given request."	| fields |	fields := Dictionary new.	self getFields associationsDo:[:a| fields add: a].	self postFields associationsDo:[:a| fields add: a].	self multipartFields associationsDo:[:a| fields add: a].	^fields! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 2/21/2010 09:55'!getFields	"Decodes the fields embedded in the url ?var1=val1&var2=val2"	| args |	args := (rawUrl copyAfter: $?) ifEmpty:[^Dictionary new].	^WebUtils decodeUrlEncodedForm: args multipleValues: false! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 09:02'!initialize	"Initialize the receiver"	super initialize.	method := 'GET'.	protocol := 'HTTP/1.1'.	headers := OrderedCollection new.! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 9/4/2010 11:09'!initializeFromUrl: urlString	"Initialize the client from a http url or string"	| urlStream |	urlStream := urlString readStream.	"Skip past scheme if present"	urlStream upToAll: '://'.	urlStream atEnd 		ifTrue:[rawUrl := urlString]		ifFalse:[rawUrl := urlStream upTo: $/; upToEnd].	(rawUrl beginsWith: '/') ifFalse:[rawUrl := '/', rawUrl].! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 6/23/2010 15:18'!isDeleteRequest	"Returns true if this is an HTTP DELETE request"	^self method = 'DELETE'! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 10:40'!isGetRequest	"Returns true if this is an HTTP GET request"	^self method = 'GET'! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 10:41'!isHeadRequest	"Returns true if this is an HTTP HEAD request"	^self method = 'HEAD'! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 6/23/2010 15:19'!isOptionsRequest	"Returns true if this is an HTTP OPTIONS request"	^self method = 'OPTIONS'! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 10:41'!isPostRequest	"Returns true if this is an HTTP POST request"	^self method = 'POST'! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 6/23/2010 15:18'!isPutRequest	"Returns true if this is an HTTP PUT request"	^self method = 'PUT'! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 6/23/2010 15:18'!isTraceRequest	"Returns true if this is an HTTP TRACE request"	^self method = 'TRACE'! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 10:40'!method	"The request method (GET, POST etc)"	^method! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 10:40'!method: aString	"The request method (GET, POST etc)"	method := aString! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 7/28/2010 21:01'!multipartFields	"Answers the multipart fields of a post request"	| fields |	fields := Dictionary new.	self multipartFieldsDo:[:hdrs :params :cntnt|		params at: 'name' ifPresent:[:fieldName| fields at: fieldName put: cntnt].	].	^fields! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 7/20/2010 20:08'!multipartFieldsDo: aBlock	"Evaluate aBlock with the multipart fields of a post request.	The block is expected to take three arguments:		* The headers from the part being processed		* The parameters from the content-disposition header		* The content from the part being processed	"	^(self isPostRequest and: [		self contentType beginsWith: 'multipart/form-data'])			ifTrue: [WebUtils decodeMultipartForm: self content readStream boundary: self multipartBoundary do: aBlock]			ifFalse: [Dictionary new]! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 4/1/2010 16:03'!newResponse	"Create a new response entitiy.	Subclasses can override this method to provide a different response class"	^(WebResponse new)		request: self;		yourself! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 7/8/2010 19:11'!newWebSocketOn: aStream	"Create a new socket entitiy.	Subclasses can override this method to provide a different response class"	^WebSocket on: aStream! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'klub 4/22/2013 14:53'!postFields	"Answers the multipart fields of a post request"	^(self isPostRequest and: [		self contentType beginsWith: 'application/x-www-form-urlencoded'])			ifTrue: [				WebUtils 					decodeUrlEncodedForm: self content 					multipleValues: true					withConverter: self textConverterForContentType ]			ifFalse: [Dictionary new]! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 10:40'!rawUrl	"The raw (unparsed) url"	^rawUrl! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2010 20:07'!rawUrl: aString	"The raw (unparsed) url"	rawUrl := aString! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 8/4/2010 21:25'!readFrom: aStream	"Initialize the receiver initialized from an existing socket stream 	This method will block until the headers have been parsed."	| tokens |	stream := aStream.	stream isBinary ifTrue:[stream ascii].	"Parse request header"	request := stream upToAll: String crlf.	tokens := request findTokens: ' '.	tokens size < 2 ifTrue:[^self error: 'Invalid HTTP request: ', request].	method := tokens first.	rawUrl := tokens second.	tokens size > 2 		ifTrue:[protocol := tokens third]		ifFalse:[protocol := 'HTTP/1.0'].	"Parse HTTP header"	headers := WebUtils readHeadersFrom: stream.! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 7/28/2010 19:49'!requestLine	"The actual request line as sent by the client"	^request ifNil:[self method, ' ', self rawUrl, ' ', self protocol]! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'SvenVanCaekenberghe 6/14/2010 20:31'!send200Response: aString	"Send a 200 OK response"	^self 		send200Response: (aString convertToWithConverter: UTF8TextConverter new) 		contentType: 'text/plain; charset=utf-8'.! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 15:42'!send200Response: aString contentType: contentType	"Send a 200 OK response"	^self send200Response: aString contentType: contentType do:[:resp]! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 2/25/2010 16:32'!send200Response: aString contentType: contentType do: aBlock	"Send a 200 OK response"	| resp |	resp := self newResponse protocol: 'HTTP/1.1' code: 200.	resp headerAt: 'Content-Type' put: contentType.	aBlock value: resp.	^self sendResponse: resp content: aString.! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 2/25/2010 03:26'!send301Response: location	"Send a 301 permanent redirect response"	^self send301Response: location do:[:resp].! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 2/25/2010 03:27'!send301Response: location do: aBlock	"Send a 301 permanent redirect response"	^self send3xxResponse: location code: 301 do: aBlock! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 2/25/2010 03:26'!send302Response: location	"Send a 302 temporary redirect response"	^self send302Response: location do:[:resp].! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 2/25/2010 03:26'!send302Response: location do: aBlock	"Send a 302 temporary redirect response"	^self send3xxResponse: location code: 302 do: aBlock! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 15:42'!send3xxResponse: location code: statusCode	"Send a 3xx redirect response"	^self send3xxResponse: location code: statusCode do:[:resp].! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 7/23/2010 09:33'!send3xxResponse: location code: statusCode do: aBlock	"Send a 3xx redirect response"	| resp url |	"If the redirect is not to an absolute url, prefix it with the host if we have one"	url := location.	(location findString: '://') > 0 ifFalse:[		(self headerAt: 'host') ifNotEmpty:[:host| url := 'http://', host, location]].	resp := self newResponse protocol: 'HTTP/1.1' code: statusCode.	resp headerAt: 'Location' put: url.	aBlock value: resp.	^self sendResponse: resp content: ''.! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 7/31/2010 09:44'!send400Response	"Send a 400 bad request response"	| message |	message := '<html><head><title>400 Bad Request</title></head><body>',		'<h1>Bad Request</h1>		<p>The server encountered a request it did not understand.		</body></html>'.		self sendResponseCode: 400 		content: message squeakToUtf8		type: 'text/plain; charset=utf-8'		close: true! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 15:43'!send404Response	"Send a 404 not found response"	^self send404Response: '<html><head><title>404 Not Found</title></head><body><h1>404 Not Found</h1><p>The requested URL ',self rawUrl,' was not found on this server.</p></body></html>'.! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'SvenVanCaekenberghe 6/14/2010 20:32'!send404Response: body	"Send a 404 not found response"	^self 		send404Response: (body convertToWithConverter: UTF8TextConverter new) 		do: [ :resp | resp headerAt: 'Content-Type' put: 'text/html; charset=utf-8' ]! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 2/25/2010 16:32'!send404Response: body do: aBlock	"Send a 404 not found response"	| resp |	resp := self newResponse protocol: 'HTTP/1.1' code: 404.	resp headerAt: 'Content-Type' put: 'text/html; charset=utf-8'.	aBlock value: resp.	^self sendResponse: resp content: body.! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2010 20:08'!send405Response: allowed	"Send a 405 method not allowed response"	^self send405Response: allowed content: '<html><head><title>405 Method Not Allowed</title></head><body><h1>405 Method Not Allowed</h1><p>The requested method ',self method,' is not allowed for the URL', self rawUrl, '</p></body></html>'.! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2010 20:08'!send405Response: allowed content: body	"Send a 405 method not allowed response"	| resp |	resp := self newResponse protocol: 'HTTP/1.1' code: 405.	resp headerAt: 'Content-Type' put: 'text/html; charset=utf-8'.	resp headerAt: 'allow' put: (String streamContents:[:s|		allowed do:[:m| s nextPutAll: m] separatedBy:[s nextPut: $,]	]).	^self sendResponse: resp content: body.! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'klub 10/5/2010 16:08'!send500Response: errReport	"Send a 500 internal server error response"	| errLog |	errLog := '<html><head><title>500 Internal Server Error</title></head><body>',		'<h1>Internal Server Error</h1><pre>',		(errReport  copyReplaceAll: String cr with: String crlf),		'</pre></body></html>'.	self sendResponseCode: 500				content: errLog squeakToUtf8				type: 'text/html; charset=utf-8'				close: true.! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2010 20:08'!sendOptionsResponse: allowed	"Send a 200 OK response for an OPTIONS request"	^self send200Response: '' contentType: 'application/octet-stream' do:[:resp|		resp headerAt: 'allow' put: (String streamContents:[:s|			allowed do:[:m| s nextPutAll: m] separatedBy:[s nextPut: $,]		]).	].! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 8/31/2010 22:16'!sendResponse: code chunked: chunkBlock	"Send a chunked response"	^self sendResponse: code chunked: chunkBlock do:[:resp]! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 8/31/2010 22:16'!sendResponse: code chunked: chunkBlock do: hdrBlock	"Send a chunked response"	| resp |	resp := self newResponse protocol: 'HTTP/1.1' code: code.	resp headerAt: 'Transfer-Encoding' put: 'chunked'.	hdrBlock value: resp.	^self sendResponse: resp contentBlock:[:aStream|		"Set the stream in the request and pass it in the chunk block"		resp stream: aStream.		chunkBlock value: resp.		"send termination chunk"		aStream nextPutAll: '0'; crlf; crlf; flush.	].! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 22:04'!sendResponse: resp content: aString	"Send a WebResponse with content."	^self sendResponse: resp contentStream: aString readStream size: aString size! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 8/31/2010 22:11'!sendResponse: resp contentBlock: contentBlock	"Sends a WebResponse, streaming its contents from aStream.	If a size is provided, insert a Content-Length header, otherwise	ensure that the connection is transient."	"Add Date and Server headers"	resp headerAt: 'Date' put: (server ifNil:[WebServer]) serverDate.	resp headerAt: 'Server' put: (server ifNil:[WebServer]) serverString.	self closeIfTransient: resp after:[		"Ignore all network errors while sending the response"		[resp writeOn: stream.		stream flush.		self isHeadRequest ifFalse:[contentBlock value: stream].		] on: NetworkError do:["ignore"].		"Make sure we log before closing the connection"		server ifNotNil:[server logRequest: self response: resp].	].! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 8/31/2010 22:12'!sendResponse: resp contentStream: aStream size: streamSize	"Sends a WebResponse, streaming its contents from aStream.	If a size is provided, insert a Content-Length header, otherwise	ensure that the connection is transient."	streamSize 		ifNil:[self headerAt: 'Connection' put: 'close'] "mark transient"		ifNotNil:[resp headerAt: 'Content-Length' put: streamSize].	^self sendResponse: resp contentBlock:[:sockStream|		resp streamFrom: aStream to: sockStream size: streamSize progress: nil	]! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 7/28/2010 20:22'!sendResponseCode: code content: aString type: contentType close: aBool	"Send a 500 Internal server error response"	^self sendResponseCode: code content: aString type: contentType do:[:hdr|		aBool ifTrue:[hdr headerAt: 'Connection' put: 'close'].	].! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 7/28/2010 20:19'!sendResponseCode: code content: aString type: contentType do: aBlock	"Send a 500 Internal server error response"	| resp |	resp := self newResponse protocol: 'HTTP/1.1' code: code.	contentType ifNotNil:[resp headerAt: 'Content-Type' put: contentType].	aBlock value: resp.	^self sendResponse: resp content: aString.! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2010 23:35'!sendXmlResponse: xmlString	"Send an a-ok 200 xml-ish response"	^self send200Response: xmlString contentType: 'application/xml'! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 6/14/2010 20:55'!server	"If non-nil, the WebServer instance associated with the request."	^server! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 6/14/2010 20:55'!server: aWebServer	"If non-nil, the WebServer instance associated with the request."	server := aWebServer! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 2/25/2010 03:48'!stream200Response: aStream	"Stream a 200 OK response"	^self stream200Response: aStream size: aStream size! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 2/25/2010 03:53'!stream200Response: aStream size: streamSize	"Stream a 200 OK response"	^self stream200Response: aStream size: streamSize type: 'application/octet-stream'! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 2/25/2010 03:53'!stream200Response: aStream size: streamSize type: contentType	"Stream a 200 OK response"	^self stream200Response: aStream size: streamSize type: contentType do:[:resp].! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 2/25/2010 18:14'!stream200Response: aStream size: streamSize type: contentType do: aBlock	"Stream a 200 OK response"	| resp |	resp := self newResponse protocol: 'HTTP/1.1' code: 200.	resp headerAt: 'Content-Type' put: contentType.	aBlock value: resp.	^self sendResponse: resp contentStream: aStream size: streamSize.! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ul 10/15/2014 19:53'!textConverterForContentType	| index contentType |	contentType := self contentType.	contentType size < 8 ifTrue: [ ^nil ].	index := contentType findString: 'charset=' startingAt: 1 caseSensitive: false.	index = 0 ifTrue: [ ^nil ].	^TextConverter newForEncoding: (contentType allButFirst: index + 7) "'charset=' size - 1"! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 3/27/2010 01:43'!url	"The url without fragment or arguments"	^((rawUrl copyUpTo: $#) copyUpTo: $?) unescapePercentsWithTextEncoding: nil! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 16:33'!writeOn: aStream	"Write the request"	self writeRequestOn: aStream.	super writeOn: aStream! !!WebRequest methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 16:33'!writeRequestOn: aStream	"Write the request"	aStream nextPutAll: method; space; nextPutAll: rawUrl; space; nextPutAll: protocol; crlf.! !!WebRequest class methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 11:23'!readFrom: aStream	"Create a WebRequest from a given stream"	^self new readFrom: aStream! !!MyTestNotification methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!MyTestNotification class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!FieldNode class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!CanvasCharacterScanner class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!GreekEnvironment methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!Url class methodsFor: 'as yet unclassified' stamp: 'crl 7/27/2016 23:22'!initialize	SchemeRegistry := Dictionary new		at: 'browser' put: BrowserUrl;		at: 'file' put: FileUrl;		at: 'ftp' put: FtpUrl;		at: 'http' put: HttpUrl;		at: 'https' put: HttpUrl;		at: 'mailto' put: MailtoUrl;		at: 'chrome-extension' put: ChromeExtensionUrl;		at: nil put: HttpUrl;		yourself! !!Url class methodsFor: 'as yet unclassified' stamp: 'crl 7/27/2016 23:25'!schemeNameForString: aString	"Get the scheme name from a string, or return nil if it's not specified. 	Used in internal parsing routines - an outsider may as well use asUrl. 	Return scheme in lowercases."		"Url schemeNameForString: 'http://www.yahoo.com'"	"Url schemeNameForString: '/etc/passwed'"	"Url schemeNameForString: '/etc/testing:1.2.3'"	| index schemeName |	index := aString indexOf: $: ifAbsent: [^ nil].	schemeName := aString first: index - 1.	"(schemeName allSatisfy: [:each | each isLetter]) ifFalse: [^ nil]."	^ schemeName asLowercase! !!SUnitToolBuilder class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!Peer methodsFor: 'as yet unclassified' stamp: 'crl 10/24/2007 13:12'!associate: netResourceHandle withReadabilityIndex: readabilityIndex andWritabilityIndex: writabilityIndex	"Associate the net resource corresponding to netResourceHandle with the given external semaphore indices."	<primitive: 'associateNetResourceWithReadabilityIndexAndWritabilityIndex' module: 'Flow'>	self primitiveFailed! !!Peer methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2012 01:38'!close	"Close myself."	super close.	self unregisterScribingSemaphores! !!Peer methodsFor: 'as yet unclassified' stamp: 'crl 5/29/2011 20:34'!dataAvailable	"Answer whether there is data available for reading."	^(self dataAvailableFor: handle) and: [self isOpen]! !!Peer methodsFor: 'as yet unclassified' stamp: 'crl 8/3/2002 02:22'!dataAvailableFor: theHandle	"Answer whether there is data available for reading for the resource with theHandle."	^self subclassResponsibility! !!Peer methodsFor: 'as yet unclassified' stamp: 'il prior: 0!!!!!!!!!!!!!!!!'!enable	super enable.	self registerScribingSemaphores! !!Peer methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 20:10'!initialize	"Initialize myself."	peerClosed := false.	super initialize! !!Peer methodsFor: 'as yet unclassified' stamp: 'crl 5/24/2001 17:29'!next: anInteger from: netResourceHandle into: aByteArray startingAt: startIndex	"Read the next anInteger bytes into aByteArray, starting at startIndex. Answer the number of bytes actually read."	^self subclassResponsibility! !!Peer methodsFor: 'as yet unclassified' stamp: 'crl 5/22/2001 20:01'!next: anInteger into: aByteArray startingAt: startIndex	"Read the next anInteger bytes into aByteArray, starting at startIndex. Answer the number of bytes actually read."	^self		next: anInteger		into: aByteArray		startingAt: startIndex		timeoutAfter: nil! !!Peer methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2012 13:14'!next: anInteger into: aByteArray startingAt: startIndex timeoutAfter: numberOfMilliseconds 	self waitForReadabilityTimeoutAfter: numberOfMilliseconds.	^ self timedOut		ifTrue: [Timeout signal]		ifFalse: [self				next: anInteger				from: handle				into: aByteArray				startingAt: startIndex]! !!Peer methodsFor: 'as yet unclassified' stamp: 'crl 8/3/2002 02:19'!nextPut: anInteger from: aByteArray startingAt: startIndex	"Write the next anInteger elements in aByteArray, starting at startIndex. Answer the number of bytes actually written."	"The system should support writing timeouts."	^self		needsWork;		notify: handle		whenItMayPerform: write;		nextPut: anInteger		from: aByteArray		to: handle		startingAt: startIndex! !!Peer methodsFor: 'as yet unclassified' stamp: 'crl 8/3/2002 02:27'!nextPut: anInteger from: aByteArray to: netResourceHandle startingAt: startIndex	"Write the next anInteger elements in aByteArray, starting at startIndex. Answer the number of bytes actually written."	"Assume that there is writing buffer space available (e.g., we've already waited for it via >>nextPut:from:startingAt:)."	^self subclassResponsibility! !!Peer methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2012 14:58'!notePeerClosed	self close.	peerClosed _ true! !!Peer methodsFor: 'as yet unclassified' stamp: 'crl 3/15/2001 15:52'!notify: resourceHandle whenItMayPerform: opcode	"Notify the resource corresponding to resourceHandle when it may perform the operation corresponding to opcode without waiting."	self		notify: resourceHandle		whenItMayPerform: opcode		timeoutAfter: nil! !!Peer methodsFor: 'as yet unclassified' stamp: 'crl 3/15/2001 15:52'!notify: resourceHandle whenItMayPerform: opcode timeoutAfter: numberOfMilliseconds	"Notify the resource corresponding to resourceHandle when it may perform the operation corresponding to opcode without waiting. Handle the situation in which numberOfMilliseconds pass in the meantime."	self subclassResponsibility! !!Peer methodsFor: 'as yet unclassified'!peerAddress	"Assuming I'm connection-oriented, answer my peer address."	^self subclassResponsibility! !!Peer methodsFor: 'as yet unclassified' stamp: 'crl 4/17/2007 22:15'!peerClosed	"Answer whether my peer closed."	self isActive.	^peerClosed! !!Peer methodsFor: 'as yet unclassified' stamp: 'crl 8/3/2002 02:22'!printInactivityExplanationOn: aStream	"Print an inactivity explanation on aStream."	self needsWork.	aStream		nextPutAll: ', closed ';		nextPutAll: (			"Is this a remnant from a fixed-object system?"			readability = 0				ifTrue: ['by a system suspension']				ifFalse: ['explicitly'])! !!Peer methodsFor: 'as yet unclassified' stamp: 'crl 6/24/2005 15:10'!readability	"Answer my readability sempahore."	^readability! !!Peer methodsFor: 'as yet unclassified' stamp: 'crl 5/14/2007 17:01'!registerScribingSemaphores	"Register semaphores on which I can wait for reading and writing readiness."	self		associate: handle		withReadabilityIndex: (ExternalSemaphoreTable registerExternalObject: (readability _ Semaphore new))		andWritabilityIndex: (ExternalSemaphoreTable registerExternalObject: (writability _ Semaphore new))! !!Peer methodsFor: 'as yet unclassified' stamp: 'crl 8/3/2002 02:21'!timedOut	"Answer whether I missed a deadline in my most recent wait."	^self timedOut: handle! !!Peer methodsFor: 'as yet unclassified' stamp: 'crl 8/3/2002 02:21'!timedOut: theHandle	"Answer whether I missed a deadline in my most recent wait."	^self subclassResponsibility! !!Peer methodsFor: 'as yet unclassified' stamp: 'crl 8/20/2017 12:29'!unregisterReadingSemaphore	"Unregister my reading semaphore."	readability ifNotNil: [		ExternalSemaphoreTable unregisterExternalObject: readability.		readability _ nil]! !!Peer methodsFor: 'as yet unclassified' stamp: 'crl 1/20/2003 03:13'!unregisterScribingSemaphores	"Unregister my scribing semaphores."	self		unregisterReadingSemaphore;		unregisterWritingSemaphore! !!Peer methodsFor: 'as yet unclassified' stamp: 'crl 8/20/2017 12:29'!unregisterWritingSemaphore	"Unregister my writing semaphore."	writability ifNotNil: [		ExternalSemaphoreTable unregisterExternalObject: writability.		writability _ nil]! !!Peer methodsFor: 'as yet unclassified' stamp: 'BEL 3/22/2003 17:19'!waitForReadability	"Wait until I may perform a read."	self notify: handle whenItMayPerform: read.	readability wait! !!Peer methodsFor: 'as yet unclassified' stamp: 'crl 1/20/2003 04:13'!waitForReadabilityTimeoutAfter: numberOfMilliseconds	"Wait for readability, timing out after numberOfMilliseconds."	self		notify: handle		whenItMayPerform: read		timeoutAfter: numberOfMilliseconds.	readability wait! !!Peer methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2012 00:29'!waitForWritability	"self		notify: handle		whenItMayPerform: write		timeoutAfter: nil.	writability wait"! !!Peer methodsFor: 'as yet unclassified' stamp: 'crl 6/24/2005 15:10'!writability	"Answer my writability sempahore."	^writability! !!ParseNode methodsFor: 'as yet unclassified' stamp: 'crl 4/29/2017 19:29'!noJavaScriptSupport	self error: 'JavaScript doesn''t support this.'! !!ParseNode methodsFor: 'as yet unclassified' stamp: 'crl 4/29/2017 11:17'!printJavaScriptCommentOn: aStream indent: indent 	| thisComment |	self comment == nil ifTrue: [^ self].	1 to: self comment size	   do: [:index |		index > 1 ifTrue: [aStream crtab: indent].		aStream nextPutAll: '/*'.		thisComment := self comment at: index.		self			printSingleComment: thisComment			on: aStream			indent: indent.		aStream nextPutAll: ' */']! !!ParseNode methodsFor: 'as yet unclassified' stamp: 'crl 5/4/2017 22:24'!printJavaScriptOn: stream indent: anInteger 	"If control gets here, avoid recursion loop."	super printJavaScriptOn: stream! !!ParseNode methodsFor: 'as yet unclassified' stamp: 'crl 4/30/2017 18:34'!printJavaScriptOn: aStream indent: level precedence: p	self printJavaScriptOn: aStream indent: level! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2016 19:34'!addPendingIncomingExchange: anIncomingRemoteMessageExchange	"Add aRemoteMessageExchange to the collection of pending exchanges, for the inspection convenience of humans."	^pendingIncomingExchanges add: anIncomingRemoteMessageExchange! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/5/2016 03:23'!addPendingOutgoingExchange: outgoingRemoteMessageExchange	"Add outgoingRemoteMessageExchange to the collection of pending exchanges, for the inspection convenience of humans."	pendingOutgoingExchanges		at: outgoingRemoteMessageExchange id		put: outgoingRemoteMessageExchange.		self push: outgoingRemoteMessageExchange! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 9/1/2016 23:03'!allClassNames	| names |		names := OrderedCollection new.		Object withAllSubclassesDo: [:subclass |		subclass isMeta ifFalse: [names add: subclass name]].		^names! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 9/1/2016 23:08'!classNamed: className	"Delegate this to me to minimize remote messages sent."	Object withAllSubclassesDo: [:class | (class name = className) ifTrue: [^class]].	^nil! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 16:36'!classWithBaseID: baseID	ProtoObject withAllSubclassesDo: [:behavior | behavior baseID = baseID ifTrue: [^behavior]].	^nil! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/1/2016 00:24'!classWithID: classID	^classID activeClass! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 02:24'!classify: newClassName under: category	SystemOrganization		classify: newClassName		under: category! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 13:47'!close	portal close! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 4/2/2019 19:35'!counterpartForWindowWithID: windowID	^(Webpage current windowManager windowWithID: windowID) otherVia: self! !!Tether methodsFor: 'as yet unclassified'!debug	<version: 1>	^ 1337! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/10/2016 19:20'!deliver: answer under: id	"Deliver answer to the outgoing exchange with id."	(		pendingOutgoingExchanges			at: id			ifAbsent: [				3 halt.				^self]	)		deliver: answer! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/13/2016 23:53'!editHistory: editHistory	EditHistory local: editHistory! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 15:00'!environment	^Smalltalk environment! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2016 17:55'!expose: object	^exposedObjects		at: object		ifAbsent: [			self				expose: object				as: object exposureHash]! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2016 17:55'!expose: object as: value	^exposedObjects		at: object		put: value! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/10/2016 22:32'!exposedAProcessAt: identity	^(exposedObjects keyAtValue: identity ifAbsent: [^false]) class == Process! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 20:00'!handleEvent	(peer recyclingHash = 0)		ifTrue: [			peer := self next..			portal isExit ifFalse: [self push: self].			peerSet signal]		ifFalse: [			| nextWord handler |						nextWord := portal nextWord.			handler := Classes at: nextWord ifAbsent: [3 halt].			handler				ifNil: [3 halt]				ifNotNil: [handler handleEventFrom: self]]! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 13:36'!history	^EditHistory local! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 3/20/2019 12:48'!initialize	exposedObjects := IdentityDictionary new.	pendingIncomingExchanges := IdentitySet new.	pendingOutgoingExchanges := Dictionary new.	peerSet := Semaphore new.	module := ModuleEdition new! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 02:05'!installClassEdition: classEdition	module installClassEdition: classEdition! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/14/2016 19:40'!installMethodEdition: methodEdition	module installMethodEdition: methodEdition! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 21:14'!isConnected	^portal isConnected! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/25/2016 18:35'!isOpen	^portal isOpen! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 9/1/2016 22:59'!module	^nil! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 3/24/2019 23:48'!next	"Answer the next object from my entrance."	| tag |	tag := portal nextWord.	^[		SpecialVariables			keyAtValue: tag			ifAbsent: [				(tag >= InstructionsBase)					ifTrue: [self error: 'instruction encountered when object expected']					ifFalse: [						(tag >= OtherMarkerTagBase)							ifTrue: [								Other									withRemoteIdentity: tag - OtherMarkerTagBase									andTether: self]							ifFalse: [								(tag >= SmallIntegerTagBase)									ifTrue: [tag - SmallIntegerTagBase]									ifFalse: [										(tag >= ClassTagsBase)											ifTrue: [(Classes at: tag) fromTether: self]											ifFalse: [exposedObjects keyAtValue: tag]]]]]	]		on: Error		do: [:exception |			JS alert: exception receiver printString, ' ', exception printString.			JS debugger]! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 8/31/2016 16:30'!next16Bits	^portal next16Bits! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 8/31/2016 15:08'!next16BitsPut: sixteenBits	^portal next16BitsPut: sixteenBits! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 8/31/2016 16:32'!next: integer	^portal next: integer! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 19:39'!nextByte	^portal nextByte! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 16:34'!nextPut: byte	^portal nextPut: byte! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 02:56'!nextPutAll: bytes	^portal nextPutAll: bytes! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2016 14:58'!nextPutByte: byte	^portal nextPutByte: byte! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2016 19:45'!nextWord	^portal nextWord! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2016 19:52'!nextWordPut: word	^portal nextWordPut: word! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 9/2/2016 15:06'!peer	^peer! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2016 18:19'!pendingOutgoingMessage	^portal pendingOutgoingMessage! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2016 17:14'!performNextIncomingMessage	"Perform the next incoming message."	IncomingMessageExchange		send: (Symbol fromTether: (self skipWord; skipWord))		withParameters: (Array fromTether: self skipWord)		to: self next		over: self		under: self next! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 12:59'!ping	^1001! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/13/2016 23:39'!portal: aPortal	portal := aPortal.	portal isExit ifTrue: [self push: self]! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/4/2016 00:30'!printOn: stream	super printOn: stream.	stream		nextPutAll: ' through ';		print: portal! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 8/31/2016 23:02'!push: object	self send: [self store: object]! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/20/2016 15:00'!quit	[		(Delay forSeconds: 1) wait.		SmalltalkImage current snapshot: false andQuit: true	]		fork! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/1/2016 21:33'!remember	((ProtoObject withAllSubclasses asSortedCollection: [:earlier :later | earlier allSubclasses size > later allSubclasses size]) reject: [:behavior | behavior isMeta]) do: [:protoclass |		{protoclass class. protoclass} do: [:behavior | behavior remember]].		((ProtoObject withAllSubclasses reject: [:behavior | behavior isMeta]) asSortedCollection: [:earlier :later | earlier name < later name]) do: [:protoclass |		{protoclass. protoclass class} do: [:behavior |			behavior selectorsDo: [:selector | behavior rememberMethodAt: selector]]]! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 03:12'!removeFromSystem: classEdition	classEdition activeClass removeFromSystem! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2016 19:35'!removePendingIncomingExchange: anIncomingRemoteMessageExchange	"Remove anIncomingRemoteMessageExchange from the collection of pending incoming exchanges."	^pendingIncomingExchanges remove: anIncomingRemoteMessageExchange! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/10/2016 22:04'!removePendingOutgoingExchange: outgoingMessageExchange	"Remove outgoingMessageExchange from the collection of pending outgoing exchanges."	^pendingOutgoingExchanges removeKey: outgoingMessageExchange id ifAbsent: []! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2016 22:45'!removeSelector: selector fromClassForEdition: edition	edition activeClass removeSelector: selector! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 21:22'!resumeComposingMessageAfter: block	| pendingOutgoingMessage result |		pendingOutgoingMessage := portal pendingOutgoingMessage.	result := block value.	self		startMessage;		nextPutAll: pendingOutgoingMessage.	^result! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2016 17:32'!save	self class save! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2016 21:23'!send: block	portal startMessage.	block value.	portal send! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 14:47'!setBaseIDs	Class allSubclassesDo: [:metaclass |		Transcript			cr;			nextPutAll: metaclass soleInstance name;			endEntry.					peer			setBaseIDsOfClassNamed: metaclass soleInstance name			to: {				metaclass baseID.				metaclass soleInstance baseID}]		! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 9/2/2016 15:36'!setBaseIDsFor: className to: ids	| class |		class := Smalltalk at: className ifAbsent: [^self].		class class baseID: ids first.	class baseID: ids second! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2016 23:49'!setBaseIDsOfClassNamed: className to: uuids	| class |		class := Smalltalk at: className ifAbsent: [^self].		class baseID: uuids first.	class class baseID: uuids second! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2016 19:45'!skipWord	self nextWord! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2016 18:20'!startMessage	portal startMessage! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 9/1/2016 22:53'!store: object	object storeOnTether: self! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/1/2016 21:23'!systemOrganization	^SystemOrganization! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 13:46'!waitForPeer	peerSet isSignaled ifFalse: [peerSet wait]! !!Tether class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 21:27'!finalRemovedClassNames	"^#(		PreferenceViewRegistry.		Flaps.		Locale.		LocaleID.		TheWorldMenu.		TextDomainManager.		PackageOrganizer.		MethodReference.		TTFontReader.		DisplayObject.		Morph.		StandardScriptingSystem.		AbstractFont.		ImageSegment.		AbstractLauncher.		ExternalDropHandler.		MCReader.		MCRepository.		ServiceRegistry.		ServiceAction.		PackageInfo.		Presenter.		NaturalLanguageTranslator.		MailComposition.		StringHolder.		CodeHolder.		ChangeList.		ChangeSorter.		Browser.		DisplayMedium.		Form.		Cursor.		CursorWithMask.		ImageMorph.		BorderedMorph.		EllipseMorph.		RectangleMorph.		PolygonMorph.		PasteUpMorph.		AlignmentMorph.		TextMorph.		BooklikeMorph.		BookMorph.		TTCFont.		StrikeFont.		MCVersionReader.		SmallLandColorTheme.		ServiceCategory.		MCMockPackageInfo.		ParseNode.		AbstractEvent.		GraphicSymbol.		UrlArgumentList.		FloatCollection.		TestFailure.		MCNoChangesException.		WebAuthRequired.		FTPConnectionException.		ProtocolClientError.		MyResumableTestError.		IllegalURIException.		DuplicateVariableError.		CRCError.		SyntaxErrorNotification.		LoginFailedException.		TelnetProtocolError.		ProjectEntryNotification.		ProjectViewOpenNotification.		ProgressTargetRequestNotification.		OutOfScopeNotification.		ProgressNotification.		ProjectPasswordNotification.		InMidstOfFileinNotification.		MCChangeSelectionRequest.		MCMergeResolutionRequest.		ParserNotification.		UndeclaredVariableReference.		HTTPProgress.		ProgressInitiationException.		ReparseAfterSourceEditing.		MCProxyMaterialization.		MissingFont.		MCVersionNameAndMessageRequest.		UndeclaredVariableWarning.		UndeclaredVariable.		UndefinedVariable.		UnknownSelector.		UnusedVariable.		AmbiguousSelector.		AddedEvent.		CommentedEvent.		DoItEvent.		ModifiedEvent.		RecategorizedEvent.		RemovedEvent.		RenamedEvent.		ReorganizedEvent.		ModifiedClassDefinitionEvent.		ModifiedTraitDefinitionEvent.		AutoStart.		MailComposition.		MailSender.		AppRegistry.		FileList.		ColorTheme.		ServiceAction)"! !!Tether class methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 00:00'!frozenClassHierarchyRoots	^{		Association.		"BitMatchingPattern."		BytecodeEncoder.		Categorizer.		ClassID.		ContextPart.		Delay.		Edition.		FileDirectory.		FileStream.		FileStreamException.		Halt.		HashedCollection.		"HostPlatform.		License.		Manifest."		MessageExchange.		MessageExchange.		"MethodLiteralTransmissionMarker."		MimeConverter.		NetworkError.		NotImplemented.		Number.		Portal.		RemoteMessagingService.		RemoteServiceInstructions.		"SmalltalkDialect."		SourceFileArray.		Symbol.		TextConverter.		"UniformResourceIdentifier."		WeakKeyDictionary.		WebMessage}! !!Tether class methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 01:26'!fusedClassHierarchyRoots	^{		Association.		"BitMatchingPattern."		BytecodeEncoder.		Categorizer.		ClassID.		ContextPart.		Delay.		Edition.		FileDirectory.		FileStream.		FileStreamException.		Halt.		HashedCollection.		"HostPlatform.		License.		Manifest."		MessageExchange.		MessageExchange.		"MethodLiteralTransmissionMarker."		MimeConverter.		NetworkError.		NotImplemented.		Number.		Portal.		RemoteMessagingService.		RemoteMessagingServiceInstructions.		"SmalltalkDialect."		SourceFileArray.		Symbol.		TextConverter.		"UniformResourceIdentifier."		WeakKeyDictionary.		WebMessage}! !!Tether class methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 00:02'!fusedClasses	^{		AdditionalMethodState.		ArithmeticError.		Author.		Behavior.		BlockCannotReturn.		BlockClosure.		Boolean.		ByteString.		Character.		CharacterSet.		CharacterSetComplement.		Class.		ClassBinding.		ClassDescription.		CompiledMethod.		CompiledMethodTrailer.		"CounterpartRequest."		CurrentReadOnlySourceFiles.		Deprecation.		EditHistory.		EndOfStream.		Exception.		"ExceptionMarker."		ExceptionSet.		ExtendedNumberParser.		ExternalObjectTable.		False.		Heap.		IllegalResumeAttempt.		InvalidDirectoryError.		InvalidSocketStatusException.		InvalidUTF8.		JSObjectProxy.		KeyNotFound.		LimitedWriteStream.		"MemoryProfile."		Message.		Metaclass.		MethodDictionary.		"ModuleDescription.		ModuleID."		Monitor.		Mutex.		NetNameResolver.		NonBooleanReceiver.		NotFound.		ObjectFinalizerCollection.		Other.		OtherMarker.		OutOfMemory.		PositionableStream.		Preferences.		Process.		ProcessorScheduler.		Promise.		ProtoObject.		Random.		ReadStream.		ReadWriteStream.		RemoteMessageAnswer.		RemoteString.		RunArray.		Scanner.		SecureHashAlgorithm.		Semaphore.		SetElement.		SharedQueue.		SmalltalkImage.		Socket.		SocketAddress.		SocketAddressInformation.		SocketStream.		SortedCollection.		SystemChangeNotifier.		SystemDictionary.		SystemNavigation.		SystemVersion.		Tether.		Text.		ThirtyTwoBitRegister.		ThreadSafeRandom.		Time.		TimedOut.		TraitComposition.		True.		UnhandledError.		Unicode.		UUID.		UUIDGenerator.		UndefinedObject.		"Version."		WeakArray.		WeakFinalizationList.		WeakFinalizerItem.		WeakMessageSend.		WeakOrderedCollection.		WeakRegistry.		WebClient.		WebServer.		WebSocket07.		WebUtils.		WideString.		WrappedBreakpoint.		WriteStream}! !!Tether class methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 00:01'!fusedMethods	^{		{Object. #(			->			=			actAsExecutor			adaptToFloat:andCompare:			adaptToFloat:andSend:			adaptToFraction:andCompare:			adaptToFraction:andSend:			adaptToInteger:andCompare:			adaptToInteger:andSend:			adaptToScaledDecimal:andCompare:			addDependent:			asJSArgument			asJSObject			asOop			asString			at:			at:put:			basicAt:			basicAt:put:			basicSize			breakDependents			caseOf:			caseOf:otherwise:			changed			changed:			changed:with:			class			className			copy			copyFrom:			dependents			deprecated:			deprecated:block:			doesNotUnderstand:			enclosedSetElement			error			error:			errorImproperStore			errorNonIntegerIndex			errorNotIndexable			errorSubscriptBounds:			executor			exposureHash			finalizationRegistry			finalize			future			future:			futureDo:at:args:			futureSend:at:args:			halt			halt:			handles:			hasLiteralSuchThat:			hasMultipleExecutors			hash			instVarAt:			instVarAt:put:			instVarNamed:			instVarNamed:put:			isCharacter			isPseudoContext			isStream			isSymbol			mustBeBoolean			mustBeBooleanIn:			myDependents			myDependents:			otherVia:			perform:			perform:with:			perform:with:with:			perform:with:with:with:			perform:with:with:with:with:			perform:withArguments:			perform:withArguments:inSuperclass:			perform:withEnoughArguments:			pin			postCopy			primitiveChangeClassTo:			primitiveFailed			primitiveFailed:			printOn:			printString			printStringLimitedTo:			readFromString:			recyclingHash			removeDependent:			retryWithGC:until:			shallowCopy			shouldNotImplement			size			storeOnTether:			subclassResponsibility			tag			unpin			update:			update:with:			yourself			yourselfUnlessNil:			~=)}}! !!Tether class methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2016 19:46'!handleEventFrom: tether	tether performNextIncomingMessage! !!Tether class methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 03:20'!initialize	"Smalltalk addToStartUpList: self"! !!Tether class methodsFor: 'as yet unclassified' stamp: 'crl 10/11/2016 15:26'!nonEssentialProcessLabels	^#(		'the user interrupt watcher'		'the event tickler'		'the Sound Player'		'the CPUWatcher'		'the inactive MVC controller process'		'the inactive Morphic UI process'		'the UI process')! !!Tether class methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2016 17:32'!save	Smalltalk snapshot: true andQuit: false! !!Tether class methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 03:20'!startUp: resuming	resuming ifTrue: [		JS			ifConnected: [				WebServer reset.				"Establish localhost Tether service."				TetherEntranceToLocalhost := nil.				"self establishLocalTetherService"]			ifNotConnected: [				JSObjectProxy stop.				Exit start]]! !!Tether class methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 01:26'!through: portal	^self new portal: portal! !!Tether class methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 14:51'!to: url	| entrance tether |		entrance := Entrance to: url.	tether := self through: entrance.		entrance onMessage: [:message |		entrance incomingMessage: message.		tether handleEvent]..		tether waitForPeer.	^tether! !!MethodLiteralTransmissionMarker methodsFor: 'as yet unclassified' stamp: 'crl 8/3/2007 14:06'!attach	"Ensure that every object to which I refer is installed."	"By default, no action is necessary."! !!MethodLiteralTransmissionMarker methodsFor: 'as yet unclassified'!ensureBehaviorVia: remoteModule	"Ensure that remoteModule's system has the behavior to which I refer installed."	"By default, I don't refer to a behavior; do nothing."! !!MethodLiteralTransmissionMarker methodsFor: 'as yet unclassified'!literal	"Answer the method literal I represent."	^self subclassResponsibility! !!MethodLiteralTransmissionMarker methodsFor: 'as yet unclassified'!marks: literal 	^ self subclassResponsibility! !!MethodLiteralTransmissionMarker methodsFor: 'as yet unclassified' stamp: 'crl 5/29/2007 17:21'!mentionsBehavior	^false! !!MethodLiteralTransmissionMarker methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2016 15:16'!storeOnTether: tether	"Store a copy of myself on tether, suitable for re-animation in a remote system."	tether nextWordPut: self tag! !!MethodLiteralTransmissionMarker methodsFor: 'as yet unclassified'!tag	"Answer my transmission tag."	^self subclassResponsibility! !!MethodLiteralTransmissionMarker class methodsFor: 'as yet unclassified' stamp: 'crl 11/2/2008 15:13'!canRepresent: literal inMethod: aCompiledMethod of: aClass	^false! !!MethodLiteralTransmissionMarker class methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2012 03:11'!forLiteral: literal inMethod: aCompiledMethod ofClass: aClass	"Answer an instance of the appropriate subclass for representing literal when transferring aCompiledMethod from aClass."	^(		(self allSubclasses)			detect: [:subclass |				subclass					canRepresent: literal					inMethod: aCompiledMethod					of: aClass]			ifNone: [^self error: 'I can''t transmit that literal.']	)		forLiteral: literal		inMethod: aCompiledMethod		ofClass: aClass! !!MethodLiteralTransmissionMarker class methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 18:51'!fromTether: tether	"Answer an instance of myself composed from bytes supplied by aStream, and objects supplied by anObjectTransferCorrespondent."	^self subclassResponsibility! !!MIDIVelocity methodsFor: 'as yet unclassified' stamp: 'crl 1/24/2003 04:09'!appliedTo: anObject	"Answer anObject, after applying myself to it."	^anObject applyVelocity: self! !!VariableNode methodsFor: 'as yet unclassified' stamp: 'crl 5/4/2017 22:26'!printJavaScriptOn: stream indent: level 	stream nextPutAll: name! !!MethodIDPattern methodsFor: 'as yet unclassified' stamp: 'crl 7/15/2011 21:28'!classAuthorID	self maskFromByte: 35 to: 50! !!MethodIDPattern methodsFor: 'as yet unclassified' stamp: 'crl 7/15/2011 21:28'!methodVersion	self maskFromByte: 51 to: 52! !!MethodIDPattern methodsFor: 'as yet unclassified' stamp: 'crl 7/15/2011 21:28'!selector	self maskFromByte: 53 to: reference size! !!MethodIDPattern class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!ExternalResource methodsFor: 'as yet unclassified' stamp: 'crl 11/30/2000 18:59'!bufferSize	"Answer the size a stream should use for a reading or reading/writing buffer."	"There may be a meaningful default; I don't have a basis for one yet."	^self subclassResponsibility! !!ExternalResource methodsFor: 'as yet unclassified' stamp: 'crl 5/29/2011 20:16'!close	handle ifNotNil: [		self close: handle.		self disconnect]! !!ExternalResource methodsFor: 'as yet unclassified' stamp: 'crl 6/13/2001 17:44'!close: theHandle	"Close the external resource corresponding to theHandle."	self subclassResponsibility! !!ExternalResource methodsFor: 'as yet unclassified' stamp: 'crl 12/19/2000 21:58'!commit	"Ensure all pending information has been sent to the external resource I represent."	"By default, no explicit action is required from object memory to accomplish this."! !!ExternalResource methodsFor: 'as yet unclassified' stamp: 'crl 5/30/2011 02:20'!disconnect	"Disassociate myself with my handle."	handle _ nil! !!ExternalResource methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 20:06'!enable	handle := LargePositiveInteger new: 4.	self		newResourceHandleInto: handle;		enable: handle;		initialize! !!ExternalResource methodsFor: 'as yet unclassified' stamp: 'crl 6/11/2001 14:56'!enable: externalResourceHandle	"Enable the ExternalResource corresponding to externalResourceHandle."	"In this message I am concerned with creating the external resource I represent, rather than establishing a connection with a peer (that comes later)."	self subclassResponsibility! !!ExternalResource methodsFor: 'as yet unclassified' stamp: 'crl 7/4/2005 15:02'!handle	^handle! !!ExternalResource methodsFor: 'as yet unclassified'!initialize	"Initialize myself."	"By default, do nothing. Instances of some subclasses do need initialization."! !!ExternalResource methodsFor: 'as yet unclassified' stamp: 'crl 11/3/1999 03:25'!isActive	"Answer whether I'm active. In general, active means both myself and my peer(s) consider there to be a connection."	^self isOpen! !!ExternalResource methodsFor: 'as yet unclassified' stamp: 'crl 2/21/2006 11:36'!isOpen	^handle ~~ nil! !!ExternalResource methodsFor: 'as yet unclassified' stamp: 'crl 1/15/2003 14:13'!newResourceHandleInto: theHandle	"Write a new resource handle into theHandle."	self subclassResponsibility! !!ExternalResource methodsFor: 'as yet unclassified' stamp: 'crl 8/20/2017 13:16'!open	"Ensure that I am open. Answer whether I was closed before."	^self isOpen not yourselfIfTrueDoFirst: [self enable]! !!ExternalResource methodsFor: 'as yet unclassified'!printOn: aStream	"Print a character-based description of myself on aStream."	aStream nextPutAll: 'an '.	self isActive ifFalse: [aStream nextPutAll: 'in'].	aStream nextPutAll: 'active '; print: self class! !!ExternalResource methodsFor: 'as yet unclassified' stamp: 'crl 4/9/2001 21:55'!scribes	"Answer whether I consume or produce data."	^true! !!ExternalResource class methodsFor: 'as yet unclassified' stamp: 'crl 3/23/2003 17:02'!initialize	"Initialize myself."	"self initialize"	Smalltalk addToStartUpList: self.	ConditionNames _ (		(IdentityDictionary new)			at: 1 put: #directoryFull;			at: 2 put: #diskFull;			at: 3 put: #noSuchVolume;			at: 4 put: #ioError;			at: 5 put: #badNameWhenMovingFile;			at: 6 put: #fileNotOpen;			at: 7 put: #endOfFile;			at: 8 put: #positionBeforeStartOfFile;			at: 9 put: #memoryFull;			at: 10 put: #tooManyFilesOpen;			at: 11 put: #fileNotFound;			at: 12 put: #writeProtected;			at: 13 put: #fileLocked;			at: 14 put: #volumeLocked;			at: 15 put: #fileBusyDirEmptyWorkingDirectoryOpen;			at: 16 put: #alreadyExists;			at: 17 put: #alreadyOpenForWriting;			at: 18 put: #noDefaultVolumeParameterErrorEtc;			at: 19 put: #badFileHandle;			at: 20 put: #getFilePosition;			at: 21 put: #permissionsError;			at: 22 put: #externalFileSystem;			at: 23 put: #rename;			at: 24 put: #badMasterDirectoryBlock;			at: 25 put: #writePermissions;			at: 26 put: #directoryNotFoundOrBadPath;			at: 27 put: #cannotMoveIntoOffspring;			at: 28 put: #serverVolumeDisconnected;			at: 29 put: #noForegroundProcess;			at: 30 put: #notDirectory;			at: 31 put: #serverFilenameMismatch;			at: 32 put: #notFile;			at: 33 put: #dateTimeFormat;			at: 34 put: #makeDirectoryError;			at: 35 put: #badArgument;			at: 36 put: #badArgument;			at: 37 put: #badCommand;			at: 38 put: #illegalCharacters;			at: 39 put: #badInstVarClass;			at: 40 put: #readBufferOverrun;			at: 41 put: #nullExternalPathSegmentsNotSupported;			at: 42 put: #fileCrossVolumeMoveError;			at: 43 put: #accessDenied;			at: 44 put: #denyConflict;			yourself).	self compileAll! !!ExternalResource class methodsFor: 'as yet unclassified' stamp: 'il prior: 35035400!!!!!!!!!!!!!!!!'!new	"Answer a new initialized instance of myself."	^super new enable! !!ExternalResource class methodsFor: 'as yet unclassified' stamp: 'crl 10/1/2006 16:16'!resume	"Resume after a system restart."	self allSubInstances do: [:resource | resource disconnect]! !!ExternalResource class methodsFor: 'as yet unclassified' stamp: 'crl 7/19/2005 21:11'!startUp: resuming	"Resume after a system restart."	resuming ifTrue: [self allSubInstances do: [:resource | resource disconnect]]! !!TraitOrganizer class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!PluggablePanelMorph class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!TranscriptStream methodsFor: 'as yet unclassified' stamp: 'crl 4/4/2003 00:23'!previousTake: anInteger	"Take back the last anInteger written elements, and answer them (in the order in which they were written)."	"Note this implementation is only correct for internal, positionable streams."	| elements |	readLimit _ position.	position _ position - anInteger.	elements _ collection copyFrom: position + 1 to: readLimit.	readLimit _ position.	^elements! !!DAVMethod methodsFor: 'as yet unclassified' stamp: 'crl 1/5/2015 03:28'!selector: aSymbol class: aClassDAVResource	selector _ aSymbol.	class _ aClassDAVResource.	source _ (		self addFile: (			DAVFile				named: 'source'				withContents: [((class superclassImplementing: selector) sourceCodeAt: selector) asString])).	history _ (		self addFile: (			DAVFile				named: 'history'				withContents: ['']))! !!DAVMethod class methodsFor: 'as yet unclassified' stamp: 'crl 1/4/2015 01:55'!canRepresentAnInstanceOf: aClass	^aClass == CompiledMethod! !!DAVMethod class methodsFor: 'as yet unclassified' stamp: 'crl 1/2/2015 17:30'!forMethodAt: selector in: aClassDAVResource	^(self new) selector: selector class: aClassDAVResource! !!HTMLQuoteElement methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!HTMLQuoteElement class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!LivecodingTalk methodsFor: 'as yet unclassified' stamp: 'crl 9/10/2017 13:33'!createWorldOfKind: worldKind withCanvas: canvas	super createWorldOfKind: worldKind withCanvas: canvas.		(canvas window)		styleAt: #position put: 'absolute';		styleAt: #top put: '100px';		styleAt: #left put: '100px'.			^canvas! !!LivecodingTalk methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2019 13:19'!initialize	super initialize.	JQuery load.	(self elementAt: 'text-editor')		styleAt: #transition put: 'transform 500ms';		styleAt: #transform put: 'translate(-50%, -50%) translate3d(1000px, 6200px, 1000px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scale(4)'.			[		| workspace |				(Delay forMilliseconds: 500) wait.		workspace := HTML5PasteUpMorph newWorldInCanvasWithID: 'title-workspace-canvas'.		Workspace openInWorld: workspace.		workspace beOpaque; beDraggable	]		fork! !!LivecodingTalk methodsFor: 'as yet unclassified' stamp: 'crl 9/10/2017 17:32'!parentOfNewWorldWithCanvas: canvas	| parentOfNewWorld |		parentOfNewWorld := canvas parentNode.	parentOfNewWorld class == HTMLDivElement ifFalse: [		parentOfNewWorld := (			(ActiveWorld isKindOf: HTML5PasteUpMorph)				ifTrue: [ActiveWorld canvas canvas window]				ifFalse: [Webpage containingCanvas]) parentNode.		canvas beVisible; beOpaque.		^parentOfNewWorld].	parentOfNewWorld parentNode children do: [:child | child styleAt: #pointerEvents put: 'none'].	parentOfNewWorld		styleAt: #pointerEvents put: 'all';		styleAt: #zIndex put: 10.					^parentOfNewWorld! !!LivecodingTalk methodsFor: 'as yet unclassified' stamp: 'crl 10/22/2017 17:24'!setHardwareCursorFor: cursor	(ActiveWorld isKindOf: HTML5PasteUpMorph) ifFalse: [		[			| slide |				slide := self elementAt: #caffeine.				(cursor == Cursor normal)				ifTrue: [slide styleAt: #cursor put: '']				ifFalse: [					slide styleAt: #cursor put: 'none'.					cursorCanvas beVisible]		]			ifError: []]! !!LivecodingTalk class methodsFor: 'as yet unclassified' stamp: 'crl 7/27/2017 16:31'!appID	^'9e5a5337-6b13-4e75-8936-d4e62a5500e8'! !!LivecodingTalk class methodsFor: 'as yet unclassified' stamp: 'crl 7/27/2017 16:31'!appName	^'Livecoding Talk'! !!ChromeDebuggingMessage methodsFor: 'as yet unclassified' stamp: 'crl 7/30/2016 23:27'!id	^id! !!ChromeDebuggingMessage methodsFor: 'as yet unclassified' stamp: 'crl 7/30/2016 00:43'!invokes	^self subclassResponsibility! !!ChromeDebuggingMessage class methodsFor: 'as yet unclassified' stamp: 'crl 8/1/2016 10:28'!fromDictionary: dictionary for: tab	^(		(dictionary includesKey: 'method')			ifTrue: [ChromeMethodInvocation]			ifFalse: [ChromeResult]	)		fromDictionary: dictionary for: tab! !!NonBooleanReceiver class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!PluggableListMorphOfMany methodsFor: 'as yet unclassified' stamp: 'bf 4/13/2012 16:27'!itemSelectedAmongMultiple: index	^self listSelectionAt: (self modelIndexFor: index)! !!PluggableListMorphOfMany methodsFor: 'as yet unclassified' stamp: 'ar 3/17/2001 17:07'!list: listOfStrings	scroller removeAllMorphs.	list := listOfStrings ifNil: [Array new].	list isEmpty ifTrue: [^ self selectedMorph: nil].	super list: listOfStrings.	"At this point first morph is sensitized, and all morphs share same handler."	scroller firstSubmorph on: #mouseEnterDragging						send: #mouseEnterDragging:onItem:						to: self.	scroller firstSubmorph on: #mouseUp						send: #mouseUp:onItem:						to: self.	"This should add this behavior to the shared event handler thus affecting all items"! !!PluggableListMorphOfMany methodsFor: 'as yet unclassified' stamp: 'tpr 10/4/2001 21:26'!listSelectionAt: index	getSelectionListSelector ifNil:[^false].	^model perform: getSelectionListSelector with: index! !!PluggableListMorphOfMany methodsFor: 'as yet unclassified' stamp: 'tpr 10/4/2001 21:27'!listSelectionAt: index put: value	setSelectionListSelector ifNil:[^false].	^model perform: setSelectionListSelector with: index with: value! !!PluggableListMorphOfMany methodsFor: 'as yet unclassified' stamp: 'bf 4/13/2012 16:23'!mouseDown: event	| oldIndex oldVal row index |	event yellowButtonPressed ifTrue: [^ self yellowButtonActivity: event shiftPressed].	row := self rowAtLocation: event position.	row = 0 ifTrue: [^super mouseDown: event].	index := self modelIndexFor: row.	model okToChange ifFalse: [^ self].  "No change if model is locked"	"Set meaning for subsequent dragging of selection"	dragOnOrOff := (self listSelectionAt: index) not.	oldIndex := self getCurrentSelectionIndex.	oldIndex ~= 0 ifTrue: [oldVal := self listSelectionAt: oldIndex].	"Set or clear new primary selection (listIndex)"	dragOnOrOff		ifTrue: [self changeModelSelection: index]		ifFalse: [self changeModelSelection: 0].	"Need to restore the old one, due to how model works, and set new one."	oldIndex ~= 0 ifTrue: [self listSelectionAt: oldIndex put: oldVal].	self listSelectionAt: index put: dragOnOrOff.	"event hand releaseMouseFocus: aMorph."! !!PluggableListMorphOfMany methodsFor: 'as yet unclassified' stamp: 'bf 4/13/2012 16:22'!mouseMove: event 	"The mouse has moved, as characterized by the event provided.  Adjust the scrollbar, and alter the selection as appropriate"	| oldIndex oldVal row index |	event position y < self top 		ifTrue: 			[scrollBar scrollUp: 1.			row := self rowAtLocation: scroller topLeft + (1 @ 1)]		ifFalse: 			[row := event position y > self bottom 				ifTrue: 					[scrollBar scrollDown: 1.					self rowAtLocation: scroller bottomLeft + (1 @ -1)]				ifFalse: [ self rowAtLocation: event position]].	row = 0 ifTrue: [^super mouseDown: event].	index := self modelIndexFor: row.	model okToChange ifFalse: [^self].	"No change if model is locked"	dragOnOrOff ifNil: 			["Was not set at mouse down, which means the mouse must have gone down in an area where there was no list item"			dragOnOrOff := (self listSelectionAt: index) not].	"Set meaning for subsequent dragging of selection"	oldIndex := self getCurrentSelectionIndex.	oldIndex ~= 0 ifTrue: [oldVal := self listSelectionAt: oldIndex].	"Set or clear new primary selection (listIndex)"	dragOnOrOff 		ifTrue: [self changeModelSelection: index]		ifFalse: [self changeModelSelection: 0].	"Need to restore the old one, due to how model works, and set new one."	oldIndex ~= 0 ifTrue: [self listSelectionAt: oldIndex put: oldVal].	self listSelectionAt: index put: dragOnOrOff.! !!PluggableListMorphOfMany methodsFor: 'as yet unclassified' stamp: 'mt 4/9/2015 13:44'!mouseUp: event	dragOnOrOff := nil.  "So improperly started drags will have not effect"	event hand newKeyboardFocus: self. 	hasFocus := true.! !!PluggableListMorphOfMany methodsFor: 'as yet unclassified' stamp: 'tpr 10/4/2001 21:24'!on: anObject list: listSel primarySelection: getSelectionSel changePrimarySelection: setSelectionSel listSelection: getListSel changeListSelection: setListSel menu: getMenuSel keystroke: keyActionSel	"setup a whole load of pluggability options"	getSelectionListSelector := getListSel.	setSelectionListSelector := setListSel.	super on: anObject list: listSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel! !!PluggableListMorphOfMany methodsFor: 'as yet unclassified' stamp: 'di 11/10/1998 14:44'!update: aSymbol 	aSymbol == #allSelections ifTrue:		[self selectionIndex: self getCurrentSelectionIndex.		^ self changed].	^ super update: aSymbol! !!PluggableListMorphOfMany class methodsFor: 'as yet unclassified' stamp: 'tpr 10/4/2001 21:54'!on: anObject list: listSel primarySelection: getSelectionSel changePrimarySelection: setSelectionSel listSelection: getListSel changeListSelection: setListSel menu: getMenuSel	^ self new		on: anObject		list: listSel		primarySelection: getSelectionSel		changePrimarySelection: setSelectionSel		listSelection: getListSel		changeListSelection: setListSel		menu: getMenuSel		keystroke: #arrowKey:from:		"default"! !!PluggableListMorphOfMany class methodsFor: 'as yet unclassified' stamp: 'tpr 10/4/2001 21:52'!on: anObject list: listSel primarySelection: getSelectionSel changePrimarySelection: setSelectionSel listSelection: getListSel changeListSelection: setListSel menu: getMenuSel keystroke: keyActionSel 	^ self new		on: anObject		list: listSel		primarySelection: getSelectionSel		changePrimarySelection: setSelectionSel		listSelection: getListSel		changeListSelection: setListSel		menu: getMenuSel		keystroke: keyActionSel! !!PasteUpMorph methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 22:31'!defaultDesktopCommandKeyTriplets	"Answer a list of triplets of the form		<key> <receiver> <selector>   [+ optional fourth element, a <description> for use in desktop-command-key-help]that will provide the default desktop command key handlers.  If the selector takes an argument, that argument will be the command-key event"	| noviceKeys expertKeys |	noviceKeys := {		{ $o.	ActiveWorld.						#activateObjectsTool.						'Activate the "Objects Tool"'}.		{ $r.	ActiveWorld.						#restoreMorphicDisplay.					'Redraw the screen'}.				{ $z.	self.								#undoOrRedoCommand.					'Undo or redo the last undoable command'}.		{ $F.	Project current.					#toggleFlapsSuppressed.					'Toggle the display of flaps'}.		{ $N.	self.								#toggleClassicNavigatorIfAppropriate.	'Show/Hide the classic Navigator, if appropriate'}.		{ $M.	self.								#toggleShowWorldMainDockingBar.		'Show/Hide the Main Docking Bar'}.		{ $].	Smalltalk.							#saveSession.								'Save the image.'}.	}.	Preferences noviceMode			ifTrue:[^ noviceKeys].	expertKeys := {		{ $b.	SystemBrowser.					#defaultOpenBrowser.						'Open a new System Browser'}.		{ $k.	StringHolder.					#open.										'Open a new, blank Workspace'}.		{ $m.	self.								#putUpNewMorphMenu.					'Put up the "New Morph" menu'}.		{ $t.	self.	 							#findATranscript:.							'Make a System Transcript visible'}.		{ $w.	SystemWindow.					#closeTopWindow.							'Close the topmost window'}.		{ $C.	self.								#findAChangeSorter:.						'Make a Change Sorter visible'}.		{ $L.	self.								#findAFileList:.								'Make a File List visible'}.		{ $P.	self.								#findAPreferencesPanel:.					'Activate the Preferences tool'}.		{ $R.	Utilities. 								#browseRecentSubmissions.		'Make a Recent Submissions browser visible'}.		{ $W.	self. 								#findAMessageNamesWindow:.			'Make a MessageNames tool visible'}.		{ $Z.	ChangeList. 						#browseRecentLog.							'Browse recently-logged changes'}.		{ $\.	SystemWindow. 					#sendTopWindowToBack.					'Send the top window to the back'}.		{ $_.	Smalltalk.							#quitPrimitive.								'Quit the image immediately.'}.	}.	^ noviceKeys, expertKeys! !!PasteUpMorph methodsFor: 'as yet unclassified' stamp: 'crl 6/20/2017 13:33'!displayForm: form at: origin	form copyInto: Display at: origin! !!PasteUpMorph methodsFor: 'as yet unclassified' stamp: 'crl 6/21/2017 12:55'!drawRubberBand: rectangle for: snowglobeMorph	Display		border: rectangle		width: 2		rule: Form reverse		fillColor: Color gray! !!PasteUpMorph methodsFor: 'as yet unclassified' stamp: 'crl 4/15/2018 21:17'!halt	ActiveWorld := self.	3 halt! !!PasteUpMorph methodsFor: 'as yet unclassified' stamp: 'crl 4/17/2018 00:35'!halt: message	ActiveWorld := self.	3 halt: message! !!PasteUpMorph methodsFor: 'as yet unclassified' stamp: 'crl 6/13/2017 19:00'!openWorkspace	Workspace openInWorld: self! !!PasteUpMorph methodsFor: 'as yet unclassified' stamp: 'dgd 4/3/2006 14:36'!restoreMorphicDisplay	DisplayScreen startUp.	ThumbnailMorph recursionReset.	self		extent: Display extent;		viewBox: Display boundingBox;		handsDo: [:h | h visible: true; showTemporaryCursor: nil];		restoreFlapsDisplay;		restoreMainDockingBarDisplay;		fullRepaintNeeded.			WorldState		addDeferredUIMessage: [Cursor normal show].! !!PasteUpMorph methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 21:01'!saveOnFile	"Ask the user for a filename and save myself on a SmartReferenceStream file.  Writes out the version and class structure.  The file is fileIn-able.  UniClasses will be filed out."	| aFileName fileStream ok |	self flag: #bob0302.	aFileName := ('my {1}' translated format: {self class name}) asFileName.	"do better?"	aFileName := UIManager default request: 'File name? (".project" will be added to end)' translated 			initialAnswer: aFileName.	aFileName isEmpty ifTrue: [^ Beeper beep].	self allMorphsDo: [:m | m prepareToBeSaved].	ok := aFileName endsWith: '.project'.	"don't double them"	ok := ok | (aFileName endsWith: '.sp').	ok ifFalse: [aFileName := aFileName,'.project'].	fileStream := FileStream newFileNamed: aFileName asFileName.	fileStream fileOutClass: nil andObject: self.	"Puts UniClass definitions out anyway"! !!PasteUpMorph methodsFor: 'as yet unclassified' stamp: 'crl 6/21/2017 01:14'!stopRubberBanding! !!IllegalURIException class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/14/2017 11:36'!drawString: s from: firstIndex to: lastIndex at: pt font: font color: aColor	self drawString: s from: firstIndex to: lastIndex in: (pt extent: Display extent) font: font color: aColor! !!Canvas methodsFor: 'as yet unclassified' stamp: 'crl 5/14/2017 21:53'!fontHeightIn: morph	^morph font height! !!UpdatingSimpleButtonMorph class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!HTMLCollection methodsFor: 'as yet unclassified' stamp: 'crl 8/2/2017 00:21'!asArray	| array |		array := OrderedCollection new.		self do: [:element | array add: element].	^array asArray! !!HTMLCollection methodsFor: 'as yet unclassified' stamp: 'crl 8/1/2017 20:54'!at: key	^(proxy at: key) counterpart! !!HTMLCollection methodsFor: 'as yet unclassified' stamp: 'crl 8/2/2017 11:00'!collect: block	^self asArray collect: block! !!HTMLCollection methodsFor: 'as yet unclassified' stamp: 'crl 3/28/2019 17:24'!detect: aBlock ifNone: exceptionBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Answer the first element for which aBlock evaluates to true. If none  	evaluate to true, then evaluate the argument, exceptionBlock."	^self asArray detect: aBlock ifNone: exceptionBlock! !!HTMLCollection methodsFor: 'as yet unclassified' stamp: 'crl 6/17/2017 22:48'!do: block	0		to: self length - 1		do: [:index | block value: (self at: index) counterpart]! !!HTMLCollection methodsFor: 'as yet unclassified' stamp: 'crl 8/1/2017 20:54'!first	^self at: '0'! !!HTMLCollection methodsFor: 'as yet unclassified' stamp: 'crl 3/30/2019 18:47'!onlyOne	^self asArray onlyOne! !!HTMLCollection class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSBlob methodsFor: 'as yet unclassified' stamp: 'crl 7/20/2018 13:02'!asByteArray	| byteArray bytesSet reader |		byteArray := ByteArray new: (proxy at: #size).	reader := JS FileReader newWithParameters: #().	bytesSet := Semaphore new.		reader		addEventListener: 'loadend'		with: [			byteArray setBytesFrom: reader result proxy.			bytesSet signal].		reader readAsArrayBuffer: proxy.	bytesSet wait.	^byteArray! !!JSBlob class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!NetNameResolver methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!HardwarePort methodsFor: 'as yet unclassified' stamp: 'crl 6/14/2001 13:51'!enable: hardwarePortHandle	"Enable the HardwareResource corresponding to hardwarePortHandle."	self enable: hardwarePortHandle at: port! !!HardwarePort methodsFor: 'as yet unclassified' stamp: 'crl 6/14/2001 13:52'!enable: hardwarePortHandle at: anInteger	"Enable the HardwareResource corresponding to hardwarePortHandle, at port anInteger."	self subclassResponsibility! !!HardwarePort methodsFor: 'as yet unclassified' stamp: 'crl 8/13/2002 22:22'!port	"Answer my port number."	^port! !!HardwarePort methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 20:05'!port: anInteger	"Set my port to anInteger."	port := anInteger.	self initialize! !!HardwarePort methodsFor: 'as yet unclassified' stamp: 'crl 5/4/2008 14:31'!signature: anObject	"Set my signature to anObject."	signature _ anObject.	self initialize! !!HardwarePort class methodsFor: 'as yet unclassified' stamp: 'crl 2/21/2006 12:04'!at: portNumber	"Answer an instance of myself which uses the hardware port indicated by portNumber."	"By default, the sender must enable the instance separately."	^self basicNew port: portNumber! !!AFrameLivecodingDemo methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2019 13:18'!addMorph: morph atIndex: index	"Use the main development environment world."		^(super addMorph: morph atIndex: index)		beDraggable;		opacity: 0.8;		yourself! !!AFrameLivecodingDemo methodsFor: 'as yet unclassified' stamp: 'crl 10/22/2017 16:32'!parentOfNewWorldWithCanvas: canvas	^(Webpage top)		ifNil: [			| parentOfNewWorld |						parentOfNewWorld := canvas parentNode.			parentOfNewWorld ifNil: [parentOfNewWorld := self document body].			parentOfNewWorld parentNode children do: [:child |				child					at: #tabIndex put: -1;					styleAt: #pointerEvents put: 'none'].			parentOfNewWorld				styleAt: #pointerEvents put: 'all';				styleAt: #zIndex put: 10.			parentOfNewWorld]		ifNotNil: [self elementAt: #scene]! !!AFrameLivecodingDemo methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2019 13:19'!populateTitleSlideWorkspace	| workspace |		workspace := HTML5PasteUpMorph newWorldInCanvasWithID: 'title-workspace-canvas'.	Workspace openInWorld: workspace.	workspace beOpaque; beDraggable.	(workspace canvas canvas) beVisible; beOpaque! !!AFrameLivecodingDemo methodsFor: 'as yet unclassified' stamp: 'crl 8/12/2017 16:10'!setCameraResetButton	(self topDocument getElementById: 'headup')		at: #onclick		put: [			(self elementAt: #camera)				appendChild: (					(self topDocument createElement: 'a-animation')						setAttribute: #attribute with: 'position';						setAttribute: #to with: '0 5 -2.5';						setAttribute: #delay with: '500';						at: #id put: 'camera-position';						yourself);				appendChild: (					(self topDocument createElement: 'a-animation')						setAttribute: #attribute with: 'rotation';						setAttribute: #to with: '0 0 0';						setAttribute: #delay with: '400';						at: #id put: 'camera-rotation';						yourself).									(Delay forSeconds: 1) wait.						#('camera-position' 'camera-rotation') do: [:name | (self elementAt: name) remove]]! !!AFrameLivecodingDemo methodsFor: 'as yet unclassified' stamp: 'crl 8/18/2017 16:41'!styleNewWindow: window	super styleNewWindow: window.	window opacity: 0.8! !!AFrameLivecodingDemo class methodsFor: 'as yet unclassified' stamp: 'crl 8/11/2017 17:51'!appID	^'d93ea2a2-bf59-4f59-bb21-c36c596c4488'! !!ChangeList methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2019 16:13'!initialExtent	^ 832@528! !!LargeNegativeInteger methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 19:47'!storeOnTether: tether
	tether
		nextWordPut: LargeNegativeIntegerTag;
		store: self negated! !!LargeNegativeInteger class methodsFor: 'as yet unclassified' stamp: 'crl 3/19/2019 12:46'!fromTether: tether	^tether next negated! !!PluggableCodePaneSpec class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!ClassCommentReader class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!HTMLInputElement methodsFor: 'as yet unclassified' stamp: 'crl 7/12/2017 13:25'!value	^(proxy at: #value) counterpart simplestRepresentation! !!HTMLInputElement class methodsFor: 'as yet unclassified' stamp: 'crl 4/17/2017 01:34'!exemplar	^(JS Function new: 'return window.document.createElement(''input'')') call! !!VariableScopeFinder class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!JSTe methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!JSTe class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!UndeclaredVariableReference class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!ShadowDrawingCanvas class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:55'!foo! !!XMLException methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!XMLException class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!WeakSet class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!WebMIDIOutput methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!WebMIDIOutput class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!Oscillator methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 14:46'!frequency: frequency sync: sync offset: offset	| oscillator |		oscillator := JS top at: #osc.		proxy := (		frequency			ifNil: [oscillator call]			ifNotNil: [				sync					ifNil: [oscillator call: nil with: frequency]					ifNotNil: [						offset							ifNil: [								oscillator									call: nil									with: frequency									with: sync]							ifNotNil: [								oscillator									call: nil									with: frequency									with: sync									with: offset]]])! !!Oscillator class methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 14:43'!frequency: frequency sync: sync offset: offset	^(super new)		frequency: frequency		sync: sync		offset: offset! !!Oscillator class methodsFor: 'as yet unclassified' stamp: 'crl 9/15/2019 14:42'!new	^self		frequency: nil		sync: nil		offset: nil! !!HTMLStyleElement methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!HTMLStyleElement class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!CRCError class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!LiteralVariableNode class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!AbsoluteTimepoint methodsFor: 'as yet unclassified' stamp: 'crl 3/6/2006 00:39'!appliedTo: anObject	"Answer anObject after applying myself to it."	^anObject applyAbsoluteTimepoint: self! !!AbsoluteTimepoint methodsFor: 'as yet unclassified' stamp: 'crl 3/6/2006 00:17'!millisecondsUntil: anAbsoluteTimepoint	^(anAbsoluteTimepoint totalSubframes - self totalSubframes) // 3! !!AbsoluteTimepoint methodsFor: 'as yet unclassified' stamp: 'crl 3/6/2006 20:50'!printOn: aStream	| hasFractionalSeconds |	hasFractionalSeconds _ ((frames > 0) or: [subframes > 0]).	(seconds > 0)		ifTrue: [self printIntervalOn: aStream]		ifFalse: [hasFractionalSeconds ifFalse: [^aStream nextPutAll: 'at the beginning']].	hasFractionalSeconds ifTrue: [		| milliseconds |		milliseconds _ ((frames / 30) + (subframes / 3000)) * 1000.		(seconds > 0) ifTrue: [aStream nextPutAll: ', '].		aStream print: milliseconds truncated.		milliseconds isFraction ifTrue: [			aStream				nextPutAll: ' and ';				print: ((milliseconds numerator) \\ (milliseconds denominator));				nextPut: $/;				print: milliseconds denominator].			aStream nextPutAll: ' milliseconds in ('.		self printWithSMPTETermsOn: aStream].	aStream nextPutAll: ' in'.	hasFractionalSeconds ifTrue: [aStream nextPut: $)]! !!WebEntrance methodsFor: 'as yet unclassified' stamp: 'crl 4/24/2019 15:18'!close	worker ifNotNil: [		3 halt.		worker terminate.		worker := nil.		super close]! !!WebEntrance methodsFor: 'as yet unclassified' stamp: 'crl 4/2/2019 12:51'!connectTo: url	"Post a message to the worker JS thread, requesting a websocket connection to url."		websocket := JS WebSocket newWithParameters: {url}! !!WebEntrance methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 01:12'!send	websocket send: self outgoingPayload! !!WebEntrance methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 00:24'!service: remoteMessagingService	super service: remoteMessagingService.		worker := remoteMessagingService worker! !!WebEntrance methodsFor: 'as yet unclassified' stamp: 'crl 1/22/2019 11:25'!worker	^worker! !!WebEntrance class methodsFor: 'as yet unclassified' stamp: 'crl 4/2/2019 12:47'!initialize	Smalltalk addToStartUpList: self after: HostPlatform! !!WebEntrance class methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 21:32'!startUp: resuming	resuming ifTrue: [		self allSubInstancesDo: [:entrance | entrance websocket: nil]]! !!IllegalResumeAttempt class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!WebMIDI methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!WebMIDI class methodsFor: 'as yet unclassified' stamp: 'crl 8/2/2017 20:34'!enable	self enable: [		Transcript			cr;			nextPutAll: 'WebMIDI enabled: ';			print: WebMIDI enabled;			endEntry]! !!WebMIDI class methodsFor: 'as yet unclassified' stamp: 'crl 8/2/2017 19:44'!initialize	Smalltalk addToStartUpList: self! !!WebMIDI class methodsFor: 'as yet unclassified' stamp: 'crl 8/2/2017 22:29'!loadInto: webpage	webpage		loadScriptFrom: 'js/webmidi.min.js'		then: [.			globalObject := (webpage top proxy at: #module) exports counterpart.			self enable]! !!WebMIDI class methodsFor: 'as yet unclassified' stamp: 'crl 8/9/2017 17:47'!startUp: resuming	"resuming ifTrue: [		globalObject := nil.		JS ifConnected: [self loadInto: Webpage current]]"! !!WebMIDI class methodsFor: 'as yet unclassified' stamp: 'crl 8/2/2017 22:35'!symbolFodder	"Selectors commonly used for sending messages to JavaScript proxies, but which need no corresponding Smalltalk methods. Listed here to keep the system from complaining that they don't exist when evaluating workspace expressions."		#(outputs playNote:with:with:)! !!SystemBrowser methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!HTMLButtonElement methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!HTMLButtonElement class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!CounterpartRequest methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!CounterpartRequest class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!ZipFileConstants methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!AutoStart methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!ReverbSound class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!WebResponse methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 10:39'!code	"The HTTP response code"	^code! !!WebResponse methodsFor: 'as yet unclassified' stamp: 'ar 6/18/2010 23:51'!content	"Reimplemented to close the socket if the request is transient"	content ifNil:[		content := self getContent.		self closeIfTransient.	].	^content! !!WebResponse methodsFor: 'as yet unclassified' stamp: 'ar 1/31/2012 14:02'!contentStream	"Answers a stream for the conent."	(self headerAt: 'transfer-encoding') = 'chunked' ifTrue:[		^WebChunkedStream on: stream.	].	^super contentStream! !!WebResponse methodsFor: 'as yet unclassified' stamp: 'topa 4/3/2013 17:32'!getContent	"Do not read any content if this was a HEAD request or code is 204 (no content)"	(request method = 'HEAD' or: [code = 204]) ifTrue:[^''].	^super getContent! !!WebResponse methodsFor: 'as yet unclassified' stamp: 'ar 7/9/2010 00:27'!isInformational	"Is this a 1xx response?"	^self code between: 100 and: 199! !!WebResponse methodsFor: 'as yet unclassified' stamp: 'ar 8/10/2010 08:56'!isRedirect	"Is this a redirect response?"	^self code between: 300 and: 399! !!WebResponse methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 10:13'!isSuccess	"Is this a successful response?"	^self code between: 200 and: 299! !!WebResponse methodsFor: 'as yet unclassified' stamp: 'SvenVanCaekenberghe 6/14/2010 15:48'!protocol: respProtocol code: respCode	"Initialize a response from protocol and code"	code := respCode.	protocol := respProtocol.	status := protocol, ' ', code asString, ' ', (self class statusCodeAt: code).	headers := OrderedCollection new.! !!WebResponse methodsFor: 'as yet unclassified' stamp: 'ar 2/22/2010 02:40'!readFrom: aStream	"Parse an HTTP response from the given stream"	| tokens |	stream := aStream.	status := stream upToAll: String crlf.	tokens := status findTokens: ' '.	tokens size < 2 ifTrue:[^self error:'Invalid response: ', status].	protocol := tokens first.	code := tokens second asNumber.	headers := WebUtils readHeadersFrom: stream.! !!WebResponse methodsFor: 'as yet unclassified' stamp: 'ar 4/1/2010 16:02'!request	"The original request for this response"	^request! !!WebResponse methodsFor: 'as yet unclassified' stamp: 'ar 4/1/2010 16:03'!request: aRequest	"The original request for this response"	request := aRequest! !!WebResponse methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 19:35'!setCookie: aCookie	"Adds a Set-Cookie header"	^self addHeader: 'Set-Cookie' value: aCookie asString! !!WebResponse methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 19:35'!setCookie: name value: value path: path 	"Adds a Set-Cookie header"	^self setCookie: ((WebCookie new)			name: name;			value: value;			path: path;		yourself)! !!WebResponse methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 19:35'!setCookie: name value: value path: path expires: date domain: domain secure: aBool	"Adds a Set-Cookie header"	^self setCookie: ((WebCookie new)			name: name;			value: value;			path: path;			expiry: date;			domain: domain;			secure: aBool;		yourself)! !!WebResponse methodsFor: 'as yet unclassified' stamp: 'ar 2/25/2010 18:16'!setCookieAt: key	"Evaluate aBlock with all the cookies deined in the request"	self setCookiesDo:[:cookie|		cookie name = key ifTrue:[^cookie].	].	^nil! !!WebResponse methodsFor: 'as yet unclassified' stamp: 'ar 2/21/2010 09:51'!setCookiesDo: aBlock	"Evaluate aBlock with all the cookies deined in the request"	self headersAt: 'Set-Cookie' do:[:hdr|		aBlock value: (WebCookie new readFrom: hdr readStream)	].! !!WebResponse methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 10:39'!status	"The status line from the response"	^status! !!WebResponse methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 10:39'!status: aString	"The status line from the response"	status := aString! !!WebResponse methodsFor: 'as yet unclassified' stamp: 'ar 8/24/2010 21:37'!url	"The url of the resource at which a request was terminated after a series	of redirects. Without redirects, this will be the same as the request url."	^url! !!WebResponse methodsFor: 'as yet unclassified' stamp: 'ar 8/24/2010 21:37'!url: urlString	"The url of the resource at which a request was terminated after a series	of redirects. Without redirects, this will be the same as the request url."	url := urlString! !!WebResponse methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 16:33'!writeOn: aStream	"Store this response on aStream"	self writeStatusOn: aStream.	super writeOn: aStream.! !!WebResponse methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 16:33'!writeStatusOn: aStream	"Store this response on aStream"	aStream nextPutAll: status; crlf.! !!WebResponse class methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 11:24'!protocol: protocol code: code	"Create a response using the given protocol / code"	^self new protocol: protocol code: code! !!PluggableDialogWindow class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 7/20/2004 23:31'!= anObject	"Answer whether I am equivalent to anObject (but not necessarily identical)."	^self class = anObject class and: [resource = anObject resource]! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 9/23/2002 22:48'!atEnd	"Answer whether I can read any more elements."	"It's generally possible for a remote party to send additional elements at some time in the future. To find out whether there are elements available to read currently, use >>dataAvailable."	^false! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 4/26/2001 15:17'!bufferSize: bufferSize	"Initialize buffering for future reading and writing operations."	self error: 'Ambiguous; use readingBufferSize:, writingBufferSize:, or readingBufferSize:writingBufferSize:.'! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 9/10/2012 13:54'!bufferingWrittenElements	"Answer whether I'm buffering written elements."	^false! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 6/9/2011 02:53'!close	filling ifNotNil: [filling terminate].	super close! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 1/18/2003 20:41'!contents	"Answer all of my readable elements."	^self error: 'My complete sequence is undefined, since some of my elements may have yet to arrive from a remote location. You may look at unconsumed elements with >>peek and >>peek:.'! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2012 22:05'!defaultTimeoutInMilliseconds: numberOfMilliseconds	defaultTimeoutInMilliseconds _ numberOfMilliseconds! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2012 22:03'!fill	"Attempt to fill the reading buffer."	| numberOfElementsToFetch nextElements numberOfElementsRead |	availableSpaceStraddles _ position <= readLimit.	numberOfElementsToFetch _ (		availableSpaceStraddles			ifTrue: [readingBufferSize - readLimit + position]			ifFalse: [position - readLimit]).	"Don't fill the reading buffer completely, because (position = readLimit) means empty."	numberOfElementsToFetch _ (numberOfElementsToFetch - 1) max: 1.	nextElements _ collection species new: numberOfElementsToFetch.	availableSpaceStraddles		ifTrue: [			numberOfElementsRead _ (				[					"This could wait indefinitely."					resource						next: numberOfElementsToFetch						into: nextElements						startingAt: 1				]					on: Timeout					do: [0]).			"Fill the reading buffer from the old read limit to the end."			readingBufferLock critical: [				(readLimit = readingBufferSize) ifFalse: [					collection						replaceFrom: (readLimit + 1)						to: ((readLimit + numberOfElementsRead) min: readingBufferSize)						with: nextElements						startingAt: 1].				"Fill the reading buffer from the beginning."				readLimit _ (					(readLimit + numberOfElementsRead > readingBufferSize)						ifTrue: [							collection								replaceFrom: 1								to: numberOfElementsRead - (readingBufferSize - readLimit)								with: nextElements								startingAt: readingBufferSize - readLimit + 1.							numberOfElementsRead - (readingBufferSize - readLimit)]						ifFalse: [readLimit + numberOfElementsRead])]]		ifFalse: [			"Available space does not straddle the end."			numberOfElementsRead _ (				"This could wait indefinitely."				resource					next: numberOfElementsToFetch					into: nextElements					startingAt: 1).			readingBufferLock critical: [				collection					replaceFrom: readLimit + 1					to: readLimit + numberOfElementsRead					with: nextElements					startingAt: 1.				readLimit _ readLimit + numberOfElementsRead]]! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 12/15/2000 00:57'!flush	"Flush any unwritten elements."	"There is a semantic difference between 'flush' and 'commit'. 'Flush' sends buffered data from object memory to the virtual machine, while 'commit' flushes buffered data and subsequently ensures that the data is actually sent to the appropriate external resource. This provides for portable buffering in object memory, while allowing for additional buffering optimization by the virtual machine and host environment (if any). If there is no such additional buffering, then 'flush' and 'commit' are equivalent."	self isDirty ifTrue: [		super flush.		writingPosition _ indexOfFirstWritableField - 1]! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 12/14/2000 18:57'!flushWritingBuffer	"Send unsent writing buffer elements to the virtual machine."	"Assume my resource is active."	resource		nextPut: indexOfLastDirtyElement - indexOfFirstWritableField + 1		from: collection		startingAt: indexOfFirstWritableField! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 7/20/2004 23:30'!hash	"Answer an identifier that any object equivalent to me (but not necessarily identical) would also answer."	^self class hash + resource hash! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 12/14/2000 16:55'!indexOfFirstWritableField	"Answer the index of the first writable field."	^indexOfFirstWritableField! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2012 22:11'!next	"Answer the next element, waiting for it to be available if necessary."	^self nextTimeoutAfter: defaultTimeoutInMilliseconds! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2012 22:10'!next: anInteger	"Answer the next anInteger bytes from the Net."	^self		next: anInteger		timeoutAfter: defaultTimeoutInMilliseconds! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2012 21:31'!next: numberOfElementsRequested into: aSequenceableCollection timeoutAfter: numberOfMilliseconds	"Copy the next numberOfElementsRequested elements into aSequenceableCollection. Handle the situation in which numberOfMilliseconds pass with no progress (an empty reading buffer). Answer aSequenceableCollection."	| numberOfElementsConsumed targetWritingIndex |	numberOfElementsConsumed _ 0.	targetWritingIndex _ 1.	[numberOfElementsConsumed < numberOfElementsRequested] whileTrue: [		(filling = nil)			ifTrue: [				"We're not buffering at all. Answer elements directly from my resource."				| numberOfElementsFetched |				numberOfElementsFetched _ (					resource						next: (numberOfElementsRequested - numberOfElementsConsumed)						into: aSequenceableCollection						startingAt: numberOfElementsConsumed + 1						timeoutAfter: numberOfMilliseconds).				(numberOfElementsFetched = 0)					ifTrue: [						"We have timed out."						Timeout signal]					ifFalse: [numberOfElementsConsumed _ numberOfElementsConsumed + numberOfElementsFetched]]			ifFalse: [				"We are buffering."				| timedOut |				timedOut _ false.				(self numberOfBufferedElementsAvailable < scarcityThreshold) ifTrue: [					scarcity signal.					availability waitTimeoutAfter: numberOfMilliseconds].				"Transfer the requested elements, set the reading position, and answer how many elements were consumed this time."				readingBufferLock critical: [					"Transcript cr; nextPutAll: 'requested: '; print: numberOfElementsRequested; nextPutAll: ', buffer: '; nextPutAll: (collection copyTo: readingBufferSize); nextPutAll: ', position: '; print: position; nextPutAll: ', read limit: '; print: readLimit; endEntry."					(position = readLimit)						ifTrue: [							"We have timed out."							timedOut _ true]						ifFalse: [							(position < readLimit)								ifTrue: [									"Readable data does not straddle the end of the reading buffer."									| numberOfElementsConsumedFromBuffer |									numberOfElementsConsumedFromBuffer _ (readLimit - position) min: numberOfElementsRequested.									aSequenceableCollection										replaceFrom: targetWritingIndex										to: (targetWritingIndex + numberOfElementsConsumedFromBuffer - 1)										with: collection										startingAt: position + 1.									"Transcript cr; print: numberOfElementsConsumedFromBuffer; nextPutAll: ' no-straddle: '; nextPutAll: aSequenceableCollection; endEntry."									position _ position + numberOfElementsConsumedFromBuffer.									targetWritingIndex _ targetWritingIndex + numberOfElementsConsumedFromBuffer.									numberOfElementsConsumed _ numberOfElementsConsumed + numberOfElementsConsumedFromBuffer]								ifFalse: [									"Readable data straddles the end of the reading buffer."									| endIndex numberOfElementsConsumedFromEndOfBuffer |									numberOfElementsConsumedFromEndOfBuffer _ readingBufferSize - position min: numberOfElementsRequested.							endIndex _ targetWritingIndex + numberOfElementsConsumedFromEndOfBuffer - 1.									aSequenceableCollection										replaceFrom: targetWritingIndex										to: endIndex										with: collection										startingAt: position + 1.											"Transcript cr; print: numberOfElementsConsumedFromEndOfBuffer; nextPutAll: ' from buffer end: '; nextPutAll: aSequenceableCollection; endEntry."									position _ position + numberOfElementsConsumedFromEndOfBuffer.									targetWritingIndex _ endIndex + 1.									numberOfElementsConsumed _ numberOfElementsConsumed + numberOfElementsConsumedFromEndOfBuffer.											(numberOfElementsConsumed < numberOfElementsRequested) ifTrue: [										| numberOfElementsConsumedFromBeginningOfBuffer |												"Elements from the beginning of the reading buffer must be used to satisfy the request."										numberOfElementsConsumedFromBeginningOfBuffer _ readLimit min: (numberOfElementsRequested - numberOfElementsConsumed).										aSequenceableCollection											replaceFrom: targetWritingIndex											to: endIndex + numberOfElementsConsumedFromBeginningOfBuffer											with: collection											startingAt: 1.												"Transcript cr; print: numberOfElementsConsumedFromBeginningOfBuffer; nextPutAll: ' from buffer beginning: '; nextPutAll: aSequenceableCollection; endEntry."												position _ numberOfElementsConsumedFromBeginningOfBuffer.										targetWritingIndex _ targetWritingIndex + numberOfElementsConsumedFromBeginningOfBuffer.										numberOfElementsConsumed _ numberOfElementsConsumed + numberOfElementsConsumedFromBeginningOfBuffer]]]].		timedOut ifTrue: [Timeout signal]]].			^aSequenceableCollection! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 5/31/2011 01:38'!next: anInteger timeoutAfter: numberOfMilliseconds	"Answer the next anInteger elements. Handle the situation in which numberOfMilliseconds pass with no progress (an empty reading buffer)."	^self		next: anInteger		into: (collection species new: anInteger)		timeoutAfter: numberOfMilliseconds! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 4/15/2001 22:47'!nextAvailable	"Answer the next available bytes."	^self nextAvailable: 10000! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 8/3/2002 04:32'!nextAvailable: anInteger	"Answer the next anInteger bytes, or however many are available."	^self nextAvailable: anInteger timeoutAfter: 0! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2012 13:15'!nextAvailable: anInteger timeoutAfter: numberOfMilliseconds	"Answer the next anInteger bytes that become available without waiting more than numberOfMilliseconds for any one of them."	"Speed the case where numberOfMilliseconds is zero and I'm not buffering."	^(numberOfMilliseconds = 0 and: [filling == nil])		ifTrue: [			resource dataAvailable				ifTrue: [					| bytes |					bytes _ ByteArray new: anInteger.					bytes _ bytes copyTo: (						resource							next: anInteger							into: bytes							startingAt: 1).					binary						ifTrue: [bytes]						ifFalse: [bytes asString]]				ifFalse: [#()]]		ifFalse: [			[self next: anInteger timeoutAfter: numberOfMilliseconds]				on: Timeout				do: [:exception |					position _ readLimit.					exception interimElements]]! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 4/16/2001 00:05'!nextAvailableTimeoutAfter: numberOfMilliseconds	"Answer the next available bytes."	"The 'large number' should only appear once..."	self needsWork.	^self nextAvailable: 10000 timeoutAfter: numberOfMilliseconds! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 6/17/2001 18:14'!nextPutMultiByte: anInteger	"Put anInteger, which is larger than eight bits, from the next position. Answer it."	| remainder |	remainder _ anInteger.	[remainder > 0] whileTrue: [		self nextPut: (remainder bitAnd: 2r11111111).		remainder _ remainder bitShift: -8].	^anInteger! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 8/26/2005 13:10'!nextPutString: aString	"Write aString to my stream, switching temporarily to textual mode if necessary."	self beTextualWhile: [self nextPutAll: aString]! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 3/7/2001 17:11'!nextTimeoutAfter: numberOfMilliseconds	"Answer the next element, timing out after numberOfMilliseconds."	^(self next: 1 timeoutAfter: numberOfMilliseconds) at: 1! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 5/30/2011 15:47'!numberOfBufferedElementsAvailable	"Answer the number of elements available in my reading buffer."	"This should be only be sent in a reading buffer critical section."	^(position = readLimit)		ifTrue: [0]		ifFalse: [			position < readLimit				ifTrue: [readLimit - position]				ifFalse: [readingBufferSize - position + readLimit]]! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2001 13:08'!peek	"Answer the next element without consuming it."	^(self peek: 1) first! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 2/6/2003 23:59'!peek: anInteger	"Answer the next anInteger elements without consuming them, waiting indefinitely for the availability of any particular element."	^self peek: anInteger timeoutAfter: nil! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 5/31/2011 01:04'!peek: anInteger timeoutAfter: numberOfMilliseconds	"Answer the next anInteger elements without consuming them, waiting at most numberOfMilliseconds for the availability of any particular element."	^((self readingBufferCapacity) < anInteger)		ifTrue: [			self readingBufferCapacity: 64.			scarcity signal.			availability waitTimeoutAfter: numberOfMilliseconds.			self peek: anInteger]		ifFalse: [			((self numberOfBufferedElementsAvailable) < anInteger)				ifTrue: [					scarcity signal.					availability waitTimeoutAfter: numberOfMilliseconds.					self peek: anInteger]				ifFalse: [					| elements |					elements _ collection species new: anInteger.					elements						replaceFrom: 1						to: ((readingBufferSize - position) min: anInteger)						with: collection						startingAt: position + 1;						replaceFrom: (readingBufferSize - position + 1)						to: anInteger								with: collection						startingAt: 1.					elements]]! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 5/30/2011 15:32'!pendingIncomingElements	"Answer the contents of my reading buffer."	^readingBufferLock critical: [		(position = readLimit)			ifTrue: [collection species new]			ifFalse: [				| elements |				elements _ (collection species new: self readingBufferCapacity) writableStream.				(position < readLimit)					ifTrue: [						"Readable elements do not straddle the end of the reading buffer."						elements nextPutAll: (							collection								copyFrom: (position + 1)								to: readLimit)]					ifFalse: [						"Readable elements straddle the end of the reading buffer."						elements							nextPutAll: (								collection									copyFrom: position + 1									to: readingBufferSize);							nextPutAll: (								collection									copyFrom: 1									to: readLimit)].				elements contents]]! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 6/7/2001 23:55'!port	"Answer the connection identifier of my resource."	^resource port! !!NetStream methodsFor: 'as yet unclassified'!position	self error: 'I don''t have a meaningful position.'! !!NetStream methodsFor: 'as yet unclassified'!position: anInteger	self error: 'I don''t have a meaningful position.'! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 5/30/2011 15:34'!prepend: eightBitValues	"Prepend eightBitValues to my reading buffer."	"As a side-effect, this clears the writing buffer."	| oldReadingBufferContents eightBitValuesSize |	eightBitValuesSize _ eightBitValues size.	oldReadingBufferContents _ self stopBuffering.	self readingBufferCapacity: eightBitValuesSize + oldReadingBufferContents size.	readingBufferLock critical: [		collection			replaceFrom: 1			to: eightBitValuesSize			with: eightBitValues;			replaceFrom: eightBitValuesSize + 1			to: readingBufferSize			with: oldReadingBufferContents]! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 1/29/2006 03:14'!previousTake	self error: 'You can''t take things back from a NetStream.'! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 11/28/2000 17:29'!readLimit	"Answer my read limit."	"I should answer positive infinity."	^SmallInteger maxVal! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 1/30/2004 17:24'!readingBufferCapacity	"Answer my reading buffer capacity."	"The actual reading buffer is one element larger than requested, so that (position = readLimit) can unambiguously mean that the reading buffer is empty."	^readingBufferSize - 1! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 5/31/2011 01:05'!readingBufferCapacity: readingBufferCapacity	"Set my reading buffer capacity to readingBufferCapacity."	self		readingBufferCapacity: readingBufferCapacity 		readingBufferScarcityThreshold: 2! !!NetStream methodsFor: 'as yet unclassified' stamp: 'il prior: 36950925!!!!!!!!!!!!!!!!'!readingBufferCapacity: readingBufferCapacity readingBufferScarcityThreshold: readingBufferScarcityThreshold	"Set my reading buffer capacity to readingBufferCapacity and my reading buffer scarcity threshold to readingBufferScarcityThreshold."	readingBufferCapacity = 0		ifTrue: [self stopBuffering]		ifFalse:[			self				readingBufferCapacity: readingBufferCapacity				readingBufferScarcityThreshold: readingBufferScarcityThreshold				writingBufferCapacity: writeLimit - readingBufferSize]! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2012 19:10'!readingBufferCapacity: readingBufferCapacity readingBufferScarcityThreshold: readingBufferScarcityThreshold writingBufferCapacity: writingBufferCapacity	"Initialize buffering for future reading and writing operations."	"Use my collection as two logical buffers, the first for reading and the second for writing."	| oldReadingBufferContents |	(filling notNil and: [readingBufferCapacity < (self numberOfBufferedElementsAvailable)]) ifTrue: [^self error: 'The requested reading buffer capacity is not sufficient to accomodate the current reading buffer contents.'].	oldReadingBufferContents _ self stopBuffering.	"The reading buffer size is one element larger than the requested capacity, so that (position = readLimit) can unambiguously mean that the reading buffer is empty (as opposed to full)."	readingBufferSize _ readingBufferCapacity + 1.	self emptyCollection: (collection species new: readingBufferSize + writingBufferCapacity).	collection		replaceFrom: 1		to: oldReadingBufferContents size		with: oldReadingBufferContents		startingAt: 1.	readLimit _ oldReadingBufferContents size.	position _ readingBufferSize.	writingPosition _ readingBufferSize.	indexOfFirstWritableField _ writingPosition + 1.	(readingBufferSize > 0) ifTrue: [		scarcityThreshold _ readingBufferScarcityThreshold.		scarcity _ Semaphore new.		"Note that, if I was read-buffering already, any process waiting on the current availability semaphore will now wait forever."		availability _ Semaphore new.		filling _ (			[				[					scarcity wait.					"Attempt to fill the reading buffer to a level equal to the scarcityThreshold."					self fill.					position = readLimit ifFalse: [availability signal]				]					repeat			]				forkAt: 70)]! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 12/8/2000 21:48'!relativeWritingPosition	"Answer my writing position, relative to the beginning of my buffering sequence (as opposed to the beginning of some externally-held sequence)."	^writingPosition! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 12/8/2000 21:49'!relativeWritingPosition: anInteger	"Set my writing position, relative to the beginning of my buffering sequence (as opposed to the beginning of some externally-held sequence)."	writingPosition _ anInteger! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 5/30/2011 14:50'!resource: anExternalResource	"Initialize myself."	super resource: anExternalResource.	self stopTranscribingTraffic.	readingBufferSize _ 0.	readingBufferLock _ Semaphore forMutualExclusion! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 3/7/2001 17:00'!size	"Answer the number of readable elements I have."	^self error: 'My complete sequence is undefined, since some of my elements may have yet to arrive from a remote location. You may ask the reading buffer size via >>readingBufferSize.'! !!NetStream methodsFor: 'as yet unclassified' stamp: 'nil prior: 0!!!!!!!!!!!!!!!!'!skip: anInteger	"Skip the next anInteger elements."	anInteger < 0		ifTrue: [self error: 'I don''t support skipping backward yet.']		ifFalse: [self next: anInteger]! !!NetStream methodsFor: 'as yet unclassified' stamp: 'nil prior: 40683592!!!!'!stopBuffering	"Stop buffering. Flush the writing buffer and answer the reading buffer contents (or an empty collection if I wasn't buffering in the first place)."	^filling == nil		ifTrue: [collection species new: 0]		ifFalse: [			| readingBufferContents |			self flush.			filling terminate.			scarcity _ availability _ filling _ nil.			writeLimit _ 0.			readingBufferContents _ (				position < readLimit					ifTrue: [						collection							copyFrom: (position max: 1)							to: readLimit]					ifFalse: [						(collection species new: readingBufferSize)							replaceFrom: 1							to: (readingBufferSize - position)							with: collection							startingAt: position;							replaceFrom: (readingBufferSize - position + 1)							to: readingBufferSize							with: collection							startingAt: 1;							yourself]).			readLimit _ 0.			collection _ collection species new.			readingBufferContents]! !!NetStream methodsFor: 'as yet unclassified'!stopTranscribingTraffic	"Stop transcribing traffic onto the Transcript."	transcribeTraffic _ false! !!NetStream methodsFor: 'as yet unclassified'!transcribeTraffic	"Transcribe traffic onto the Transcript."	transcribeTraffic _ true! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 3/22/2003 21:00'!transcribeTrafficOnto: aStream	"Transcribe traffic onto aStream."	transcript _ aStream.	self transcribeTraffic! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 1/18/2003 20:42'!upTo: anObject	"Answer a collection of elements from the current position to the first occurrence of an object equal to anObject."	^self upToAll: (collection species with: anObject)! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 4/11/2007 15:56'!upToAll: pattern	"Answer the next elements up to but not including those in pattern."	| oldTranscriptionValue |	oldTranscriptionValue _ transcribeTraffic.	^[		| elements |		transcribeTraffic ifTrue: [transcribeTraffic _ false].		elements _ super upToAll: pattern.		oldTranscriptionValue ifTrue: ["Transcript nextPutAll: 'incoming: '; print: elements"].		elements	]		ensure: [transcribeTraffic _ oldTranscriptionValue]! !!NetStream methodsFor: 'as yet unclassified' stamp: 'BEL 3/22/2003 17:11'!waitForReadability	"Wait until I may perform a read."	resource waitForReadability! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 1/30/2006 22:20'!waitForReadabilityTimeoutAfter: numberOfMilliseconds	"Wait until I may perform a read, timing out after numberOfMilliseconds."	resource waitForReadabilityTimeoutAfter: numberOfMilliseconds! !!NetStream methodsFor: 'as yet unclassified' stamp: 'crl 9/11/2012 00:11'!writingBufferCapacity: writingBufferCapacity	"Set my writing buffer capacity to writingBufferCapacity."	self		readingBufferCapacity: self readingBufferCapacity		readingBufferScarcityThreshold: scarcityThreshold		writingBufferCapacity: writingBufferCapacity! !!NetStream class methodsFor: 'as yet unclassified' stamp: 'crl 8/25/2005 22:07'!transport	"Answer a Transport which uses my instances to establish connections."	^self subclassResponsibility! !!MIDIPortMap methodsFor: 'as yet unclassified' stamp: 'crl 8/21/2017 17:28'!size	^proxy at: #size! !!MIDIPortMap class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!ChromeRuntimeAPI methodsFor: 'as yet unclassified' stamp: 'crl 7/31/2016 00:14'!executionContextCreated: parameters	<parseParameters: #parseExecutionContextFrom:>! !!ChromeRuntimeAPI methodsFor: 'as yet unclassified' stamp: 'crl 7/31/2016 00:17'!parseExecutionContextFrom: dictionary	^ChromeExecutionContext fromDictionary: (dictionary at: 'context')! !!ChromeRuntimeAPI class methodsFor: 'as yet unclassified' stamp: 'crl 7/29/2016 12:41'!domain	^'Runtime'! !!SystemWindowButton class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!ServiceCancelled class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!WideString methodsFor: 'as yet unclassified' stamp: 'crl 8/19/2016 15:43'!asSqueakString	| string |		string := (String new: self size) writeStream.	self do: [:character | string nextPut: character].	^string contents! !!WideString methodsFor: 'as yet unclassified' stamp: 'crl 5/20/2018 23:24'!storeOnTether: tether
	tether
		nextWordPut: WideStringTag;
		store: self asByteArray! !!WideString class methodsFor: 'as yet unclassified'!fromTether: tether	^self fromByteArray: tether next! !!WebClient methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 21:22'!defaultUserAgent	"Answer the default User-Agent string to use for WebClient"	^'WebClient/1.5'! !!WebClient methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 13:44'!detectProxyServer! !!WebClient class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 13:48'!initialize	"WebClient initialize"	FlagAcceptCookies := 1.	FlagAllowAuth := 2.	FlagAllowRedirect := 4.	"Default proxy handler"	"ProxyHandler := WebUtils."	self registerHttpSocketRequestHandler.! !!WebClient class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 13:50'!proxyHandler! !!WebClient class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 13:49'!proxyHandler: anObject! !!WebClient class methodsFor: 'as yet unclassified' stamp: 'crl 6/30/2017 11:01'!webSocket07: serverUrl protocol: protocol	"Attempt to connect to the given server url using the WebSocket api"	"http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-07"	| hash client req resp nonce |	nonce := ByteArray new: 16.	(1 to: nonce size) collect:[:i| nonce at: i put: (256 atRandom - 1)].	nonce := nonce base64Encoded.	client := self new.	client initializeFromUrl: serverUrl.	req := client requestWithUrl: serverUrl.	req method: 'GET'.	req headerAt: 'Upgrade' put: 'WebSocket'.	req headerAt: 'Connection' put: 'Upgrade'.	req headerAt: 'Sec-WebSocket-Origin' put: 'null'.	protocol ifNotNil:[req headerAt: 'Sec-WebSocket-Protocol' put: protocol].	req headerAt: 'Sec-WebSocket-Key' put: nonce.	req headerAt: 'Sec-WebSocket-Version' put: '13'.	resp := client sendRequest: req.	resp code = 101 ifFalse:[client close. ^nil].	"Verify WebSocket hash"	hash := WebUtils webSocketHash07: nonce.	hash = (resp headerAt: 'Sec-WebSocket-Accept') ifFalse:[client close. ^nil].	"Close of stream is left to caller"	^WebSocket07 on: resp stream.! !!WebClient class methodsFor: 'as yet unclassified' stamp: 'crl 6/30/2017 11:01'!webSocketTo: serverUrl protocol: protocol	"Attempt to connect to the given server url using the WebSocket api"	^self webSocket07: serverUrl protocol: protocol! !!MorphExtension class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!WriteStream methodsFor: 'as yet unclassified' stamp: 'crl 7/14/2017 10:33'!cr: anInteger	anInteger timesRepeat: [self cr]! !!WriteStream methodsFor: 'as yet unclassified' stamp: 'crl 3/20/2019 14:25'!next16BitsPut: sixteenBits	^self nextPutAll: (		ByteArray			with: (sixteenBits bitShift: -8)			with: (sixteenBits bitAnd: 255)).! !!WriteStream methodsFor: 'as yet unclassified' stamp: 'crl 7/12/2017 11:29'!resetAndRetainContents	"Reset my position to the beginning, and retain my contents (normally resetting a writable stream causes it to be empty)."	self size.	position := 0! !!DAVSessionStop methodsFor: 'as yet unclassified' stamp: 'crl 1/12/2015 00:16'!initialName	^'stop'! !!DAVSessionStop class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!IntegerArray methodsFor: 'as yet unclassified' stamp: 'crl 2/15/2019 11:38'!asJSArgument	^self! !!IntegerArray class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!CP1250TextConverter methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:55'!foo! !!HTML5FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 2/5/2019 20:27'!asJSArgument	^canvas asJSArgument! !!HTML5FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 2/5/2019 18:09'!at: key ifAbsent: block	^self canvas at: key ifAbsent: block! !!HTML5FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 2/5/2019 18:00'!at: key put: value	^self canvas at: key put: value! !!HTML5FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 6/12/2017 12:35'!canvas	^canvas! !!HTML5FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 4/20/2018 13:12'!context	^context! !!HTML5FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 4/20/2018 14:47'!displayForm: theForm at: theOrigin	theForm copyInto: form at: theOrigin.	self		showForm: theForm		at: theOrigin		onContext: context! !!HTML5FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 8/6/2017 08:09'!drawRubberBand: rectangle for: snowglobeMorph	rubberBand		ifNil: [			rubberBand := Webpage current createCanvasOfExtent: 1000@1000.			rubberBand				at: #id put: 'rubberBand';				displayForm: (self contentsOfArea: rectangle)				at: 200@200;				styleAt: #zIndex put: 100;				position: rectangle origin + (canvas window left @ canvas window top) - (200@200);				beVisible;				beOpaque;				beDraggable;				at: #onmousemove				put: [:event |					rubberBandOffset ifNil: [rubberBandOffset := ((event x - canvas window left - rectangle left) @ (event y - canvas window top - rectangle top))].					Time millisecondClockValue - timeOfLastRubberBand > 100 ifTrue: [						timeOfLastRubberBand := Time millisecondClockValue.						rubberBand position: (event x @ event y) - rubberBandOffset - (200@200)]];				at: #onmouseup				put: [:event |					snowglobeMorph						handleMouseUp: (							(MouseButtonEvent new)								setType: 1								position: (((event x - canvas proxy getBoundingClientRect left) rounded) @ ((event y - canvas proxy getBoundingClientRect top) rounded))								which: 0								buttons: 0								hand: nil								stamp: event timeStamp rounded);						stopRubberBanding]]		ifNotNil: [			(rubberBand class = SmallInteger)				ifTrue: [					Time millisecondClockValue > rubberBand ifTrue: [rubberBand := nil]]				ifFalse: [					| lastMouseMovePosition |										lastMouseMovePosition := snowglobeMorph lastMouseMove position.										rubberBandOffset := ((lastMouseMovePosition x - rectangle left) @ (lastMouseMovePosition y - rectangle top))]]! !!HTML5FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 6/11/2017 18:48'!flushDisplay	3 halt! !!HTML5FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 6/27/2017 15:11'!forceDamageToScreen	self		showForm: form		at: 0@0		onContext: context! !!HTML5FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 4/20/2018 14:58'!forceDamageToScreen: rectangles	rectangles isEmpty ifFalse: [		"Just force the whole form."		self forceDamageToScreen]! !!HTML5FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 6/11/2017 18:49'!forceToScreen:rect	3 halt! !!HTML5FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 6/13/2017 14:30'!fullDrawMorph: morph	(JS top document activeElement style)		at: #cursor		put: (			(morph isHandMorph and: [morph submorphs isEmpty not])				ifTrue: ['none']				ifFalse: [nil]).	super fullDrawMorph: morph! !!HTML5FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 1/11/2019 02:33'!html5Canvas: html5Canvas	canvas := Webpage current createMorphicWorldWithCanvas: html5Canvas.	context := [(canvas getContext: '2d') proxy] on: Error do: [nil]! !!HTML5FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 7/27/2017 16:39'!initialize	timeOfLastRubberBand := 0! !!HTML5FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 8/18/2017 17:38'!onClose: block	canvas		addEventListener: 'close'		with: block! !!HTML5FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 6/12/2017 22:09'!onKeyDown: block	canvas		addEventListener: 'keydown'		with: block! !!HTML5FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 8/12/2017 21:40'!onKeyPress: block	canvas		addEventListener: 'keypress'		with: block! !!HTML5FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 6/12/2017 22:12'!onKeyUp: block	canvas		addEventListener: 'keyup'		with: block! !!HTML5FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 6/17/2017 01:04'!onMouseDown: block	canvas		addEventListener: 'mousedown'		with: block! !!HTML5FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 6/12/2017 23:08'!onMouseEnter: block	canvas		addEventListener: 'mouseenter'		with: block! !!HTML5FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 6/12/2017 23:08'!onMouseLeave: block	canvas		addEventListener: 'mouseleave'		with: block! !!HTML5FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 6/12/2017 16:29'!onMouseMove: block	canvas		addEventListener: 'mousemove'		with: block! !!HTML5FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 6/12/2017 16:11'!onMouseUp: block	canvas		addEventListener: 'mouseup'		with: block! !!HTML5FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 9/10/2017 18:11'!paragraph: para bounds: bounds color: c	[super paragraph: para bounds: bounds color: c] ifError: []! !!HTML5FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 4/20/2018 13:12'!primitiveShowTop: top left: left bottom: bottom right: right inForm: form at: origin onContext: context	<primitive: 247>	World halt: 'oops'! !!HTML5FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 6/21/2017 15:15'!rubberBandPosition: position	rubberBand position: position! !!HTML5FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 6/11/2017 18:49'!showAt: pt invalidRects: updateRects	3 halt! !!HTML5FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 4/25/2018 16:48'!showForm: theForm at: theOrigin onContext: theContext	"ManagingSnowglobeMorph displayToTranscript: theForm."	self		primitiveShowTop: 0		left: 0		bottom: theForm height		right: theForm width		inForm: theForm		at: theOrigin - (0@1)		onContext: theContext! !!HTML5FormCanvas methodsFor: 'as yet unclassified' stamp: 'crl 12/12/2017 16:39'!stopRubberBanding	({UndefinedObject. SmallInteger} includes: rubberBand class) ifFalse: [rubberBand remove].	rubberBand := Time millisecondClockValue + 500.	rubberBandOffset := nil! !!HTML5FormCanvas class methodsFor: 'as yet unclassified' stamp: 'crl 8/26/2019 06:55'!extent: extent onHTML5Canvas: canvas	^(self extent: extent) html5Canvas: canvas! !!HTML5FormCanvas class methodsFor: 'as yet unclassified' stamp: 'crl 4/30/2019 02:23'!onHTML5Canvas: canvas	^[self extent: canvas extent onHTML5Canvas: canvas]		on: Error		do: [:exception |			JS alert: 'form canvas get nil html5 canvas'.			JS debugger]! !!WorldState methodsFor: 'as yet unclassified' stamp: 'ar 10/26/2000 14:10'!assuredCanvas	remoteServer ifNotNil:[^self assuredRemoteCanvas].	(canvas isNil or: [(canvas extent ~= viewBox extent) or: [canvas form depth ~= Display depth]])		ifTrue:			["allocate a new offscreen canvas the size of the window"			self canvas: (Display defaultCanvasClass extent: viewBox extent)].	^ self canvas! !!WorldState methodsFor: 'as yet unclassified' stamp: 'crl 7/7/2016 15:40'!displayWorld: aWorld submorphs: submorphs	"Update this world's display."	| deferredUpdateMode handsToDraw allDamage handDamageRects worldDamageRects |	submorphs do: [:m | m fullBounds].  "force re-layout if needed"	self checkIfUpdateNeeded ifFalse: [^ self].  "display is already up-to-date"	deferredUpdateMode := self doDeferredUpdatingFor: aWorld.	deferredUpdateMode ifFalse: [self assuredCanvas].	worldDamageRects := self drawWorld: aWorld submorphs: submorphs invalidAreasOn: canvas.  "repair world's damage on canvas"	"self handsDo:[:h| h noticeDamageRects: worldDamageRects]."	handsToDraw := self selectHandsToDrawForDamage: worldDamageRects.	handDamageRects := handsToDraw collect: [:h | h savePatchFrom: canvas].	allDamage := worldDamageRects, handDamageRects.	handsToDraw reverseDo: [:h | canvas fullDrawMorph: h].  "draw hands onto world canvas"	"*make this true to flash damaged areas for testing*"	Preferences debugShowDamage ifTrue: [aWorld flashRects: allDamage color: Color black].	canvas ifNotNil: [canvas finish: allDamage].	"quickly copy altered rects of canvas to Display:"	deferredUpdateMode		ifTrue: [self forceDamageToScreen: allDamage]		ifFalse: [canvas showAt: aWorld viewBox origin invalidRects: allDamage].	handsToDraw do: [:h | h restoreSavedPatchOn: canvas].  "restore world canvas under hands"	Display deferUpdates: false; forceDisplayUpdate.! !!WorldState methodsFor: 'as yet unclassified' stamp: 'md 3/19/2006 22:16'!doOneCycleNowFor: aWorld	"Immediately do one cycle of the interaction loop.	This should not be called directly, but only via doOneCycleFor:"	| capturingGesture |	DisplayScreen checkForNewScreenSize.	capturingGesture := false.	"self flag: #bob.	"	"need to consider remote hands in lower worlds"	"process user input events"	LastCycleTime := Time millisecondClockValue.	self handsDo: [:h |		ActiveHand := h.		h processEvents.		capturingGesture := capturingGesture or: [ h isCapturingGesturePoints ].		ActiveHand := nil	].	"the default is the primary hand"	ActiveHand := self hands first.	"The gesture recognizer needs enough points to be accurate.	Therefore morph stepping is disabled while capturing points for the recognizer"	capturingGesture ifFalse: 		[aWorld runStepMethods.		"there are currently some variations here"		self displayWorldSafely: aWorld].! !!WorldState methodsFor: 'as yet unclassified' stamp: 'mt 4/16/2015 10:59'!drawWorld: aWorld submorphs: submorphs invalidAreasOn: aCanvas 	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas thatwere redrawn."	| rectList n morphs rects validList |	rectList := damageRecorder invalidRectsFullBounds: aWorld viewBox.	"sort by areas to draw largest portions first"	rectList := rectList asArray sort: [:r1 :r2 | r1 area > r2 area].	damageRecorder reset.	n := submorphs size.	morphs := OrderedCollection new: n * 2.	rects := OrderedCollection new: n * 2.	validList := OrderedCollection new: n * 2.	"This is added in case we are drawing to a form that is to be used as a texture, and we want the background to be translucent."	aWorld color isTranslucent ifTrue:		[rectList do: [:r | aCanvas form fill: r fillColor: aWorld color]].	rectList do: 			[:dirtyRect | 			dirtyRect allAreasOutsideList: validList				do: 					[:r | | mm rectToFill remnants c rect i | 					"Experimental top-down drawing --			Traverses top to bottom, stopping if the entire area is filled.			If only a single rectangle remains, then continue with the reduced rectangle."					rectToFill := r.					i := 1.					[rectToFill isNil or: [i > n]] whileFalse: 							[mm := submorphs at: i.							((mm fullBounds intersects: r) and: [mm visible]) 								ifTrue: 									[morphs addLast: mm.									rects addLast: rectToFill.									remnants := mm areasRemainingToFill: rectToFill.									remnants size = 1 ifTrue: [rectToFill := remnants first].									remnants isEmpty ifTrue: [rectToFill := nil]].							i := i + 1].					"Now paint from bottom to top, but using the reduced rectangles."					rectToFill 						ifNotNil: [(c := aCanvas copyClipRect: rectToFill) drawMorph: aWorld].					[morphs isEmpty] whileFalse: 							[(rect := rects removeLast) == rectToFill 								ifFalse: [c := aCanvas copyClipRect: (rectToFill := rect)].							c fullDrawMorph: morphs removeLast].					morphs reset.					rects reset.					validList add: r]].	^validList! !!WorldState methodsFor: 'as yet unclassified' stamp: 'crl 5/15/2017 21:55'!forceDamageToScreen: allDamage	"here for the convenience of NebraskaWorldState"	canvas ifNotNil: [canvas forceDamageToScreen: allDamage].	self remoteCanvasesDo: [ :each | 		allDamage do: [:r | each forceToScreen: r].		each displayIsFullyUpdated.	].! !!WorldState methodsFor: 'as yet unclassified' stamp: 'crl 6/14/2017 14:14'!switchToHTMLCanvas	self canvas: (HTML5Canvas on: (Webpage current containingCanvas getContext: '2d'))! !!HTMLDocument methodsFor: 'as yet unclassified' stamp: 'crl 8/12/2019 23:56'!isMobile	^(JS at: #mobilecheck) call! !!HTMLDocument methodsFor: 'as yet unclassified' stamp: 'crl 4/16/2018 17:13'!loadScriptFrom: locator	self loadScriptFrom: locator then: []! !!HTMLDocument methodsFor: 'as yet unclassified' stamp: 'crl 4/16/2018 17:12'!loadScriptFrom: locator then: block	| script |		script := (		(self createElement: 'script')			at: 'type' put: 'text/javascript';			at: 'onload'			put: [block valueWithPossibleArgs: {script}];			yourself).				self head appendChild: script.	script at: 'src' put: locator! !!HTMLDocument class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!SystemChangeNotifier methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 21:27'!methodChangedFrom: oldMethod to: newMethod selector: aSymbol inClass: aClass requestor: requestor	"self trigger: (ModifiedEvent					methodChangedFrom: oldMethod					to: newMethod					selector: aSymbol 					inClass: aClass					requestor: requestor)"! !!SystemChangeNotifier methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 21:31'!methodRemoved: aMethod selector: aSymbol inProtocol: protocol class: aClass 	"A method with the given selector was removed from the class."	"self trigger: (RemovedEvent				method: aMethod 				selector: aSymbol				protocol: protocol				class: aClass)"! !!FileModifyingSimpleServiceEntry class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!TTGlyph class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 8/29/2017 19:42'!& object	^Chord withAll: {		Note withPitch: self.		object}! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 1/24/2003 00:11'!+ anInteger	"Answer the pitch anInteger half-steps away from me (there's no other reasonable interpretation for addition)."	^self class fromMIDINoteNumber: (self midiNoteNumber + anInteger)! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 1/19/2003 16:43'!, aMagnitude	"Answer a Note which has myself and aMagnitude as attributes."	^aMagnitude appliedTo: (Note withPitch: self)! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 9/17/2005 12:11'!< aPitch	"Answer whether I am equivalent to aPitch."	^self midiNoteNumber < aPitch midiNoteNumber! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 9/17/2005 12:11'!<= aPitch	"Answer whether I am equivalent to aPitch."	^self < aPitch or: [self = aPitch]! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 4/4/2003 00:57'!= aPitch	"Answer whether I am equivalent to aPitch."	^self class = aPitch class and: [self midiNoteNumber = aPitch midiNoteNumber]! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 9/17/2005 12:10'!> aPitch	"Answer whether I am equivalent to aPitch."	^(self <= aPitch) not! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 9/17/2005 12:11'!>= aPitch	"Answer whether I am equivalent to aPitch."	^self > aPitch or: [self = aPitch]! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 12/30/2004 14:55'!adjustBy: numberOfHalfSteps	"Adjust myself by numberOfHalfSteps."	self midiNoteNumber: (self midiNoteNumber + numberOfHalfSteps)! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 11/30/2004 18:17'!aeolian	"Answer the pitches of the aeolian mode, ascending, with myself as the root."	^self pitchSetRootedOnSelfInMode: Mode aeolian! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 4/4/2003 01:05'!alteration	"Answer my alteration."	^alteration yourselfUnlessNil: [		alteration _ (			(#(1 3 6 8 10) includes: (midiNoteNumber \\ 12))				ifTrue: [1]				ifFalse: [0])]! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 1/24/2003 00:24'!appliedTo: aMagnitude	"Answer aMagnitude after applying myself to it."	^aMagnitude applyPitch: self! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 7/27/2003 11:49'!asMusicalEvent	"Answer myself as a MusicalEvent."	^Note withPitch: self! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2005 16:59'!asRoot	^RootPitch fromMIDINoteNumber: self midiNoteNumber! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 12/30/2004 14:54'!class: aSymbol octave: anInteger	"Set my class and octave from the given parameters."	class _ aSymbol.	self		natural;		octave: anInteger! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 12/29/2004 16:14'!distanceFrom: aPitch	"Answer the number of half-steps between myself and aPitch."	^(self midiNoteNumber - aPitch midiNoteNumber) abs! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 11/30/2004 18:17'!dorian	"Answer the pitches of the dorian mode, ascending, with myself as the root."	^self pitchSetRootedOnSelfInMode: Mode dorian! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 7/22/2003 16:29'!down	"Adjust my octave down by one."	self down: 1! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 7/22/2003 16:28'!down: numberOfOctaves	"Adjust my octave down by numberOfOctaves."	self octave: self octave - numberOfOctaves! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2005 18:09'!flat	"Alter myself one half-step flatter."	self midiNoteNumber.	alteration _ self alteration - 1.	midiNoteNumber _ midiNoteNumber - 1.	alteration = -3 ifTrue: [self midiNoteNumber: midiNoteNumber]! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 9/17/2005 11:55'!halfStepsFrom: aPitch	"Answer the number of half-steps between myself and aPitch."	^self midiNoteNumber - aPitch midiNoteNumber! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 9/17/2005 12:09'!in: aPitchSet	^aPitchSet degreeOf: self! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 11/30/2004 18:17'!ionian	"Answer the pitches of the ionian mode, ascending, with myself as the root."	^self pitchSetRootedOnSelfInMode: Mode ionian! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 11/30/2004 18:17'!locrian	"Answer the pitches of the locrian mode, ascending, with myself as the root."	^self pitchSetRootedOnSelfInMode: Mode locrian! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 11/30/2004 18:17'!lydian	"Answer the pitches of the lydian mode, ascending, with myself as the root."	^self pitchSetRootedOnSelfInMode: Mode lydian! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 12/29/2004 16:47'!major	^self ionian! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 4/4/2003 00:50'!midiNoteNumber	"Answer the number used to represent me in the MIDI protocol."	^midiNoteNumber yourselfUnlessNil: [midiNoteNumber _ ((octave + 1) * 12) + ((#(C C D D E F F G G A A B) indexOf: class) - 1) + alteration]! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 12/30/2004 14:55'!midiNoteNumber: sevenBitPositiveInteger	"Set my midiNoteNumber to sevenBitPositiveInteger."	midiNoteNumber _ sevenBitPositiveInteger.	class _ octave _ alteration _ nil! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 12/29/2004 16:47'!minor	^self aeolian! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 11/30/2004 18:17'!mixolydian	"Answer the pitches of the mixolydian mode, ascending, with myself as the root."	^self pitchSetRootedOnSelfInMode: Mode mixolydian! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 12/30/2004 14:55'!natural	"Undo any alteration."	alteration _ 0.	midiNoteNumber _ nil! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 4/4/2003 01:06'!octave	"Answer my octave."	^octave yourselfUnlessNil: [octave _ (midiNoteNumber // 12) - 1]! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 4/3/2003 23:53'!octave: anInteger	"Set my octave to anInteger."	"Resolve my class and alteration."	self		pitchClass;		alteration.	octave _ anInteger.	midiNoteNumber _ nil! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 11/30/2004 18:17'!phrygian	"Answer the pitches of the phrygian mode, ascending, with myself as the root."	^self pitchSetRootedOnSelfInMode: Mode phrygian! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2004 13:47'!pitch	^self! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 4/4/2003 00:00'!pitchClass	"Answer my pitch class."	^class yourselfUnlessNil: [class _ #(C C D D E F F G G A A B) at: (midiNoteNumber \\ 12) + 1]! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 11/30/2004 18:16'!pitchSetRootedOnSelfInMode: aMode	"Answer a PitchSet rooted on myself, in aMode."	^PitchSet		withRootPitch: self		inMode: aMode! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 12/29/2004 11:56'!printAlterationOn: aStream	(self alteration == 0) ifFalse: [		aStream nextPut: $-.		(alteration abs = 2) ifTrue: [aStream nextPutAll: 'double-'].		aStream nextPutAll: (			(alteration positive)				ifTrue: ['sharp']				ifFalse: ['flat'])]! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2005 19:37'!printOn: aStream	"Print a textual representation of myself on aStream."	(self == IndefinitePitch)		ifTrue: [aStream nextPutAll: 'an indefinite pitch']		ifFalse: [			((self midiNoteNumber) = 0)				ifTrue: [aStream nextPutAll: 'a rest']				ifFalse: [					aStream						nextPutAll: 'the ';						print: (Rank for: self octave);						space;						nextPutAll: self pitchClass.					self printAlterationOn: aStream]]! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2005 18:09'!sharp	"Alter myself one half-step sharper."	self midiNoteNumber.	alteration _ self alteration + 1.	midiNoteNumber _ midiNoteNumber + 1.	alteration = 3 ifTrue: [self midiNoteNumber: midiNoteNumber]! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2004 21:43'!storeOn: aStream	aStream		store: (Rank for: self octave);		space;		nextPutAll: self pitchClass asLowercase.	self alteration = 0 ifFalse: [		| negative |		negative _ alteration negative.		alteration abs timesRepeat: [			aStream				space;				nextPutAll: (					negative						ifTrue: ['flat']						ifFalse: ['sharp'])]]! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 7/22/2003 18:13'!up	"Adjust my octave up by one."	self up: 1! !!Pitch methodsFor: 'as yet unclassified' stamp: 'crl 7/22/2003 18:12'!up: numberOfOctaves	"Adjust my octave up by numberOfOctaves."	self octave: self octave + numberOfOctaves! !!Pitch class methodsFor: 'as yet unclassified' stamp: 'crl 4/3/2003 23:56'!class: pitchClass octave: octave	"Answer an instance of myself for pitchClass and octave."	^(self new)		class: pitchClass		octave: octave! !!Pitch class methodsFor: 'as yet unclassified' stamp: 'crl 1/24/2003 00:02'!classAMember: index	"Answer the member of the A pitch class corresponding to index."	^self		class: #A		octave: index! !!Pitch class methodsFor: 'as yet unclassified' stamp: 'crl 1/24/2003 00:03'!classBMember: index	"Answer the member of the B pitch class corresponding to index."	^self		class: #B		octave: index! !!Pitch class methodsFor: 'as yet unclassified' stamp: 'crl 1/24/2003 00:03'!classCMember: index	"Answer the member of the C pitch class corresponding to index."	^self		class: #C		octave: index! !!Pitch class methodsFor: 'as yet unclassified' stamp: 'crl 1/24/2003 00:03'!classDMember: index	"Answer the member of the D pitch class corresponding to index."	^self		class: #D		octave: index! !!Pitch class methodsFor: 'as yet unclassified' stamp: 'crl 1/24/2003 00:03'!classEMember: index	"Answer the member of the E pitch class corresponding to index."	^self		class: #E		octave: index! !!Pitch class methodsFor: 'as yet unclassified' stamp: 'crl 1/19/2003 05:25'!classFMember: index	"Answer the member of the F pitch class corresponding to index."	^(self new)		class: #F		octave: index! !!Pitch class methodsFor: 'as yet unclassified' stamp: 'crl 1/24/2003 00:03'!classGMember: index	"Answer the member of the G pitch class corresponding to index."	^self		class: #G		octave: index! !!Pitch class methodsFor: 'as yet unclassified' stamp: 'crl 4/3/2003 19:27'!fromMIDINoteNumber: midiNoteNumber	"Answer an instance of me corresponding to midiNoteNumber."	^self new midiNoteNumber: midiNoteNumber! !!Pitch class methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2005 19:44'!indefinite	^IndefinitePitch! !!Pitch class methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2005 19:38'!initialize	"Initialize myself."	IndefinitePitch _ self fromMIDINoteNumber: -1! !!Pitch class methodsFor: 'as yet unclassified' stamp: 'crl 9/10/2004 16:46'!rest	"Answer the pitch of a rest."	^self fromMIDINoteNumber: 0! !!AudibleMusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 7/28/2003 16:40'!= aNote	"Answer whether I am equivalent to aNote."	^super = aNote and: [absoluteDuration = aNote absoluteDuration]! !!AudibleMusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 7/28/2003 16:40'!absoluteDuration	"Answer my absoluteDuration."	^absoluteDuration! !!AudibleMusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 7/28/2003 16:43'!absoluteDuration: anAbsoluteDuration	"Set my duration to anAbsoluteDuration."	self applyAbsoluteDuration: anAbsoluteDuration! !!AudibleMusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 9/16/2005 01:31'!addToSequence: aSequence	aSequence add: self.	^true! !!AudibleMusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 8/22/2017 10:56'!addUninitializedAspectsTo: aspects	self loudness ifNil: [aspects add: 'loudness'].	(delayInMilliseconds isNil or: [absoluteDuration = 0 seconds]) ifTrue: [		aspects add: (			(relativeDuration isNil or: [relativeDuration = 0 quarters])				ifTrue: ['duration']				ifFalse: ['tempo'])]! !!AudibleMusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 8/24/2017 16:18'!antievent	^self subclassResponsibility! !!AudibleMusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 6/18/2006 01:17'!applyAbsoluteDuration: anAbsoluteDuration	"Use anAbsoluteDuration as my absoluteDuration, and answer myself."	absoluteDuration _ anAbsoluteDuration.	delayInMilliseconds _ (absoluteDuration asSeconds * 1000) rounded.	delay _ Delay forMilliseconds: delayInMilliseconds! !!AudibleMusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 8/23/2017 15:27'!applyAbsoluteLoudness: loudness	absoluteLoudness := loudness! !!AudibleMusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 7/28/2003 18:02'!applyRelativeDuration: aRelativeDuration	"Use aRelativeDuration as my relativeDuration, and answer myself."	relativeDuration _ aRelativeDuration! !!AudibleMusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 2/1/2005 15:05'!applyTempo: aTempo	"Set my tempo to aTempo."	self applyAbsoluteDuration: (self relativeDuration absoluteDurationAtTempo: aTempo)! !!AudibleMusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 8/22/2017 10:56'!completeFrom: anAudibleMusicalEvent	"Set my uninitialized parameters from anAudibleMusicalEvent."	super completeFrom: anAudibleMusicalEvent.	relativeDuration ifNil: [self, anAudibleMusicalEvent relativeDuration].	absoluteDuration ifNil: [self, anAudibleMusicalEvent absoluteDuration].	self loudness ifNil: [self, anAudibleMusicalEvent loudness]! !!AudibleMusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 9/17/2005 23:13'!down	self subclassResponsibility! !!AudibleMusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 7/28/2003 16:39'!hash	"Answer a hash which all objects equivalent to me share."	^super hash + absoluteDuration hash! !!AudibleMusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 9/1/2017 21:37'!initialize	self, 100 percent loudness, 0 quarters, 0 seconds! !!AudibleMusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 8/22/2017 10:56'!isPlayable	^super isPlayable and: [self loudness notNil and: [absoluteDuration notNil and: [absoluteDuration > 0 seconds]]]! !!AudibleMusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 8/24/2017 12:49'!loudness	^absoluteLoudness yourselfUnlessNil: [relativeLoudness]! !!AudibleMusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 8/29/2017 12:27'!needsNoteOff	^(self loudness = 0 or: [(channel = 10th channel) or: [delayInMilliseconds == nil]]) not! !!AudibleMusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 8/29/2017 20:20'!packetsToLoopForDuration: totalDuration	self absoluteDuration.	^(totalDuration < absoluteDuration)		ifTrue: [self error: 'I''m longer than that.']		ifFalse: [			(totalDuration = absoluteDuration)				ifTrue: [self packets]				ifFalse: [					| maximumNumberOfRepetitions packets buffer originalPackets firstTimestamp accumulatedMilliseconds firstStartingTime totalMilliseconds myMilliseconds |					maximumNumberOfRepetitions _ (totalDuration / self absoluteDuration) ceiling.					buffer _ (Array new: maximumNumberOfRepetitions) writableStream.					packets _ (Array new: maximumNumberOfRepetitions) writableStream.					accumulatedMilliseconds _ 0.					originalPackets _ self packets.					myMilliseconds _ absoluteDuration totalMilliseconds ceiling.					firstStartingTime _ originalPackets min bitShift: -32.					totalMilliseconds _ totalDuration totalMilliseconds floor.					0						to: maximumNumberOfRepetitions						do: [:repetition |							originalPackets do: [:packet | buffer nextPut: (((packet bitShift: -32) + (myMilliseconds * repetition)) ceiling bitShift: 32) + (packet bitAnd: 16rFFFFFFFF)]].					buffer resetAndRetainContents.					"3 halt."					[accumulatedMilliseconds < totalMilliseconds] whileTrue: [						| nextPacket |						nextPacket _ buffer next.						packets nextPut: nextPacket.						accumulatedMilliseconds _ (buffer peek bitShift: -32) - firstStartingTime].					"3 halt."					packets contents]]! !!AudibleMusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 2/22/2006 02:04'!play	super play.	delay == nil ifFalse: [delay wait]! !!AudibleMusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 8/24/2017 16:25'!postCopy	super postCopy.	absoluteDuration ifNotNil: [self, absoluteDuration]! !!AudibleMusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2017 15:21'!printDurationsOn: stream	[self relativeDuration; absoluteDuration] ifError: [].	stream nextPutAll: ', for '.	(relativeDuration == nil or: [relativeDuration = 0 quarters])		ifTrue: [			(([self absoluteDuration] ifError: [nil]) isNil)				ifTrue: [stream nextPutAll: 'an indeterminate duration']				ifFalse: [stream print: absoluteDuration]]		ifFalse: [			stream				print: relativeDuration;				nextPutAll: ' at '.			(absoluteDuration isNil)				ifTrue: [stream nextPutAll: 'an indeterminate tempo']				ifFalse: [					stream						print: self tempo;						nextPutAll: ' (';						print: absoluteDuration;						nextPut: $)]]! !!AudibleMusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 8/29/2017 19:50'!printOn: stream	self printDurationsOn: stream.	super printOn: stream! !!AudibleMusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 8/28/2017 14:14'!relativeDuration	"Answer my relativeDuration."	^relativeDuration! !!AudibleMusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2017 15:30'!scheduleFor: duration	(duration isAbsolute)		ifTrue: [			(				(duration < self absoluteDuration)					ifTrue: [						| packets currentTime |						currentTime _ MIDIPort currentTime.						self timestamp: currentTime.						packets _ self packets.						(FrozenMusicalEvent fromPackets: packets at: currentTime), duration]					ifFalse: [						((3rd c, 0 percent loudness, 1st channel, duration) & self)]			)				schedule]		ifFalse: [self scheduleFor: duration at: self tempo]! !!AudibleMusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2017 15:29'!scheduleFor: duration at: tempo	self scheduleFor: (duration absoluteDurationAtTempo: self tempo)! !!AudibleMusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 8/29/2017 10:47'!scheduleOn: aMIDIStream	"Schedule myself for immediate rendering on aMIDIStream. Answer how many bytes were processed."	| numberOfBytesWritten |	numberOfBytesWritten _ super scheduleOn: aMIDIStream.	self needsNoteOff ifTrue: [numberOfBytesWritten _ numberOfBytesWritten + ((self copy, 0 percent loudness) scheduleOn: aMIDIStream forNowPlus: delayInMilliseconds)].	^numberOfBytesWritten! !!AudibleMusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2005 02:31'!stop	"Stop playing myself."	delay == nil ifFalse: [self, absoluteDuration]! !!AudibleMusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2004 19:51'!storeOn: aStream	relativeDuration == nil ifFalse: [		aStream			nextPutAll: ', ';			store: relativeDuration].	absoluteDuration == nil ifFalse: [		aStream			nextPutAll: ', ';			store: absoluteDuration].	super storeOn: aStream! !!AudibleMusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 8/30/2017 15:16'!tempo	^[(absoluteDuration asSeconds reciprocal * relativeDuration magnitude * 240) rounded bpm] ifError: [nil]! !!AudibleMusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 9/17/2005 23:13'!up	self subclassResponsibility! !!AudibleMusicalEvent methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2005 12:49'!wait	delay wait! !!AudibleMusicalEvent class methodsFor: 'as yet unclassified' stamp: 'crl 9/7/2008 22:31'!initialize	"Initialize myself."	tagMinimum _ 16r80.	tagMaximum _ 16r9F! !!PluggableSpacerSpec class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!StandardToolSet methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!StandardToolSet class methodsFor: 'as yet unclassified' stamp: 'crl 9/10/2017 21:19'!inspect: anObject label: aString	"Open an inspector on the given object. The tool set must know which inspector type to use for which object - the object cannot possibly know what kind of inspectors the toolset provides."	^(self inspectorClassOf: anObject) openOn: anObject withLabel: aString! !!ContextPart methodsFor: 'as yet unclassified' stamp: 'crl 3/20/2019 13:26'!firstLocalContext	| context processingMethod |	processingMethod := IncomingMessageExchange compiledMethodAt: #send:withParameters:to:over:under:.	context := self.	[context sender home method == processingMethod] whileFalse: [context := context sender].	^context! !!ContextPart methodsFor: 'as yet unclassified' stamp: 'crl 3/21/2019 06:58'!fuse	self method ifNotNilDo: [:it | it fuse]! !!ContextPart methodsFor: 'as yet unclassified' stamp: 'crl 3/20/2019 14:45'!id	^self method id! !!ContextPart methodsFor: 'as yet unclassified' stamp: 'crl 4/15/2018 20:11'!object: anObject perform: selector withArguments: argArray inClass: lookupClass	"Send the selector, aSymbol, to anObject with arguments in argArray.	 Fail if the number of arguments expected by the selector 	 does not match the size of argArray, or if lookupClass	 cannot be found among the anObject's superclasses.	 Primitive. Essential for the debugger."	<primitive: 100 error: error>	(selector isSymbol) ifFalse:		[^self error: 'selector argument must be a Symbol'].	(argArray isMemberOf: Array) ifFalse:		[^self error: 'argArray must be an Array'].	(selector numArgs = argArray size)		ifFalse: [^self error: 'incorrect number of arguments'].	((self objectClass: anObject) == lookupClass	 or: [(self objectClass: anObject) inheritsFrom: lookupClass]) ifFalse:		[^self error: 'lookupClass is not in anObject''s inheritance chain'].	anObject class == JSObjectProxy ifTrue: [^anObject perform: selector withArguments: argArray].	self primitiveFailed! !!ContextPart methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2019 16:49'!performSelector	<primitive: 'performSelector' module: 'Flow'>	self primitiveFailed! !!ContextPart methodsFor: 'as yet unclassified' stamp: 'crl 9/7/2019 13:40'!selectorJustSent	| lines keys key line thresholdPC selector |	lines := Dictionary new.	thresholdPC := pc - 1.	self method symbolicLinesDo: [:eachPC :eachLine | lines at: eachPC put: eachLine].	keys := lines keys asSortedCollection asArray reversed readStream.	key := keys next.		[key > thresholdPC] whileTrue: [key := keys next].	line := lines at: key.	['*> *end: *' match: line] whileFalse: [line := lines at: keys next].	selector := (line reversed readStream upTo: Character space) reversed asSymbol.	^('perform:*' match: selector)		ifTrue: [thisContext sender sender performSelector]		ifFalse: [selector]! !!ContextPart methodsFor: 'as yet unclassified' stamp: 'crl 3/20/2019 13:36'!source	| homeMethod |		homeMethod := self method.		^(EditHistory residesLocally not and: [homeMethod methodClass includesSelector: homeMethod selector])		ifTrue: [homeMethod id edition source]		ifFalse: [			(EditHistory residesLocally)				ifTrue: [homeMethod getSource]				ifFalse: [homeMethod decompile decompileString]]! !!ContextPart class methodsFor: 'as yet unclassified' stamp: 'crl 4/27/2017 22:35'!javaScriptSourceFor: aBlock	| source result |		source := (String new: 1024) writeStream.		result := thisContext sender		runSimulated: aBlock		contextAtEachStep: [:current | ].			3 halt.		^source contents! !!TaggedEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2008 21:44'!activeTagsEdition	^activeTagsEdition! !!TaggedEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/6/2008 12:01'!activeTagsEdition: aTagsEdition	activeTagsEdition := aTagsEdition! !!TaggedEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2008 21:42'!addTags: anArray	(activeTagsEdition includesTags: anArray) ifFalse: [		| oldTags |		oldTags := activeTagsEdition tags.		self clearTags.		oldTags do: [:tags | activeTagsEdition addTags: tags].		activeTagsEdition addTags: anArray]! !!TaggedEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2008 20:20'!clearTags	| newTagsEdition |	newTagsEdition := TagsEdition about: self.	activeTagsEdition ifNotNil: [		activeTagsEdition nextEdition: newTagsEdition.		newTagsEdition previousEdition: activeTagsEdition].	activeTagsEdition := newTagsEdition! !!TaggedEdition methodsFor: 'as yet unclassified' stamp: 'crl 1/1/2014 11:29'!initialize	super initialize.	self clearTags! !!TaggedEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2008 21:44'!previousEdition: anEdition	super previousEdition: anEdition.	activeTagsEdition := previousEdition activeTagsEdition! !!TaggedEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2008 20:24'!removeTags: anArray	| oldTags |	oldTags := activeTagsEdition tags.	self clearTags.	(oldTags copyWithout: anArray) do: [:tags | activeTagsEdition addTags: tags]! !!TaggedEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 15:50'!storeOnTether: tether	super storeOnTether: tether.	tether store: activeTagsEdition! !!TaggedEdition methodsFor: 'as yet unclassified' stamp: 'crl 7/10/2011 11:53'!tags	^activeTagsEdition tags! !!TaggedEdition class methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 18:52'!fromTether: tether	| taggedEdition tagsEdition |	taggedEdition := super fromTether: tether.	tagsEdition := tether next.	taggedEdition activeTagsEdition: tagsEdition.	tagsEdition ifNotNil: [tagsEdition taggedEdition: taggedEdition].	^taggedEdition! !!PluggableListMorphPlus class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!AttributedTextStream methodsFor: 'as yet unclassified' stamp: 'nice 12/9/2009 08:26'!contents	| ans |	currentRun > 0 ifTrue:[		attributeValues nextPut: currentAttributes.		attributeRuns nextPut: currentRun.		currentRun := 0].	ans := Text string: characters contents  runs: 		(RunArray runs: attributeRuns contents values: attributeValues contents).	^ans! !!AttributedTextStream methodsFor: 'as yet unclassified' stamp: 'ul 11/2/2010 21:51'!cr	"Append a carriage return character to the receiver."	self nextPut: Character cr! !!AttributedTextStream methodsFor: 'as yet unclassified' stamp: 'ul 11/2/2010 21:51'!crlf	"Append a carriage return and a line feed to the receiver."	self nextPut: Character cr; nextPut: Character lf! !!AttributedTextStream methodsFor: 'as yet unclassified' stamp: 'ls 6/27/1998 15:09'!currentAttributes	"return the current attributes"	^currentAttributes! !!AttributedTextStream methodsFor: 'as yet unclassified' stamp: 'ar 10/16/2001 22:57'!currentAttributes: newAttributes	"set the current attributes"	(currentRun > 0 and:[currentAttributes ~= newAttributes]) ifTrue:[		attributeRuns nextPut: currentRun.		attributeValues nextPut: currentAttributes.		currentRun := 0.	].	currentAttributes := newAttributes.! !!AttributedTextStream methodsFor: 'as yet unclassified' stamp: 'ul 11/2/2010 21:57'!initialize	characters := String new writeStream.	currentAttributes := #().	currentRun := 0.	attributeValues := (Array new: 50) writeStream.	attributeRuns := (Array new: 50) writeStream! !!AttributedTextStream methodsFor: 'as yet unclassified' stamp: 'ul 11/2/2010 21:45'!lf	"Append a line feed character to the receiver."	self nextPut: Character lf! !!AttributedTextStream methodsFor: 'as yet unclassified' stamp: 'nice 3/19/2010 19:03'!nextPut: aChar	currentRun := currentRun + 1.	^characters nextPut: aChar! !!AttributedTextStream methodsFor: 'as yet unclassified' stamp: 'nice 3/19/2010 19:12'!nextPutAll: aString	"add an entire string with the same attributes"	currentRun := currentRun + aString size.	^characters nextPutAll: aString.! !!AttributedTextStream methodsFor: 'as yet unclassified' stamp: 'ls 9/10/1998 03:36'!size	"number of characters in the stream so far"	^characters size! !!AttributedTextStream methodsFor: 'as yet unclassified' stamp: 'ul 11/2/2010 21:57'!withAttribute: attribute do: aBlock	^self withAttributes: { attribute } do: aBlock! !!AttributedTextStream methodsFor: 'as yet unclassified' stamp: 'ul 11/2/2010 06:42'!withAttributes: attributes do: aBlock	| previousAttributes |	previousAttributes := currentAttributes.	[		self currentAttributes: attributes.		aBlock value ]			ensure: [ self currentAttributes: previousAttributes ]! !!AttributedTextStream class methodsFor: 'as yet unclassified' stamp: 'gk 2/9/2004 18:50'!new	"For this class we override Stream class>>new since this	class actually is created using #new, even though it is a Stream."		^self basicNew initialize! !!MacRomanTextConverter methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:55'!foo! !!ModuleIDPattern methodsFor: 'as yet unclassified' stamp: 'crl 7/15/2011 21:29'!authorID	self maskFromByte: 17 to: 32! !!ModuleIDPattern methodsFor: 'as yet unclassified' stamp: 'crl 7/15/2011 21:28'!baseID	self maskFromByte: 1 to: 16! !!ModuleIDPattern methodsFor: 'as yet unclassified' stamp: 'crl 7/15/2011 21:30'!majorVersion	self maskFromByte: 33 to: 34! !!ModuleIDPattern methodsFor: 'as yet unclassified' stamp: 'crl 7/15/2011 21:30'!minorVersion	self maskFromByte: 35 to: 36! !!ModuleIDPattern methodsFor: 'as yet unclassified' stamp: 'crl 7/15/2011 21:33'!versionIteration	self maskBits: 2r111111 atByte: 37! !!ModuleIDPattern methodsFor: 'as yet unclassified' stamp: 'crl 7/15/2011 21:32'!versionStage	self maskBits: 2r11000000 atByte: 37! !!ModuleIDPattern class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 13:16'!asBinaryOrTextStream	^ self! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 13:16'!ascii	isBinary := false! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 16:01'!basicNext	^ super next ! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'md 10/20/2004 15:32'!basicNext: anInteger	^ super next: anInteger.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 13:21'!basicNext: n into: aString	^ super next: n into: aString.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'ul 1/31/2011 02:04'!basicNext: anInteger putAll: aCollection startingAt: startIndex	^super next: anInteger putAll: aCollection startingAt: startIndex! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 13:21'!basicNextInto: aString	^ super nextInto: aString.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 13:21'!basicNextPut: char	^ super nextPut: char.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 13:21'!basicNextPutAll: aString	^ super nextPutAll: aString.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 13:21'!basicPeek	^ super peek! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 13:21'!basicPosition	^ super position.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 13:21'!basicPosition: pos	^ super position: pos.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 13:16'!binary	isBinary := true! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'cmm 9/3/2013 16:05'!contents	| ret state |	state := converter saveStateOf: self.	self position: 0.	ret := self upToEnd.	converter restoreStateOf: self with: state.	^ ret! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'nk 8/2/2004 17:02'!converter	converter ifNil: [converter := self class defaultConverter].	^ converter! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 8/7/2003 09:12'!converter: aConverter	converter := aConverter.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 8/17/2004 10:02'!fileIn	self setConverterForCode.	super fileIn.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 16:31'!fileInObjectAndCode	"This file may contain:1) a fileIn of code  2) just an object in SmartReferenceStream format 3) both code and an object.	File it in and return the object.  Note that self must be a FileStream or RWBinaryOrTextStream.  Maybe ReadWriteStream incorporate RWBinaryOrTextStream?"	| refStream object |	self text.	self peek asciiValue = 4		ifTrue: [  "pure object file"			self binary.			refStream := SmartRefStream on: self.			object := refStream nextAndClose]		ifFalse: [  "objects mixed with a fileIn"			self fileIn.  "reads code and objects, then closes the file"			self binary.			object := SmartRefStream scannedObject].	"set by side effect of one of the chunks"	SmartRefStream scannedObject: nil.  "clear scannedObject"	^ object! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 3/1/2005 06:10'!fileInObjectAndCodeForProject	"This file may contain:1) a fileIn of code  2) just an object in SmartReferenceStream format 3) both code and an object.	File it in and return the object.  Note that self must be a FileStream or RWBinaryOrTextStream.  Maybe ReadWriteStream incorporate RWBinaryOrTextStream?"	| refStream object |	self text.	self peek asciiValue = 4		ifTrue: [  "pure object file"			self binary.			refStream := SmartRefStream on: self.			object := refStream nextAndClose]		ifFalse: [  "objects mixed with a fileIn"			self fileInProject.  "reads code and objects, then closes the file"			self binary.			object := SmartRefStream scannedObject].	"set by side effect of one of the chunks"	SmartRefStream scannedObject: nil.  "clear scannedObject"	^ object! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 3/1/2005 06:46'!fileInProject	self setConverterForCodeForProject.	super fileIn.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'tak 1/12/2005 13:47'!fileOutClass: extraClass andObject: theObject 	UTF8TextConverter writeBOMOn: self.	^ super fileOutClass: extraClass andObject: theObject! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'nice 1/18/2010 13:41'!guessConverter	^ (self originalContents includesSubString: #[27 36] asString)		ifTrue: [CompoundTextConverter new]		ifFalse: [self class defaultConverter ]! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 13:25'!isBinary	^ isBinary! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 16:39'!next	| n |	n := self converter nextFromStream: self.	n ifNil: [^ nil].	isBinary and: [n isCharacter ifTrue: [^ n asciiValue]].	^ n.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'ar 4/12/2005 17:34'!next: anInteger 	| multiString |	"self halt."	self isBinary ifTrue: [^ (super next: anInteger) asByteArray].	multiString := WideString new: anInteger.	1 to: anInteger do: [:index |		| character |		(character := self next) ifNotNil: [			multiString at: index put: character		] ifNil: [			multiString := multiString copyFrom: 1 to: index - 1.			^ multiString		]	].	^ multiString.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'ul 1/31/2011 02:08'!next: anInteger putAll: aCollection startingAt: startIndex	(self isBinary or: [ aCollection class == ByteArray ]) ifTrue: [		^super next: anInteger putAll: aCollection startingAt: startIndex ].	^self converter next: anInteger putAll: aCollection startingAt: startIndex toStream: self! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 12/25/2003 16:05'!nextDelimited: terminator	| out ch pos |	out := WriteStream on: (String new: 1000).	self atEnd ifTrue: [^ ''].	pos := self position.	self next = terminator ifFalse: [		"absorb initial terminator"		self position: pos.	].	[(ch := self next) == nil] whileFalse: [		(ch = terminator) ifTrue: [			self peek = terminator ifTrue: [				self next.  "skip doubled terminator"			] ifFalse: [				^ out contents  "terminator is not doubled; we're done!!"			].		].		out nextPut: ch.	].	^ out contents.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 13:24'!nextMatchAll: aColl    | save |    save := converter saveStateOf: self.    aColl do: [:each |       (self next) = each ifFalse: [            converter restoreStateOf: self with: save.            ^ false.		].	].    ^ true.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'nice 3/19/2010 19:05'!nextPut: aCharacter	aCharacter isInteger ifTrue: [^ super nextPut: aCharacter asCharacter].	self converter nextPut: aCharacter toStream: self.	^aCharacter! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'nice 3/19/2010 19:14'!nextPutAll: aCollection	self isBinary ifTrue: [		^ super nextPutAll: aCollection.	].	^aCollection do: [:e | self nextPut: e].! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 12/25/2003 16:04'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "	| next pos |	self atEnd ifTrue: [^ nil].	pos := self position.	next := self next.	self position: pos.	^ next.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'ul 5/26/2010 04:13'!peekFor: item 	| next state |	"self atEnd ifTrue: [^ false]. -- SFStream will give nil"	state := converter saveStateOf: self.	(next := self next) ifNil: [^ false].	item = next ifTrue: [^ true].	converter restoreStateOf: self with: state.	^ false.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'cmm 10/23/2013 16:12'!remainingContents	| ret state |	state := converter saveStateOf: self.	ret := self upToEnd.	converter restoreStateOf: self with: state.	^ ret! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'nk 7/29/2004 12:02'!reset	super reset.	isBinary ifNil: [isBinary := false].	collection class == ByteArray ifTrue: ["Store as String and convert as needed."		collection := collection asString.		isBinary := true].	self converter. "ensure that we have a converter."! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'nice 1/18/2010 13:42'!setConverterForCode	| current |	current := converter saveStateOf: self.	self position: 0.	self binary.	((self next: 3) = #[ 16rEF 16rBB 16rBF ]) ifTrue: [		self converter: UTF8TextConverter new	] ifFalse: [		self converter: MacRomanTextConverter new.	].	converter restoreStateOf: self with: current.	self text.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 3/1/2005 06:46'!setConverterForCodeForProject	self converter: UTF8TextConverter new.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 7/7/2004 09:43'!setEncoderForSourceCodeNamed: streamName	| l |	l := streamName asLowercase."	((l endsWith: FileStream multiCs) or: [		(l endsWith: FileStream multiSt) or: [			(l endsWith: (FileStream multiSt, '.gz')) or: [				(l endsWith: (FileStream multiCs, '.gz'))]]]) ifTrue: [					self converter: UTF8TextConverter new.					^ self.	]."	((l endsWith: FileStream cs) or: [		(l endsWith: FileStream st) or: [			(l endsWith: (FileStream st, '.gz')) or: [				(l endsWith: (FileStream cs, '.gz'))]]]) ifTrue: [					self converter: MacRomanTextConverter new.					^ self.	].	self converter: UTF8TextConverter new.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/14/2002 13:49'!setFileTypeToObject	"do nothing.  We don't have a file type"! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 16:17'!skipSeparators	[self atEnd] whileFalse: [		self basicNext isSeparator ifFalse: [			^ self position: self position - 1]]! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 12/25/2003 16:04'!skipSeparatorsAndPeekNext	"A special function to make nextChunk fast"	| peek pos |	[self atEnd] whileFalse: [		pos := self position.		(peek := self next) isSeparator ifFalse: [			self position: pos.			^ peek.		].	].! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 16:33'!text	isBinary := false! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'nice 8/27/2010 20:49'!upTo: delim 	| out ch |	out := WriteStream on: (String new: 1000).	self atEnd ifTrue: [^ ''].	[(ch := self next) == nil] whileFalse: [		(ch = delim) ifTrue: [			^ out contents  "terminator is not doubled; we're done!!"		].		out nextPut: ch.	].	^ out contents.! !!MultiByteBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'yo 11/11/2002 16:17'!upToEnd	| newStream element newCollection |	newCollection := self isBinary				ifTrue: [ByteArray new: 100]				ifFalse: [String new: 100].	newStream := WriteStream on: newCollection.	[(element := self next) notNil]		whileTrue: [newStream nextPut: element].	^ newStream contents! !!MultiByteBinaryOrTextStream class methodsFor: 'as yet unclassified' stamp: 'yo 2/25/2005 20:04'!defaultConverter	^ Latin1TextConverter new.! !!MultiByteBinaryOrTextStream class methodsFor: 'as yet unclassified' stamp: 'ykoubo 9/28/2003 19:59'!on: aCollection encoding: encodingName 	| aTextConverter |	encodingName isNil		ifTrue: [aTextConverter := TextConverter default]		ifFalse: [aTextConverter := TextConverter newForEncoding: encodingName].	^ (self on: aCollection)		converter: aTextConverter! !!MultiByteBinaryOrTextStream class methodsFor: 'as yet unclassified' stamp: 'yo 11/23/2003 20:32'!with: aCollection encoding: encodingName 	| aTextConverter |	encodingName isNil		ifTrue: [aTextConverter := TextConverter default]		ifFalse: [aTextConverter := TextConverter newForEncoding: encodingName].	^ (self with: aCollection)		converter: aTextConverter! !!Behavior methodsFor: 'as yet unclassified' stamp: 'crl 3/25/2019 09:49'!depth	| depth class |		class := self.	depth := 0.		[class == nil] whileFalse: [		depth := depth + 1.		class := class superclass].		^depth! !!Behavior methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 16:33'!id	"Answer my ID."	^ClassID for: self! !!Behavior methodsFor: 'as yet unclassified' stamp: 'crl 3/14/2019 21:38'!includesSelector: aSymbol 	"Answer whether the message whose selector is the argument is in the 	method dictionary of the receiver's class."	^ (self methodDict includesKey: aSymbol) and: [(self methodDict at: aSymbol) class == CompiledMethod]! !!Behavior methodsFor: 'as yet unclassified' stamp: 'crl 3/19/2019 04:58'!newEditionForMethod: method at: selector withSource: source	| literalsArray instructions |	literalsArray := (		"Don't bother with the method properties or class binding."		(method literals copyFrom: 1 to: method literals size - 2) collect: [:literal | 			MethodLiteralTransmissionMarker				forLiteral: literal				inMethod: method				ofClass: self]).	(method primitive = 117) ifTrue: [		"Clear the cached session ID and function index from the special first literal that external-call methods have."		(literalsArray first literal)			at: 3 put: 0;			at: 4 put: 0].	instructions := (ByteArray new: method endPC - method initialPC + 1) writeStream.	method initialPC		to: method endPC		do: [:index | instructions nextPut: (method at: index)].		^(MethodEdition new)		id: (			MethodID				"The actual version will be assigned later."				forVersion: 0				ofMethodAt: selector				inActiveClass: self);		headerVersion: MethodEdition localHeaderVersion		instructions: instructions contents		literalMarkers: literalsArray		header: method header		primitive: method primitive		initialPC: method initialPC		endPC: method endPC		source: source		classEdition: self edition;		methodAuthor: Author current;		yourself! !!Behavior methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2019 16:45'!recompile: selector from: oldClass	"Compile the method associated with selector in the receiver's method dictionary."	"ar 7/10/1999: Use oldClass compiledMethodAt: not self compiledMethodAt:"	| method trailer methodNode |	method := oldClass compiledMethodAt: selector.	trailer := method trailer.	methodNode := self newCompiler				compile: (oldClass sourceCodeAt: selector)				in: self				notifying: nil				ifFail: [^ self].   "Assume OK after proceed from SyntaxError"	"selector == methodNode selector ifFalse: [self error: 'selector changed!!']."	self basicAddSelector: selector withMethod: (methodNode generate: trailer).! !!Behavior methodsFor: 'as yet unclassified' stamp: 'crl 3/16/2019 22:26'!swapOutMethodAt: selector	"Replace the method at selector with a method that swaps in the corresponding method from a tether."		self basicAddSelector: selector withMethod: SwapInThisMethod! !!Behavior class methodsFor: 'as yet unclassified' stamp: 'crl 3/23/2019 06:17'!initialize	"Behavior initialize"	"Never called for real"		| newReloadingMethod |		ObsoleteSubclasses		ifNil: [self initializeObsoleteSubclasses]		ifNotNil: [| newDict | 			newDict := WeakKeyToCollectionDictionary newFrom: ObsoleteSubclasses.			newDict rehash.			ObsoleteSubclasses := newDict].			newReloadingMethod := (		(			(self new)				compile: '					swapInThisMethod						"Swap in the corresponding method for this signature from a tethered system."												| selector |						selector := thisContext sender selectorJustSent.						[							| lookupClass newMethod |													lookupClass := self class.																						EditHistory swapInMethodAt: selector in: lookupClass.													[newMethod isNil and: [lookupClass notNil]] whileTrue: [								newMethod := (									lookupClass										compiledMethodAt: selector										ifAbsent: [											lookupClass := lookupClass superclass.											nil])].															newMethod								ifNil: [JS debugger]								ifNotNil: [newMethod isFused]						]							on: MessageNotUnderstood							do: [:exception |								JS console log: exception printString.								JS debugger].												thisContext method flushCache.						JS alert: ''about to resend''.						thisContext arguments inspectInJS.						^self perform: selector withArguments: thisContext arguments'				notifying: nil				trailer: self defaultMethodTrailer				ifFail: [^nil]		)			method).				newReloadingMethod		fuse;		setAsReloadingMethod.			SwapInThisMethod becomeForward: newReloadingMethod! !!Behavior class methodsFor: 'as yet unclassified' stamp: 'crl 3/23/2019 02:56'!reloadingMethod	^SwapInThisMethod! !!Behavior class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 18:16'!setReloadingMethod	"self setReloadingMethod"		| newReloadingMethod |	newReloadingMethod := self class compiledMethodAt: #swapInThisMethod.				newReloadingMethod fuse.			SwapInThisMethod		ifNil: [SwapInThisMethod := newReloadingMethod]		ifNotNil: [SwapInThisMethod becomeForward: newReloadingMethod]! !!Behavior class methodsFor: 'as yet unclassified' stamp: 'crl 9/9/2019 13:14'!swapInThisMethod	"Swap in the corresponding method for this signature from a tethered system."	"When this method is run, the arguments intended by the sender are copied by the virtual machine into the 'arguments' temporary variable."		| arguments selector lookupClass newMethod |		JS isConnected ifFalse: [3 error: 'This feature requires support lacking in the current virtual machine.'].			selector := thisContext sender selectorJustSent.	lookupClass := self class.		[		lookupClass ifNil: [3 halt: 'method ', selector, ' for a ', self class printString, ' not found'].		(lookupClass includesSelector: selector) and: [(lookupClass compiledMethodAt: selector) == SwapInThisMethod]	]		whileFalse: [lookupClass := lookupClass superclass].	EditHistory swapInMethodAt: selector in: lookupClass.		[newMethod isNil and: [lookupClass notNil]] whileTrue: [		newMethod := (			lookupClass				compiledMethodAt: selector				ifAbsent: [					lookupClass := lookupClass superclass.					nil])].				newMethod ifNil: [		JS			alert: 'method not installed';			debugger].			thisContext method flushCache.			^self		perform: selector		withArguments: arguments! !!SetInspector class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!Trait methodsFor: 'as yet unclassified' stamp: 'ar 12/22/2009 08:48'!asClassDefinition	^Smalltalk at: #MCTraitDefinition ifPresent:[:aClass|		aClass			name: self name			traitComposition: self traitCompositionString			category: self category 			comment: self organization classComment asString			commentStamp: self organization commentStamp].! !!Trait methodsFor: 'as yet unclassified' stamp: 'ar 12/29/2009 18:34'!asTraitComposition	"Convert me into a trait composition"	^TraitComposition with: self! !!Trait methodsFor: 'as yet unclassified' stamp: 'ar 12/21/2009 19:49'!baseTrait	^self! !!Trait methodsFor: 'as yet unclassified' stamp: 'ar 12/21/2009 20:17'!bindingOf: varName	"Answer the binding of some variable resolved in the scope of the receiver"	^self environment bindingOf: varName asSymbol.! !!Trait methodsFor: 'as yet unclassified' stamp: 'ar 11/18/2007 15:37'!category	"Answer the system organization category for the receiver. First check whether the	category name stored in the ivar is still correct and only if this fails look it up	(latter is much more expensive)"	| result |	category ifNotNilDo: [ :symbol |		((SystemOrganization listAtCategoryNamed: symbol) includes: self name)			ifTrue: [ ^symbol ] ].	category := (result := SystemOrganization categoryOfElement: self name).	^result! !!Trait methodsFor: 'as yet unclassified' stamp: 'ar 11/18/2007 15:38'!category: aString 	"Categorize the receiver under the system category, aString, removing it from 	any previous categorization."	| oldCategory |	oldCategory := category.	aString isString		ifTrue: [			category := aString asSymbol.			SystemOrganization classify: self name under: category ]		ifFalse: [self errorCategoryName].	SystemChangeNotifier uniqueInstance		class: self recategorizedFrom: oldCategory to: category! !!Trait methodsFor: 'as yet unclassified' stamp: 'nice 1/1/2010 21:49'!classDefinitions	| definitions |	definitions := OrderedCollection with: self asClassDefinition.	(self hasClassTrait		and: [self classTrait hasTraitComposition		and: [self classTrait traitComposition isEmpty not]])			ifTrue: [definitions add: self classTrait asMCDefinition].	^definitions asArray! !!Trait methodsFor: 'as yet unclassified' stamp: 'ar 12/30/2009 02:31'!classTrait	^classTrait! !!Trait methodsFor: 'as yet unclassified' stamp: 'ar 12/27/2009 19:40'!definition	^String streamContents: [:stream |		stream nextPutAll: 'Trait named: ';				store: self name.		stream cr; tab; nextPutAll: 'uses: ';				nextPutAll: self traitComposition asString.		stream cr; tab; nextPutAll: 'category: ';				store: self category asString].! !!Trait methodsFor: 'as yet unclassified' stamp: 'ar 11/18/2007 15:37'!environment	^environment! !!Trait methodsFor: 'as yet unclassified' stamp: 'ar 11/18/2007 15:37'!environment: anObject	environment := anObject! !!Trait methodsFor: 'as yet unclassified' stamp: 'ar 12/19/2009 18:06'!fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex	super fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex.	self classSide hasMethods ifTrue:[		aFileStream cr; nextPutAll: '"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!!'; cr; cr.			self classSide				fileOutOn: aFileStream				moveSource: moveSource				toFile: fileIndex].! !!Trait methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2008 01:57'!hasClassTrait	^true! !!Trait methodsFor: 'as yet unclassified' stamp: 'ar 12/30/2009 01:59'!initialize	super initialize.	classTrait := ClassTrait for: self.! !!Trait methodsFor: 'as yet unclassified' stamp: 'ar 11/18/2007 22:59'!isBaseTrait	^true! !!Trait methodsFor: 'as yet unclassified' stamp: 'ar 11/18/2007 15:41'!isObsolete	"Return true if the receiver is obsolete."	^(self environment at: name ifAbsent: [nil]) ~~ self! !!Trait methodsFor: 'as yet unclassified' stamp: 'nice 1/1/2010 22:06'!isValidTraitName: aSymbol	^(aSymbol isEmptyOrNil		or: [aSymbol first isLetter not		or: [aSymbol anySatisfy: [:character | character isAlphaNumeric not]]]) not! !!Trait methodsFor: 'as yet unclassified' stamp: 'ar 11/18/2007 15:37'!name	^name! !!Trait methodsFor: 'as yet unclassified' stamp: 'ar 11/18/2007 15:37'!name: aSymbol	name := aSymbol! !!Trait methodsFor: 'as yet unclassified' stamp: 'ar 12/30/2009 01:55'!obsolete	self name: ('AnObsolete' , self name) asSymbol.	self classTrait obsolete.	super obsolete! !!Trait methodsFor: 'as yet unclassified' stamp: 'crl 3/26/2019 20:14'!removeFromSystem	self removeFromSystem: false! !!Trait methodsFor: 'as yet unclassified' stamp: 'ar 11/28/2007 21:00'!removeFromSystem: logged	self environment forgetClass: self logged: logged.	self obsolete! !!Trait methodsFor: 'as yet unclassified' stamp: 'nice 11/1/2013 23:56'!rename: aString 	"The new name of the receiver is the argument, aString."	| newName |	(newName := aString asSymbol) ~= self name		ifFalse: [^ self].	(self environment includesKey: newName)		ifTrue: [^ self error: newName , ' already exists'].	((self environment undeclared includesKey: newName)		and: [(self environment undeclared unreferencedKeys includes: newName) not])		ifTrue: [self inform: 'There are references to, ' , aString printString , 'from Undeclared. Check them after this change.'].	self environment renameClass: self as: newName.	name := newName! !!Trait methodsFor: 'as yet unclassified' stamp: 'cwp 4/29/2013 10:49'!setName: aSymbol andRegisterInCategory: categorySymbol environment: aSystemDictionary	(self isValidTraitName: aSymbol) ifFalse: [self error:'Invalid trait name'].	(self environment == aSystemDictionary		and: [self name = aSymbol			and: [self category = categorySymbol]]) ifTrue: [^self].			((aSystemDictionary includesKey: aSymbol) and: [(aSystemDictionary at: aSymbol) ~~ self])		ifTrue: [self error: 'The name ''' , aSymbol , ''' is already used'].	(self environment notNil and: [self name notNil and: [self name ~= aSymbol]]) ifTrue: [		self environment renameClass: self as: aSymbol].		self name: aSymbol.	self environment: aSystemDictionary.		[self environment at: self name put: self]		on: AttemptToWriteReadOnlyGlobal		do: [:n | n resume: true].	self environment organization classify: self name under: categorySymbol.	^ true! !!Trait methodsFor: 'as yet unclassified' stamp: 'ar 12/30/2009 01:55'!theMetaClass	^self classTrait! !!Trait methodsFor: 'as yet unclassified' stamp: 'cwp 1/10/2014 10:19'!unload	"For polymorphism with classes. Do nothing"! !!Trait class methodsFor: 'as yet unclassified' stamp: 'ul 9/28/2012 10:29'!allTraitsDo: aBlock	"Evaluate aBlock with all the instance and class traits present in the system"		Smalltalk allTraitsDo: [ :aTrait |		aBlock			value: aTrait instanceSide;			value: aTrait classSide ]! !!Trait class methodsFor: 'as yet unclassified' stamp: 'ar 3/5/2010 21:10'!convertClassToTrait: aClass	"Convert the given class to a trait"	| aTrait |	"Move the class out of the way"	aClass environment removeKey: aClass name.	"Create the trait in its place"	aTrait := Trait named: aClass name				uses: {}				category: aClass category.	aClass organization commentRemoteStr ifNotNil:[		aTrait classComment: aClass organization classComment 				stamp: aClass organization commentStamp].	aClass selectorsAndMethodsDo:[:sel :meth|		aTrait compile: (aClass sourceCodeAt: sel)			classified: (aClass organization categoryOfElement: sel)			withStamp: (aClass compiledMethodAt: sel) timeStamp			notifying: nil].	aClass classSide selectorsAndMethodsDo:[:sel :meth|		aTrait classSide compile: (aClass classSide sourceCodeAt: sel)			classified: (aClass classSide organization categoryOfElement: sel)			withStamp: (aClass classSide compiledMethodAt: sel) timeStamp			notifying: nil].	aClass obsolete.	^aTrait! !!Trait class methodsFor: 'as yet unclassified' stamp: 'ar 3/5/2010 21:11'!convertTraitToClass: aTrait	"Convert the given trait to a class"	| aClass |	"Move the trait out of the way"	aTrait environment removeKey: aTrait name.	"Create the class in its place"	aClass := Object subclass: aTrait name				instanceVariableNames: ''				classVariableNames: ''				poolDictionaries: ''				category: aTrait category.	aTrait organization commentRemoteStr ifNotNil:[		aClass classComment: aTrait organization classComment 				stamp: aTrait organization commentStamp].	aTrait selectorsAndMethodsDo:[:sel :meth|		aClass compile: (aTrait sourceCodeAt: sel)			classified: (aTrait organization categoryOfElement: sel)			withStamp: (aTrait compiledMethodAt: sel) timeStamp			notifying: nil].	aTrait classSide selectorsAndMethodsDo:[:sel :meth|		aClass classSide compile: (aTrait classSide sourceCodeAt: sel)			classified: (aTrait classSide organization categoryOfElement: sel)			withStamp: (aTrait classSide compiledMethodAt: sel) timeStamp			notifying: nil].	aTrait obsolete.	^aClass! !!Trait class methodsFor: 'as yet unclassified' stamp: 'nice 1/10/2010 17:46'!flattenTraitMethodsInClass: aClass	"Flatten all the trait methods in the given class"		(aClass isTrait or:[aClass hasTraitComposition]) ifFalse:[^self].	self storeTraitInfoInClass: aClass.	aClass selectorsAndMethodsDo:[:sel :meth| | oldClass |		(aClass includesLocalSelector: sel) ifFalse:[			oldClass := meth methodHome.			aClass compile: (aClass sourceCodeAt: sel)				classified: (aClass organization categoryOfElement: sel)				withStamp: (oldClass compiledMethodAt: sel ifAbsent:[meth]) timeStamp				notifying: nil]].	aClass traitComposition: #().! !!Trait class methodsFor: 'as yet unclassified' stamp: 'ar 1/1/2010 20:09'!initialize	"Install after loading"	self install.! !!Trait class methodsFor: 'as yet unclassified' stamp: 'ar 1/1/2010 20:09'!install	"Make me the default Trait implementation"	ClassDescription traitImpl: self.	"And restore any previously flattened traits"	self restoreAllTraits.! !!Trait class methodsFor: 'as yet unclassified' stamp: 'ar 12/27/2009 14:12'!named: aSymbol uses: aTraitCompositionOrCollection category: aString	"Dispatch through ClassDescription for alternative implementations"	^ClassDescription newTraitNamed: aSymbol uses: aTraitCompositionOrCollection category: aString! !!Trait class methodsFor: 'as yet unclassified' stamp: 'ar 3/11/2010 08:47'!named: aSymbol uses: aTraitComposition category: aString env: anEnvironment	| trait oldTrait systemCategory |	systemCategory := aString asSymbol.	trait := anEnvironment at: aSymbol ifAbsent: [nil].	(trait == nil or:[trait isMemberOf: Trait]) ifFalse: [		^self error: trait name , ' is not a Trait'].	oldTrait := trait shallowCopy.	trait ifNil:[trait := Trait new].	trait		setName: aSymbol		andRegisterInCategory: systemCategory		environment: anEnvironment.	trait uses: aTraitComposition.		"... notify interested clients ..."	oldTrait ifNil:[		SystemChangeNotifier uniqueInstance classAdded: trait inCategory: systemCategory.	] ifNotNil:[		SystemChangeNotifier uniqueInstance traitDefinitionChangedFrom: oldTrait to: trait.		systemCategory = oldTrait category  ifFalse:[			SystemChangeNotifier uniqueInstance class: trait 				recategorizedFrom: oldTrait category to: systemCategory].	].	^ trait! !!Trait class methodsFor: 'as yet unclassified' stamp: 'ar 12/27/2009 19:07'!newTemplateIn: categoryString	^String streamContents: [:stream |		stream			nextPutAll: 'Trait named: #NameOfTrait';			cr; tab;			nextPutAll: 'uses: {}';			cr; tab;			nextPutAll: 'category: ';			nextPut: $';			nextPutAll: categoryString;			nextPut: $' ]! !!Trait class methodsFor: 'as yet unclassified' stamp: 'ar 12/29/2009 18:20'!newTraitComposition	"Creates a new TraitComposition"	^TraitComposition new! !!Trait class methodsFor: 'as yet unclassified' stamp: 'ar 12/27/2009 14:11'!newTraitNamed: aSymbol uses: aTraitCompositionOrCollection category: aString	"Creates a new trait."	| env |	env := self environment.	^self		named: aSymbol		uses: aTraitCompositionOrCollection		category: aString		env: env! !!Trait class methodsFor: 'as yet unclassified' stamp: 'ar 1/1/2010 18:52'!removeAllTraits		"Trait removeAllTraits"	"Removes all traits currently in use. 	Preserves enough information so that traits can be recovered."	| converted remain |	converted := Set new.	Smalltalk allClasses do:[:aClass|		self flattenTraitMethodsInClass: aClass classSide.		self flattenTraitMethodsInClass: aClass.		converted add: aClass.	] displayingProgress: 'Flattening classes'.	remain := Smalltalk allTraits asSet.	(1 to: remain size) do:[:i| | trait |		trait := remain 			detect:[:any| any users allSatisfy:[:aClass| converted includes: aClass]]			ifNone:[self error: 'Cyclic traits detected'].		remain remove: trait.		self flattenTraitMethodsInClass: trait classSide.		self flattenTraitMethodsInClass: trait.		converted add: trait.	] displayingProgress: 'Flattening traits'.	"Convert all traits to classes"	Smalltalk allTraits		do:[:trait| self convertTraitToClass: trait] 		displayingProgress:[:trait| 'Converting ', trait name].! !!Trait class methodsFor: 'as yet unclassified' stamp: 'nice 1/10/2010 17:46'!restoreAllTraits		"Trait restoreAllTraits"	"Restores traits that had been previously removed.	This is the inverse operation to removeAllTraits."	| classes |	classes := Smalltalk allClasses select:[:aClass| aClass includesSelector: #traitInfo].	classes do:[:aClass| | method |		method := aClass compiledMethodAt: #traitInfo.		(method pragmaAt: #traitDefinition:) ifNotNil:[:pragma| 			pragma arguments first				ifTrue:[self convertClassToTrait: aClass]].	] displayingProgress:[:aClass| 'Creating trait ', aClass name].	classes := Smalltalk allClassesAndTraits select:[:aClass| 		(aClass includesSelector: #traitInfo) 			or:[aClass classSide includesSelector: #traitInfo]].	classes do:[:aClass|		self restoreCompositionOf: aClass.		self restoreCompositionOf: aClass classSide.	] displayingProgress:[:aClass| 'Updating ', aClass name].! !!Trait class methodsFor: 'as yet unclassified' stamp: 'ar 1/1/2010 18:24'!restoreCompositionOf: aClass	"Restore the trait composition for the given class"	| method requires composition |	method := aClass compiledMethodAt: #traitInfo ifAbsent:[^self].	aClass removeSelector: #traitInfo.	requires := (method pragmaAt: #traitRequires:) 		ifNil:[#()]		ifNotNil:[:pragma| pragma arguments first].	(requires allSatisfy:[:tn| (Smalltalk at: tn ifAbsent:[nil]) isKindOf: Trait])		ifFalse:[^self inform: 'Cannot restore composition of ', aClass name].	composition := (method pragmaAt: #traitComposition:) 		ifNil:[^self]		ifNotNil:[:pragma| Compiler evaluate: pragma arguments first].	aClass uses: composition.	aClass traitComposition selectorsAndMethodsDo:[:sel :meth|		| oldMethod newMethod |		newMethod := meth methodHome compiledMethodAt: sel.		oldMethod := aClass compiledMethodAt: sel ifAbsent:[newMethod].		oldMethod timeStamp = newMethod timeStamp				ifTrue:[aClass removeSelector: sel]].! !!Trait class methodsFor: 'as yet unclassified' stamp: 'ar 1/1/2010 17:01'!storeTraitInfoInClass: aClass	"Store trait information in the given class"	| code |	code := WriteStream on: (String new: 100).	code nextPutAll: 'traitInfo	"This method contains information to restore the trait structure	for the receiver when traits are loaded or unloaded"'.	aClass isTrait ifTrue:[		code crtab; nextPutAll: '"This class was originally a trait"'.		code crtab; nextPutAll: '<traitDefinition: true>'.	].	aClass hasTraitComposition ifTrue:[		code crtab; nextPutAll: '"The trait composition for the receiver"'.		code crtab; nextPutAll: '<traitComposition: ', aClass traitCompositionString storeString,'>'.		code crtab; nextPutAll: '"The required traits for this trait"'.		code crtab; nextPutAll: '<traitRequires: ', (aClass traits collect:[:t| t baseTrait name]),'>'.	].	aClass compile: code contents.! !!Trait class methodsFor: 'as yet unclassified' stamp: 'ul 4/25/2015 11:34'!unloadTraits	"Trait unloadTraits"	Trait traitImpl == self ifTrue:[Trait traitImpl: nil].	self removeAllTraits.	Behavior compileSilently: 'updateTraits' classified: 'accessing'.	ClassDescription removeSelectorSilently: #updateTraits.	ClassOrganizer organization classify: #traitComposition under: 'accessing'.	(MCPackage named: 'Traits') unload.	ClassOrganizer removeSelectorSilently: #traitComposition.	Behavior removeSelectorSilently: #updateTraits.	CurrentReadOnlySourceFiles cacheDuring: [		Compiler recompileAll ]! !!MIDIChannel methodsFor: 'as yet unclassified' stamp: 'crl 1/19/2003 18:11'!appliedTo: anObject	"Answer anObject, after applying myself to it."	^anObject applyChannel: self! !!MIDIChannel methodsFor: 'as yet unclassified' stamp: 'crl 1/31/2003 23:51'!applyMIDIController: aMIDIController	"Answer myself after applying aMIDIController."	^(ControlChange changing: aMIDIController to: nil) applyChannel: self! !!MIDIChannel methodsFor: 'as yet unclassified' stamp: 'crl 1/24/2003 00:27'!applyPitch: aPitch	"Answer myself after applying aPitch."	^(Note withPitch: aPitch) applyChannel: self! !!MIDIChannel methodsFor: 'as yet unclassified' stamp: 'crl 9/17/2005 02:42'!applyScaleDegree: aScaleDegree	^(Note withDegree: aScaleDegree), self! !!MIDIChannel methodsFor: 'as yet unclassified' stamp: 'crl 1/21/2003 10:01'!name	"Answer a String describing me in general."	^'channel'! !!MIDIChannel methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2004 21:15'!storeOn: aStream	aStream		store: index th;		nextPutAll: ' channel'! !!ReplaceExistingFileException class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!ByteArray methodsFor: 'as yet unclassified' stamp: 'crl 2/15/2019 11:37'!asJSArgument	^self! !!ByteArray methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 03:27'!recyclingHash	^0! !!ByteArray methodsFor: 'as yet unclassified' stamp: 'crl 7/20/2018 10:20'!setBytesFrom: arrayBuffer	<primitive: 'setBytesFrom' module: 'Flow'>	self primitiveFailed! !!ByteArray methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 03:45'!storeElementsOnTether: tether	tether nextPutAll: self! !!ByteArray methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 03:50'!tag	"Answer my transmission tag."	^ByteArrayTag! !!ByteArray class methodsFor: 'as yet unclassified'!fromTether: tether	^self withAll: (tether next: tether nextWord)! !!TetherConstants methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:52'!foo! !!TetherConstants class methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 18:03'!initialize	"Initialize myself."	| tagNames |	tagNames := #(		TrueTag		FalseTag		NilTag		SymbolTag		StringTag		CounterpartRequestTag		MessageSendTag		ArrayTag		MethodTag		FloatTag		CharacterTag		AssociationTag		MethodDictionaryTag		NegativeNumberTag		LargePositiveIntegerTag		LargeNegativeIntegerTag		UUIDTag		MethodIDTag		SetTag		ClassLiteralMarkerTag		ClassVariableLiteralMarkerTag		MetaSuperSendLiteralMarkerTag		UndeclaredLiteralMarkerTag		GlobalLiteralMarkerTag		PositiveManifestTag		NegativeManifestTag		ByteArrayTag		ExceptionMarkerTag		AnswerTag		OrderedCollectionTag		IntervalTag		SortedCollectionTag		MessageTag		ClassIDTag		DictionaryTag		PublishedVariableLiteralMarkerTag		InstallRemoteModuleTag		BrowseAvailableModulesTag		ModuleDescriptionTag		AuthorIDTag		VersionTag		GPLTag		ApacheTag		SqueakTag		MITTag		GPL3Tag		MethodEditionTag		ProtoclassEditionTag		MetaclassEditionTag		IdentityLiteralMarkerTag		EditTag		AuthorTag		CommentEditionTag		TagsEditionTag		CheckpointTag		PublishedVariableDictionaryLiteralMarkerTag		ModuleIDTag		ModuleEditionTag		MemoryProfileTag		ScaledDecimalTag		FractionTag		WideSymbolTag		WideStringTag).	InstructionsBase := 2r11100000000000000000000000000000.	OtherMarkerTagBase := 2r11000000000000000000000000000001.	SmallIntegerTagBase := 2r10000000000000000000000000000000.	ClassTagsBase := 2r01000000000000000000000000000000.	1		to: tagNames size		do: [:index |			classPool				at: (tagNames at: index)				put: 2r01000000000000000000000000000000 + index].				SpecialVariables := (		(Dictionary new)			at: true put: TrueTag;			at: false put: FalseTag;			at: nil put: NilTag;			yourself).	Classes := (		(Dictionary new)			at: SymbolTag put: Symbol;			at: StringTag put: String;			at: MessageSendTag put: Tether;			at: CounterpartRequestTag put: CounterpartRequest;			at: ArrayTag put: Array;			at: MethodTag put: CompiledMethod;			at: FloatTag put: Float;			at: CharacterTag put: Character;			at: AssociationTag put: Association;			at: MethodDictionaryTag put: MethodDictionary;			at: NegativeNumberTag put: Number;			at: LargePositiveIntegerTag put: LargePositiveInteger;			at: LargeNegativeIntegerTag put: LargeNegativeInteger;			at: UUIDTag put: UUID;			at: ClassIDTag put: ClassID;			at: MethodIDTag put: MethodID;			at: SetTag put: Set;			at: ClassLiteralMarkerTag put: ClassLiteralMarker;			at: ClassVariableLiteralMarkerTag put: ClassVariableLiteralMarker;			at: MetaSuperSendLiteralMarkerTag put: MetaSuperSendLiteralMarker;			at: UndeclaredLiteralMarkerTag put: UndeclaredLiteralMarker;			at: GlobalLiteralMarkerTag put: GlobalLiteralMarker;			at: PositiveManifestTag put: PositiveManifest;			at: NegativeManifestTag put: NegativeManifest;			at: ByteArrayTag put: ByteArray;			at: ExceptionMarkerTag put: ExceptionMarker;			at: AnswerTag put: RemoteMessageAnswer;			at: OrderedCollectionTag put: OrderedCollection;			at: IntervalTag put: Interval;			at: SortedCollectionTag put: SortedCollection;			at: MessageTag put: Message;			at: DictionaryTag put: Dictionary;			at: PublishedVariableLiteralMarkerTag put: PublishedVariableLiteralMarker;			at: InstallRemoteModuleTag put: InstallRemoteModule;			at: BrowseAvailableModulesTag put: BrowseAvailableModules;			at: ModuleDescriptionTag put: ModuleDescription;			at: VersionTag put: Version;			at: GPLTag put: GPL;			at: GPL3Tag put: GPL3;			at: ApacheTag put: Apache;			at: MITTag put: MIT;			at: SqueakTag put: SqueakLicense;			at: MethodEditionTag put: MethodEdition;			at: ProtoclassEditionTag put: ProtoclassEdition;			at: MetaclassEditionTag put: MetaclassEdition;			at: IdentityLiteralMarkerTag put: IdentityLiteralMarker;			at: EditTag put: Edit;			at: AuthorTag put: Author;			at: CommentEditionTag put: CommentEdition;			at: TagsEditionTag put: TagsEdition;			at: CheckpointTag put: Checkpoint;			at: PublishedVariableDictionaryLiteralMarkerTag put: PublishedVariableDictionaryLiteralMarker;			at: ModuleIDTag put: ModuleID;			at: ModuleEditionTag put: ModuleEdition;			at: MemoryProfileTag put: MemoryProfile;			at: ScaledDecimalTag put: ScaledDecimal;			at: FractionTag put: Fraction;			at: WideSymbolTag put: WideSymbol;			at: WideStringTag put: WideString;			yourself)! !!TetherConstants class methodsFor: 'as yet unclassified' stamp: 'crl 8/29/2016 21:46'!instructionsBase	^InstructionsBase! !!MouseMoveEvent class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !!UndeclaredVariableWarning class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:53'!foo! !!ServicePreferences methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:50'!foo! !!Vue methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:54'!foo! !!Vue class methodsFor: 'as yet unclassified' stamp: 'crl 3/28/2019 15:03'!ensureLoadedInto: webpage	| loaded |		loaded := Semaphore new.		(webpage window at: #Vue)		ifNil: [			self				loadInto: webpage				then: [loaded signal]]		ifNotNil: [loaded signal].			loaded wait! !!Vue class methodsFor: 'as yet unclassified' stamp: 'crl 4/1/2019 01:20'!fribbly	^88! !!Vue class methodsFor: 'as yet unclassified' stamp: 'crl 3/28/2019 15:00'!loadInto: webpage then: block	webpage		loadScriptFrom: 'https://unpkg.com/vue'		then: [			webpage				loadScriptFrom: 'https://unpkg.com/http-vue-loader'				then: block]! !!WeakValueDictionary class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2019 09:51'!foo! !Smalltalk condenseChanges!----QUIT----{18 September 2019 . 1:11:47 am} caffeine.image priorSource: 1468101!----STARTUP----{18 September 2019 . 1:18:19 am} as /Users/craig/Downloads/caffeine/Caffeine Helper 2/memories/caffeine.image!'From 2019.3 [latest update: #2019.3] on 17 September 2019 at 10:17:47 pm'!Caffeine methodsFor: 'as yet unclassified' stamp: 'crl 9/17/2019 21:04'!!Caffeine methodsFor: 'as yet unclassified' stamp: 'crl 9/17/2019 21:04' prior: 34437212!initialize
	super initialize.
	(window document getElementById: 'sqSpinner') beOpaque! !Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/17/2019 21:16'!!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/17/2019 21:16' prior: 33998905!fullscreen: fullscreen
	"Set fullscreen mode accordingly."

	(Fullscreen == fullscreen) ifFalse: [
		Fullscreen := fullscreen.
		ContainingCanvas
			ifNil: [
				(Project current lastScreenModeSelected == fullscreen) ifFalse: [
					fullscreen
						ifTrue: [Project current fullScreenOn]
						ifFalse: [Project current fullScreenOff]]]
			ifNotNil: [
				3 ifNotNil: [
					| newWidth newHeight newX newY |
				
					ContainingFrame ifNotNil: [ContainingFrame
						styleAt: #transition put: '';
						beTransparent].

					JS touch at: #orig put: nil.
	
					fullscreen
						ifTrue: [
							self captureCurrentExtent.
							newWidth := JS innerWidth - 4.
							newHeight := JS innerHeight - 4.
							newX := newY := 2.

							ContainingDiv
								styleAt: #boxShadow put: '';
								styleAt: #border put: '']
						ifFalse: [
							newWidth := OldWidth.
							newHeight := OldHeight.
							newX := OldX.
							newY := OldY.

							ContainingDiv
								styleAt: #boxShadow put: '1px 1px 7px #999, 2px 2px 8px #999, 3px 3px 9px #999';
								styleAt: #border put: '2px inset gray'].
				
					self bounds: ((newX @ newY) extent: (newWidth @ newHeight)).
				
					[
						(Delay forMilliseconds: 500) wait.
						ContainingFrame ifNotNil: [ContainingFrame styleAt: #transition put: 'opacity 500ms'.
						ContainingFrame beOpaque]
					]
						fork]]]! !Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/17/2019 21:47'!!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/17/2019 21:47' prior: 34005425!startUp: resuming
	"After a system resumption, if the system is being run by SqueakJS in a web browser, reset constants related to that web browser's JavaScript environment."

	| forceToScreen |
	resuming ifTrue: [
		(self == Webpage)
			ifTrue: [
				Fullscreen := false.
				
				Top := TopDocument := ContainingDiv := ContainingCanvas := ContainingFrame := Current := Options := nil.

				Preferences
					setPreference: #fastDragWindowForMorphic
					toValue: JS isConnected.
				
				JS ifConnected: [
					| url |
										
					Top := [JS top counterpart magicWindow] on: Error do: [:exception | JS window].
					url := (
						Top
							ifNil: [String randomOfLength: 5]
							ifNotNil: [
								TopDocument := Top document.
								Url absoluteFromText: Top location href asString]).
					Options := (
						(JS SqueakJS options at: #parameters)
							ifNil: [nil]
							ifNotNil: [JS SqueakJS options parameters counterpart]).
							
					ContainingCanvas := JS document counterpart getElementById: 'squeak'.

					ContainingCanvas
						at: #width put: Options width;
						at: #height put: Options height.
						
					Top ifNotNil: [ContainingFrame := Top document getElementById: #Caffeine].
					ContainingCanvas ifNotNil: [
						ContainingDiv := (
							ContainingFrame
								ifNil: [ContainingCanvas parentNode]
								ifNotNil: [
									self styleAt: #transition put: 'opacity 500ms'.
									ContainingFrame parentNode parentNode]).
						ContainingDiv at: #onresize put: [self resize].
						ContainingCanvas at: #tabIndex put: 0.
						self captureCurrentExtent.

						ContainingCanvas onclick: [self focus]].
					
					forceToScreen := [:event | Display forceToScreen].

					Top
						at: #onresize
						put: forceToScreen; 						at: #onscroll
						put: forceToScreen;
						at: #onorientationchange
						put: [:event |
							forceToScreen value: event.
							self scrollToTop].
										
					ContainingCanvas ifNotNil: [
						ContainingCanvas
							styleAt: 'user-select'
							put: [false]].

					Pages
						at: url
						ifAbsent: [
							self
								ifOptionAt: 'appID'
								then: [:appID |
									| appClass |
									
									appClass := self allSubclasses detect: [:subclass | subclass appID = appID] ifNone: [nil].
									appClass
										ifNil: [nil]
										ifNotNil: [
											Pages
												at: url
												put: (appClass fromURL: url)]]
								else: [nil]]]]]! !Webpage methodsFor: 'as yet unclassified' stamp: 'crl 9/17/2019 21:52'!!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 9/17/2019 21:52' prior: 33987950!scrollToBottom
	self window scrollTo: 0 with: 900! !----End fileIn of /Users/craig/Downloads/debugging.st----!----QUIT----{18 September 2019 . 1:18:42 am} caffeine.image priorSource: 1468129!----STARTUP----{18 September 2019 . 1:19:31 am} as /SqueakJS/caffeine.image!!CaffeineExtension methodsFor: 'as yet unclassified' stamp: 'crl 9/18/2019 01:25' prior: 33657352!initialize	"Connect to the Caffeine Helper web browser extension."		tabs := IdentityDictionary new.	promises := IdentityDictionary new.	nextPromiseID := 1.	port := JS chrome runtime connect: 'kfifbhlilndoognbpbaipgbhfphcldnp'.		port onMessage addListener: [:message |		(message at: 'method')			ifNil: [				"Resolve a promised answer from the extension."								| promise |								promise := promises at: (message at: 'promiseID') ifAbsent: [nil].								promise ifNotNil: [promise resolveWith: (message at: 'result') counterpart simplestRepresentation]]			ifNotNil: [				"Handle a message from the web browser."								| tabID |								tabID := message at: 'tabID'.				(					ChromeMethodInvocation						fromDictionary: message counterpart simplestRepresentation						for: (							tabs								at: tabID								ifAbsent: [									tabs										at: tabID										put: (											(ChromeTab new)												initializeFromTabInfo: (tabInfo detect: [:tab | tab id = tabID]);												transport: self;												yourself)])				)					perform]].			self getTabInfo! !JS at: #foobly put: port!| request |request := JS XMLHttpRequest new.	request		open: 'GET'		with: 'http://127.0.0.1:9222/json/list';		send!----STARTUP----{18 September 2019 . 1:40:17 am} as /SqueakJS/caffeine.image!----SNAPSHOT----{18 September 2019 . 1:41:39 am} caffeine.image priorSource: 1473117!| request |request := JS XMLHttpRequest new.request	open: 'GET'	with: 'http://127.0.0.1:9222/json/list';	responseType: 'text';	addEventListener: 'load'	with: [3 halt];	send!JS chrome!JS chrome runtime connect: {#name -> 'devtools-page'}!JS chrome runtime connect: {#name -> 'devtools_page'}!JS at: #foobly put: self!JS chrome devtools inspectedWindow tabId!!CaffeineExtension methodsFor: 'as yet unclassified' stamp: 'crl 9/18/2019 02:06' prior: 33657352!initialize	"Connect to the Caffeine Helper web browser extension."		tabs := IdentityDictionary new.	promises := IdentityDictionary new.	nextPromiseID := 1.	port := JS chrome runtime connect: 'kfifbhlilndoognbpbaipgbhfphcldnp'.		port onMessage addListener: [:message |		(message at: 'method')			ifNil: [				"Resolve a promised answer from the extension."								| promise |								promise := promises at: (message at: 'promiseID') ifAbsent: [nil].								promise ifNotNil: [promise resolveWith: (message at: 'result') counterpart simplestRepresentation]]			ifNotNil: [				"Handle a message from the web browser."								| tabID |								tabID := message at: 'tabID'.				(					ChromeMethodInvocation						fromDictionary: message counterpart simplestRepresentation						for: (							tabs								at: tabID								ifAbsent: [									tabs										at: tabID										put: (											(ChromeTab new)												initializeFromTabInfo: (tabInfo detect: [:tab | tab id = tabID]);												transport: self;												yourself)])				)					perform]].			self getTabInfo! !----SNAPSHOT----{18 September 2019 . 2:06:45 am} caffeine.image priorSource: 1474711!JS chrome devtools inspectedWindow getResources: [:result | 3 halt]!JS chrome devtools inspectedWindow reload!JS chrome devtools inspectedWindow reload!JS chrome devtools inspectedWindow reload!----SNAPSHOT----{18 September 2019 . 2:10:44 am} caffeine.image priorSource: 1476380!----STARTUP----{18 September 2019 . 2:12:41 am} as /SqueakJS/caffeine.image!JS chrome devtools inspectedWindow reload!JS chrome devtools inspectedWindow tabId!JS chrome devtools inspectedWindow reload!(JS chrome tabs)	get: JS chrome devtools inspectedWindow tabId	with: [:tab | 3 halt]!JS at: #foobly put: tab!JS chrome debugger at: #sendCommand	!JS chrome debugger at: #sendCommand!JS chrome devtools inspectedWindow getResources: [:result | 3 halt]!JS chrome devtools inspectedWindow tabId!JS chrome debugger at: #DetachReason!JS chrome debugger!3!JS chrome!JS chrome debugger!EditHistory connectTo: 'ws://localhost:8091/tether'.!JS chrome debugger!JS at: #foobly put: JS chrome debugger!JS chrome debugger!JS at: #foobly put: self!JS at: #foobly put: (JS chrome at: #debugger)!(JS chrome at: #debugger)	sendCommand: {#tabId -> 50}	with: 'Debugger.resume'!(JS chrome at: #debugger) detach: {#tabId -> 50}!----SNAPSHOT----{18 September 2019 . 3:03:18 am} caffeine.image priorSource: 1476669!JS chrome devtools inspectedWindow at: #reload!JS chrome devtools inspectedWindow reload!JS chrome devtools inspectedWindow at: #reload!(JS chrome at: #debugger) attach: {#tabId -> 50} with: '1.0'.!(JS chrome at: #debugger)	sendCommand: {#tabId -> 50}	with: 'Page.reload'!----SNAPSHOT----{18 September 2019 . 3:10:29 am} caffeine.image priorSource: 1477714!(JS chrome at: #debugger) detach: {#tabId -> 50}!----SNAPSHOT----{18 September 2019 . 3:13:58 am} caffeine.image priorSource: 1478085!----STARTUP----{18 September 2019 . 3:16:47 am} as /Users/craig/Downloads/caffeine/Caffeine Helper 2/memories/caffeine.image!----QUIT/NOSAVE----{18 September 2019 . 3:16:57 am} caffeine.image priorSource: 1478223!----STARTUP----{19 September 2019 . 12:51:10 pm} as /Users/craig/Downloads/caffeine/backups/34 (post-condense)/caffeine.image!'From Squeak4.6 of 8 July 2015 [latest update: #15102] on 19 September 2019 at 12:13:49 pm'!SystemOrganization addCategory: #'Environments-Policies'!Object subclass: #BindingPolicy	instanceVariableNames: 'policy environment addSelector removeSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'Environments-Policies'!Object subclass: #BindingPolicy	instanceVariableNames: 'policy environment addSelector removeSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'Environments-Policies'!BindingPolicy methodsFor: 'as yet unclassified' stamp: 'cwp 12/30/2013 18:09'!!BindingPolicy methodsFor: 'as yet unclassified' stamp: 'cwp 12/30/2013 18:09'!binding: aBinding addedTo: anEnvironment notify: anObject	environment == anEnvironment ifTrue: 		[policy name: aBinding key do:			[:name || binding |			binding := aBinding asBinding: name.			anObject perform: addSelector with: binding]].! !BindingPolicy methodsFor: 'as yet unclassified' stamp: 'cwp 12/30/2013 18:09'!!BindingPolicy methodsFor: 'as yet unclassified' stamp: 'cwp 12/30/2013 18:09'!binding: aBinding removedFrom: anEnvironment notify: anObject	environment == anEnvironment ifTrue: 		[policy name: aBinding key do:			[:name || binding |			binding := aBinding asBinding: name.			anObject perform: removeSelector with: binding]].! !BindingPolicy methodsFor: 'as yet unclassified' stamp: 'cwp 3/23/2014 20:31'!!BindingPolicy methodsFor: 'as yet unclassified' stamp: 'cwp 3/23/2014 20:31'!environment	^ environment! !BindingPolicy methodsFor: 'as yet unclassified' stamp: 'cwp 12/30/2013 18:08'!!BindingPolicy methodsFor: 'as yet unclassified' stamp: 'cwp 12/30/2013 18:08'!initializeWithEnvironment: anEnvironment policy: aNamePolicy addSelector: aSelector removeSelector: rSelector	self initialize.	environment := anEnvironment.	policy := aNamePolicy.	addSelector := aSelector.	removeSelector := rSelector! !BindingPolicy methodsFor: 'as yet unclassified' stamp: 'cwp 2/19/2013 21:06'!!BindingPolicy methodsFor: 'as yet unclassified' stamp: 'cwp 2/19/2013 21:06'!name: aSymbol do: aBlock	^ policy name: aSymbol do: aBlock! !BindingPolicy methodsFor: 'as yet unclassified' stamp: 'cwp 3/22/2014 20:59'!!BindingPolicy methodsFor: 'as yet unclassified' stamp: 'cwp 3/22/2014 20:59'!removeObserver: anEnvironment	environment removeObserver: anEnvironment ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!BindingPolicy class	instanceVariableNames: ''!BindingPolicy class methodsFor: 'as yet unclassified' stamp: 'cwp 12/30/2013 18:06'!!BindingPolicy class methodsFor: 'as yet unclassified' stamp: 'cwp 12/30/2013 18:06'!environment: anEnvironment policy: aNamePolicy addSelector: addSelector removeSelector: removeSelector	^ self basicNew 		initializeWithEnvironment: anEnvironment 		policy: aNamePolicy 		addSelector: addSelector		removeSelector: removeSelector! !----End fileIn of /Users/craig/Downloads/caffeine/backups/34 (post-condense)/BindingPolicy.st----!'From Squeak4.6 of 8 July 2015 [latest update: #15102] on 19 September 2019 at 12:33:42 pm'!Object subclass: #NamePolicy	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Environments-Policies'!Object subclass: #NamePolicy	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Environments-Policies'!NamePolicy methodsFor: 'as yet unclassified' stamp: 'cwp 2/19/2013 20:39'!!NamePolicy methodsFor: 'as yet unclassified' stamp: 'cwp 2/19/2013 20:39'!name: aSymbol do: aBlock	self subclassResponsibility! !----End fileIn of /Users/craig/Downloads/caffeine/backups/34 (post-condense)/NamePolicy.st----!'From Squeak4.6 of 8 July 2015 [latest update: #15102] on 19 September 2019 at 12:33:46 pm'!NamePolicy subclass: #AddPrefixNamePolicy	instanceVariableNames: 'prefix'	classVariableNames: ''	poolDictionaries: ''	category: 'Environments-Policies'!NamePolicy subclass: #AddPrefixNamePolicy	instanceVariableNames: 'prefix'	classVariableNames: ''	poolDictionaries: ''	category: 'Environments-Policies'!AddPrefixNamePolicy methodsFor: 'as yet unclassified' stamp: 'cwp 3/3/2013 13:21'!!AddPrefixNamePolicy methodsFor: 'as yet unclassified' stamp: 'cwp 3/3/2013 13:21'!initializeWithPrefix: aString	self initialize.	prefix := aString! !AddPrefixNamePolicy methodsFor: 'as yet unclassified' stamp: 'cwp 3/3/2013 14:20'!!AddPrefixNamePolicy methodsFor: 'as yet unclassified' stamp: 'cwp 3/3/2013 14:20'!name: aSymbol do: aBlock	^ (aSymbol beginsWith: prefix) ifFalse: 		[aBlock value: (prefix, aSymbol) asSymbol].	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AddPrefixNamePolicy class	instanceVariableNames: ''!AddPrefixNamePolicy class methodsFor: 'as yet unclassified' stamp: 'cwp 3/3/2013 13:21'!!AddPrefixNamePolicy class methodsFor: 'as yet unclassified' stamp: 'cwp 3/3/2013 13:21'!prefix: aString	^ self basicNew initializeWithPrefix: aString! !----End fileIn of /Users/craig/Downloads/caffeine/backups/34 (post-condense)/AddPrefixNamePolicy.st----!'From Squeak4.6 of 8 July 2015 [latest update: #15102] on 19 September 2019 at 12:33:48 pm'!NamePolicy subclass: #AllNamePolicy	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Environments-Policies'!NamePolicy subclass: #AllNamePolicy	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Environments-Policies'!AllNamePolicy methodsFor: 'as yet unclassified' stamp: 'cwp 2/19/2013 20:39'!!AllNamePolicy methodsFor: 'as yet unclassified' stamp: 'cwp 2/19/2013 20:39'!name: aSymbol do: aBlock	^ aBlock value: aSymbol! !----End fileIn of /Users/craig/Downloads/caffeine/backups/34 (post-condense)/AllNamePolicy.st----!'From Squeak4.6 of 8 July 2015 [latest update: #15102] on 19 September 2019 at 12:33:51 pm'!NamePolicy subclass: #ExplicitNamePolicy	instanceVariableNames: 'aliases'	classVariableNames: ''	poolDictionaries: ''	category: 'Environments-Policies'!NamePolicy subclass: #ExplicitNamePolicy	instanceVariableNames: 'aliases'	classVariableNames: ''	poolDictionaries: ''	category: 'Environments-Policies'!ExplicitNamePolicy methodsFor: 'as yet unclassified' stamp: 'cwp 2/19/2013 21:10'!!ExplicitNamePolicy methodsFor: 'as yet unclassified' stamp: 'cwp 2/19/2013 21:10'!initializeWithAliases: aCollection	self initialize.	aliases := IdentityDictionary withAll: aCollection! !ExplicitNamePolicy methodsFor: 'as yet unclassified' stamp: 'cwp 2/19/2013 21:11'!!ExplicitNamePolicy methodsFor: 'as yet unclassified' stamp: 'cwp 2/19/2013 21:11'!name: aSymbol do: aBlock	^ aBlock value: (aliases at: aSymbol ifAbsent: [^ nil])! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ExplicitNamePolicy class	instanceVariableNames: ''!ExplicitNamePolicy class methodsFor: 'as yet unclassified' stamp: 'cwp 2/19/2013 21:10'!!ExplicitNamePolicy class methodsFor: 'as yet unclassified' stamp: 'cwp 2/19/2013 21:10'!aliases: aCollection	^ self basicNew initializeWithAliases: aCollection! !ExplicitNamePolicy class methodsFor: 'as yet unclassified' stamp: 'cwp 3/1/2013 10:00'!!ExplicitNamePolicy class methodsFor: 'as yet unclassified' stamp: 'cwp 3/1/2013 10:00'!flattenSpec: anObject into: names	anObject isSymbol ifTrue:		[^ names at: anObject put: anObject].	anObject isVariableBinding ifTrue:		[^ names add: anObject].	anObject isDictionary ifTrue:		[^ names addAll: anObject].	anObject do:		[:ea | self flattenSpec: ea into: names]! !ExplicitNamePolicy class methodsFor: 'as yet unclassified' stamp: 'cwp 3/1/2013 10:06'!!ExplicitNamePolicy class methodsFor: 'as yet unclassified' stamp: 'cwp 3/1/2013 10:06'!spec: anObject	| aliases |	(anObject isKindOf: NamePolicy) ifTrue: [^ anObject].	aliases := IdentityDictionary new.	self flattenSpec: anObject into: aliases.	^ self aliases: aliases! !----End fileIn of /Users/craig/Downloads/caffeine/backups/34 (post-condense)/ExplicitNamePolicy.st----!'From Squeak4.6 of 8 July 2015 [latest update: #15102] on 19 September 2019 at 12:33:53 pm'!NamePolicy subclass: #RemovePrefixNamePolicy	instanceVariableNames: 'prefix'	classVariableNames: ''	poolDictionaries: ''	category: 'Environments-Policies'!NamePolicy subclass: #RemovePrefixNamePolicy	instanceVariableNames: 'prefix'	classVariableNames: ''	poolDictionaries: ''	category: 'Environments-Policies'!RemovePrefixNamePolicy methodsFor: 'as yet unclassified' stamp: 'cwp 3/3/2013 14:17'!!RemovePrefixNamePolicy methodsFor: 'as yet unclassified' stamp: 'cwp 3/3/2013 14:17'!initializeWithPrefix: aString	self initialize.	prefix := aString! !RemovePrefixNamePolicy methodsFor: 'as yet unclassified' stamp: 'cwp 3/3/2013 14:29'!!RemovePrefixNamePolicy methodsFor: 'as yet unclassified' stamp: 'cwp 3/3/2013 14:29'!name: aSymbol do: aBlock	^ (aSymbol beginsWith: prefix) 		ifTrue: [aBlock value: (aSymbol allButFirst: prefix size) asSymbol]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RemovePrefixNamePolicy class	instanceVariableNames: ''!RemovePrefixNamePolicy class methodsFor: 'as yet unclassified' stamp: 'cwp 3/3/2013 14:18'!!RemovePrefixNamePolicy class methodsFor: 'as yet unclassified' stamp: 'cwp 3/3/2013 14:18'!prefix: aString	^ self basicNew initializeWithPrefix: aString! !----End fileIn of /Users/craig/Downloads/caffeine/backups/34 (post-condense)/RemovePrefixNamePolicy.st----!----SNAPSHOT----{19 September 2019 . 12:53:12 pm} caffeine.image priorSource: 1478223!'From Squeak4.6 of 8 July 2015 [latest update: #15102] on 19 September 2019 at 12:53:43 pm'!Environment methodsFor: 'as yet unclassified' stamp: 'cwp 12/31/2013 12:33'!!Environment methodsFor: 'as yet unclassified' stamp: 'cwp 12/31/2013 12:33'!importSelf	| policy |	policy := BindingPolicy		environment: self		policy: AllNamePolicy new		addSelector: #showBinding:		removeSelector: #hideBinding:.	policies := policies copyWith: policy.		declarations associationsDo:		[:ea | (bindings includesKey: ea key) ifFalse:			[bindings add: ea]]! !----End fileIn of /Users/craig/Downloads/caffeine/backups/28 (history server)/Environment-importSelf.st----!Object environment importSelf!Object environment !----SNAPSHOT----{19 September 2019 . 12:54:18 pm} caffeine.image priorSource: 1488147!----QUIT/NOSAVE----{19 September 2019 . 12:55:40 pm} caffeine.image priorSource: 1488954!----STARTUP----{19 September 2019 . 12:55:48 pm} as /Users/craig/Downloads/caffeine/backups/34 (post-condense)/caffeine.image!----QUIT/NOSAVE----{19 September 2019 . 12:56:37 pm} caffeine.image priorSource: 1488954!!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 12:57' prior: 35024822!startUp: resuming	"After a system resumption, if the system is being run by SqueakJS in a web browser, reset constants related to that web browser's JavaScript environment."	| forceToScreen |	resuming ifTrue: [		(self == Webpage)			ifTrue: [				Fullscreen := false.								Top := TopDocument := ContainingDiv := ContainingCanvas := ContainingFrame := Current := Options := nil.				Preferences					setPreference: #fastDragWindowForMorphic					toValue: JS isConnected.								JS ifConnected: [					| url |															Top := [JS top counterpart magicWindow] on: Error do: [:exception | nil].					url := (						Top							ifNil: [String randomOfLength: 5]							ifNotNil: [								TopDocument := Top document.								Url absoluteFromText: Top location href asString]).					Options := (						(JS SqueakJS options at: #parameters)							ifNil: [nil]							ifNotNil: [JS SqueakJS options parameters counterpart]).												ContainingCanvas := JS document counterpart getElementById: 'squeak'.								Top ifNotNil: [ContainingFrame := Top document getElementById: #Caffeine].					ContainingCanvas ifNotNil: [						ContainingDiv := (							ContainingFrame								ifNil: [ContainingCanvas parentNode]								ifNotNil: [									self styleAt: #transition put: 'opacity 500ms'.									ContainingFrame parentNode parentNode]).						ContainingDiv at: #onresize put: [self resize].						ContainingCanvas at: #tabIndex put: 0.						self captureCurrentExtent.						ContainingCanvas onclick: [self focus]].										forceToScreen := [:event | Display forceToScreen].					Top						at: #onresize						put: forceToScreen; 						at: #onscroll						put: forceToScreen;						at: #onorientationchange						put: [:event |							forceToScreen value: event.							self scrollToTop].															ContainingCanvas ifNotNil: [						ContainingCanvas							styleAt: 'user-select'							put: [false]].											Pages						at: url						ifAbsent: [							self								ifOptionAt: 'appID'								then: [:appID |									| appClass |																		appClass := self allSubclasses detect: [:subclass | subclass appID = appID] ifNone: [nil].									appClass										ifNil: [nil]										ifNotNil: [											Pages												at: url												put: (appClass fromURL: url)]]								else: [nil]]]]]! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 12:59' prior: 35024822!startUp: resuming	"After a system resumption, if the system is being run by SqueakJS in a web browser, reset constants related to that web browser's JavaScript environment."	| forceToScreen |	resuming ifTrue: [		(self == Webpage)			ifTrue: [				Fullscreen := false.								Top := TopDocument := ContainingDiv := ContainingCanvas := ContainingFrame := Current := Options := nil.				Preferences					setPreference: #fastDragWindowForMorphic					toValue: JS isConnected.								JS ifConnected: [					| url |															Top := [JS top counterpart magicWindow] on: Error do: [:exception | nil].					url := (						Top							ifNil: [String randomOfLength: 5]							ifNotNil: [								TopDocument := Top document.								Url absoluteFromText: Top location href asString]).					Options := (						(JS SqueakJS options at: #parameters)							ifNil: [nil]							ifNotNil: [JS SqueakJS options parameters counterpart]).												ContainingCanvas := JS document counterpart getElementById: 'squeak'.								Top ifNotNil: [ContainingFrame := Top document getElementById: #Caffeine].					ContainingCanvas ifNotNil: [						ContainingDiv := (							ContainingFrame								ifNil: [ContainingCanvas parentNode]								ifNotNil: [									self styleAt: #transition put: 'opacity 500ms'.									ContainingFrame parentNode parentNode]).						ContainingDiv at: #onresize put: [self resize].						ContainingCanvas at: #tabIndex put: 0.						self captureCurrentExtent.						ContainingCanvas onclick: [self focus]].										forceToScreen := [:event | Display forceToScreen].					Top						at: #onresize						put: forceToScreen; 						at: #onscroll						put: forceToScreen;						at: #onorientationchange						put: [:event |							forceToScreen value: event.							self scrollToTop].															ContainingCanvas ifNotNil: [						ContainingCanvas							styleAt: 'user-select'							put: [false]].											Pages						at: url						ifAbsent: [							self								ifOptionAt: 'appID'								then: [:appID |									| appClass |																		appClass := self allSubclasses detect: [:subclass | subclass appID = appID] ifNone: [nil].									appClass										ifNil: [nil]										ifNotNil: [											Pages												at: url												put: (appClass fromURL: url)]]								else: [nil]]]]]! !----STARTUP----{19 September 2019 . 12:59:25 pm} as /SqueakJS/caffeine.image!!Caffeine methodsFor: 'as yet unclassified' stamp: 'crl 9/3/2019 23:03' prior: 35023014!initialize	super initialize.		Top ifNotNil: [		self			status: 'starting window system...';			windowize;			"modifySummary;"			finishProgress.						ContainingDiv			styleAt: #pointerEvents put: 'all';			beVisible.					(window top document getElementById: 'sqSpinner') beOpaque]! !Webpage current initialize!----SNAPSHOT----{19 September 2019 . 1:00:20 pm} caffeine.image priorSource: 1488954!!Environment methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 13:01' prior: 34391307!binding: aBinding removedFrom: anEnvironment	policies do:		[:ea | ea binding: aBinding removedFrom: anEnvironment notify: self]! !Smalltalk renameClassNamed: #ChromeTab as: #ChromeTabViaPage!ChromeTab halt; rename: #ChromeTabViaPage!----SNAPSHOT----{19 September 2019 . 1:02:25 pm} caffeine.image priorSource: 1494733!----STARTUP----{19 September 2019 . 1:03:32 pm} as /SqueakJS/caffeine.image!!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/13/2019 21:44' prior: 35023277!fullscreen: fullscreen	"Set fullscreen mode accordingly."	(Fullscreen == fullscreen) ifFalse: [		Fullscreen := fullscreen.		ContainingCanvas			ifNil: [				(Project current lastScreenModeSelected == fullscreen) ifFalse: [					fullscreen						ifTrue: [Project current fullScreenOn]						ifFalse: [Project current fullScreenOff]]]			ifNotNil: [				ContainingFrame ifNotNil: [					| newWidth newHeight newX newY |									ContainingFrame						styleAt: #transition put: '';						beTransparent.						fullscreen						ifTrue: [							self captureCurrentExtent.							newWidth := JS top innerWidth - 4.							newHeight := JS top innerHeight - 4.							newX := newY := 2.							ContainingDiv								styleAt: #boxShadow put: '';								styleAt: #border put: '']						ifFalse: [							newWidth := OldWidth.							newHeight := OldHeight.							newX := OldX.							newY := OldY.							ContainingDiv								styleAt: #boxShadow put: '1px 1px 7px #999, 2px 2px 8px #999, 3px 3px 9px #999';								styleAt: #border put: '2px inset gray'].									self bounds: ((newX @ newY) extent: (newWidth @ newHeight)).					JS top touch at: #orig put: nil.					self zoomOut.					[						(Delay forMilliseconds: 500) wait.						ContainingFrame styleAt: #transition put: 'opacity 500ms'.						ContainingFrame beOpaque					]						fork]]]! !----SNAPSHOT----{19 September 2019 . 1:04:11 pm} caffeine.image priorSource: 1495153!----SNAPSHOT----{19 September 2019 . 1:04:36 pm} caffeine.image priorSource: 1496770!----SNAPSHOT----{19 September 2019 . 1:06:24 pm} caffeine.image priorSource: 1496857!!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/17/2019 21:47' prior: 35046326!startUp: resuming
	"After a system resumption, if the system is being run by SqueakJS in a web browser, reset constants related to that web browser's JavaScript environment."

	| forceToScreen |
	resuming ifTrue: [
		(self == Webpage)
			ifTrue: [
				Fullscreen := false.
				
				Top := TopDocument := ContainingDiv := ContainingCanvas := ContainingFrame := Current := Options := nil.

				Preferences
					setPreference: #fastDragWindowForMorphic
					toValue: JS isConnected.
				
				JS ifConnected: [
					| url |
										
					Top := [JS top counterpart magicWindow] on: Error do: [:exception | JS window].
					url := (
						Top
							ifNil: [String randomOfLength: 5]
							ifNotNil: [
								TopDocument := Top document.
								Url absoluteFromText: Top location href asString]).
					Options := (
						(JS SqueakJS options at: #parameters)
							ifNil: [nil]
							ifNotNil: [JS SqueakJS options parameters counterpart]).
							
					ContainingCanvas := JS document counterpart getElementById: 'squeak'.

					ContainingCanvas
						at: #width put: Options width;
						at: #height put: Options height.
						
					Top ifNotNil: [ContainingFrame := Top document getElementById: #Caffeine].
					ContainingCanvas ifNotNil: [
						ContainingDiv := (
							ContainingFrame
								ifNil: [ContainingCanvas parentNode]
								ifNotNil: [
									self styleAt: #transition put: 'opacity 500ms'.
									ContainingFrame parentNode parentNode]).
						ContainingDiv at: #onresize put: [self resize].
						ContainingCanvas at: #tabIndex put: 0.
						self captureCurrentExtent.

						ContainingCanvas onclick: [self focus]].
					
					forceToScreen := [:event | Display forceToScreen].

					Top
						at: #onresize
						put: forceToScreen; 						at: #onscroll
						put: forceToScreen;
						at: #onorientationchange
						put: [:event |
							forceToScreen value: event.
							self scrollToTop].
										
					ContainingCanvas ifNotNil: [
						ContainingCanvas
							styleAt: 'user-select'
							put: [false]].

					Pages
						at: url
						ifAbsent: [
							self
								ifOptionAt: 'appID'
								then: [:appID |
									| appClass |
									
									appClass := self allSubclasses detect: [:subclass | subclass appID = appID] ifNone: [nil].
									appClass
										ifNil: [nil]
										ifNotNil: [
											Pages
												at: url
												put: (appClass fromURL: url)]]
								else: [nil]]]]]! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 13:12' prior: 35051559!startUp: resuming	"After a system resumption, if the system is being run by SqueakJS in a web browser, reset constants related to that web browser's JavaScript environment."	| forceToScreen |	resuming ifTrue: [		(self == Webpage)			ifTrue: [				Fullscreen := false.								Top := TopDocument := ContainingDiv := ContainingCanvas := ContainingFrame := Current := Options := nil.				Preferences					setPreference: #fastDragWindowForMorphic					toValue: JS isConnected.								JS ifConnected: [					| url |															Top := [JS top counterpart magicWindow] on: Error do: [:exception | JS window].					url := (						Top							ifNil: [String randomOfLength: 5]							ifNotNil: [								TopDocument := Top document.								Url absoluteFromText: Top location href asString]).					Options := (						(JS SqueakJS options at: #parameters)							ifNil: [nil]							ifNotNil: [JS SqueakJS options parameters counterpart]).												ContainingCanvas := JS document counterpart getElementById: 'squeak'.					ContainingCanvas						at: #width put: Options width;						at: #height put: Options height.											Top ifNotNil: [ContainingFrame := Top document getElementById: #Caffeine].					ContainingCanvas ifNotNil: [						ContainingDiv := (							ContainingFrame								ifNil: [ContainingCanvas parentNode]								ifNotNil: [									self styleAt: #transition put: 'opacity 500ms'.									ContainingFrame parentNode parentNode]).						ContainingDiv at: #onresize put: [self resize].						ContainingCanvas at: #tabIndex put: 0.						self captureCurrentExtent.						ContainingCanvas onclick: [self focus]].										forceToScreen := [:event | Display forceToScreen].					Top						at: #onresize						put: forceToScreen; 						at: #onscroll						put: forceToScreen;						at: #onorientationchange						put: [:event |							forceToScreen value: event.							self scrollToTop].															ContainingCanvas ifNotNil: [						ContainingCanvas							styleAt: 'user-select'							put: [false]].					Pages						at: url						ifAbsent: [							self								ifOptionAt: 'appID'								then: [:appID |									| appClass |																		appClass := self allSubclasses detect: [:subclass | subclass appID = appID] ifNone: [nil].									appClass										ifNil: [nil]										ifNotNil: [											Pages												at: url												put: (appClass fromURL: url)]]								else: [nil]]]]]! !!Caffeine methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 13:12' prior: 35048845!initialize	super initialize.	(window document getElementById: 'sqSpinner') beOpaque! !----STARTUP----{19 September 2019 . 1:12:36 pm} as /SqueakJS/caffeine.image!----SNAPSHOT----{19 September 2019 . 1:12:57 pm} caffeine.image priorSource: 1496944!Webpage exportSnapshot!!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 14:24'!zoomTo: point	ContainingCanvas		at: #width put: point x;		at: #height put: point y! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 14:25' prior: 34008738!zoomOut	"Zoom out the containing canvas."		ContainingCanvas		styleAt: #left put: 0;		styleAt: #top put: 0.			self zoomTo: (ContainingCanvas width @ ContainingCanvas height)! !	self zoomTo: (1982@1933)!!MorphicProject methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 14:28' prior: 34309804!setAsBackground: aForm	"Set  aForm as a background image."	| thisWorld newColor |	thisWorld := self currentWorld.	newColor := InfiniteForm with: aForm.	aForm rememberCommand:		(Command new cmdWording: 'set background to a picture' translated;			undoTarget: thisWorld selector: #color: argument: thisWorld color;			redoTarget: thisWorld selector: #color: argument: newColor).	thisWorld color: newColor! !----SNAPSHOT----{19 September 2019 . 2:28:59 pm} caffeine.image priorSource: 1502385!(JS chrome tabs)	query: {#title -> '*'}	with: [:result | 3 halt]!EditHistory connectTo: 'ws://localhost:8091/tether'.!result counterpart asArray explore!JS chrome == JS chrome!JS chrome = JS chrome!!CaffeineExtension methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 14:55' prior: 35029708!initialize	"Connect to the Caffeine Helper web browser extension."		tabs := IdentityDictionary new.	promises := IdentityDictionary new.	nextPromiseID := 1.	port := JS chrome runtime connect: 'kfifbhlilndoognbpbaipgbhfphcldnp'.		port onMessage addListener: [:message |		(message at: 'method')			ifNil: [				"Resolve a promised answer from the extension."								| promise |								promise := promises at: (message at: 'promiseID') ifAbsent: [nil].								promise ifNotNil: [promise resolveWith: (message at: 'result') counterpart simplestRepresentation]]			ifNotNil: [				"Handle a message from the web browser."								| tabID |								tabID := message at: 'tabID'.				(					ChromeMethodInvocation						fromDictionary: message counterpart simplestRepresentation						for: (							tabs								at: tabID								ifAbsent: [									tabs										at: tabID										put: (											(ChromeTabViaPage new)												initializeFromTabInfo: (tabInfo detect: [:tab | tab id = tabID]);												transport: self;												yourself)])				)					perform]].			self getTabInfo! !----SNAPSHOT----{19 September 2019 . 2:55:49 pm} caffeine.image priorSource: 1503482!----SNAPSHOT----{19 September 2019 . 3:01:41 pm} caffeine.image priorSource: 1504990!----STARTUP----{19 September 2019 . 3:02:26 pm} as /SqueakJS/caffeine.image!----SNAPSHOT----{19 September 2019 . 6:58:06 pm} caffeine.image priorSource: 1505077!----STARTUP----{19 September 2019 . 7:41:42 pm} as /SqueakJS/caffeine.image!Webpage zoomTo: 1200@1200!Webpage zoomTo: 2000@1800!Webpage zoomTo: 2000@1900!Webpage zoomTo: 2000@2000!----STARTUP----{19 September 2019 . 10:41:09 pm} as /SqueakJS/caffeine.image!JS chrome at: #debugger!JS chrome at: #debugger!self counterpart!JS chrome devtools counterpart!JS console counterpart!JS console dir: JS document!JS document!(JS chrome tabs)	query: {#title -> '*'}	with: [:result | 3 halt]!result counterpart asArray explore!(JS chrome at: #debugger)	sendCommand: {#tabId -> 104}	with: 'Dom.getDocument'!(JS chrome at: #debugger)	sendCommand: {#tabId -> 104}	with: 'DOM.getDocument'!(JS chrome at: #debugger)	attach: {#tabId -> 104}	with: '1.0'.!(JS chrome at: #debugger)	sendCommand: {#tabId -> 104}	with: 'DOM.getDocument'!(JS chrome at: #debugger)	sendCommand: {#tabId -> 104}	with: 'DOM.getDocument'!(JS chrome at: #debugger)	sendCommand: {#tabId -> 104}	with: 'Debugger.enable'!(JS chrome at: #debugger)	sendCommand: {#tabId -> 104}	with: 'DOM.getDocument'!(JS chrome at: #debugger)	sendCommand: {#tabId -> 104}	with: 'DOM.getDocument'!(JS chrome at: #debugger)	sendCommand: {#tabId -> 104}	with: 'DOM.getDocument'	with: {#depth -> -1}!(JS chrome at: #debugger)	sendCommand: {#tabId -> 104}	with: 'DOM.getDocument'	with: {#depth -> -1}	with: [:result | 3 halt]!(JS chrome at: #debugger)	sendCommand: {#tabId -> 104}	with: 'DOM.getDocument'	with: [:result | 3 halt]!result counterpart!self explore!(JS chrome at: #debugger)	sendCommand: {#tabId -> 104}	with: 'DOM.getDocument'	with: {#depth -> -1}	with: [:result | 3 halt]!result counterpart explore!JSObject subclass: #RemoteJSObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!RemoteJSObject forProxy: self!self!!RemoteJSObject methodsFor: 'no messages' stamp: 'crl 9/20/2019 00:26'!printOn: stream	! !JS document!JS document counterpart!RemoteJSObject forProxy: result!!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 00:29' prior: 35061763!printOn: stream	3 halt.	super printOn: stream! !RemoteJSObject forProxy: result!(RemoteJSObject forProxy: result) explore!!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 00:31'!remote	^RemoteJSObject forProxy: proxy! !!RemoteJSObject methodsFor: 'no messages' stamp: 'crl 9/20/2019 00:32'!doesNotUnderstand: message	^(super doesNotUnderstand: message) remote! !----SNAPSHOT----{20 September 2019 . 12:32:45 am} caffeine.image priorSource: 1505243!(RemoteJSObject forProxy: result) explore!!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 00:33'!at: key	^(super at: key) remote! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 00:34'!remote	^RemoteJSObject forProxy: self! !result remote explore!!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 00:35' prior: 35062558!at: key	^[(super at: key) remote]		on: Error		do: [:exception | super at: key]! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 01:50' prior: 35062835!at: key	| value |		value := super at: key.		^(value class == Array)		ifTrue: [			value collect: [:element | element remote]]		ifFalse: [value remote]! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 01:52' prior: 35063016!at: key	| value |		value := super at: key.		^(value class == Array)		ifTrue: [			value collect: [:element |				[element remote]					on: Error					do: [:exception | element]]]		ifFalse: [			[value remote]				on: Error				do: [:exception | value]]! !result remote explore!!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 01:56' prior: 34682267!keysSortedSafely	"Answer a sorted Array containing the receiver's keys."		^('function *' match: self printString)		ifTrue: [#()]		ifFalse: [self keys sort: [:x :y | x compareSafely: y]]! !result remote explore!self printString!'function *' match: proxy printString!!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 01:58' prior: 35063650!keysSortedSafely	"Answer a sorted Array containing the receiver's keys."		^('function *' match: proxy printString)		ifTrue: [#()]		ifFalse: [self keys sort: [:x :y | x compareSafely: y]]! !result remote explore!!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:01' prior: 33972286!with: argument retry: retryBlock	| error |	(error := self primGetError) ifNil: [^ self error: 'JSBridge error'].	(error beginsWith: 'asJSArgument') ifTrue: [		3 halt.		^retryBlock value: argument asJSArgument].	(error beginsWith: 'CallbackSemaphore') ifTrue: [		self class initCallbacks.		^retryBlock value: argument].	self error: error.! !result remote explore!proxy class!!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:07' prior: 34682942!properties	^(		(			('function *' match: proxy printString)				ifTrue: [#()]				ifFalse: [JS Object keys: proxy]		)			asArray select: [:key |				| source keyString number |						source := (String new: 32) writeStream.				source nextPutAll: 'try {return typeof this'.				keyString := key asString.						number := [keyString asNumber] on: Error do: [:exception | nil].				number					ifNil: [						source							nextPut: $.;							nextPutAll: keyString]					ifNotNil: [						source							nextPut: $[;							nextPutAll: keyString;							nextPut: $]].								source nextPutAll: ';} catch (e) {''string''}'.				[(proxy evaluate: source contents) asString ~= 'function'] on: Error do: [:exception | false]]	)		collect: [:proxy | proxy asString]! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:07' prior: 35064331!with: argument retry: retryBlock	| error |	(error := self primGetError) ifNil: [^ self error: 'JSBridge error'].	(error beginsWith: 'asJSArgument') ifTrue: [		^retryBlock value: argument asJSArgument].	(error beginsWith: 'CallbackSemaphore') ifTrue: [		self class initCallbacks.		^retryBlock value: argument].	self error: error.! !!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 8/19/2017 12:51' prior: 35064017!keysSortedSafely	"Answer a sorted Array containing the receiver's keys."		^self keys sort: [:x :y | x compareSafely: y]! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:09' prior: 35065673!with: argument retry: retryBlock	| error |	(error := self primGetError) ifNil: [^ self error: 'JSBridge error'].	(error beginsWith: 'asJSArgument') ifTrue: [		3 halt.		^retryBlock value: argument asJSArgument].	(error beginsWith: 'CallbackSemaphore') ifTrue: [		self class initCallbacks.		^retryBlock value: argument].	self error: error.! !result remote explore!proxy printString!proxy class!!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:11' prior: 35064810!properties	^(		(			[JS Object keys: proxy]				on: Error				do: [:exception | #()]		)			asArray select: [:key |				| source keyString number |						source := (String new: 32) writeStream.				source nextPutAll: 'try {return typeof this'.				keyString := key asString.						number := [keyString asNumber] on: Error do: [:exception | nil].				number					ifNil: [						source							nextPut: $.;							nextPutAll: keyString]					ifNotNil: [						source							nextPut: $[;							nextPutAll: keyString;							nextPut: $]].								source nextPutAll: ';} catch (e) {''string''}'.				[(proxy evaluate: source contents) asString ~= 'function'] on: Error do: [:exception | false]]	)		collect: [:proxy | proxy asString]! !result remote explore!argument class !argument asJSArgument!argument asJSArgument == argument!!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:16' prior: 35066325!with: argument retry: retryBlock	| error |	(error := self primGetError) ifNil: [^ self error: 'JSBridge error'].	(error beginsWith: 'asJSArgument') ifTrue: [		^(argument asJSArgument == argument)			ifTrue: [self error: error]			ifFalse: [retryBlock value: argument asJSArgument]].	(error beginsWith: 'CallbackSemaphore') ifTrue: [		self class initCallbacks.		^retryBlock value: argument].	self error: error! !self!self proxy counterpart!self proxy!self proxy counterpart simplestRepresentation!self proxy counterpart simplestRepresentation!!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:27' prior: 35063273!at: key	| value |		value := super at: key.		^(value class == Array)		ifTrue: [			value collect: [:element |				[element counterpart simplestRepresentation remote]					on: Error					do: [:exception | element]]]		ifFalse: [			[value remote]				on: Error				do: [:exception | value]]! !EditHistory connectTo: 'ws://localhost:8091/tether'.!result remote explore!!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:28' prior: 35068420!at: key	| value |		value := super at: key.		^(value class == Array)		ifTrue: [			value collect: [:element |				[element counterpart simplestRepresentation remote]					on: Error					do: [:exception | element counterpart simplestRepresentation]]]		ifFalse: [			[value remote]				on: Error				do: [:exception | value]]! !----SNAPSHOT----{20 September 2019 . 2:28:59 am} caffeine.image priorSource: 1507913!self at: #attributes!JSObject subclass: #RemoteJSObject	instanceVariableNames: 'attributes'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!JSObject subclass: #RemoteJSObject	instanceVariableNames: 'attributes'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:32'!attributes	attributes ifNil: [attributes := self at: #attributes].	^attributes! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:33'!attributeAt: key	| stream |		stream := self attributes readStream.		[stream atEnd] whileFalse: [		(stream next = key) ifTrue: [^stream next]].		^nil! !self attributeAt: #id!!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:34'!id	^self attributeAt: #id! !self id!----SNAPSHOT----{20 September 2019 . 2:34:38 am} caffeine.image priorSource: 1514793!!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:37'!classAttribute	^self attributeAt: #class! !self classAttribute!!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:39'!getElementsByClassName: className	! !self at: #children!JSObject subclass: #RemoteJSObject	instanceVariableNames: 'attributes children'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!JSObject subclass: #RemoteJSObject	instanceVariableNames: 'attributes children'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:40'!children	children ifNil: [children := self at: #children].	^children! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:44'!getElementsByClassName: className into: elements	(self classAttribute = className) ifTrue: [elements add: self].	self children do: [:child | child getElementsByClassName: className into: elements].	^elements! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:44' prior: 35070518!getElementsByClassName: className	| elements |		elements := Set new.	self getElementsByClassName: className into: elements.	^elements! !----SNAPSHOT----{20 September 2019 . 2:45:47 am} caffeine.image priorSource: 1515771!!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:47'!at: key ifAbsent: block	| value |		value := super at: key.	^value		ifNil: [block value]		ifNotNil: [			(value class == Array)				ifTrue: [					value collect: [:element |						[element counterpart simplestRepresentation remote]							on: Error							do: [:exception | element counterpart simplestRepresentation]]]				ifFalse: [					[value remote]						on: Error						do: [:exception | value]]]! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:48' prior: 35068893!at: key	^self at: key ifAbsent: [nil]! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:49' prior: 35069900!attributeAt: key	| stream |		self attributes.	^attributes		ifNil: [nil]		ifNotNil: [			stream := self attributes readStream.				[stream atEnd] whileFalse: [				(stream next = key) ifTrue: [^stream next]].				nil]! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:28' prior: 35072278!at: key	| value |		value := super at: key.		^(value class == Array)		ifTrue: [			value collect: [:element |				[element counterpart simplestRepresentation remote]					on: Error					do: [:exception | element counterpart simplestRepresentation]]]		ifFalse: [			[value remote]				on: Error				do: [:exception | value]]! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:51' prior: 35071150!getElementsByClassName: className into: elements	(self classAttribute = className) ifTrue: [elements add: self].	self children.	children ifNotNil: [		children do: [:child | child getElementsByClassName: className into: elements]].		^elements! !self getElementsByClassName: 'button-nfplayerFastForward'!self getElementsByClassName: 'button-nfplayerFastForward'!self classAttribute!!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:57' prior: 35069736!attributes	attributes ifNil: [		| stream |				stream := self at: #attributes.		attributes := IdentityDictionary new.				[stream atEnd] whileFalse: [attributes at: stream next asSymbol put: stream next]].	^attributes! !result remote root!----SNAPSHOT----{20 September 2019 . 2:58:35 am} caffeine.image priorSource: 1517169!(JS chrome at: #debugger)	sendCommand: {#tabId -> 104}	with: 'DOM.getDocument'	with: {#depth -> -1}	with: [:result | 3 halt]!result root!result remote!result remote root!!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 03:00' prior: 35073660!attributes	attributes ifNil: [		| stream |				stream := (self at: #attributes) readStream.		attributes := IdentityDictionary new.				[stream atEnd] whileFalse: [attributes at: stream next asSymbol put: stream next]].	^attributes! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 03:01' prior: 35072416!attributeAt: key	self attributes.	^attributes		ifNil: [nil]		ifNotNil: [attributes at: key]! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 03:01' prior: 35074611!attributeAt: key	self attributes.	^attributes		ifNil: [nil]		ifNotNil: [attributes at: key ifAbsent: [nil]]! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 03:04' prior: 35074274!attributes	attributes ifNil: [		| stream |				attributes := IdentityDictionary new.		stream := self at: #attributes.		stream			ifNil: [^attributes]			ifNotNil: [stream := stream readStream].		[stream atEnd] whileFalse: [attributes at: stream next asSymbol put: stream next]].	^attributes! !result remote root getElementsByClassName: 'button-nfplayerFastForward'!result remote root!self classAttribute!!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 03:11' prior: 35073170!getElementsByClassName: className into: elements	('*className*' match: self classAttribute) ifTrue: [elements add: self].	self children.	children ifNotNil: [		children do: [:child | child getElementsByClassName: className into: elements]].		^elements! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 03:11' prior: 35075535!getElementsByClassName: className into: elements	(('*', className, '*') match: self classAttribute) ifTrue: [elements add: self].	self children.	children ifNotNil: [		children do: [:child | child getElementsByClassName: className into: elements]].		^elements! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 03:13' prior: 35070371!classAttribute	^(self attributeAt: #class) yourselfUnlessNil: ['']! !result remote root getElementsByClassName: 'button-nfplayerFastForward'!(JS chrome at: #debugger)	sendCommand: {#tabId -> 104}	with: 'Runtime.getProperties'	with: {#objectId -> 1801}	with: [:result | 3 halt]!(JS chrome at: #debugger)	sendCommand: {#tabId -> 104}	with: 'Runtime.getProperties'	with: {#objectId -> '1801'}	with: [:result | 3 halt]!(JS chrome at: #debugger)	sendCommand: {#tabId -> 104}	with: 'Runtime.getProperties'	with: {#objectId -> '2533'}	with: [:result | 3 halt]!(JS chrome at: #debugger)	sendCommand: {#tabId -> 104}	with: 'Runtime.getProperties'	with: {#objectId -> '1801'}	with: [:result | 3 halt]!(JS chrome at: #debugger)	sendCommand: {#tabId -> 104}	with: 'Runtime.getProperties'	with: {#objectId -> '1801'}	with: [:result | 3 halt]!(JS chrome at: #debugger)	sendCommand: {#tabId -> 104}	with: 'Runtime.getProperties'	with: {#objectId -> 1801}	with: [:result | 3 halt]!(JS chrome at: #debugger)	sendCommand: {#tabId -> 104}	with: 'Debugger.pause'!(JS chrome at: #debugger)	sendCommand: {#tabId -> 104}	with: 'Runtime.getProperties'	with: {#objectId -> '1801'}	with: [:result | 3 halt]!(JS chrome at: #debugger)	sendCommand: {#tabId -> 104}	with: 'Runtime.evaluate'	with: {#expression -> 'document'}	with: [:result | 3 halt]!result counterpart!self result!self className!self description!self objectId!(JS chrome at: #debugger)	sendCommand: {#tabId -> 104}	with: 'Runtime.getProperties'	with: {#id -> '1801'}	with: [:result | 3 halt]!self objectId!(JS chrome at: #debugger)	sendCommand: {#tabId -> 104}	with: 'Runtime.getProperties'	with: {#id -> '1801'}	with: [:result | 3 halt]!(JS chrome at: #debugger)	sendCommand: {#tabId -> 104}	with: 'Runtime.getProperties'	with: {#objectId -> '8'}	with: [:result | 3 halt]!(JS chrome at: #debugger)	sendCommand: {#tabId -> 104}	with: 'Runtime.getProperties'	with: {#injectedScriptId -> 27. #id -> '8'}	with: [:result | 3 halt]!(JS chrome at: #debugger)	sendCommand: {#tabId -> 104}	with: 'Runtime.getProperties'	with: {#injectedScriptId -> 27. #id -> 8}	with: [:result | 3 halt]!(JS chrome at: #debugger)	sendCommand: {#tabId -> 104}	with: 'Runtime.getProperties'	with: {#objectId -> 8}	with: [:result | 3 halt]!(JS chrome at: #debugger)	sendCommand: {#tabId -> 104}	with: 'Runtime.getProperties'	with: {#objectId -> '8'}	with: [:result | 3 halt]!(JS chrome at: #debugger)	sendCommand: {#tabId -> 104}	with: 'Runtime.getProperties'	with: {#objectId -> '{"injectedScriptId":27,"id":8}'}	with: [:result | 3 halt]!result counterpart!self result!self first name!self first at: #name!self collect: [:el | el at: #name]!self first at: #value!self description!self className!self at: #className!self objectId!self type!result remote!(JS chrome at: #debugger)	sendCommand: {#tabId -> 104}	with: 'DOM.resolveNode'	with: {#nodeId -> 1801}	with: [:result | 3 halt]!result counterpart!self object!self objectId!(JS chrome at: #debugger)	sendCommand: {#tabId -> 104}	with: 'Runtime.getProperties'	with: {#objectId -> '{"injectedScriptId":27,"id":124}'}	with: [:result | 3 halt]!result counterpart!self result!self select:  [:el | '*react*' match: el name]!self select:  [:el | '*react*' match: (el at: #name)]!self select:  [:el | (el at: #name) = '__reactInternalInstance$xltok6p4dic']!Smalltalk renameClassNamed: #RemoteJSObject as: #RemoteDOMNode!!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 11:45' prior: 35062157!remote	^RemoteDOMNode forProxy: proxy! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 11:45' prior: 35062673!remote	^RemoteDOMNode forProxy: self! !JSObject subclass: #RemoteJSObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!----SNAPSHOT----{20 September 2019 . 11:45:54 am} caffeine.image priorSource: 1519476!self explore!JSObject subclass: #ChromeAPI	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!ChromeAPI subclass: #ChromeRootAPI	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!Smalltalk renameClassNamed: #ChromeDebuggingAPI as: #ChromeDebuggingDomainAPI!Smalltalk renameClassNamed: #ChromeCSSAPI as: #ChromeCSSDomainAPI!(JS chrome at: #debugger)	sendCommand: {#tabId -> 104}	with: 'Debugger.resume'!Smalltalk renameClassNamed: #ChromeConsoleAPI as: #ChromeConsoleDomainAPI!Smalltalk renameClassNamed: #ChromeDOMAPI as: #ChromeDOMDomainAPI!Smalltalk renameClassNamed: #ChromeDebuggerAPI as: #ChromeDebuggerDomainAPI!Smalltalk renameClassNamed: #ChromeEmulationAPI as: #ChromeEmulationDomainAPI!Smalltalk renameClassNamed: #ChromeInspectorAPI as: #ChromeInspectorDomainAPI!Smalltalk renameClassNamed: #ChromeNetworkAPI as: #ChromeNetworkDomainAPI!Smalltalk renameClassNamed: #ChromePageAPI as: #ChromePageDomainAPI!Smalltalk renameClassNamed: #ChromeProfilerAPI as: #ChromeProfilerDomainAPI!Smalltalk renameClassNamed: #ChromeRenderingAPI as: #ChromeRenderingDomainAPI!Smalltalk renameClassNamed: #ChromeRuntimeAPI as: #ChromeRuntimeDomainAPI!Smalltalk renameClassNamed: #ChromeSecurityAPI as: #ChromeSecurityDomainAPI!Smalltalk renameClassNamed: #ChromeServiceWorkerAPI as: #ChromeServiceWorkerDomainAPI!Smalltalk renameClassNamed: #ChromeWorkerAPI as: #ChromeWorkerDomainAPI!!ChromeTabViaPage methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 13:26' prior: 33713181!transport: websocketOrExtension	transport := websocketOrExtension.	apis := (		(Dictionary new)			at: #Console put: (console := ChromeConsoleDomainAPI for: self);			at: #Network put: (network := ChromeNetworkDomainAPI for: self);			at: #Page put: (page := ChromePageDomainAPI for: self);			at: #Runtime put: (runtime := ChromeRuntimeDomainAPI for: self);			at: #Debugger put: (debugger := ChromeDebuggerDomainAPI for: self);			at: #DOM put: (dom := ChromeDOMDomainAPI for: self);			at: #CSS put: (css := ChromeCSSDomainAPI for: self);			at: #Worker put: (worker := ChromeWorkerDomainAPI for: self);			at: #Profiler put: (profiler := ChromeProfilerDomainAPI for: self);			at: #ServiceWorker put: (serviceWorker := ChromeServiceWorkerDomainAPI for: self);			at: #Emulation put: (emulation := ChromeEmulationDomainAPI for: self);			at: #Rendering put: (rendering := ChromeRenderingDomainAPI for: self);			at: #Inspector put: (inspector := ChromeInspectorDomainAPI for: self);			at: #Security put: (security := ChromeSecurityDomainAPI for: self);			yourself).				self close! !ChromeRootAPI subclass: #ChromeDebuggerAPI	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!----SNAPSHOT----{20 September 2019 . 1:26:52 pm} caffeine.image priorSource: 1525786!ChromeRootAPI subclass: #ChromeDebuggerAPI	instanceVariableNames: 'tab'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 13:37'!chrome	"Answer the root Chrome API."		^ChromeRootAPI forProxy: (self at: #chrome)! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 13:37'!chrome	^window chrome! !Webpage current chrome!ChromeRootAPI subclass: #ChromeTabsAPI	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!!ChromeRootAPI methodsFor: 'no messages' stamp: 'crl 9/20/2019 13:39'!debugger	^ChromeDebuggerAPI forProxy: (proxy at: #debugger)! !Webpage current chrome debugger!ChromeRootAPI subclass: #ChromeTabsAPI	instanceVariableNames: 'callbackResult'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!ChromeRootAPI subclass: #ChromeTabsAPI	instanceVariableNames: 'callbackResult'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!!ChromeTabsAPI methodsFor: 'no messages' stamp: 'crl 9/20/2019 13:50'!query: signature	^self resultFrom: [:resultAvailable |		self			query: signature			with: [:result |				callbackResult := result.				resultAvailable signal]]! !!ChromeTabsAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 13:53'!resultFrom: block	| resultAvailable |		resultAvailable := Semaphore new.		[block value: resultAvailable] fork.	resultAvailable wait.	^callbackResult! !!ChromeRootAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 13:54'!tabs	^ChromeTabsAPI forProxy: proxy tabs! !Webpage current chrome tabs query: {#title -> '*'}!JSObject subclass: #ChromeAPI	instanceVariableNames: 'callbackResult'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!JSObject subclass: #ChromeAPI	instanceVariableNames: 'callbackResult'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!!ChromeAPI methodsFor: 'no messages' stamp: 'crl 9/20/2019 13:55'!resultFrom: block	| resultAvailable |		resultAvailable := Semaphore new.		[block value: resultAvailable] fork.	resultAvailable wait.	^callbackResult! !ChromeAPI subclass: #ChromeDebuggerAPI	instanceVariableNames: 'tab'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!ChromeAPI subclass: #ChromeTabsAPI	instanceVariableNames: 'callbackResult'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!ChromeAPI subclass: #ChromeTabsAPI	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!SystemOrganization addCategory: #Unknown!Object subclass: #ChromeTabViaExtension	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Unknown'!SystemOrganization classify: #ChromeTabViaExtension under: 'Caffeine'!!ChromeAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 14:17'!debuggerForTabWithID: tabID	^ChromeDebuggerAPI forTab: (ChromeTabViaExtension withID: tabID)! !!ChromeDebuggerAPI class methodsFor: 'no messages' stamp: 'crl 9/20/2019 14:18'!forTab: aChromeTabViaExtension	^(self new)		tab: aChromeTabViaExtension;		yourself! !!ChromeDebuggerAPI methodsFor: 'no messages' stamp: 'crl 9/20/2019 14:18'!tab: aChromeTabViaExtension	tab := aChromeTabViaExtension! !EditHistory connectTo: 'ws://localhost:8091/tether'.!!ChromeRootAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 14:19'!debuggerForTabWithID: tabID	^ChromeDebuggerAPI forTab: (ChromeTabViaExtension withID: tabID)! !!ChromeRootAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 14:20' prior: 35083962!debugger	^ChromeDebuggerAPI new! !!ChromeRootAPI methodsFor: 'no messages' stamp: 'crl 9/20/2019 13:39' prior: 35087118!debugger	^ChromeDebuggerAPI forProxy: (proxy at: #debugger)! !!ChromeRootAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 14:28' prior: 35086926!debuggerForTabWithID: tabID	^(self debugger)		tab: (ChromeTabViaExtension withID: tabID);		yourself! !!ChromeTabViaExtension class methodsFor: 'no messages' stamp: 'crl 9/20/2019 14:46'!forTabWithID: tabID	^(self new)		id: tabID;		yourself! !!ChromeTabViaExtension methodsFor: 'no messages' stamp: 'crl 9/20/2019 14:46'!id: tabID	id := tabID! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 14:47'!attach	proxy		attach: {#tabId -> tab id}		with: '1.0'! !Webpage subclass: #ChromeTabViaExtension	instanceVariableNames: 'id debugger'	classVariableNames: ''	poolDictionaries: ''	category: 'Caffeine'!!ChromeTabViaExtension methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 14:56'!debugger: aChromeDebuggerAPI	debugger := aChromeDebuggerAPI! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 14:56' prior: 35086730!tab: aChromeTabViaExtension	tab := aChromeTabViaExtension.	aChromeTabViaExtension debugger: self! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 14:59' prior: 35087839!attach	| tabID |		tabID := {#tabId -> tab id}.		proxy		attach: tabID		with: '1.0';		sendCommand: tabID		with: 'Debugger.enable'! !ChromeAPI subclass: #ChromeDebuggerAPI	instanceVariableNames: 'tab tabID'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!ChromeAPI subclass: #ChromeDebuggerAPI	instanceVariableNames: 'tab tabID'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 15:00' prior: 35088298!tab: aChromeTabViaExtension	tab := aChromeTabViaExtension.	tabID := {#tabId -> tab id}.	aChromeTabViaExtension debugger: self! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 15:00' prior: 35088499!attach	proxy		attach: tabID		with: '1.0';		sendCommand: tabID		with: 'Debugger.enable'! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 15:01'!pause	proxy		sendCommand: tabID		with: 'Debugger.pause'! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 15:01'!resume	proxy		sendCommand: tabID		with: 'Debugger.resume'! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 15:05'!getDocument	^self resultFrom: [:resultAvailable |		proxy			sendCommand: tabID			with: 'Debugger.getDocument'			with: {#depth -> -1}			with: [:result |				callbackResult := result.				resultAvailable signal]]! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 15:06' prior: 35089765!getDocument	^self resultFrom: [:resultAvailable |		proxy			sendCommand: tabID			with: 'Debugger.getDocument'			with: {#depth -> -1}			with: [:result |				callbackResult := RemoteDOMNode forProxy: result.				resultAvailable signal]]! !JSObject subclass: #RemoteDOMNode	instanceVariableNames: 'attributes children debugger'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 15:08' prior: 35090083!getDocument	^self resultFrom: [:resultAvailable |		proxy			sendCommand: tabID			with: 'Debugger.getDocument'			with: {#depth -> -1}			with: [:result |				callbackResult := (					(RemoteDOMNode forProxy: result)						debugger: self;						yourself).										resultAvailable signal]]! !!RemoteDOMNode methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 15:08'!debugger: aChromeDebuggerAPI	debugger := aChromeDebuggerAPI! !!RemoteDOMNode methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 15:10'!resolve	^debugger resolve: self! !result counterpart!self object!!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 15:14'!resolve: remoteDOMNode	^self resultFrom: [:resultAvailable |		self			sendCommand: tabID			with: 'DOM.resolveNode'			with: {#nodeId -> remoteDOMNode nodeId}			with: [:result |				callbackResult := RemoteJSObject forProxy: result object.				resultAvailable signal]]! !----SNAPSHOT----{20 September 2019 . 3:15:49 pm} caffeine.image priorSource: 1528765!!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 15:49' prior: 35091275!resolve: remoteDOMNode	^self resultFrom: [:resultAvailable |		self			sendCommand: tabID			with: 'DOM.resolveNode'			with: {#nodeId -> remoteDOMNode nodeId}			with: [:result |				callbackResult := (					(RemoteJSObject forProxy: result object)						debugger: self;						yourself).										resultAvailable signal]]! !Smalltalk renameClassNamed: #RemoteJSObject as: #RemoteRuntimeJSObject!!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 15:50' prior: 35091736!resolve: remoteDOMNode	^self resultFrom: [:resultAvailable |		self			sendCommand: tabID			with: 'DOM.resolveNode'			with: {#nodeId -> remoteDOMNode nodeId}			with: [:result |				callbackResult := (					(RemoteRuntimeJSObject forProxy: result object)						debugger: self;						yourself).										resultAvailable signal]]! !JSObject subclass: #RemoteJSObject	instanceVariableNames: 'debugger'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!RemoteJSObject subclass: #RemoteDOMNode	instanceVariableNames: 'attributes children'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!!RemoteJSObject methodsFor: 'no messages' stamp: 'crl 9/20/2019 15:51'!debugger: aChromeDebuggerAPI	debugger := aChromeDebuggerAPI! !RemoteJSObject subclass: #RemoteRuntimeJSObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!RemoteJSObject subclass: #RemoteRuntimeJSObject	instanceVariableNames: 'properties'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!RemoteJSObject subclass: #RemoteRuntimeJSObject	instanceVariableNames: 'properties'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!!RemoteRuntimeJSObject methodsFor: 'no messages' stamp: 'crl 9/20/2019 15:58'!getProperties	properties := debugger getPropertiesFor: self! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:14'!getPropertiesFor: remoteRuntimeJSObject	^self resultFrom: [:resultAvailable |		self			sendCommand: tabID			with: 'Runtime.getProperties'			with: {#objectId -> remoteRuntimeJSObject objectId}			with: [:result |				callbackResult := result result.				resultAvailable signal]]! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:19'!detach	proxy detach: tabID! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:20'!enable	proxy		sendCommand: tabID		with: 'Debugger.enable'! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:20'!disable	proxy		sendCommand: tabID		with: 'Debugger.disable'! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:20' prior: 35089295!attach	proxy		attach: tabID		with: '1.0';		enable! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:20' prior: 35094144!detach	self disable.	proxy detach: tabID! !----SNAPSHOT----{20 September 2019 . 4:21:29 pm} caffeine.image priorSource: 1537117!----SNAPSHOT----{20 September 2019 . 4:23:05 pm} caffeine.image priorSource: 1540339!!ChromeTabViaExtension class methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:24'!withID: tabID	^(self new)		id: tabID;		yourself! !!ChromeTabViaExtension methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:25'!id	^id! !!ChromeTabViaExtension class methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:28' prior: 35095039!withID: tabID	3 halt.	^(self new)		id: tabID;		yourself! !!ChromeTabViaExtension class methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:28' prior: 35095300!withID: tabID	^(self new)		id: tabID;		yourself! !Webpage current chrome debuggerForTabWithID: 104!self getDocument!!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:33' prior: 35090602!getDocument	^self resultFrom: [:resultAvailable |		proxy			sendCommand: tabID			with: 'DOM.getDocument'			with: {#depth -> -1}			with: [:result |				callbackResult := (					(RemoteDOMNode forProxy: result)						debugger: self;						yourself).										resultAvailable signal]]! !self getDocument!!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:33' prior: 35095695!getDocument	^self resultFrom: [:resultAvailable |		proxy			sendCommand: tabID			with: 'DOM.getDocument'			with: {#depth -> -1}			with: [:result |				callbackResult := (					(RemoteDOMNode forProxy: result root)						debugger: self;						yourself).										resultAvailable signal]]! !self getDocument!!RemoteDOMNode methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:40' prior: 35062272!doesNotUnderstand: message	| result |		result := super doesNotUnderstand: message.		^[result remote]		on: Error		do: [:exception | result]! !| debugger fastForwardButton |debugger := Webpage current chrome debuggerForTabWithID: 104."debugger attach."fastForwardButton := debugger resolve: (debugger getDocument getElementsByClassName: 'button-nfplayerFastForward') onlyOne.	debugger detach.fastForwardButton!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:45'!callFunctionNamed: functionName	^debugger callFunctionNamed: functionName on: self! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:47'!remoteDOMNode	^RemoteDOMNode forProxy: self! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:48'!remoteRuntimeJSObject	^RemoteRuntimeJSObject forProxy: self! !!RemoteDOMNode methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:48' prior: 35072741!at: key	| value |		value := super at: key.		^(value class == Array)		ifTrue: [			value collect: [:element |				[element counterpart simplestRepresentation remoteDOMNode]					on: Error					do: [:exception | element counterpart simplestRepresentation]]]		ifFalse: [			[value remote]				on: Error				do: [:exception | value]]! !!RemoteDOMNode methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:48' prior: 35096516!doesNotUnderstand: message	| result |		result := super doesNotUnderstand: message.		^[result remoteDOMNode]		on: Error		do: [:exception | result]! !!RemoteDOMNode methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:49' prior: 35097482!at: key	| value |		value := super at: key.		^(value class == Array)		ifTrue: [			value collect: [:element |				[element counterpart simplestRepresentation remoteDOMNode]					on: Error					do: [:exception | element counterpart simplestRepresentation]]]		ifFalse: [			[value remoteDOMNode]				on: Error				do: [:exception | value]]! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:49'!callFunctionNamed: functionName on: remoteRuntimeJSObject	^self resultFrom: [:resultAvailable |		self			sendCommand: tabID			with: 'Runtime.callFunctionOn'			with: {#objectId -> remoteRuntimeJSObject objectId}			with: [:result |				callbackResult := result remoteRuntimeJSObject.				resultAvailable signal]]! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:52' prior: 35098598!callFunctionNamed: functionName on: remoteRuntimeJSObject	^self resultFrom: [:resultAvailable |		self			sendCommand: tabID			with: 'Runtime.callFunctionOn'			with: {#objectId -> remoteRuntimeJSObject objectId}			with: [:result |				callbackResult := (					result						ifNil: [result]						ifNotNil: [remoteRuntimeJSObject]).										resultAvailable signal]]! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:54' prior: 35094570!attach	proxy		attach: tabID		with: '1.0'.	self enable! !	self enable!self callFunctionNamed: #click!self callFunctionNamed: #click!self type!self description!self callFunctionNamed: #click!self callFunctionNamed: #click!!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 17:00' prior: 35099016!callFunctionNamed: functionName on: remoteRuntimeJSObject	^self resultFrom: [:resultAvailable |		self			sendCommand: tabID			with: 'Runtime.callFunctionOn'			with: {				#objectId -> remoteRuntimeJSObject objectId.				#functionDeclaration -> functionName}			with: [:result |				callbackResult := (					result						ifNil: [result]						ifNotNil: [remoteRuntimeJSObject]).										resultAvailable signal]]! !self objectId!| debugger fastForwardButton |debugger := Webpage current chrome debuggerForTabWithID: 104.debugger detach!| debugger fastForwardButton |debugger := Webpage current chrome debuggerForTabWithID: 104.debugger attach.fastForwardButton := debugger resolve: (debugger getDocument getElementsByClassName: 'button-nfplayerFastForward') onlyOne.	debugger detach.fastForwardButton!!ChromeRootAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 17:02' prior: 35087400!debuggerForTabWithID: tabID	^(self debugger)		tab: (ChromeTabViaExtension withID: tabID);		attach;		yourself! !----SNAPSHOT----{20 September 2019 . 5:04:04 pm} caffeine.image priorSource: 1540426!| debugger fastForwardButton |debugger := Webpage current chrome debuggerForTabWithID: 104.fastForwardButton := debugger resolve: (debugger getDocument getElementsByClassName: 'button-nfplayerFastForward') onlyOne.fastForwardButton!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 17:05'!doesNotUnderstand: message	^debugger callFunctionNamed: message selector on: self! !!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 17:13' prior: 35101279!doesNotUnderstand: message	^[super doesNotUnderstand: message]		on: MessageNotUnderstood		do: [:exception | debugger callFunctionNamed: message selector on: self]! !!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 17:15' prior: 35101468!doesNotUnderstand: message	^[super doesNotUnderstand: message]		on: Error		do: [:exception | debugger callFunctionNamed: message selector on: self]! !| debugger fastForwardButton |debugger := Webpage current chrome debuggerForTabWithID: 104.fastForwardButton := debugger resolve: (debugger getDocument getElementsByClassName: 'button-nfplayerFastForward') onlyOne.fastForwardButton!self click!self click!| debugger fastForwardButton |debugger := Webpage current chrome debuggerForTabWithID: 104.fastForwardButton := debugger resolve: (debugger getDocument getElementsByClassName: 'button-nfplayerFastForward') onlyOne.fastForwardButton!self click!self click! jsSelector contents asSymbol!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 17:21' prior: 35101740!doesNotUnderstand: message	^[super doesNotUnderstand: message]		on: Error		do: [:exception |			3 halt.			debugger callFunctionNamed: message selector on: self]! !remoteRuntimeJSObject objectId!self resultFrom: [:resultAvailable |		self			sendCommand: tabID			with: 'Runtime.callFunctionOn'			with: {				#objectId -> remoteRuntimeJSObject objectId.				#functionDeclaration -> functionName}			with: [:result |				callbackResult := (					result						ifNil: [result]						ifNotNil: [remoteRuntimeJSObject]).										resultAvailable signal]]!self type!self description!self objectId!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 17:29' prior: 35102561!doesNotUnderstand: message	^[super doesNotUnderstand: message]		on: Error		do: [:exception | debugger callFunctionNamed: message selector on: self]! !self click!| debugger fastForwardButton |debugger := Webpage current chrome debuggerForTabWithID: 104.fastForwardButton := debugger resolve: (debugger getDocument getElementsByClassName: 'button-nfplayerFastForward') onlyOne.fastForwardButton!self click!!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 17:39' prior: 35099828!callFunctionNamed: functionName on: remoteRuntimeJSObject	^self resultFrom: [:resultAvailable |		self			sendCommand: tabID			with: 'Runtime.callFunctionOn'			with: {				#objectId -> remoteRuntimeJSObject objectId.				#functionDeclaration -> functionName}			with: [:result |				callbackResult := (					result						ifNil: [result]						ifNotNil: [result remoteRuntimeJSObject]).										resultAvailable signal]]! !self click!self explore!!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 17:48' prior: 35103791!callFunctionNamed: functionName on: remoteRuntimeJSObject	^self resultFrom: [:resultAvailable |		self			sendCommand: tabID			with: 'Runtime.callFunctionOn'			with: {				#objectId -> remoteRuntimeJSObject objectId.				#functionDeclaration -> functionName.				#executionContextId -> remoteRuntimeJSObject objectId}			with: [:result |				callbackResult := (					result						ifNil: [result]						ifNotNil: [result remoteRuntimeJSObject]).										resultAvailable signal]]! !self click!----SNAPSHOT----{20 September 2019 . 5:50:47 pm} caffeine.image priorSource: 1546432!!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 20:16' prior: 35104346!callFunctionNamed: functionName on: remoteRuntimeJSObject	3 halt.	^self resultFrom: [:resultAvailable |		self			sendCommand: tabID			with: 'Runtime.callFunctionOn'			with: {				#objectId -> remoteRuntimeJSObject objectId.				#functionDeclaration -> functionName.				#executionContextId -> remoteRuntimeJSObject objectId}			with: [:result |				callbackResult := (					result						ifNil: [result]						ifNotNil: [result remoteRuntimeJSObject]).										resultAvailable signal]]! !remoteRuntimeJSObject objectId!!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 20:35' prior: 35105032!callFunctionNamed: functionName on: remoteRuntimeJSObject	^self resultFrom: [:resultAvailable |		self			sendCommand: tabID			with: 'Runtime.callFunctionOn'			with: {				#objectId -> remoteRuntimeJSObject objectId.				#functionDeclaration -> functionName}			with: [:result |				callbackResult := (					result						ifNil: [result]						ifNotNil: [result remoteRuntimeJSObject]).										resultAvailable signal]]! !self click!self click!!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 20:42'!callFunctionWithSource: source on: remoteRuntimeJSObject	^self resultFrom: [:resultAvailable |		self			sendCommand: tabID			with: 'Runtime.callFunctionOn'			with: {				#objectId -> remoteRuntimeJSObject objectId.				#functionDeclaration -> source}			with: [:result |				callbackResult := (					result						ifNil: [result]						ifNotNil: [result remoteRuntimeJSObject]).										resultAvailable signal]]! !!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 20:43'!callFunctionWithSource: functionName	^debugger callFunctionWithSource: functionName on: self! !!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 20:44' prior: 35103272!doesNotUnderstand: message	^[super doesNotUnderstand: message]		on: Error		do: [:exception |			debugger				callFunctionWithSource: '() => {this.', message selector, '()}'				on: self]! !self click!self click!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 20:56' prior: 35106705!callFunctionWithSource: source	^debugger callFunctionWithSource: source on: self! !!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 20:58' prior: 35106905!doesNotUnderstand: message	^[super doesNotUnderstand: message]		on: Error		do: [:exception |			debugger				callFunctionWithSource: '(receiver) => {receiver.', message selector, '()}'				withParameters: {self}				on: self]! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 21:13'!callFunctionWithSource: source withParameters: parameters on: remoteRuntimeJSObject	^self resultFrom: [:resultAvailable |		| arguments |				arguments := (String new: 32) writableStream.				arguments nextPut: $[.		parameters do: [:parameter |			arguments				nextPutAll: '{#objectId: "', parameter objectId, '"}';				nextPutAll: ', '].		arguments previousTake: 2.						self			sendCommand: tabID			with: 'Runtime.callFunctionOn'			with: {				#objectId -> remoteRuntimeJSObject objectId.				#functionDeclaration -> source.				#arguments -> arguments contents}			with: [:result |				callbackResult := (					result						ifNil: [result]						ifNotNil: [result remoteRuntimeJSObject]).										resultAvailable signal]]! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 21:13' prior: 35106197!callFunctionWithSource: source on: remoteRuntimeJSObject	^self		callFunctionWithSource: source		withParameters: {}		on: remoteRuntimeJSObject! !self click!| debugger fastForwardButton |debugger := Webpage current chrome debuggerForTabWithID: 104.fastForwardButton := debugger resolve: (debugger getDocument getElementsByClassName: 'button-nfplayerFastForward') onlyOne.fastForwardButton!!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 21:47' prior: 35107730!callFunctionWithSource: source withParameters: parameters on: remoteRuntimeJSObject	3 halt.	^self resultFrom: [:resultAvailable |		| arguments |				arguments := (String new: 32) writableStream.				arguments nextPut: $[.		parameters do: [:parameter |			arguments				nextPutAll: '{#objectId: "', parameter objectId, '"}';				nextPutAll: ', '].		arguments previousTake: 2.						self			sendCommand: tabID			with: 'Runtime.callFunctionOn'			with: {				#objectId -> remoteRuntimeJSObject objectId.				#functionDeclaration -> source.				#arguments -> arguments contents}			with: [:result |				callbackResult := (					result						ifNil: [result]						ifNotNil: [result remoteRuntimeJSObject]).										resultAvailable signal]]! !remoteRuntimeJSObject objectId.!!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 21:50' prior: 35109073!callFunctionWithSource: source withParameters: parameters on: remoteRuntimeJSObject	3 halt.	^self resultFrom: [:resultAvailable |		| arguments |				arguments := (String new: 32) writableStream.				arguments nextPut: $[.		parameters do: [:parameter |			arguments				nextPutAll: '{#objectId: "', parameter objectId, '"}';				nextPutAll: ', '].		arguments			previousTake: 2;			nextPut: $].						self			sendCommand: tabID			with: 'Runtime.callFunctionOn'			with: {				#objectId -> remoteRuntimeJSObject objectId.				#functionDeclaration -> source.				#arguments -> arguments contents}			with: [:result |				callbackResult := (					result						ifNil: [result]						ifNotNil: [result remoteRuntimeJSObject]).										resultAvailable signal]]! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 21:50' prior: 35109958!callFunctionWithSource: source withParameters: parameters on: remoteRuntimeJSObject	^self resultFrom: [:resultAvailable |		| arguments |				arguments := (String new: 32) writableStream.				arguments nextPut: $[.		parameters do: [:parameter |			arguments				nextPutAll: '{#objectId: "', parameter objectId, '"}';				nextPutAll: ', '].		arguments			previousTake: 2;			nextPut: $].						self			sendCommand: tabID			with: 'Runtime.callFunctionOn'			with: {				#objectId -> remoteRuntimeJSObject objectId.				#functionDeclaration -> source.				#arguments -> arguments contents}			with: [:result |				callbackResult := (					result						ifNil: [result]						ifNotNil: [result remoteRuntimeJSObject]).										resultAvailable signal]]! !self click!self click!self click!!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 21:50' prior: 35110828!callFunctionWithSource: source withParameters: parameters on: remoteRuntimeJSObject	^self resultFrom: [:resultAvailable |		| arguments |				arguments := (String new: 32) writableStream.				arguments nextPut: $[.		parameters do: [:parameter |			arguments				nextPutAll: '{#objectId: "', parameter objectId, '"}';				nextPutAll: ', '].		arguments			previousTake: 2;			nextPut: $].						3 halt.				self			sendCommand: tabID			with: 'Runtime.callFunctionOn'			with: {				#objectId -> remoteRuntimeJSObject objectId.				#functionDeclaration -> source.				#arguments -> arguments contents}			with: [:result |				callbackResult := (					result						ifNil: [result]						ifNotNil: [result remoteRuntimeJSObject]).										resultAvailable signal]]! !arguments contents!!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 21:53' prior: 35111728!callFunctionWithSource: source withParameters: parameters on: remoteRuntimeJSObject	^self resultFrom: [:resultAvailable |		| arguments |				arguments := (String new: 32) writableStream.				arguments nextPut: $[.		parameters do: [:parameter |			arguments				nextPutAll: '{#objectId: ''', parameter objectId, '''}';				nextPutAll: ', '].		arguments			previousTake: 2;			nextPut: $].						self			sendCommand: tabID			with: 'Runtime.callFunctionOn'			with: {				#objectId -> remoteRuntimeJSObject objectId.				#functionDeclaration -> source.				#arguments -> arguments contents}			with: [:result |				callbackResult := (					result						ifNil: [result]						ifNotNil: [result remoteRuntimeJSObject]).										resultAvailable signal]]! !self click!!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 21:54' prior: 35112623!callFunctionWithSource: source withParameters: parameters on: remoteRuntimeJSObject	^self resultFrom: [:resultAvailable |		| arguments |				arguments := (String new: 32) writableStream.				arguments nextPut: $[.		parameters do: [:parameter |			arguments				nextPutAll: '{#objectId: ''', parameter objectId, '''}';				nextPutAll: ', '].		arguments			previousTake: 2;			nextPut: $].						3 halt.				self			sendCommand: tabID			with: 'Runtime.callFunctionOn'			with: {				#objectId -> remoteRuntimeJSObject objectId.				#functionDeclaration -> source.				#arguments -> arguments contents}			with: [:result |				callbackResult := (					result						ifNil: [result]						ifNotNil: [result remoteRuntimeJSObject]).										resultAvailable signal]]! !				arguments contents!				arguments contents!arguments contents!!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 21:58' prior: 35113499!callFunctionWithSource: source withParameters: parameters on: remoteRuntimeJSObject	^self resultFrom: [:resultAvailable |		| arguments |				arguments := OrderedCollection new.		parameters do: [:parameter | arguments add: '{#objectId: ''', parameter objectId, '''}'].						self			sendCommand: tabID			with: 'Runtime.callFunctionOn'			with: {				#objectId -> remoteRuntimeJSObject objectId.				#functionDeclaration -> source.				#arguments -> arguments asArray}			with: [:result |				callbackResult := (					result						ifNil: [result]						ifNotNil: [result remoteRuntimeJSObject]).										resultAvailable signal]]! !self click!!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 21:59' prior: 35114446!callFunctionWithSource: source withParameters: parameters on: remoteRuntimeJSObject	^self resultFrom: [:resultAvailable |		| arguments |				arguments := OrderedCollection new.		parameters do: [:parameter | arguments add: '{#objectId: ''', parameter objectId, '''}'].					3 halt.				self			sendCommand: tabID			with: 'Runtime.callFunctionOn'			with: {				#objectId -> remoteRuntimeJSObject objectId.				#functionDeclaration -> source.				#arguments -> arguments asArray}			with: [:result |				callbackResult := (					result						ifNil: [result]						ifNotNil: [result remoteRuntimeJSObject]).										resultAvailable signal]]! !arguments := OrderedCollection new.		parameters do: [:parameter | arguments add: {#objectId -> parameter objectId}].!arguments!!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:04' prior: 35115198!callFunctionWithSource: source withParameters: parameters on: remoteRuntimeJSObject	^self resultFrom: [:resultAvailable |		| arguments |				arguments := OrderedCollection new.		parameters do: [:parameter | arguments add: {#objectId -> parameter objectId}].					self			sendCommand: tabID			with: 'Runtime.callFunctionOn'			with: {				#objectId -> remoteRuntimeJSObject objectId.				#functionDeclaration -> source.				#arguments -> arguments asArray}			with: [:result |				callbackResult := (					result						ifNil: [result]						ifNotNil: [result remoteRuntimeJSObject]).										resultAvailable signal]]! !self click!self click!self click!self click!self click!----SNAPSHOT----{20 September 2019 . 10:04:56 pm} caffeine.image priorSource: 1550413!self properties!self properties!self getProperties!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:07' prior: 35093629!getProperties	properties := (debugger getPropertiesFor: self) collect: [:property | property remoteRuntimeJSObject]! !!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:08' prior: 35117024!getProperties	properties := (debugger getPropertiesFor: self) asArray collect: [:property | property remoteRuntimeJSObject]! !self getProperties!properties first!properties := nil!JSObject subclass: #RemoteRuntimeJSObjectProperties	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!JSObject subclass: #JSObjectMetadata	instanceVariableNames: 'debugger'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!JSObjectMetadata subclass: #RemoteJSObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!JSObjectMetadata subclass: #RemoteRuntimeJSObjectProperties	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!----SNAPSHOT----{20 September 2019 . 10:17:03 pm} caffeine.image priorSource: 1562343!!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:19'!remoteRuntimeJSObjectProperties	^RemoteRuntimeJSObjectProperties forProxy: self! !!JSObjectMetadata class methodsFor: 'no messages' stamp: 'crl 9/20/2019 22:20'!forProxy: proxy byDebugger: debugger	^(super forProxy: proxy) debugger: debugger! !!JSObjectMetadata methodsFor: 'no messages' stamp: 'crl 9/20/2019 22:20'!debugger: aChromeDebuggerAPI	debugger := aChromeDebuggerAPI! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:21' prior: 35096105!getDocument	^self resultFrom: [:resultAvailable |		proxy			sendCommand: tabID			with: 'DOM.getDocument'			with: {#depth -> -1}			with: [:result |				callbackResult := (RemoteDOMNode forProxy: result root byDebugger: self).				resultAvailable signal]]! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:21' prior: 35092237!resolve: remoteDOMNode	^self resultFrom: [:resultAvailable |		self			sendCommand: tabID			with: 'DOM.resolveNode'			with: {#nodeId -> remoteDOMNode nodeId}			with: [:result |				callbackResult := (RemoteRuntimeJSObject forProxy: result object byDebugger: self).				resultAvailable signal]]! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:23'!remoteRuntimeJSObjectByDebugger: debugger	^RemoteRuntimeJSObject forProxy: self byDebugger: debugger! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:23'!remoteRuntimeJSObjectPropertiesByDebugger: debugger	^RemoteRuntimeJSObjectProperties forProxy: self byDebugger: debugger! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:23' prior: 35116082!callFunctionWithSource: source withParameters: parameters on: remoteRuntimeJSObject	^self resultFrom: [:resultAvailable |		| arguments |				arguments := OrderedCollection new.		parameters do: [:parameter | arguments add: {#objectId -> parameter objectId}].					self			sendCommand: tabID			with: 'Runtime.callFunctionOn'			with: {				#objectId -> remoteRuntimeJSObject objectId.				#functionDeclaration -> source.				#arguments -> arguments asArray}			with: [:result |				callbackResult := (					result						ifNil: [result]						ifNotNil: [result remoteRuntimeJSObjectByDebugger: self]).										resultAvailable signal]]! !!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:24' prior: 35117247!getProperties	properties := (debugger getPropertiesFor: self) asArray collect: [:property | property remoteRuntimeJSObjectByDebugger: debugger]! !!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:24' prior: 35120645!getProperties	properties := (debugger getPropertiesFor: self) asArray collect: [:property | property remoteRuntimeJSObjectPropertiesByDebugger: debugger]! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:25' prior: 35119109!resolve: remoteDOMNode	^self resultFrom: [:resultAvailable |		self			sendCommand: tabID			with: 'DOM.resolveNode'			with: {#nodeId -> remoteDOMNode nodeId}			with: [:result |				callbackResult := (result object remoteRuntimeJSObjectByDebugger: self).				resultAvailable signal]]! !----SNAPSHOT----{20 September 2019 . 10:26:25 pm} caffeine.image priorSource: 1563662!self getProperties!properties size!properties first name!!JSObjectMetadata methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:27'!name	^proxy at: #name! !properties first name!properties first class!!JSObjectMetadata methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:30' prior: 35121676!name	^self at: #name! !properties select: [:property | '__reactInternalInstance$*' match: property name]!Smalltalk renameClassNamed: #RemoteRuntimeJSObjectProperties as: #RemoteRuntimeJSObjectProperty!!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:35'!remoteRuntimeJSObjectPropertyByDebugger: debugger	^RemoteRuntimeJSObjectProperty forProxy: self byDebugger: debugger! !!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:35' prior: 35120896!getProperties	properties := (debugger getPropertiesFor: self) asArray collect: [:property | property remoteRuntimeJSObjectPropertyByDebugger: debugger]! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:35' prior: 35122135!remoteRuntimeJSObjectPropertyByDebugger: debugger	^RemoteRuntimeJSObjectProperty forProxy: self byDebugger: debugger! !!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:35'!getProperties	properties := (debugger getPropertiesFor: self) asArray collect: [:property | property remoteRuntimeJSObjectPropertyByDebugger: debugger]! !----SNAPSHOT----{20 September 2019 . 10:37:23 pm} caffeine.image priorSource: 1567010!!RemoteRuntimeJSObjectProperty methodsFor: 'no messages' stamp: 'crl 9/20/2019 22:41'!printOn: stream	stream		nextPutAll: 'the ''';		nextPutAll: self name;		nextPutAll: ''' property of a remote JavaScript object'! !self description!!RemoteRuntimeJSObjectProperty methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:43'!value	^self at: #value! !self value!!RemoteRuntimeJSObjectProperty methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:44' prior: 35123397!value	^(self at: #value) remoteRuntimeJSObjectByDebugger: debugger! !self value!self value!!RemoteRuntimeJSObjectProperty methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:46' prior: 35123548!value	^(self at: #value) proxy remoteRuntimeJSObjectByDebugger: debugger! !self value!self getProperties!properties size!properties collect: [:property | property name]!self return!self at: #return!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:50'!at: key	^(properties detect: [:property | property name = key]) value! !self at: #return!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:51' prior: 35124055!at: key	^(self getProperties detect: [:property | property name = key]) value! !!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:51' prior: 35122818!getProperties	properties := (debugger getPropertiesFor: self) asArray collect: [:property | property remoteRuntimeJSObjectPropertyByDebugger: debugger].	^properties! !self getProperties!self value!self getProperties!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:57'!atMatching: pattern	^(self getProperties detect: [:property | pattern match: property name]) value! !self atMatching: '__reactInternalInstance$*'!(((self atMatching: '__reactInternalInstance$*') at: #return) at: #stateNode) at: #props!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 23:05'!keys	^self getProperties collect: [:property | property name]! !((((self atMatching: '__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) keys!((((self atMatching: '__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick!self description!self description!self getProperties!self name!self name value!self at: #name!proxy at: #value!self getProperties!!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 23:44' prior: 35093776!getPropertiesFor: remoteRuntimeJSObject	^self resultFrom: [:resultAvailable |		self			sendCommand: tabID			with: 'Runtime.getProperties'			with: {#objectId -> remoteRuntimeJSObject objectId}			with: [:result |				callbackResult := result.				resultAvailable signal]]! !!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 23:44' prior: 35124436!getProperties	properties := (debugger getPropertiesFor: self) result asArray collect: [:property | property remoteRuntimeJSObjectPropertyByDebugger: debugger].	^properties! !debugger getPropertiesFor: self!self counterpart!self internalProperties!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 23:49' prior: 35125972!getProperties	| result |		result := debugger getPropertiesFor: self.	properties := OrderedCollection new.		{		result result.		result internalProperties	}		do: [:things | properties addAll: (things asArray collect: [:property | property remoteRuntimeJSObjectPropertyByDebugger: debugger])].			properties := properties asArray.	^properties! !!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 23:50'!printOn: stream	stream		nextPutAll: 'a ';		print: self class;		nextPutAll: ' described by ''';		nextPutAll: self description! !!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 23:51' prior: 35126772!printOn: stream	stream		nextPutAll: 'a ';		print: self class;		nextPutAll: ' described by ''';		nextPutAll: self description;		nextPut: $'! !self getProperties!!RemoteRuntimeJSObjectProperty methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 23:52' prior: 35123149!printOn: stream	stream		nextPutAll: 'the ''';		nextPutAll: self name;		nextPutAll: ''' property of ';		print: self value! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 23:54'!remoteRuntimeJSObjectPropertyOf: remoteRuntimeJSObject byDebugger: debugger	^(RemoteRuntimeJSObjectProperty forProxy: self byDebugger: debugger)		home: remoteRuntimeJSObject;		yourself! !!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 23:54' prior: 35126331!getProperties	| result |		result := debugger getPropertiesFor: self.	properties := OrderedCollection new.		{		result result.		result internalProperties	}		do: [:things | properties addAll: (things asArray collect: [:property | property remoteRuntimeJSObjectPropertyOf: self byDebugger: debugger])].			properties := properties asArray.	^properties! !JSObjectMetadata subclass: #RemoteRuntimeJSObjectProperty	instanceVariableNames: 'home'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!JSObjectMetadata subclass: #RemoteRuntimeJSObjectProperty	instanceVariableNames: 'home'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!!RemoteRuntimeJSObjectProperty methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 23:55'!home: remoteRuntimeJSObject	home := remoteRuntimeJSObject! !!RemoteRuntimeJSObjectProperty methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 23:55' prior: 35127288!printOn: stream	stream		nextPutAll: 'the ''';		nextPutAll: self name;		nextPutAll: ''' property of ';		print: home! !!RemoteRuntimeJSObjectProperty class methodsFor: 'no messages' stamp: 'crl 9/20/2019 23:56'!forProxy: proxy byDebugger: debugger	^self shouldNotImplement! !self getProperties!self at: '[[BoundThis]]'!self value at: '[[BoundThis]]'!self at: '[[BoundThis]]'!result counterpart!result at: #internalProperties!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 00:04' prior: 35127790!getProperties	| result |		result := debugger getPropertiesFor: self.	properties := OrderedCollection new.		{		result result.		(result at: #internalProperties) yourselfUnlessNil: [{}]	}		do: [:things | properties addAll: (things asArray collect: [:property | property remoteRuntimeJSObjectPropertyOf: self byDebugger: debugger])].			properties := properties asArray.	^properties! !(self at: '[[BoundThis]]') at: #props!((self at: '[[BoundThis]]') at: #props) at: #onClick!(((self at: '[[BoundThis]]') at: #props) at: #onClick) at: '[[BoundThis]]'!self getProperties!(((((((((self atMatching: '__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick) at: '[[BoundThis]]') at: #props) at: #onClick) at: '[[BoundThis]]') at: #onSeekForward!----SNAPSHOT----{21 September 2019 . 12:07:57 am} caffeine.image priorSource: 1568541!self at: '[[BoundThis]]'!self context!self context!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 00:28' prior: 35107415!doesNotUnderstand: message	^[super doesNotUnderstand: message]		on: Error		do: [:exception |			3 halt.			debugger				callFunctionWithSource: '(receiver) => {receiver.', message selector, '()}'				withParameters: {self}				on: self]! !!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 00:34' prior: 35130356!doesNotUnderstand: message	^[super doesNotUnderstand: message]		on: Error		do: [:exception |			debugger				callFunctionWithSource: '(receiver) => {receiver.', message selector, '()}'				withParameters: {self}				on: self]! !self counterpart!self getProperties detect: [:property | property name = #context]!self value!proxy counterpart!self getProperties detect: [:property | property name = #playerApp]!self value!self playerApp!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 00:44' prior: 35130702!doesNotUnderstand: message	^[super doesNotUnderstand: message]		on: Error		do: [:exception |			3 halt.			debugger				callFunctionWithSource: '(receiver) => {receiver.', message selector, '()}'				withParameters: {self}				on: self]! !!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 00:44' prior: 35131257!doesNotUnderstand: message	^[super doesNotUnderstand: message]		on: Error		do: [:exception |			debugger				callFunctionWithSource: '(receiver) => {receiver.', message selector, '()}'				withParameters: {self}				on: self]! !self at: #playerApp!self at: #playerApp!((((((((((((self atMatching: '__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick) at: '[[BoundThis]]') at: #props) at: #onClick) at: '[[BoundThis]]') at: #onSeekForward) at: '[[BoundThis]]') at: #context) at: #playerApp!----SNAPSHOT----{21 September 2019 . 12:46:49 am} caffeine.image priorSource: 1575675!(((((((((((((self atMatching: '__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick) at: '[[BoundThis]]') at: #props) at: #onClick) at: '[[BoundThis]]') at: #onSeekForward) at: '[[BoundThis]]') at: #context) at: #playerApp) getActionCreators!----STARTUP----{21 September 2019 . 1:36:55 am} as /Users/craig/Downloads/caffeine/backups/36 (rescue)/caffeine.image!----QUIT/NOSAVE----{21 September 2019 . 1:42:55 am} caffeine.image priorSource: 1496944!----STARTUP----{21 September 2019 . 1:43:32 am} as /Users/craig/Downloads/caffeine/backups/36 (rescue)/caffeine.image!!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 13:12' prior: 35046326!startUp: resuming	"After a system resumption, if the system is being run by SqueakJS in a web browser, reset constants related to that web browser's JavaScript environment."	| forceToScreen |	resuming ifTrue: [		(self == Webpage)			ifTrue: [				Fullscreen := false.								Top := TopDocument := ContainingDiv := ContainingCanvas := ContainingFrame := Current := Options := nil.				Preferences					setPreference: #fastDragWindowForMorphic					toValue: JS isConnected.								JS ifConnected: [					| url |															Top := [JS top counterpart magicWindow] on: Error do: [:exception | JS window].					url := (						Top							ifNil: [String randomOfLength: 5]							ifNotNil: [								TopDocument := Top document.								Url absoluteFromText: Top location href asString]).					Options := (						(JS SqueakJS options at: #parameters)							ifNil: [nil]							ifNotNil: [JS SqueakJS options parameters counterpart]).												ContainingCanvas := JS document counterpart getElementById: 'squeak'.					ContainingCanvas						at: #width put: Options width;						at: #height put: Options height.											Top ifNotNil: [ContainingFrame := Top document getElementById: #Caffeine].					ContainingCanvas ifNotNil: [						ContainingDiv := (							ContainingFrame								ifNil: [ContainingCanvas parentNode]								ifNotNil: [									self styleAt: #transition put: 'opacity 500ms'.									ContainingFrame parentNode parentNode]).						ContainingDiv at: #onresize put: [self resize].						ContainingCanvas at: #tabIndex put: 0.						self captureCurrentExtent.						ContainingCanvas onclick: [self focus]].										forceToScreen := [:event | Display forceToScreen].					Top						at: #onresize						put: forceToScreen; 						at: #onscroll						put: forceToScreen;						at: #onorientationchange						put: [:event |							forceToScreen value: event.							self scrollToTop].															ContainingCanvas ifNotNil: [						ContainingCanvas							styleAt: 'user-select'							put: [false]].					Pages						at: url						ifAbsent: [							self								ifOptionAt: 'appID'								then: [:appID |									| appClass |																		appClass := self allSubclasses detect: [:subclass | subclass appID = appID] ifNone: [nil].									appClass										ifNil: [nil]										ifNotNil: [											Pages												at: url												put: (appClass fromURL: url)]]								else: [nil]]]]]! !!Caffeine methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 13:12' prior: 35048845!initialize	super initialize.	(window document getElementById: 'sqSpinner') beOpaque! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 14:24'!zoomTo: point	ContainingCanvas		at: #width put: point x;		at: #height put: point y! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 14:25' prior: 34008738!zoomOut	"Zoom out the containing canvas."		ContainingCanvas		styleAt: #left put: 0;		styleAt: #top put: 0.			self zoomTo: (ContainingCanvas width @ ContainingCanvas height)! !!MorphicProject methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 14:28' prior: 34309804!setAsBackground: aForm	"Set  aForm as a background image."	| thisWorld newColor |	thisWorld := self currentWorld.	newColor := InfiniteForm with: aForm.	aForm rememberCommand:		(Command new cmdWording: 'set background to a picture' translated;			undoTarget: thisWorld selector: #color: argument: thisWorld color;			redoTarget: thisWorld selector: #color: argument: newColor).	thisWorld color: newColor! !!CaffeineExtension methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 14:55' prior: 35029708!initialize	"Connect to the Caffeine Helper web browser extension."		tabs := IdentityDictionary new.	promises := IdentityDictionary new.	nextPromiseID := 1.	port := JS chrome runtime connect: 'kfifbhlilndoognbpbaipgbhfphcldnp'.		port onMessage addListener: [:message |		(message at: 'method')			ifNil: [				"Resolve a promised answer from the extension."								| promise |								promise := promises at: (message at: 'promiseID') ifAbsent: [nil].								promise ifNotNil: [promise resolveWith: (message at: 'result') counterpart simplestRepresentation]]			ifNotNil: [				"Handle a message from the web browser."								| tabID |								tabID := message at: 'tabID'.				(					ChromeMethodInvocation						fromDictionary: message counterpart simplestRepresentation						for: (							tabs								at: tabID								ifAbsent: [									tabs										at: tabID										put: (											(ChromeTabViaPage new)												initializeFromTabInfo: (tabInfo detect: [:tab | tab id = tabID]);												transport: self;												yourself)])				)					perform]].			self getTabInfo! !Smalltalk renameClassNamed: #ChromeDebuggingAPI as: #ChromeDebuggingDomainAPI!Smalltalk renameClassNamed: #ChromeCSSAPI as: #ChromeCSSDomainAPI!Smalltalk renameClassNamed: #ChromeConsoleAPI as: #ChromeConsoleDomainAPI!Smalltalk renameClassNamed: #ChromeDOMAPI as: #ChromeDOMDomainAPI!Smalltalk renameClassNamed: #ChromeDebuggerAPI as: #ChromeDebuggerDomainAPI!Smalltalk renameClassNamed: #ChromeEmulationAPI as: #ChromeEmulationDomainAPI!Smalltalk renameClassNamed: #ChromeInspectorAPI as: #ChromeInspectorDomainAPI!Smalltalk renameClassNamed: #ChromeNetworkAPI as: #ChromeNetworkDomainAPI!Smalltalk renameClassNamed: #ChromePageAPI as: #ChromePageDomainAPI!Smalltalk renameClassNamed: #ChromeProfilerAPI as: #ChromeProfilerDomainAPI!Smalltalk renameClassNamed: #ChromeRenderingAPI as: #ChromeRenderingDomainAPI!Smalltalk renameClassNamed: #ChromeRuntimeAPI as: #ChromeRuntimeDomainAPI!Smalltalk renameClassNamed: #ChromeSecurityAPI as: #ChromeSecurityDomainAPI!Smalltalk renameClassNamed: #ChromeServiceWorkerAPI as: #ChromeServiceWorkerDomainAPI!Smalltalk renameClassNamed: #ChromeWorkerAPI as: #ChromeWorkerDomainAPI!ProtoObject subclass: #ChromeTabsAPI	instanceVariableNames: 'callbackResult'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!JSObject subclass: #ChromeAPI	instanceVariableNames: 'callbackResult'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!SystemOrganization addCategory: #Unknown!Object subclass: #ChromeTabViaExtension	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Unknown'!SystemOrganization classify: #ChromeTabViaExtension under: 'Caffeine'!Webpage subclass: #ChromeTabViaExtension	instanceVariableNames: 'id debugger'	classVariableNames: ''	poolDictionaries: ''	category: 'Caffeine'!ChromeAPI subclass: #ChromeDebuggerAPI	instanceVariableNames: 'tab tabID'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!ProtoObject subclass: #RemoteRuntimeJSObject	instanceVariableNames: 'properties'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!JSObject subclass: #RemoteRuntimeJSObjectProperties	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!JSObject subclass: #JSObjectMetadata	instanceVariableNames: 'debugger'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!Smalltalk renameClassNamed: #RemoteRuntimeJSObjectProperties as: #RemoteRuntimeJSObjectProperty!JSObjectMetadata subclass: #RemoteRuntimeJSObjectProperty	instanceVariableNames: 'home'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 13:12' prior: 35132920!startUp: resuming	"After a system resumption, if the system is being run by SqueakJS in a web browser, reset constants related to that web browser's JavaScript environment."	| forceToScreen |	resuming ifTrue: [		(self == Webpage)			ifTrue: [				Fullscreen := false.								Top := TopDocument := ContainingDiv := ContainingCanvas := ContainingFrame := Current := Options := nil.				Preferences					setPreference: #fastDragWindowForMorphic					toValue: JS isConnected.								JS ifConnected: [					| url |															Top := [JS top counterpart magicWindow] on: Error do: [:exception | JS window].					url := (						Top							ifNil: [String randomOfLength: 5]							ifNotNil: [								TopDocument := Top document.								Url absoluteFromText: Top location href asString]).					Options := (						(JS SqueakJS options at: #parameters)							ifNil: [nil]							ifNotNil: [JS SqueakJS options parameters counterpart]).												ContainingCanvas := JS document counterpart getElementById: 'squeak'.					ContainingCanvas						at: #width put: Options width;						at: #height put: Options height.											Top ifNotNil: [ContainingFrame := Top document getElementById: #Caffeine].					ContainingCanvas ifNotNil: [						ContainingDiv := (							ContainingFrame								ifNil: [ContainingCanvas parentNode]								ifNotNil: [									self styleAt: #transition put: 'opacity 500ms'.									ContainingFrame parentNode parentNode]).						ContainingDiv at: #onresize put: [self resize].						ContainingCanvas at: #tabIndex put: 0.						self captureCurrentExtent.						ContainingCanvas onclick: [self focus]].										forceToScreen := [:event | Display forceToScreen].					Top						at: #onresize						put: forceToScreen; 						at: #onscroll						put: forceToScreen;						at: #onorientationchange						put: [:event |							forceToScreen value: event.							self scrollToTop].															ContainingCanvas ifNotNil: [						ContainingCanvas							styleAt: 'user-select'							put: [false]].					Pages						at: url						ifAbsent: [							self								ifOptionAt: 'appID'								then: [:appID |									| appClass |																		appClass := self allSubclasses detect: [:subclass | subclass appID = appID] ifNone: [nil].									appClass										ifNil: [nil]										ifNotNil: [											Pages												at: url												put: (appClass fromURL: url)]]								else: [nil]]]]]! !!Caffeine methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 13:12' prior: 35135463!initialize	super initialize.	(window document getElementById: 'sqSpinner') beOpaque! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 14:24' prior: 35135631!zoomTo: point	ContainingCanvas		at: #width put: point x;		at: #height put: point y! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 14:25' prior: 35135815!zoomOut	"Zoom out the containing canvas."		ContainingCanvas		styleAt: #left put: 0;		styleAt: #top put: 0.			self zoomTo: (ContainingCanvas width @ ContainingCanvas height)! !!MorphicProject methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 14:28' prior: 35136094!setAsBackground: aForm	"Set  aForm as a background image."	| thisWorld newColor |	thisWorld := self currentWorld.	newColor := InfiniteForm with: aForm.	aForm rememberCommand:		(Command new cmdWording: 'set background to a picture' translated;			undoTarget: thisWorld selector: #color: argument: thisWorld color;			redoTarget: thisWorld selector: #color: argument: newColor).	thisWorld color: newColor! !!CaffeineExtension methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 14:55' prior: 35136608!initialize	"Connect to the Caffeine Helper web browser extension."		tabs := IdentityDictionary new.	promises := IdentityDictionary new.	nextPromiseID := 1.	port := JS chrome runtime connect: 'kfifbhlilndoognbpbaipgbhfphcldnp'.		port onMessage addListener: [:message |		(message at: 'method')			ifNil: [				"Resolve a promised answer from the extension."								| promise |								promise := promises at: (message at: 'promiseID') ifAbsent: [nil].								promise ifNotNil: [promise resolveWith: (message at: 'result') counterpart simplestRepresentation]]			ifNotNil: [				"Handle a message from the web browser."								| tabID |								tabID := message at: 'tabID'.				(					ChromeMethodInvocation						fromDictionary: message counterpart simplestRepresentation						for: (							tabs								at: tabID								ifAbsent: [									tabs										at: tabID										put: (											(ChromeTabViaPage new)												initializeFromTabInfo: (tabInfo detect: [:tab | tab id = tabID]);												transport: self;												yourself)])				)					perform]].			self getTabInfo! !JSObjectMetadata subclass: #RemoteRuntimeJSObject	instanceVariableNames: 'properties'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!JSObjectMetadata subclass: #RemoteJSObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!RemoteJSObject subclass: #RemoteDOMNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!RemoteJSObject subclass: #RemoteRuntimeJSObject	instanceVariableNames: 'properties'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 13:12' prior: 35140625!startUp: resuming	"After a system resumption, if the system is being run by SqueakJS in a web browser, reset constants related to that web browser's JavaScript environment."	| forceToScreen |	resuming ifTrue: [		(self == Webpage)			ifTrue: [				Fullscreen := false.								Top := TopDocument := ContainingDiv := ContainingCanvas := ContainingFrame := Current := Options := nil.				Preferences					setPreference: #fastDragWindowForMorphic					toValue: JS isConnected.								JS ifConnected: [					| url |															Top := [JS top counterpart magicWindow] on: Error do: [:exception | JS window].					url := (						Top							ifNil: [String randomOfLength: 5]							ifNotNil: [								TopDocument := Top document.								Url absoluteFromText: Top location href asString]).					Options := (						(JS SqueakJS options at: #parameters)							ifNil: [nil]							ifNotNil: [JS SqueakJS options parameters counterpart]).												ContainingCanvas := JS document counterpart getElementById: 'squeak'.					ContainingCanvas						at: #width put: Options width;						at: #height put: Options height.											Top ifNotNil: [ContainingFrame := Top document getElementById: #Caffeine].					ContainingCanvas ifNotNil: [						ContainingDiv := (							ContainingFrame								ifNil: [ContainingCanvas parentNode]								ifNotNil: [									self styleAt: #transition put: 'opacity 500ms'.									ContainingFrame parentNode parentNode]).						ContainingDiv at: #onresize put: [self resize].						ContainingCanvas at: #tabIndex put: 0.						self captureCurrentExtent.						ContainingCanvas onclick: [self focus]].										forceToScreen := [:event | Display forceToScreen].					Top						at: #onresize						put: forceToScreen; 						at: #onscroll						put: forceToScreen;						at: #onorientationchange						put: [:event |							forceToScreen value: event.							self scrollToTop].															ContainingCanvas ifNotNil: [						ContainingCanvas							styleAt: 'user-select'							put: [false]].					Pages						at: url						ifAbsent: [							self								ifOptionAt: 'appID'								then: [:appID |									| appClass |																		appClass := self allSubclasses detect: [:subclass | subclass appID = appID] ifNone: [nil].									appClass										ifNil: [nil]										ifNotNil: [											Pages												at: url												put: (appClass fromURL: url)]]								else: [nil]]]]]! !!Caffeine methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 13:12' prior: 35143168!initialize	super initialize.	(window document getElementById: 'sqSpinner') beOpaque! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 14:24' prior: 35143352!zoomTo: point	ContainingCanvas		at: #width put: point x;		at: #height put: point y! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 14:25' prior: 35143536!zoomOut	"Zoom out the containing canvas."		ContainingCanvas		styleAt: #left put: 0;		styleAt: #top put: 0.			self zoomTo: (ContainingCanvas width @ ContainingCanvas height)! !!MorphicProject methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 14:28' prior: 35143815!setAsBackground: aForm	"Set  aForm as a background image."	| thisWorld newColor |	thisWorld := self currentWorld.	newColor := InfiniteForm with: aForm.	aForm rememberCommand:		(Command new cmdWording: 'set background to a picture' translated;			undoTarget: thisWorld selector: #color: argument: thisWorld color;			redoTarget: thisWorld selector: #color: argument: newColor).	thisWorld color: newColor! !!CaffeineExtension methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 14:55' prior: 35144329!initialize	"Connect to the Caffeine Helper web browser extension."		tabs := IdentityDictionary new.	promises := IdentityDictionary new.	nextPromiseID := 1.	port := JS chrome runtime connect: 'kfifbhlilndoognbpbaipgbhfphcldnp'.		port onMessage addListener: [:message |		(message at: 'method')			ifNil: [				"Resolve a promised answer from the extension."								| promise |								promise := promises at: (message at: 'promiseID') ifAbsent: [nil].								promise ifNotNil: [promise resolveWith: (message at: 'result') counterpart simplestRepresentation]]			ifNotNil: [				"Handle a message from the web browser."								| tabID |								tabID := message at: 'tabID'.				(					ChromeMethodInvocation						fromDictionary: message counterpart simplestRepresentation						for: (							tabs								at: tabID								ifAbsent: [									tabs										at: tabID										put: (											(ChromeTabViaPage new)												initializeFromTabInfo: (tabInfo detect: [:tab | tab id = tabID]);												transport: self;												yourself)])				)					perform]].			self getTabInfo! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 00:29'!printOn: stream	3 halt.	super printOn: stream! !!RemoteJSObject methodsFor: 'no messages' stamp: 'crl 9/20/2019 00:32'!doesNotUnderstand: message	^(super doesNotUnderstand: message) remote! !!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 8/19/2017 12:51' prior: 34682267!keysSortedSafely	"Answer a sorted Array containing the receiver's keys."		^self keys sort: [:x :y | x compareSafely: y]! !!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:11' prior: 34682942!properties	^(		(			[JS Object keys: proxy]				on: Error				do: [:exception | #()]		)			asArray select: [:key |				| source keyString number |						source := (String new: 32) writeStream.				source nextPutAll: 'try {return typeof this'.				keyString := key asString.						number := [keyString asNumber] on: Error do: [:exception | nil].				number					ifNil: [						source							nextPut: $.;							nextPutAll: keyString]					ifNotNil: [						source							nextPut: $[;							nextPutAll: keyString;							nextPut: $]].								source nextPutAll: ';} catch (e) {''string''}'.				[(proxy evaluate: source contents) asString ~= 'function'] on: Error do: [:exception | false]]	)		collect: [:proxy | proxy asString]! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:16' prior: 33972286!with: argument retry: retryBlock	| error |	(error := self primGetError) ifNil: [^ self error: 'JSBridge error'].	(error beginsWith: 'asJSArgument') ifTrue: [		^(argument asJSArgument == argument)			ifTrue: [self error: error]			ifFalse: [retryBlock value: argument asJSArgument]].	(error beginsWith: 'CallbackSemaphore') ifTrue: [		self class initCallbacks.		^retryBlock value: argument].	self error: error! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:34'!id	^self attributeAt: #id! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:40'!children	children ifNil: [children := self at: #children].	^children! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:44'!getElementsByClassName: className	| elements |		elements := Set new.	self getElementsByClassName: className into: elements.	^elements! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:47'!at: key ifAbsent: block	| value |		value := super at: key.	^value		ifNil: [block value]		ifNotNil: [			(value class == Array)				ifTrue: [					value collect: [:element |						[element counterpart simplestRepresentation remote]							on: Error							do: [:exception | element counterpart simplestRepresentation]]]				ifFalse: [					[value remote]						on: Error						do: [:exception | value]]]! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:28'!at: key	| value |		value := super at: key.		^(value class == Array)		ifTrue: [			value collect: [:element |				[element counterpart simplestRepresentation remote]					on: Error					do: [:exception | element counterpart simplestRepresentation]]]		ifFalse: [			[value remote]				on: Error				do: [:exception | value]]! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 03:01'!attributeAt: key	self attributes.	^attributes		ifNil: [nil]		ifNotNil: [attributes at: key ifAbsent: [nil]]! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 03:04'!attributes	attributes ifNil: [		| stream |				attributes := IdentityDictionary new.		stream := self at: #attributes.		stream			ifNil: [^attributes]			ifNotNil: [stream := stream readStream].		[stream atEnd] whileFalse: [attributes at: stream next asSymbol put: stream next]].	^attributes! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 03:11'!getElementsByClassName: className into: elements	(('*', className, '*') match: self classAttribute) ifTrue: [elements add: self].	self children.	children ifNotNil: [		children do: [:child | child getElementsByClassName: className into: elements]].		^elements! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 03:13'!classAttribute	^(self attributeAt: #class) yourselfUnlessNil: ['']! !!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 11:45'!remote	^RemoteDOMNode forProxy: proxy! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 11:45'!remote	^RemoteDOMNode forProxy: self! !!ChromeTabViaPage methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 13:26' prior: 33713181!transport: websocketOrExtension	transport := websocketOrExtension.	apis := (		(Dictionary new)			at: #Console put: (console := ChromeConsoleDomainAPI for: self);			at: #Network put: (network := ChromeNetworkDomainAPI for: self);			at: #Page put: (page := ChromePageDomainAPI for: self);			at: #Runtime put: (runtime := ChromeRuntimeDomainAPI for: self);			at: #Debugger put: (debugger := ChromeDebuggerDomainAPI for: self);			at: #DOM put: (dom := ChromeDOMDomainAPI for: self);			at: #CSS put: (css := ChromeCSSDomainAPI for: self);			at: #Worker put: (worker := ChromeWorkerDomainAPI for: self);			at: #Profiler put: (profiler := ChromeProfilerDomainAPI for: self);			at: #ServiceWorker put: (serviceWorker := ChromeServiceWorkerDomainAPI for: self);			at: #Emulation put: (emulation := ChromeEmulationDomainAPI for: self);			at: #Rendering put: (rendering := ChromeRenderingDomainAPI for: self);			at: #Inspector put: (inspector := ChromeInspectorDomainAPI for: self);			at: #Security put: (security := ChromeSecurityDomainAPI for: self);			yourself).				self close! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 13:37'!chrome	"Answer the root Chrome API."		^ChromeRootAPI forProxy: (self at: #chrome)! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 13:37'!chrome	^window chrome! !!ChromeTabsAPI methodsFor: 'no messages' stamp: 'crl 9/20/2019 13:50'!query: signature	^self resultFrom: [:resultAvailable |		self			query: signature			with: [:result |				callbackResult := result.				resultAvailable signal]]! !!ChromeTabsAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 13:53'!resultFrom: block	| resultAvailable |		resultAvailable := Semaphore new.		[block value: resultAvailable] fork.	resultAvailable wait.	^callbackResult! !ChromeAPI subclass: #ChromeRootAPI	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!ChromeAPI subclass: #ChromeTabsAPI	instanceVariableNames: 'callbackResult'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!ChromeAPI subclass: #ChromeTabsAPI	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 13:12' prior: 35146197!startUp: resuming	"After a system resumption, if the system is being run by SqueakJS in a web browser, reset constants related to that web browser's JavaScript environment."	| forceToScreen |	resuming ifTrue: [		(self == Webpage)			ifTrue: [				Fullscreen := false.								Top := TopDocument := ContainingDiv := ContainingCanvas := ContainingFrame := Current := Options := nil.				Preferences					setPreference: #fastDragWindowForMorphic					toValue: JS isConnected.								JS ifConnected: [					| url |															Top := [JS top counterpart magicWindow] on: Error do: [:exception | JS window].					url := (						Top							ifNil: [String randomOfLength: 5]							ifNotNil: [								TopDocument := Top document.								Url absoluteFromText: Top location href asString]).					Options := (						(JS SqueakJS options at: #parameters)							ifNil: [nil]							ifNotNil: [JS SqueakJS options parameters counterpart]).												ContainingCanvas := JS document counterpart getElementById: 'squeak'.					ContainingCanvas						at: #width put: Options width;						at: #height put: Options height.											Top ifNotNil: [ContainingFrame := Top document getElementById: #Caffeine].					ContainingCanvas ifNotNil: [						ContainingDiv := (							ContainingFrame								ifNil: [ContainingCanvas parentNode]								ifNotNil: [									self styleAt: #transition put: 'opacity 500ms'.									ContainingFrame parentNode parentNode]).						ContainingDiv at: #onresize put: [self resize].						ContainingCanvas at: #tabIndex put: 0.						self captureCurrentExtent.						ContainingCanvas onclick: [self focus]].										forceToScreen := [:event | Display forceToScreen].					Top						at: #onresize						put: forceToScreen; 						at: #onscroll						put: forceToScreen;						at: #onorientationchange						put: [:event |							forceToScreen value: event.							self scrollToTop].															ContainingCanvas ifNotNil: [						ContainingCanvas							styleAt: 'user-select'							put: [false]].					Pages						at: url						ifAbsent: [							self								ifOptionAt: 'appID'								then: [:appID |									| appClass |																		appClass := self allSubclasses detect: [:subclass | subclass appID = appID] ifNone: [nil].									appClass										ifNil: [nil]										ifNotNil: [											Pages												at: url												put: (appClass fromURL: url)]]								else: [nil]]]]]! !!Caffeine methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 13:12' prior: 35148740!initialize	super initialize.	(window document getElementById: 'sqSpinner') beOpaque! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 14:24' prior: 35148924!zoomTo: point	ContainingCanvas		at: #width put: point x;		at: #height put: point y! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 14:25' prior: 35149108!zoomOut	"Zoom out the containing canvas."		ContainingCanvas		styleAt: #left put: 0;		styleAt: #top put: 0.			self zoomTo: (ContainingCanvas width @ ContainingCanvas height)! !!MorphicProject methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 14:28' prior: 35149387!setAsBackground: aForm	"Set  aForm as a background image."	| thisWorld newColor |	thisWorld := self currentWorld.	newColor := InfiniteForm with: aForm.	aForm rememberCommand:		(Command new cmdWording: 'set background to a picture' translated;			undoTarget: thisWorld selector: #color: argument: thisWorld color;			redoTarget: thisWorld selector: #color: argument: newColor).	thisWorld color: newColor! !!CaffeineExtension methodsFor: 'as yet unclassified' stamp: 'crl 9/19/2019 14:55' prior: 35149901!initialize	"Connect to the Caffeine Helper web browser extension."		tabs := IdentityDictionary new.	promises := IdentityDictionary new.	nextPromiseID := 1.	port := JS chrome runtime connect: 'kfifbhlilndoognbpbaipgbhfphcldnp'.		port onMessage addListener: [:message |		(message at: 'method')			ifNil: [				"Resolve a promised answer from the extension."								| promise |								promise := promises at: (message at: 'promiseID') ifAbsent: [nil].								promise ifNotNil: [promise resolveWith: (message at: 'result') counterpart simplestRepresentation]]			ifNotNil: [				"Handle a message from the web browser."								| tabID |								tabID := message at: 'tabID'.				(					ChromeMethodInvocation						fromDictionary: message counterpart simplestRepresentation						for: (							tabs								at: tabID								ifAbsent: [									tabs										at: tabID										put: (											(ChromeTabViaPage new)												initializeFromTabInfo: (tabInfo detect: [:tab | tab id = tabID]);												transport: self;												yourself)])				)					perform]].			self getTabInfo! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 00:29' prior: 35151093!printOn: stream	3 halt.	super printOn: stream! !!RemoteJSObject methodsFor: 'no messages' stamp: 'crl 9/20/2019 00:32' prior: 35151216!doesNotUnderstand: message	^(super doesNotUnderstand: message) remote! !!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 8/19/2017 12:51' prior: 35151380!keysSortedSafely	"Answer a sorted Array containing the receiver's keys."		^self keys sort: [:x :y | x compareSafely: y]! !!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:11' prior: 35151596!properties	^(		(			[JS Object keys: proxy]				on: Error				do: [:exception | #()]		)			asArray select: [:key |				| source keyString number |						source := (String new: 32) writeStream.				source nextPutAll: 'try {return typeof this'.				keyString := key asString.						number := [keyString asNumber] on: Error do: [:exception | nil].				number					ifNil: [						source							nextPut: $.;							nextPutAll: keyString]					ifNotNil: [						source							nextPut: $[;							nextPutAll: keyString;							nextPut: $]].								source nextPutAll: ';} catch (e) {''string''}'.				[(proxy evaluate: source contents) asString ~= 'function'] on: Error do: [:exception | false]]	)		collect: [:proxy | proxy asString]! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:16' prior: 35152429!with: argument retry: retryBlock	| error |	(error := self primGetError) ifNil: [^ self error: 'JSBridge error'].	(error beginsWith: 'asJSArgument') ifTrue: [		^(argument asJSArgument == argument)			ifTrue: [self error: error]			ifFalse: [retryBlock value: argument asJSArgument]].	(error beginsWith: 'CallbackSemaphore') ifTrue: [		self class initCallbacks.		^retryBlock value: argument].	self error: error! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:34' prior: 35152933!id	^self attributeAt: #id! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:40' prior: 35153043!children	children ifNil: [children := self at: #children].	^children! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:44' prior: 35153197!getElementsByClassName: className	| elements |		elements := Set new.	self getElementsByClassName: className into: elements.	^elements! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:47' prior: 35153419!at: key ifAbsent: block	| value |		value := super at: key.	^value		ifNil: [block value]		ifNotNil: [			(value class == Array)				ifTrue: [					value collect: [:element |						[element counterpart simplestRepresentation remote]							on: Error							do: [:exception | element counterpart simplestRepresentation]]]				ifFalse: [					[value remote]						on: Error						do: [:exception | value]]]! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 02:28' prior: 35153912!at: key	| value |		value := super at: key.		^(value class == Array)		ifTrue: [			value collect: [:element |				[element counterpart simplestRepresentation remote]					on: Error					do: [:exception | element counterpart simplestRepresentation]]]		ifFalse: [			[value remote]				on: Error				do: [:exception | value]]! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 03:01' prior: 35154325!attributeAt: key	self attributes.	^attributes		ifNil: [nil]		ifNotNil: [attributes at: key ifAbsent: [nil]]! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 03:04' prior: 35154521!attributes	attributes ifNil: [		| stream |				attributes := IdentityDictionary new.		stream := self at: #attributes.		stream			ifNil: [^attributes]			ifNotNil: [stream := stream readStream].		[stream atEnd] whileFalse: [attributes at: stream next asSymbol put: stream next]].	^attributes! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 03:11' prior: 35154904!getElementsByClassName: className into: elements	(('*', className, '*') match: self classAttribute) ifTrue: [elements add: self].	self children.	children ifNotNil: [		children do: [:child | child getElementsByClassName: className into: elements]].		^elements! !!RemoteJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 03:13' prior: 35155253!classAttribute	^(self attributeAt: #class) yourselfUnlessNil: ['']! !!JSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 11:45' prior: 35155398!remote	^RemoteDOMNode forProxy: proxy! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 11:45' prior: 35155519!remote	^RemoteDOMNode forProxy: self! !!ChromeTabViaPage methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 13:26' prior: 35155658!transport: websocketOrExtension	transport := websocketOrExtension.	apis := (		(Dictionary new)			at: #Console put: (console := ChromeConsoleDomainAPI for: self);			at: #Network put: (network := ChromeNetworkDomainAPI for: self);			at: #Page put: (page := ChromePageDomainAPI for: self);			at: #Runtime put: (runtime := ChromeRuntimeDomainAPI for: self);			at: #Debugger put: (debugger := ChromeDebuggerDomainAPI for: self);			at: #DOM put: (dom := ChromeDOMDomainAPI for: self);			at: #CSS put: (css := ChromeCSSDomainAPI for: self);			at: #Worker put: (worker := ChromeWorkerDomainAPI for: self);			at: #Profiler put: (profiler := ChromeProfilerDomainAPI for: self);			at: #ServiceWorker put: (serviceWorker := ChromeServiceWorkerDomainAPI for: self);			at: #Emulation put: (emulation := ChromeEmulationDomainAPI for: self);			at: #Rendering put: (rendering := ChromeRenderingDomainAPI for: self);			at: #Inspector put: (inspector := ChromeInspectorDomainAPI for: self);			at: #Security put: (security := ChromeSecurityDomainAPI for: self);			yourself).				self close! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 13:37' prior: 35156829!chrome	"Answer the root Chrome API."		^ChromeRootAPI forProxy: (self at: #chrome)! !!Webpage methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 13:37' prior: 35156990!chrome	^window chrome! !!ChromeTabsAPI methodsFor: 'no messages' stamp: 'crl 9/20/2019 13:50' prior: 35157087!query: signature	^self resultFrom: [:resultAvailable |		self			query: signature			with: [:result |				callbackResult := result.				resultAvailable signal]]! !!ChromeTabsAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 13:53' prior: 35157331!resultFrom: block	| resultAvailable |		resultAvailable := Semaphore new.		[block value: resultAvailable] fork.	resultAvailable wait.	^callbackResult! !!ChromeRootAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 13:54'!tabs	^ChromeTabsAPI forProxy: proxy tabs! !!ChromeAPI methodsFor: 'no messages' stamp: 'crl 9/20/2019 13:55'!resultFrom: block	| resultAvailable |		resultAvailable := Semaphore new.		[block value: resultAvailable] fork.	resultAvailable wait.	^callbackResult! !!ChromeAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 14:17'!debuggerForTabWithID: tabID	^ChromeDebuggerAPI forTab: (ChromeTabViaExtension withID: tabID)! !!ChromeDebuggerAPI class methodsFor: 'no messages' stamp: 'crl 9/20/2019 14:18'!forTab: aChromeTabViaExtension	^(self new)		tab: aChromeTabViaExtension;		yourself! !!ChromeRootAPI methodsFor: 'no messages' stamp: 'crl 9/20/2019 13:39'!debugger	^ChromeDebuggerAPI forProxy: (proxy at: #debugger)! !!ChromeTabViaExtension class methodsFor: 'no messages' stamp: 'crl 9/20/2019 14:46'!forTabWithID: tabID	^(self new)		id: tabID;		yourself! !!ChromeTabViaExtension methodsFor: 'no messages' stamp: 'crl 9/20/2019 14:46'!id: tabID	id := tabID! !!ChromeTabViaExtension methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 14:56'!debugger: aChromeDebuggerAPI	debugger := aChromeDebuggerAPI! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 15:00'!tab: aChromeTabViaExtension	tab := aChromeTabViaExtension.	tabID := {#tabId -> tab id}.	aChromeTabViaExtension debugger: self! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 15:01'!pause	proxy		sendCommand: tabID		with: 'Debugger.pause'! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 15:01'!resume	proxy		sendCommand: tabID		with: 'Debugger.resume'! !!RemoteDOMNode methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 15:08'!debugger: aChromeDebuggerAPI	debugger := aChromeDebuggerAPI! !!RemoteDOMNode methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 15:10'!resolve	^debugger resolve: self! !!RemoteJSObject methodsFor: 'no messages' stamp: 'crl 9/20/2019 15:51'!debugger: aChromeDebuggerAPI	debugger := aChromeDebuggerAPI! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:20'!enable	proxy		sendCommand: tabID		with: 'Debugger.enable'! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:20'!disable	proxy		sendCommand: tabID		with: 'Debugger.disable'! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:20'!detach	self disable.	proxy detach: tabID! !!ChromeTabViaExtension methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:25'!id	^id! !!ChromeTabViaExtension class methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:28'!withID: tabID	^(self new)		id: tabID;		yourself! !!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:45'!callFunctionNamed: functionName	^debugger callFunctionNamed: functionName on: self! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:47'!remoteDOMNode	^RemoteDOMNode forProxy: self! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:48'!remoteRuntimeJSObject	^RemoteRuntimeJSObject forProxy: self! !!RemoteDOMNode methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:48'!doesNotUnderstand: message	| result |		result := super doesNotUnderstand: message.		^[result remoteDOMNode]		on: Error		do: [:exception | result]! !!RemoteDOMNode methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:49'!at: key	| value |		value := super at: key.		^(value class == Array)		ifTrue: [			value collect: [:element |				[element counterpart simplestRepresentation remoteDOMNode]					on: Error					do: [:exception | element counterpart simplestRepresentation]]]		ifFalse: [			[value remoteDOMNode]				on: Error				do: [:exception | value]]! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 16:54'!attach	proxy		attach: tabID		with: '1.0'.	self enable! !!ChromeRootAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 17:02'!debuggerForTabWithID: tabID	^(self debugger)		tab: (ChromeTabViaExtension withID: tabID);		attach;		yourself! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 20:35'!callFunctionNamed: functionName on: remoteRuntimeJSObject	^self resultFrom: [:resultAvailable |		self			sendCommand: tabID			with: 'Runtime.callFunctionOn'			with: {				#objectId -> remoteRuntimeJSObject objectId.				#functionDeclaration -> functionName}			with: [:result |				callbackResult := (					result						ifNil: [result]						ifNotNil: [result remoteRuntimeJSObject]).										resultAvailable signal]]! !!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 20:56'!callFunctionWithSource: source	^debugger callFunctionWithSource: source on: self! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 21:13'!callFunctionWithSource: source on: remoteRuntimeJSObject	^self		callFunctionWithSource: source		withParameters: {}		on: remoteRuntimeJSObject! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:19'!remoteRuntimeJSObjectProperties	^RemoteRuntimeJSObjectProperties forProxy: self! !!JSObjectMetadata class methodsFor: 'no messages' stamp: 'crl 9/20/2019 22:20'!forProxy: proxy byDebugger: debugger	^(super forProxy: proxy) debugger: debugger! !!JSObjectMetadata methodsFor: 'no messages' stamp: 'crl 9/20/2019 22:20'!debugger: aChromeDebuggerAPI	debugger := aChromeDebuggerAPI! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:21'!getDocument	^self resultFrom: [:resultAvailable |		proxy			sendCommand: tabID			with: 'DOM.getDocument'			with: {#depth -> -1}			with: [:result |				callbackResult := (RemoteDOMNode forProxy: result root byDebugger: self).				resultAvailable signal]]! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:23'!remoteRuntimeJSObjectByDebugger: debugger	^RemoteRuntimeJSObject forProxy: self byDebugger: debugger! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:23'!remoteRuntimeJSObjectPropertiesByDebugger: debugger	^RemoteRuntimeJSObjectProperties forProxy: self byDebugger: debugger! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:23'!callFunctionWithSource: source withParameters: parameters on: remoteRuntimeJSObject	^self resultFrom: [:resultAvailable |		| arguments |				arguments := OrderedCollection new.		parameters do: [:parameter | arguments add: {#objectId -> parameter objectId}].					self			sendCommand: tabID			with: 'Runtime.callFunctionOn'			with: {				#objectId -> remoteRuntimeJSObject objectId.				#functionDeclaration -> source.				#arguments -> arguments asArray}			with: [:result |				callbackResult := (					result						ifNil: [result]						ifNotNil: [result remoteRuntimeJSObjectByDebugger: self]).										resultAvailable signal]]! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:25'!resolve: remoteDOMNode	^self resultFrom: [:resultAvailable |		self			sendCommand: tabID			with: 'DOM.resolveNode'			with: {#nodeId -> remoteDOMNode nodeId}			with: [:result |				callbackResult := (result object remoteRuntimeJSObjectByDebugger: self).				resultAvailable signal]]! !!JSObjectMetadata methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:30'!name	^self at: #name! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:35'!remoteRuntimeJSObjectPropertyByDebugger: debugger	^RemoteRuntimeJSObjectProperty forProxy: self byDebugger: debugger! !!RemoteRuntimeJSObjectProperty methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:46'!value	^(self at: #value) proxy remoteRuntimeJSObjectByDebugger: debugger! !!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:51'!at: key	^(self getProperties detect: [:property | property name = key]) value! !!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 22:57'!atMatching: pattern	^(self getProperties detect: [:property | pattern match: property name]) value! !!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 23:05'!keys	^self getProperties collect: [:property | property name]! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 23:44'!getPropertiesFor: remoteRuntimeJSObject	^self resultFrom: [:resultAvailable |		self			sendCommand: tabID			with: 'Runtime.getProperties'			with: {#objectId -> remoteRuntimeJSObject objectId}			with: [:result |				callbackResult := result.				resultAvailable signal]]! !!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 23:51'!printOn: stream	stream		nextPutAll: 'a ';		print: self class;		nextPutAll: ' described by ''';		nextPutAll: self description;		nextPut: $'! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 23:54'!remoteRuntimeJSObjectPropertyOf: remoteRuntimeJSObject byDebugger: debugger	^(RemoteRuntimeJSObjectProperty forProxy: self byDebugger: debugger)		home: remoteRuntimeJSObject;		yourself! !!RemoteRuntimeJSObjectProperty methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 23:55'!home: remoteRuntimeJSObject	home := remoteRuntimeJSObject! !!RemoteRuntimeJSObjectProperty methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2019 23:55'!printOn: stream	stream		nextPutAll: 'the ''';		nextPutAll: self name;		nextPutAll: ''' property of ';		print: home! !!RemoteRuntimeJSObjectProperty class methodsFor: 'no messages' stamp: 'crl 9/20/2019 23:56'!forProxy: proxy byDebugger: debugger	^self shouldNotImplement! !!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 00:04'!getProperties	| result |		result := debugger getPropertiesFor: self.	properties := OrderedCollection new.		{		result result.		(result at: #internalProperties) yourselfUnlessNil: [{}]	}		do: [:things | properties addAll: (things asArray collect: [:property | property remoteRuntimeJSObjectPropertyOf: self byDebugger: debugger])].			properties := properties asArray.	^properties! !!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 00:44'!doesNotUnderstand: message	^[super doesNotUnderstand: message]		on: Error		do: [:exception |			debugger				callFunctionWithSource: '(receiver) => {receiver.', message selector, '()}'				withParameters: {self}				on: self]! !----QUIT----{21 September 2019 . 2:10:23 am} caffeine.image priorSource: 1496944!----STARTUP----{21 September 2019 . 2:13:31 am} as /SqueakJS/caffeine.image!Webpage current chrome tabs query: {#title -> '*'}!EditHistory connectTo: 'ws://localhost:8091/tether'.!self counterpart explore!self counterpart asArray explore!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 02:41' prior: 35180032!doesNotUnderstand: message	^[super doesNotUnderstand: message]		on: Error		do: [:exception |			3 halt.						debugger				callFunctionWithSource: '(receiver) => {receiver.', message selector, '()}'				withParameters: {self}				on: self]! !----SNAPSHOT----{21 September 2019 . 2:41:49 am} caffeine.image priorSource: 1625831!----SNAPSHOT----{21 September 2019 . 2:51:09 am} caffeine.image priorSource: 1626513!----SNAPSHOT----{21 September 2019 . 2:52:44 am} caffeine.image priorSource: 1626600!----STARTUP----{21 September 2019 . 2:57:49 am} as /SqueakJS/caffeine.image!Webpage current chrome debuggerForTabWithID: 10!!RemoteDOMNode methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 03:03' prior: 35172936!doesNotUnderstand: message	| result |		result := super doesNotUnderstand: message.		^[result remoteDOMNode]		on: Error		do: [:exception |			3 halt.			result]! !self getDocument!self getDocument!result class!!RemoteDOMNode methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 03:13' prior: 35181431!doesNotUnderstand: message	| result |		3 halt.	result := super doesNotUnderstand: message.		^[result remoteDOMNode]		on: Error		do: [:exception |			3 halt.			result]! !JSObjectMetadata subclass: #RemoteJSObject	instanceVariableNames: 'children'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!JSObjectMetadata subclass: #RemoteJSObject	instanceVariableNames: 'children attributes'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!!SystemChangeNotifier methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 03:35' prior: 34948618!methodRemoved: aMethod selector: aSymbol inProtocol: protocol class: aClass 	"A method with the given selector was removed from the class."	self trigger: (RemovedEvent				method: aMethod 				selector: aSymbol				protocol: protocol				class: aClass)! !!SystemChangeNotifier methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 03:36' prior: 34948274!methodChangedFrom: oldMethod to: newMethod selector: aSymbol inClass: aClass requestor: requestor	self trigger: (ModifiedEvent					methodChangedFrom: oldMethod					to: newMethod					selector: aSymbol 					inClass: aClass					requestor: requestor)! !RemoteJSObject removeSelector: #at:!(self getDocument getElementsByClassName: 'button-nfplayerFastForward') onlyOne!----SNAPSHOT----{21 September 2019 . 3:42:03 am} caffeine.image priorSource: 1626687!!RemoteDOMNode methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 03:43' prior: 35181749!doesNotUnderstand: message	| result |		result := super doesNotUnderstand: message.		^[result remoteDOMNode]		on: Error		do: [:exception | result]! !RemoteJSObject removeSelector: #at:ifAbsent:!RemoteJSObject removeSelector: #doesNotUnderstand:!self resolve: (self getDocument getElementsByClassName: 'button-nfplayerFastForward') onlyOne!----SNAPSHOT----{21 September 2019 . 3:48:30 am} caffeine.image priorSource: 1628677!EditHistory connectTo: 'ws://localhost:8091/tether'.!RemoteRuntimeJSObjectProperty class removeSelector: #forProxy:byDebugger:!self atMatching: '*__reactInternalInstance$*'!(self atMatching: '*__reactInternalInstance$*') at: #return!((self atMatching: '*__reactInternalInstance$*') at: #return) at: #stateNode!(((self atMatching: '*__reactInternalInstance$*') at: #return) at: #stateNode) at: #props!((((self atMatching: '*__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick!(((((self atMatching: '*__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick) at: '[[BoundThis]]'!((((((((((((self atMatching: '*__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick) at: '[[BoundThis]]') at: #props) at: #onClick) at: '[[BoundThis]]') at: #onSeekForward) at: '[[BoundThis]]') at: #context) at: #playerApp!----SNAPSHOT----{21 September 2019 . 3:53:37 am} caffeine.image priorSource: 1629211!debugger				callFunctionWithSource: '(receiver) => {receiver.', message selector, '()}'				withParameters: {self}				on: self!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 03:55' prior: 35180699!doesNotUnderstand: message	^[super doesNotUnderstand: message]		on: Error		do: [:exception |			debugger				callFunctionWithSource: '(receiver) => {receiver.', message selector, '()}'				withParameters: {self}				on: self]! !----SNAPSHOT----{21 September 2019 . 3:55:46 am} caffeine.image priorSource: 1630200!Webpage exportSnapshot!(((((((((((((self atMatching: '*__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick) at: '[[BoundThis]]') at: #props) at: #onClick) at: '[[BoundThis]]') at: #onSeekForward) at: '[[BoundThis]]') at: #context) at: #playerApp) getActionCreators!proxy counterpart!RemoteRuntimeJSObject removeSelector: #callFunctionNamed:!ChromeDebuggerAPI removeSelector: #callFunctionNamed:on:!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 04:03' prior: 35184954!doesNotUnderstand: message	^[super doesNotUnderstand: message]		on: Error		do: [:exception |			| result |						result := (				debugger					callFunctionWithSource: '(receiver) => {receiver.', message selector, '()}'					withParameters: {self}					on: self).								(result at: #exceptionDetails)				ifNil: [result result]				ifNotNil: [self error: 'JS debugger invocation failed']]! !((((((((((((self atMatching: '*__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick) at: '[[BoundThis]]') at: #props) at: #onClick) at: '[[BoundThis]]') at: #onSeekForward) at: '[[BoundThis]]') at: #context) at: #playerApp!!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 04:06' prior: 35176055!callFunctionWithSource: source withParameters: parameters on: remoteRuntimeJSObject	^self resultFrom: [:resultAvailable |		| arguments |				arguments := OrderedCollection new.		3 halt.		parameters do: [:parameter | arguments add: {#objectId -> parameter objectId}].					self			sendCommand: tabID			with: 'Runtime.callFunctionOn'			with: {				#objectId -> remoteRuntimeJSObject objectId.				#functionDeclaration -> source.				#arguments -> arguments asArray}			with: [:result |				callbackResult := (					result						ifNil: [result]						ifNotNil: [result remoteRuntimeJSObjectByDebugger: self]).										resultAvailable signal]]! !proxy counterpart!proxy objectId!self objectId!self objectId!!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 04:08' prior: 35186565!callFunctionWithSource: source withParameters: parameters on: remoteRuntimeJSObject	^self resultFrom: [:resultAvailable |		| arguments |				arguments := OrderedCollection new.		parameters do: [:parameter | [arguments add: {#objectId -> parameter objectId}] on: Error do: [:exception | 3 halt]].					self			sendCommand: tabID			with: 'Runtime.callFunctionOn'			with: {				#objectId -> remoteRuntimeJSObject objectId.				#functionDeclaration -> source.				#arguments -> arguments asArray}			with: [:result |				callbackResult := (					result						ifNil: [result]						ifNotNil: [result remoteRuntimeJSObjectByDebugger: self]).										resultAvailable signal]]! !result!proxy counterpart!result proxy!result proxy at: #exceptionDetails!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 04:10' prior: 35185814!doesNotUnderstand: message	^[super doesNotUnderstand: message]		on: Error		do: [:exception |			| result |						result := (				debugger					callFunctionWithSource: '(receiver) => {receiver.', message selector, '()}'					withParameters: {self}					on: self).								(result proxy at: #exceptionDetails)				ifNil: [result result]				ifNotNil: [self error: 'JS debugger invocation failed']]! !(result proxy at: #exceptionDetails) counterpart!self text!self exception!self exception description!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 04:12' prior: 35188255!doesNotUnderstand: message	^[super doesNotUnderstand: message]		on: Error		do: [:exception |			| result |						result := (				debugger					callFunctionWithSource: '(receiver) => {receiver.', message selector, '()}'					withParameters: {self}					on: self).								(result proxy at: #exceptionDetails)				ifNil: [result result]				ifNotNil: [					"(result proxy at: #exceptionDetails) counterpart"					self error: 'JS debugger invocation failed']]! !----SNAPSHOT----{21 September 2019 . 4:12:58 am} caffeine.image priorSource: 1630753!Webpage exportSnapshot!(((((((((((((self atMatching: '*__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick) at: '[[BoundThis]]') at: #props) at: #onClick) at: '[[BoundThis]]') at: #onSeekForward) at: '[[BoundThis]]') at: #context) at: #playerApp) getActionCreators!JSObjectProxy removeSelector: #remoteRuntimeJSObject!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 04:18' prior: 35188871!doesNotUnderstand: message	^[super doesNotUnderstand: message]		on: Error		do: [:exception |			| result |						result := (				debugger					callFunctionWithSource: '(receiver) => {receiver.', message selector, '()}'					withParameters: {self}					on: self).								(result proxy at: #exceptionDetails)				ifNil: [result result proxy remoteRuntimeJSObjectByDebugger: debugger]				ifNotNil: [					"(result proxy at: #exceptionDetails) counterpart"					self error: 'JS debugger invocation failed']]! !(((((((((((((self atMatching: '*__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick) at: '[[BoundThis]]') at: #props) at: #onClick) at: '[[BoundThis]]') at: #onSeekForward) at: '[[BoundThis]]') at: #context) at: #playerApp) getActionCreators!parameter class!parameter proxy counterpart!self type!parameters collect: [:parameter | parameter proxy]!self counterpart!!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 04:23' prior: 35187388!callFunctionWithSource: source withParameters: parameters on: remoteRuntimeJSObject	(parameters anySatisfy: [:parameter | (parameter proxy at: #objectId) isNil]) ifTrue: [3 halt].			^self resultFrom: [:resultAvailable |		| arguments |				arguments := OrderedCollection new.		parameters do: [:parameter | arguments add: {#objectId -> parameter objectId}].					self			sendCommand: tabID			with: 'Runtime.callFunctionOn'			with: {				#objectId -> remoteRuntimeJSObject objectId.				#functionDeclaration -> source.				#arguments -> arguments asArray}			with: [:result |				callbackResult := (					result						ifNil: [result]						ifNotNil: [result remoteRuntimeJSObjectByDebugger: self]).										resultAvailable signal]]! !(((((((((((((self atMatching: '*__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick) at: '[[BoundThis]]') at: #props) at: #onClick) at: '[[BoundThis]]') at: #onSeekForward) at: '[[BoundThis]]') at: #context) at: #playerApp) getActionCreators!proxy counterpart!self type!self type!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 04:26' prior: 35178512!printOn: stream	stream		nextPutAll: 'a ';		print: self class;		nextPutAll: ' described by ''';		nextPutAll: (			(proxy at: #description)				ifNil: [self type]				ifNotNil: [self description]);		nextPut: $'! !proxy counterpart!((((((((((((self atMatching: '*__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick) at: '[[BoundThis]]') at: #props) at: #onClick) at: '[[BoundThis]]') at: #onSeekForward) at: '[[BoundThis]]') at: #context) at: #playerApp!(((((((((((((self atMatching: '*__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick) at: '[[BoundThis]]') at: #props) at: #onClick) at: '[[BoundThis]]') at: #onSeekForward) at: '[[BoundThis]]') at: #context) at: #playerApp) at: #getActionCreators!!RemoteDOMNode methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 04:29'!getElementsByClassName: className into: elements	(('*', className, '*') match: self classAttribute) ifTrue: [elements add: self].	self children.	children ifNotNil: [		children do: [:child | child getElementsByClassName: className into: elements]].		^elements! !!RemoteDOMNode methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 04:29'!children	children ifNil: [children := self at: #children].	^children! !RemoteJSObject removeSelector: #children!RemoteJSObject removeSelector: #getElementsByClassName:into:!JSObjectMetadata subclass: #RemoteJSObject	instanceVariableNames: 'attributes'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!RemoteJSObject subclass: #RemoteDOMNode	instanceVariableNames: 'children'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!!RemoteDOMNode methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 04:30'!attributes	attributes ifNil: [		| stream |				attributes := IdentityDictionary new.		stream := self at: #attributes.		stream			ifNil: [^attributes]			ifNotNil: [stream := stream readStream].		[stream atEnd] whileFalse: [attributes at: stream next asSymbol put: stream next]].	^attributes! !RemoteJSObject removeSelector: #attributes!!RemoteDOMNode methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 04:30'!attributeAt: key	self attributes.	^attributes		ifNil: [nil]		ifNotNil: [attributes at: key ifAbsent: [nil]]! !RemoteJSObject removeSelector: #attributeAt:!JSObjectMetadata subclass: #RemoteJSObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!RemoteJSObject subclass: #RemoteDOMNode	instanceVariableNames: 'children attributes'	classVariableNames: ''	poolDictionaries: ''	category: 'JSBridge-core counterparts'!----SNAPSHOT----{21 September 2019 . 4:31:17 am} caffeine.image priorSource: 1634904!Webpage exportSnapshot!((((((((((((self atMatching: '*__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick) at: '[[BoundThis]]') at: #props) at: #onClick) at: '[[BoundThis]]') at: #onSeekForward) at: '[[BoundThis]]') at: #context) at: #actionCreators!self getProperties!self keys!self keys!(((((((((((self atMatching: '*__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick) at: '[[BoundThis]]') at: #props) at: #onClick) at: '[[BoundThis]]') at: #onSeekForward) at: '[[BoundThis]]') at: #context!(self at: #playerSession) getId!self at: #playerSession!self getProperties!Webpage zoomTo: 500@500!Webpage zoomTo: 800@900!Webpage zoomTo: 700@800!Webpage zoomTo: 600@800!Webpage zoomTo: 650@800!Webpage zoomTo: 650@700!Webpage zoomTo: 650@750!----SNAPSHOT----{21 September 2019 . 10:03:09 am} caffeine.image priorSource: 1640343!self at: #getId!EditHistory connectTo: 'ws://localhost:8091/tether'.!----SNAPSHOT----{21 September 2019 . 10:07 am} caffeine.image priorSource: 1641259!Webpage exportSnapshot!self at: #playerSession!self getProperties!self at: '_id'!!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 10:15' prior: 35178147!getPropertiesFor: remoteRuntimeJSObject	^self resultFrom: [:resultAvailable |		self			sendCommand: tabID			with: 'Runtime.getProperties'			with: {				#objectId -> (					[remoteRuntimeJSObject objectId]						on: MessageNotUnderstood						do: [:exception |							callbackResult := {}.							resultAvailable signal])}			with: [:result |				callbackResult := result.				resultAvailable signal]]! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 10:16' prior: 35196126!getPropertiesFor: remoteRuntimeJSObject	^self resultFrom: [:resultAvailable |		self			sendCommand: tabID			with: 'Runtime.getProperties'			with: {				#objectId -> (					[remoteRuntimeJSObject objectId]						on: Error						do: [:exception |							callbackResult := {}.							resultAvailable signal])}			with: [:result |				callbackResult := result.				resultAvailable signal]]! !	remoteRuntimeJSObject proxy at: #objectId!!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 10:22' prior: 35196633!getPropertiesFor: remoteRuntimeJSObject	^(remoteRuntimeJSObject proxy at: #objectId)		ifNil: [{}]		ifNotNil: [			self resultFrom: [:resultAvailable |				self					sendCommand: tabID					with: 'Runtime.getProperties'					with: {#objectId -> remoteRuntimeJSObject objectId}					with: [:result |						callbackResult := result.						resultAvailable signal]]]! !!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 10:23' prior: 35179551!getProperties	| result |		result := debugger getPropertiesFor: self.	properties := OrderedCollection new.		{		result			ifNil: [{}]			ifNotNil: [result].					(result at: #internalProperties) yourselfUnlessNil: [{}]	}		do: [:things | properties addAll: (things asArray collect: [:property | property remoteRuntimeJSObjectPropertyOf: self byDebugger: debugger])].			properties := properties asArray.	^properties! !!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 10:24' prior: 35197641!getProperties	| result |		result := debugger getPropertiesFor: self.	properties := OrderedCollection new.		{		(result isEmpty)			ifTrue: [{}]			ifFalse: [result result].					(result isEmpty)			ifTrue: [{}]			ifFalse: [(result at: #internalProperties) yourselfUnlessNil: [{}]]	}		do: [:things | properties addAll: (things asArray collect: [:property | property remoteRuntimeJSObjectPropertyOf: self byDebugger: debugger])].			properties := properties asArray.	^properties! !self getProperties!self getProperties!self getProperties!----SNAPSHOT----{21 September 2019 . 10:25:18 am} caffeine.image priorSource: 1641420!proxy counterpart!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 10:33' prior: 35192066!printOn: stream	self getProperties.		stream		nextPutAll: 'a ';		print: self class;		nextPutAll: ' described by ''';		nextPutAll: (			(properties isEmpty)				ifTrue: [proxy at: #value]				ifFalse: [					(proxy at: #description)						ifNil: [self type]						ifNotNil: [self description]]);		nextPut: $'! !(proxy at: #value) counterpart!(proxy at: #value) counterpart simplestRepresentation!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 10:35' prior: 35198938!printOn: stream	self getProperties.		stream		nextPutAll: 'a ';		print: self class;		nextPutAll: ' described by ''';		nextPutAll: (			(properties isEmpty)				ifTrue: [(proxy at: #value) counterpart simplestRepresentation]				ifFalse: [					(proxy at: #description)						ifNil: [self type]						ifNotNil: [self description]]);		nextPut: $'! !result counterpart!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 10:36' prior: 35198172!getProperties	| result |		result := debugger getPropertiesFor: self.	properties := OrderedCollection new.		{		(result class == Array)			ifTrue: [{}]			ifFalse: [result result].					(result class == Array)			ifTrue: [{}]			ifFalse: [(result at: #internalProperties) yourselfUnlessNil: [{}]]	}		do: [:things | properties addAll: (things asArray collect: [:property | property remoteRuntimeJSObjectPropertyOf: self byDebugger: debugger])].			properties := properties asArray.	^properties! !self getId!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 10:42' prior: 35199448!printOn: stream	self getProperties.		stream		nextPutAll: 'a ';		print: self class;		nextPutAll: ' described by '.			(properties isEmpty)		ifTrue: [stream print: (proxy at: #value) counterpart simplestRepresentation]		ifFalse: [			stream nextPut: $'.						(proxy at: #description)				ifNil: [self type]				ifNotNil: [self description].							stream nextPut: $']! !----SNAPSHOT----{21 September 2019 . 10:42:38 am} caffeine.image priorSource: 1644294!proxy counterpart!self type!self getId!(self at: #playerSession) getId!!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 10:51' prior: 35190900!callFunctionWithSource: source withParameters: parameters on: remoteRuntimeJSObject	(parameters anySatisfy: [:parameter | (parameter proxy at: #objectId) isNil]) ifTrue: [3 halt].			^self resultFrom: [:resultAvailable |		| arguments |				arguments := OrderedCollection new.		parameters do: [:parameter | arguments add: {#objectId -> parameter objectId}].					self			sendCommand: tabID			with: 'Runtime.callFunctionOn'			with: {				#objectId -> remoteRuntimeJSObject objectId.				#functionDeclaration -> source.				#arguments -> arguments asArray}			with: [:result |				callbackResult := (					result						ifNil: [result]						ifNotNil: [result remoteRuntimeJSObjectByDebugger: self]).										3 halt.				resultAvailable signal]]! !----STARTUP----{21 September 2019 . 12:28:20 pm} as /SqueakJS/caffeine.image!Webpage current chrome tabs query: {#title -> '*'}!self counterpart asArray explore!Webpage current chrome debuggerForTabWithID: 12!self resolve: (self getDocument getElementsByClassName: 'button-nfplayerFastForward') onlyOne!(((((((((((self atMatching: '*__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick) at: '[[BoundThis]]') at: #props) at: #onClick) at: '[[BoundThis]]') at: #onSeekForward) at: '[[BoundThis]]') at: #context!EditHistory connectTo: 'ws://localhost:8091/tether'.!(self at: #playerSession) at: '_id'!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 12:54'!value	self getProperties.	^(properties isEmpty)		ifTrue: [(proxy at: #value) counterpart simplestRepresentation]		ifFalse: [self error: 'I have properties.']! !self value!self value!((self at: #playerSession) at: '_id') value!(result proxy at: #exceptionDetails) counterpart!'(receiver) => {receiver.', message selector, '()}'!message selector copyUpTo: $:!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 13:02' prior: 35189881!doesNotUnderstand: message	^[super doesNotUnderstand: message]		on: Error		do: [:exception |			| result |						result := (				debugger					callFunctionWithSource: '(receiver) => {receiver.', (message selector copyUpTo: $:), '()}'					withParameters: {self}					on: self).								(result proxy at: #exceptionDetails)				ifNil: [result result proxy remoteRuntimeJSObjectByDebugger: debugger]				ifNotNil: [					"(result proxy at: #exceptionDetails) counterpart"					self error: 'JS debugger invocation failed']]! !!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 13:03' prior: 35203162!doesNotUnderstand: message	^[super doesNotUnderstand: message]		on: Error		do: [:exception |			| result |						result := (				debugger					callFunctionWithSource: '(receiver) => {receiver.', (message selector copyUpTo: $:), '()}'					withParameters: {self}					on: self).								(result proxy at: #exceptionDetails)				ifNil: [result result proxy remoteRuntimeJSObjectByDebugger: debugger]				ifNotNil: [					"(result proxy at: #exceptionDetails) counterpart explore"					self error: 'JS debugger invocation failed']]! !(result proxy at: #exceptionDetails) counterpart explore!(result proxy at: #exceptionDetails) counterpart explore!'(receiver) => {receiver.', (message selector copyUpTo: $:), '()}'!message arguments!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 13:29' prior: 35203794!doesNotUnderstand: message	^[super doesNotUnderstand: message]		on: Error		do: [:exception |			| result |						result := (				debugger					callFunctionWithSource: '(receiver, arguments) => {return receiver.', (message selector copyUpTo: $:), '.apply(null, arguments)}'					withParameters: {						self.						message arguments}					on: self).								(result proxy at: #exceptionDetails)				ifNil: [result result proxy remoteRuntimeJSObjectByDebugger: debugger]				ifNotNil: [					"(result proxy at: #exceptionDetails) counterpart explore"					self error: 'JS debugger invocation failed']]! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 13:31' prior: 35190900!callFunctionWithSource: source withParameters: parameters on: remoteRuntimeJSObject	^self resultFrom: [:resultAvailable |		| arguments |				arguments := OrderedCollection new.		parameters do: [:parameter | arguments add: {#objectId -> parameter objectId}].					self			sendCommand: tabID			with: 'Runtime.callFunctionOn'			with: {				#objectId -> remoteRuntimeJSObject objectId.				#functionDeclaration -> source.				#arguments -> arguments asArray}			with: [:result |				callbackResult := (					result						ifNil: [result]						ifNotNil: [result remoteRuntimeJSObjectByDebugger: self]).										resultAvailable signal]]! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 13:35' prior: 35205348!callFunctionWithSource: source withParameters: parameters on: remoteRuntimeJSObject	^self resultFrom: [:resultAvailable |		| arguments |				arguments := OrderedCollection new.		parameters do: [:parameter |			arguments add: (				(parameter class == Array)					ifTrue: [parameter]					ifFalse: [{#objectId -> parameter objectId}])].					self			sendCommand: tabID			with: 'Runtime.callFunctionOn'			with: {				#objectId -> remoteRuntimeJSObject objectId.				#functionDeclaration -> source.				#arguments -> arguments asArray}			with: [:result |				callbackResult := (					result						ifNil: [result]						ifNotNil: [result remoteRuntimeJSObjectByDebugger: self]).										resultAvailable signal]]! !message arguments collect: [:argument | argument asJSArgument]!!Array methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 13:41' prior: 33767628!asJSArgument	^self collect: [:element | element asJSArgument]! !message arguments collect: [:argument | argument asJSArgument]!self counterpart!argument asJSArgument!argument asJSArgument = argument!!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 13:49' prior: 35164313!with: argument retry: retryBlock	| error |	(error := self primGetError) ifNil: [^ self error: 'JSBridge error'].	(error beginsWith: 'asJSArgument') ifTrue: [		^(argument asJSArgument = argument)			ifTrue: [self error: error]			ifFalse: [retryBlock value: argument asJSArgument]].	(error beginsWith: 'CallbackSemaphore') ifTrue: [		self class initCallbacks.		^retryBlock value: argument].	self error: error! !self asJSArgument!self asJSArgument counterpart!Dictionary! message arguments!WebUtils jsonEncode: (							(Dictionary new)								addAll: message arguments onlyOne;								yourself)!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 14:05' prior: 35204641!doesNotUnderstand: message	^[super doesNotUnderstand: message]		on: Error		do: [:exception |			| result |						result := (				debugger					callFunctionWithSource: '(receiver, arguments) => {return receiver.', (message selector copyUpTo: $:), '.apply(null, arguments)}'					withParameters: {						self.						WebUtils jsonEncode: (							(Dictionary new)								addAll: message arguments onlyOne;								yourself)}					on: self).								(result proxy at: #exceptionDetails)				ifNil: [result result proxy remoteRuntimeJSObjectByDebugger: debugger]				ifNotNil: [					"(result proxy at: #exceptionDetails) counterpart explore"					self error: 'JS debugger invocation failed']]! !parameter class == ByteString!!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 14:06' prior: 35206092!callFunctionWithSource: source withParameters: parameters on: remoteRuntimeJSObject	^self resultFrom: [:resultAvailable |		| arguments |				arguments := OrderedCollection new.		parameters do: [:parameter |			arguments add: (				(parameter class == ByteString)					ifTrue: [parameter]					ifFalse: [{#objectId -> parameter objectId}])].					self			sendCommand: tabID			with: 'Runtime.callFunctionOn'			with: {				#objectId -> remoteRuntimeJSObject objectId.				#functionDeclaration -> source.				#arguments -> arguments asArray}			with: [:result |				callbackResult := (					result						ifNil: [result]						ifNotNil: [result remoteRuntimeJSObjectByDebugger: self]).										resultAvailable signal]]! !!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 14:12' prior: 35207993!doesNotUnderstand: message	^[super doesNotUnderstand: message]		on: Error		do: [:exception |			| result |						result := (				debugger					callFunctionWithSource: '(receiver, arguments) => {return receiver.', (message selector copyUpTo: $:), '.apply(null, arguments)}'					withParameters: {						self.						{WebUtils jsonEncode: (							(Dictionary new)								addAll: message arguments onlyOne;								yourself)}}					on: self).								(result proxy at: #exceptionDetails)				ifNil: [result result proxy remoteRuntimeJSObjectByDebugger: debugger]				ifNotNil: [					"(result proxy at: #exceptionDetails) counterpart explore"					self error: 'JS debugger invocation failed']]! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 14:13' prior: 35208822!callFunctionWithSource: source withParameters: parameters on: remoteRuntimeJSObject	^self resultFrom: [:resultAvailable |		| arguments |				arguments := OrderedCollection new.		parameters do: [:parameter |			arguments add: (				(parameter class == Array)					ifTrue: [parameter]					ifFalse: [{#objectId -> parameter objectId}])].					self			sendCommand: tabID			with: 'Runtime.callFunctionOn'			with: {				#objectId -> remoteRuntimeJSObject objectId.				#functionDeclaration -> source.				#arguments -> arguments asArray}			with: [:result |				callbackResult := (					result						ifNil: [result]						ifNotNil: [result remoteRuntimeJSObjectByDebugger: self]).										resultAvailable signal]]! !!ChromeDebuggerAPI methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 14:13' prior: 35210452!callFunctionWithSource: source withParameters: parameters on: remoteRuntimeJSObject	^self resultFrom: [:resultAvailable |		| arguments |				arguments := OrderedCollection new.		parameters do: [:parameter |			arguments add: (				(parameter class == Array)					ifTrue: [parameter]					ifFalse: [{#objectId -> parameter objectId}])].					self			sendCommand: tabID			with: 'Runtime.callFunctionOn'			with: {				#objectId -> remoteRuntimeJSObject objectId.				#functionDeclaration -> source.				#arguments -> arguments asArray}			with: [:result |				callbackResult := (					result						ifNil: [result]						ifNotNil: [result remoteRuntimeJSObjectByDebugger: self]).										resultAvailable signal]]! !!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 14:19' prior: 35209653!doesNotUnderstand: message	^[super doesNotUnderstand: message]		on: Error		do: [:exception |			| result |						result := (				debugger					callFunctionWithSource: (						((String new: 32) writableStream)							nextPutAll: '(receiver) => {return receiver.';							nextPutAll: (message selector copyUpTo: $:);							nextPutAll: '.apply(null, ';							nextPutAll: (								WebUtils jsonEncode: (									(Dictionary new)										addAll: message arguments onlyOne;										yourself));							nextPutAll: ')}';							contents)					withParameters: {self}					on: self).								(result proxy at: #exceptionDetails)				ifNil: [result result proxy remoteRuntimeJSObjectByDebugger: debugger]				ifNotNil: [					"(result proxy at: #exceptionDetails) counterpart explore"					self error: 'JS debugger invocation failed']]! !(result proxy at: #exceptionDetails) counterpart explore!						((String new: 32) writableStream)							nextPutAll: '(receiver) => {return receiver.';							nextPutAll: (message selector copyUpTo: $:);							nextPutAll: '.apply(null, ';							nextPutAll: (								WebUtils jsonEncode: (									(Dictionary new)										addAll: message arguments onlyOne;										yourself));							nextPutAll: ')}';							contents!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 14:23' prior: 35212100!doesNotUnderstand: message	^[super doesNotUnderstand: message]		on: Error		do: [:exception |			| result |						result := (				debugger					callFunctionWithSource: (						((String new: 32) writableStream)							nextPutAll: '(receiver) => {return receiver.';							nextPutAll: (message selector copyUpTo: $:);							nextPutAll: '.apply(null, [';							nextPutAll: (								WebUtils jsonEncode: (									(Dictionary new)										addAll: message arguments onlyOne;										yourself));							nextPutAll: '])}';							contents)					withParameters: {self}					on: self).								(result proxy at: #exceptionDetails)				ifNil: [result result proxy remoteRuntimeJSObjectByDebugger: debugger]				ifNotNil: [					"(result proxy at: #exceptionDetails) counterpart explore"					self error: 'JS debugger invocation failed']]! !(self at: #actionCreators) playerSeek: {	#seekTime -> 120000.	#sessionId -> ((self at: #playerSession) at: '_id') value}!(self at: #actionCreators) playerSeek: {	#seekTime -> 240000.	#sessionId -> ((self at: #playerSession) at: '_id') value}!----SNAPSHOT----{21 September 2019 . 2:24:13 pm} caffeine.image priorSource: 1646497!Webpage exportSnapshot!Webpage zoomTo: 500@500!Webpage zoomTo: 700@700!Webpage zoomTo: 700@750!Webpage zoomTo: 650@750!(self at: #actionCreators) playerSeek: {	#seekTime -> 360000.	#sessionId -> ((self at: #playerSession) at: '_id') value}!(self at: #actionCreators) playerSeek: {	#seekTime -> 360000.	#sessionId -> ((self at: #playerSession) at: '_id') value}!SystemOrganization addCategory: #Netflix!Object subclass: #Netflix	instanceVariableNames: 'debugger functions sessionID'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!!Netflix class methodsFor: 'no messages' stamp: 'crl 9/21/2019 19:39'!fromTabWithID: tabID	^(self new)		debugger: (Webpage current chrome debuggerForTabWithID: tabID);		yourself! !!Netflix methodsFor: 'no messages' stamp: 'crl 9/21/2019 19:40'!debugger: chromeDebuggerAPI	debugger := chromeDebuggerAPI! !!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 19:46' prior: 35215476!debugger: chromeDebuggerAPI	debugger := chromeDebuggerAPI.	functions := ((((((((((((debugger resolve: (debugger getDocument getElementsByClassName: 'button-nfplayerFastForward') onlyOne) atMatching: '*__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick) at: '[[BoundThis]]') at: #props) at: #onClick) at: '[[BoundThis]]') at: #onSeekForward) at: '[[BoundThis]]') at: #context! !!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 19:49' prior: 35215627!debugger: chromeDebuggerAPI	debugger := chromeDebuggerAPI.	functions := ((((((((((((debugger resolve: (debugger getDocument getElementsByClassName: 'button-nfplayerFastForward') onlyOne) atMatching: '*__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick) at: '[[BoundThis]]') at: #props) at: #onClick) at: '[[BoundThis]]') at: #onSeekForward) at: '[[BoundThis]]') at: #context.	sessionID := (functions at: #playerSession) at: '_id'! !!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 19:52'!seekTo: seconds	(self at: #actionCreators) playerSeek: {		#seekTime -> seconds * 1000.		#sessionId -> sessionID}! !Object subclass: #Netflix	instanceVariableNames: 'debugger functions sessionID player'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!Object subclass: #Netflix	instanceVariableNames: 'debugger functions sessionID player'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 19:53' prior: 35216127!debugger: chromeDebuggerAPI	debugger := chromeDebuggerAPI.	player := ((((((((((((debugger resolve: (debugger getDocument getElementsByClassName: 'button-nfplayerFastForward') onlyOne) atMatching: '*__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick) at: '[[BoundThis]]') at: #props) at: #onClick) at: '[[BoundThis]]') at: #onSeekForward) at: '[[BoundThis]]') at: #context.	functions := self at: #actionCreators.	sessionID := (player at: #playerSession) at: '_id'! !!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 19:53' prior: 35217189!debugger: chromeDebuggerAPI	debugger := chromeDebuggerAPI.	player := ((((((((((((debugger resolve: (debugger getDocument getElementsByClassName: 'button-nfplayerFastForward') onlyOne) atMatching: '*__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick) at: '[[BoundThis]]') at: #props) at: #onClick) at: '[[BoundThis]]') at: #onSeekForward) at: '[[BoundThis]]') at: #context.	functions := player at: #actionCreators.	sessionID := (player at: #playerSession) at: '_id'! !!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 19:58' prior: 35216667!seekTo: seconds	functions playerSeek: {		#seekTime -> seconds * 1000.		#sessionId -> sessionID}! !----STARTUP----{21 September 2019 . 8:11:54 pm} as /SqueakJS/caffeine.image!SystemOrganization addCategory: #Netflix!Object subclass: #Netflix	instanceVariableNames: 'debugger functions sessionID player'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!!Netflix class methodsFor: 'no messages' stamp: 'crl 9/21/2019 19:39'!fromTabWithID: tabID	^(self new)		debugger: (Webpage current chrome debuggerForTabWithID: tabID);		yourself! !!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 19:53'!debugger: chromeDebuggerAPI	debugger := chromeDebuggerAPI.	player := ((((((((((((debugger resolve: (debugger getDocument getElementsByClassName: 'button-nfplayerFastForward') onlyOne) atMatching: '*__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick) at: '[[BoundThis]]') at: #props) at: #onClick) at: '[[BoundThis]]') at: #onSeekForward) at: '[[BoundThis]]') at: #context.	functions := player at: #actionCreators.	sessionID := (player at: #playerSession) at: '_id'! !!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 19:58'!seekTo: seconds	functions playerSeek: {		#seekTime -> seconds * 1000.		#sessionId -> sessionID}! !SystemOrganization removeSystemCategory: #Unknown!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 20:18' prior: 35213474!doesNotUnderstand: message	^[super doesNotUnderstand: message]		on: Error		do: [:exception |			| result |						result := (				debugger					callFunctionWithSource: (						((String new: 32) writableStream)							nextPutAll: '(receiver) => {return receiver.';							nextPutAll: (message selector copyUpTo: $:);							nextPutAll: '.apply(null, [';							nextPutAll: (								(message arguments isEmpty)									ifTrue: ['{}']									ifFalse: [										WebUtils jsonEncode: (											(Dictionary new)												addAll: message arguments onlyOne;												yourself)]);							nextPutAll: '])}';							contents)					withParameters: {self}					on: self).								(result proxy at: #exceptionDetails)				ifNil: [result result proxy remoteRuntimeJSObjectByDebugger: debugger]				ifNotNil: [					"(result proxy at: #exceptionDetails) counterpart explore"					self error: 'JS debugger invocation failed']]! !Webpage current chrome tabs query: {#title -> '*'}!(Webpage current chrome tabs query: {#title -> '*'}) counterpart explore!(Webpage current chrome tabs query: {#title -> '*'}) counterpart asArray explore!(Webpage current chrome tabs query: {#title -> '*'}) counterpart asArray detect: [:tabInfo | tabInfo title = 'Netflix']!((Webpage current chrome tabs query: {#title -> '*'}) counterpart asArray detect: [:tabInfo | tabInfo title = 'Netflix']) id!ChromeDebuggerAPI instanceCount!----SNAPSHOT----{21 September 2019 . 8:32 pm} caffeine.image priorSource: 1660134!----STARTUP----{21 September 2019 . 8:33:31 pm} as /SqueakJS/caffeine.image!Netflix fromTabWithID: ((Webpage current chrome tabs query: {#title -> '*'}) counterpart asArray detect: [:tabInfo | tabInfo title = 'Netflix']) id!!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 20:37'!pause	functions playerPause! !!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 20:38'!play	functions playerPlay! !self play!functions!functions getProperties!functions!functions at: #playerPlay!self getProperties!properties size!!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 20:44' prior: 35219586!seekTo: seconds	functions playerSeek: {		#seekTime -> (seconds * 1000).		#sessionId -> sessionID}! !self seekTo: 300!self seekTo: 300!self seekTo: 300!sessionID simplestRepresentation!(sessionID proxy at: #value) simplestRepresentation!(sessionID proxy at: #value) counterpart simplestRepresentation!!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 20:47' prior: 35219010!debugger: chromeDebuggerAPI	debugger := chromeDebuggerAPI.	player := ((((((((((((debugger resolve: (debugger getDocument getElementsByClassName: 'button-nfplayerFastForward') onlyOne) atMatching: '*__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick) at: '[[BoundThis]]') at: #props) at: #onClick) at: '[[BoundThis]]') at: #onSeekForward) at: '[[BoundThis]]') at: #context.	functions := player at: #actionCreators.	sessionID := (((player at: #playerSession) at: '_id') proxy at: #value) counterpart simplestRepresentation! !self seekTo: 300!self pause!!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 20:48' prior: 35221655!pause	functions playerPause: {#sessionId -> sessionID}! !self pause!!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 20:49' prior: 35221760!play	functions playerPlay: {#sessionId -> sessionID}! !self play!self pause.!functions getProperties anyOne!functions getProperties collect: [:property | property name]!player getProperties collect: [:property | property name]!(player at: #playerApp) getProperties collect: [:property | property name]!Object subclass: #Netflix	instanceVariableNames: 'debugger functions sessionID player netflix'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!Object subclass: #Netflix	instanceVariableNames: 'debugger functions sessionID player netflix'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!Object subclass: #Netflix	instanceVariableNames: 'debugger functions sessionID player netflix context'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!Object subclass: #Netflix	instanceVariableNames: 'debugger functions sessionID player netflix context'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 21:11' prior: 35222413!debugger: chromeDebuggerAPI	debugger := chromeDebuggerAPI.	netflix := (((((((((((debugger resolve: (debugger getDocument getElementsByClassName: 'button-nfplayerFastForward') onlyOne) atMatching: '*__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick) at: '[[BoundThis]]') at: #props) at: #onClick) at: '[[BoundThis]]') at: #onSeekForward) at: '[[BoundThis]]'.	context := netflix at: #context.	functions := context at: #actionCreators.	sessionID := (((context at: #playerSession) at: '_id') proxy at: #value) counterpart simplestRepresentation! !Object subclass: #Netflix	instanceVariableNames: 'debugger functions sessionID netflix context'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 21:12'!detach	debugger detach! !self detach!----SNAPSHOT----{21 September 2019 . 9:13:23 pm} caffeine.image priorSource: 1666836!Webpage exportSnapshot!!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 21:16'!currentTime	^((netflix at: #state) at: #player) getCurrentTime! !Netflix fromTabWithID: ((Webpage current chrome tabs query: {#title -> '*'}) counterpart asArray detect: [:tabInfo | tabInfo title = 'Netflix']) id!(result proxy at: #exceptionDetails) counterpart explore!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 21:19' prior: 35219843!doesNotUnderstand: message	^[super doesNotUnderstand: message]		on: Error		do: [:exception |			| result |						result := (				debugger					callFunctionWithSource: (						((String new: 32) writableStream)							nextPutAll: '(receiver) => {return receiver.';							nextPutAll: (message selector copyUpTo: $:);							nextPutAll: '.apply(null, [';							nextPutAll: (								(message arguments isEmpty)									ifTrue: ['']									ifFalse: [										WebUtils jsonEncode: (											(Dictionary new)												addAll: message arguments onlyOne;												yourself)]);							nextPutAll: '])}';							contents)					withParameters: {self}					on: self).								(result proxy at: #exceptionDetails)				ifNil: [result result proxy remoteRuntimeJSObjectByDebugger: debugger]				ifNotNil: [					"(result proxy at: #exceptionDetails) counterpart explore"					self error: 'JS debugger invocation failed']]! !(result proxy at: #exceptionDetails) counterpart explore!						((String new: 32) writableStream)							nextPutAll: '(receiver) => {return receiver.';							nextPutAll: (message selector copyUpTo: $:);							nextPutAll: '.apply(null, [';							nextPutAll: (								(message arguments isEmpty)									ifTrue: ['']									ifFalse: [										WebUtils jsonEncode: (											(Dictionary new)												addAll: message arguments onlyOne;												yourself)]);							nextPutAll: '])}';							contents!((netflix at: #state) at: #player) toString!((netflix at: #state) at: #player) getProperties collect: [:property | property name]!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 21:26' prior: 35225760!doesNotUnderstand: message	^[super doesNotUnderstand: message]		on: Error		do: [:exception |			| result |						result := (				debugger					callFunctionWithSource: (						((String new: 32) writableStream)							nextPutAll: '(receiver) => {return receiver.';							nextPutAll: (message selector copyUpTo: $:);							nextPutAll: '.apply(receiver, [';							nextPutAll: (								(message arguments isEmpty)									ifTrue: ['']									ifFalse: [										WebUtils jsonEncode: (											(Dictionary new)												addAll: message arguments onlyOne;												yourself)]);							nextPutAll: '])}';							contents)					withParameters: {self}					on: self).								(result proxy at: #exceptionDetails)				ifNil: [result result proxy remoteRuntimeJSObjectByDebugger: debugger]				ifNotNil: [					"(result proxy at: #exceptionDetails) counterpart explore"					self error: 'JS debugger invocation failed']]! !self currentTime.!proxy counterpart explore!proxy!self simplestRepresentation!self currentTime.!self simplestRepresentation!!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 21:32' prior: 35225381!currentTime	^(((netflix at: #state) at: #player) getCurrentTime) simplestRepresentation! !proxy counterpart explore!proxy value!proxy at: #value!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 21:38'!simplestRepresentation	^(proxy at: #type)		ifNil: [self]		ifNotNil: [			(				(					(Dictionary new)						at: 'number' put: [:value | value asNumber];						yourself				)					at: proxy type			)				value: (proxy at: #value)]! !proxy type!proxy type counterpart simplestRepresentation!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 21:40' prior: 35228845!simplestRepresentation	^(proxy at: #type)		ifNil: [self]		ifNotNil: [			(				(					(Dictionary new)						at: 'number' put: [:value | value asNumber];						yourself				)					at: proxy type counterpart simplestRepresentation			)				value: (proxy at: #value)]! !!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 21:40' prior: 35229246!simplestRepresentation	^(proxy at: #type)		ifNil: [self]		ifNotNil: [			(				(					(Dictionary new)						at: 'number' put: [:value | value asNumber];						at: 'undefined' put: [:value | nil];						yourself				)					at: proxy type counterpart simplestRepresentation			)				value: (proxy at: #value)]! !self currentTime.!proxy type counterpart simplestRepresentation!proxy at: #value!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 21:43' prior: 35229621!simplestRepresentation	^(proxy at: #type)		ifNil: [proxy]		ifNotNil: [			(				(					(Dictionary new)						at: 'number' put: [:value | value asNumber];						at: 'undefined' put: [:value | nil];						at: 'object' put: [:value | value]						yourself				)					at: proxy type counterpart simplestRepresentation			)				value: (proxy at: #value)]! !proxy type!proxy counterpart!proxy subtype!proxy type!proxy value!proxy value counterpart!proxy type counterpart!proxy type counterpart simplestRepresentation!!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 21:46' prior: 35230126!simplestRepresentation	^(proxy at: #type)		ifNil: [proxy]		ifNotNil: [			(				(					(Dictionary new)						at: 'number' put: [:value | value asNumber];						at: 'undefined' put: [:value | nil];						at: 'object' put: [:value | value];						yourself				)					at: proxy type counterpart simplestRepresentation			)				value: (proxy at: #value)]! !self currentTime.!self currentTime.!Object subclass: #Netflix	instanceVariableNames: 'debugger functions sessionID netflix context onSeekForward'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!Object subclass: #Netflix	instanceVariableNames: 'debugger functions sessionID netflix context onSeekForward'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 21:50' prior: 35224335!debugger: chromeDebuggerAPI	debugger := chromeDebuggerAPI.	onSeekForward := ((((((((((debugger resolve: (debugger getDocument getElementsByClassName: 'button-nfplayerFastForward') onlyOne) atMatching: '*__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick) at: '[[BoundThis]]') at: #props) at: #onClick) at: '[[BoundThis]]') at: #onSeekForward.	self setFunctions! !!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 21:50'!setFunctions	context := (onSeekForward at: '[[BoundThis]]') at: #context.	functions := context at: #actionCreators.	sessionID := (((context at: #playerSession) at: '_id') proxy at: #value) counterpart simplestRepresentation! !!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 21:51' prior: 35228605!currentTime	self setFunctions.	^(((netflix at: #state) at: #player) getCurrentTime) simplestRepresentation! !!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 21:53' prior: 35232079!setFunctions	netflix := onSeekForward at: '[[BoundThis]]'.	context := netflix at: #context.	functions := context at: #actionCreators.	sessionID := (((context at: #playerSession) at: '_id') proxy at: #value) counterpart simplestRepresentation! !onSeekForward := ((((((((((debugger resolve: (debugger getDocument getElementsByClassName: 'button-nfplayerFastForward') onlyOne) atMatching: '*__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick) at: '[[BoundThis]]') at: #props) at: #onClick) at: '[[BoundThis]]') at: #onSeekForward.!self currentTime!----SNAPSHOT----{21 September 2019 . 9:56:30 pm} caffeine.image priorSource: 1670763!Webpage exportSnapshot!self play!self pause!345.876 * 1000!(345.876 * 1000) rounded!!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 21:59' prior: 35222008!seekTo: seconds	functions playerSeek: {		#seekTime -> (seconds * 1000) rounded.		#sessionId -> sessionID}! !self seekTo: self currentTime + 120!Webpage zoomTo: 1300@1600!Webpage zoomTo: 1500@1800!Webpage zoomTo: 1600@1850!Webpage zoomTo: 1700@1900!Webpage zoomTo: 1750@1900!----SNAPSHOT----{21 September 2019 . 10:47:35 pm} caffeine.image priorSource: 1678751!Webpage exportSnapshot!self pause.!self play.!self currentTime.!self pause.!self currentTime.!Object subclass: #Netflix	instanceVariableNames: 'debugger functions sessionID netflix context onSeekForward onClick'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!Object subclass: #Netflix	instanceVariableNames: 'debugger functions sessionID netflix context onSeekForward onClick'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 22:52' prior: 35231608!debugger: chromeDebuggerAPI	debugger := chromeDebuggerAPI.	onClick := (((((debugger resolve: (debugger getDocument getElementsByClassName: 'button-nfplayerFastForward') onlyOne) atMatching: '*__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick.	self setFunctions! !!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 22:53' prior: 35232599!setFunctions	netflix := (((((onClick at: '[[BoundThis]]') at: #props) at: #onClick) at: '[[BoundThis]]') at: #onSeekForward) at: '[[BoundThis]]'.	context := netflix at: #context.	functions := context at: #actionCreators.	sessionID := (((context at: #playerSession) at: '_id') proxy at: #value) counterpart simplestRepresentation! !onClick := (((((debugger resolve: (debugger getDocument getElementsByClassName: 'button-nfplayerFastForward') onlyOne) atMatching: '*__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick!self currentTime.!Object subclass: #Netflix	instanceVariableNames: 'debugger functions sessionID netflix context onClick'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!self play.!Object subclass: #Netflix	instanceVariableNames: 'debugger functions sessionID netflix context onClick nextEpisodeButton'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!Object subclass: #Netflix	instanceVariableNames: 'debugger functions sessionID netflix context onClick nextEpisodeButton'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 23:05' prior: 35234403!debugger: chromeDebuggerAPI	| document |		debugger := chromeDebuggerAPI.	document := debugger getDocument.	onClick := (((((debugger resolve: (document getElementsByClassName: 'button-nfplayerFastForward') onlyOne) atMatching: '*__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick.	nextEpisodeButton := debugger resolve: (document getElementsByClassName: 'button-nfplayerFastForward') onlyOne.	self setFunctions! !!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 23:06' prior: 35236024!debugger: chromeDebuggerAPI	| document |		debugger := chromeDebuggerAPI.	document := debugger getDocument.	onClick := (((((debugger resolve: (document getElementsByClassName: 'button-nfplayerFastForward') onlyOne) atMatching: '*__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick.	nextEpisodeButton := debugger resolve: (document getElementsByClassName: 'button-nfplayerNextEpisode') onlyOne.	self setFunctions! !!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 23:06'!nextEpisode	nextEpisodeButton click! !| document |document := debugger getDocument.nextEpisodeButton := debugger resolve: (document getElementsByClassName: 'button-nfplayerNextEpisode') onlyOne.!self nextEpisode!!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 23:09'!seekForward: seconds	self seekTo: self currentTime + seconds! !!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 23:10'!seekBackward: seconds	self seekTo: ((self currentTime - seconds) max: 0)! !Object subclass: #Netflix	instanceVariableNames: 'debugger functions sessionID netflix context onClick nextEpisodeButton player'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!Object subclass: #Netflix	instanceVariableNames: 'debugger functions sessionID netflix context onClick nextEpisodeButton player'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 23:12' prior: 35234791!setFunctions	netflix := (((((onClick at: '[[BoundThis]]') at: #props) at: #onClick) at: '[[BoundThis]]') at: #onSeekForward) at: '[[BoundThis]]'.	player := (netflix at: #state) at: #player.	context := netflix at: #context.	functions := context at: #actionCreators.	sessionID := (((context at: #playerSession) at: '_id') proxy at: #value) counterpart simplestRepresentation! !!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 23:13' prior: 35232398!currentTime	self setFunctions.	^player getCurrentTime simplestRepresentation! !self setFunctions!Object subclass: #Netflix	instanceVariableNames: 'debugger functions sessionID netflix context onClick nextEpisodeButton player duration'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!Object subclass: #Netflix	instanceVariableNames: 'debugger functions sessionID netflix context onClick nextEpisodeButton player duration'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 23:20' prior: 35238084!setFunctions	netflix := (((((onClick at: '[[BoundThis]]') at: #props) at: #onClick) at: '[[BoundThis]]') at: #onSeekForward) at: '[[BoundThis]]'.	player := (netflix at: #state) at: #player.	context := netflix at: #context.	functions := context at: #actionCreators.	sessionID := (((context at: #playerSession) at: '_id') proxy at: #value) counterpart simplestRepresentation.	duration := player getDuration! !self setFunctions!player getDuration!player getProperties collect: [:property | property name]!player getCurrentTime!self currentTime.!self currentTime.!self play.!self pause.!self currentTime.!self currentTime.!functions getProperties collect: [:property | property name]!(functions getProperties collect: [:property | property name]) asSortedCollection!(player getProperties collect: [:property | property name]) asSortedCollection!player getCurrentTime!self play.!player at: '_isClosing'!self setFunctions.!player getCurrentTime!!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 23:40' prior: 35238554!currentTime	^player getCurrentTime simplestRepresentation! !self currentTime.!((netflix at: #state) getProperties collect: [:property | property name]) asSortedCollection!self setFunctions.!(result proxy at: #exceptionDetails) counterpart explore!(netflix at: #state) at: #currentPlayerTime!(netflix at: #state) at: #currentPlayerTime!(netflix at: #state) at: #currentPlayerTime!(netflix at: #state) at: #duration!(netflix getProperties collect: [:property | property name]) asSortedCollection.!netflix getNFPlayerNode!self setFunctions.!netflix getNFPlayerNode!self currentTime.!!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 23:57' prior: 35236564!debugger: chromeDebuggerAPI	| document |		debugger := chromeDebuggerAPI.	document := debugger getDocument.	nextEpisodeButton := debugger resolve: (document getElementsByClassName: 'button-nfplayerNextEpisode') onlyOne.	self setFunctions! !!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 23:57' prior: 35239161!setFunctions	onClick := (((((debugger resolve: (debugger getDocument getElementsByClassName: 'button-nfplayerFastForward') onlyOne) atMatching: '*__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick.	netflix := (((((onClick at: '[[BoundThis]]') at: #props) at: #onClick) at: '[[BoundThis]]') at: #onSeekForward) at: '[[BoundThis]]'.	player := (netflix at: #state) at: #player.	context := netflix at: #context.	functions := context at: #actionCreators.	sessionID := (((context at: #playerSession) at: '_id') proxy at: #value) counterpart simplestRepresentation.	duration := player getDuration! !!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 23:58' prior: 35240929!debugger: chromeDebuggerAPI	debugger := chromeDebuggerAPI.	self setFunctions! !!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/21/2019 23:58' prior: 35241264!setFunctions	| document |		document := debugger getDocument.	onClick := (((((debugger resolve: (document getElementsByClassName: 'button-nfplayerFastForward') onlyOne) atMatching: '*__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick.	nextEpisodeButton := debugger resolve: (document getElementsByClassName: 'button-nfplayerNextEpisode') onlyOne.	netflix := (((((onClick at: '[[BoundThis]]') at: #props) at: #onClick) at: '[[BoundThis]]') at: #onSeekForward) at: '[[BoundThis]]'.	player := (netflix at: #state) at: #player.	context := netflix at: #context.	functions := context at: #actionCreators.	sessionID := (((context at: #playerSession) at: '_id') proxy at: #value) counterpart simplestRepresentation.	duration := player getDuration! !self setFunctions.!self currentTime.!!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 00:00'!duration	^player getDuration simplestRepresentation! !self duration!!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 00:00' prior: 35243052!duration	^duration! !!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 00:02' prior: 35233454!seekTo: seconds	seconds > duration ifTrue: [^self nextEpisode].		functions playerSeek: {		#seekTime -> ((seconds max: 0) * 1000) rounded.		#sessionId -> sessionID}! !!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 00:02' prior: 35237520!seekBackward: seconds	self seekTo: (self currentTime - seconds)! !self play.!EditHistory connectTo: 'ws://localhost:8091/tether'.!!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 00:04' prior: 35242155!setFunctions	| document |		document := debugger getDocument.	onClick := (((((debugger resolve: (document getElementsByClassName: 'button-nfplayerFastForward') onlyOne) atMatching: '*__reactInternalInstance$*') at: #return) at: #stateNode) at: #props) at: #onClick.	nextEpisodeButton := debugger resolve: (document getElementsByClassName: 'button-nfplayerNextEpisode') onlyOne.	netflix := (((((onClick at: '[[BoundThis]]') at: #props) at: #onClick) at: '[[BoundThis]]') at: #onSeekForward) at: '[[BoundThis]]'.	player := (netflix at: #state) at: #player.	context := netflix at: #context.	functions := context at: #actionCreators.	sessionID := (((context at: #playerSession) at: '_id') proxy at: #value) counterpart simplestRepresentation.	duration := player getDuration simplestRepresentation! !duration := player getDuration simplestRepresentation!duration := player getDuration simplestRepresentation!self seekForward: 120.!duration atRandom!----SNAPSHOT----{22 September 2019 . 12:08:03 am} caffeine.image priorSource: 1679311!| delay |delay := Delay forMilliseconds: 500.[	[		delay wait.		self seekTo: (duration - 120) atRandom	]		repeat]	fork!self terminate!| delay |delay := Delay forSeconds: 5.[	[		delay wait.		self seekTo: (duration - 120) atRandom	]		repeat]	fork!self terminate!self nextEpisode.!self pause.!self currentTime.!self setFunctions.!self currentTime.!self play.!self pause.!self currentTime.!self seekTo: 109.670.!self currentTime.!self seekTo: 109.8.!Smalltalk renameClassNamed: #Scene as: #JSScene!Object subclass: #Scene	instanceVariableNames: 'location characters startingNarrativeTime endingNarrativeTime startingRunningTime endingRunningTime'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!Object subclass: #Episode	instanceVariableNames: 'scenes season'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!Object subclass: #Scene	instanceVariableNames: 'location characters startingNarrativeTime endingNarrativeTime startingRunningTime endingRunningTime episode'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!Object subclass: #Series	instanceVariableNames: 'seasons'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!Object subclass: #SeriesCharacter	instanceVariableNames: 'name'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!Object subclass: #Season	instanceVariableNames: 'episodes'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!Object subclass: #SceneElement	instanceVariableNames: 'name'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!SceneElement subclass: #SeriesCharacter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!SceneElement subclass: #SceneLocation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!Smalltalk renameClassNamed: #SeriesCharacter as: #SceneCharacter!self pause.!self pause.!self play.!self currentTime.!self setFunctions.!self currentTime.!self play.!!Series class methodsFor: 'no messages' stamp: 'crl 9/22/2019 00:50'!entitled: title	^(self new)		title: title;		yourself! !Object subclass: #Series	instanceVariableNames: 'seasons title'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!Object subclass: #Series	instanceVariableNames: 'seasons title'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!!Series methodsFor: 'no messages' stamp: 'crl 9/22/2019 00:50'!title: string	title := string! !Object subclass: #Episode	instanceVariableNames: 'scenes season title'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!Series entitled: 'Better Call Saul'!!Series methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 00:51'!initialize	seasons := OrderedCollection new! !self initialize!!Series methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 00:52'!addSeason	^seasons add: Season new! !self addSeason!!Season methodsFor: 'no messages' stamp: 'crl 9/22/2019 00:53'!initialize	episodes := OrderedCollection new! !self initialize!!Season methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 00:54' prior: 35247968!initialize	episodes := OrderedCollection new.	self addEpisode! !!Season methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 00:55'!addEpisodeEntitled: title	^episodes add: (Episode entitled: title)! !!Season methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 00:55' prior: 35248123!initialize	episodes := OrderedCollection new! !----SNAPSHOT----{22 September 2019 . 12:56:07 am} caffeine.image priorSource: 1690341!!Episode class methodsFor: 'no messages' stamp: 'crl 9/22/2019 00:57'!entitled: title	^(self new)		title: title;		yourself! !!Episode methodsFor: 'no messages' stamp: 'crl 9/22/2019 00:57'!initialize	scenes := OrderedCollection new! !!Episode methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 00:58'!title: string	title := string! !!Episode methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 00:58'!season: aSeason	season := aSeason! !!Season methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 00:58' prior: 35248262!addEpisodeEntitled: title	^episodes add: (		(Episode entitled: title)			season: self;			yourself)! !self addEpisodeEntitled: 'Uno'!!Series methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 00:59' prior: 35247710!initialize	seasons := OrderedCollection new.	self addSeason! !self currentTime.!self currentTime.!!Episode methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:00' prior: 35248753!initialize	scenes := OrderedCollection new.	self addScene! !!Episode methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:00'!addScene	^scenes add: (		(Scene new)			episode: self;			yourself)! !!Scene methodsFor: 'no messages' stamp: 'crl 9/22/2019 01:02'!initialize	characters := IdentitySet new! !!Scene methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:02'!episode: anEpisode	episode := anEpisode! !self addScene!Object subclass: #Netflix	instanceVariableNames: 'debugger functions sessionID netflix context onClick nextEpisodeButton player duration'	classVariableNames: 'ActiveInstance'	poolDictionaries: ''	category: 'Netflix'!Object subclass: #Netflix	instanceVariableNames: 'debugger functions sessionID netflix context onClick nextEpisodeButton player duration'	classVariableNames: 'ActiveInstance'	poolDictionaries: ''	category: 'Netflix'!!Netflix class methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:05'!new	^ActiveInstance := (		(self new)			debugger: (Webpage current chrome debuggerForTabWithID: (self fromTabWithID: ((Webpage current chrome tabs query: {#title -> '*'}) counterpart asArray detect: [:tabInfo | tabInfo title = 'Netflix']) id));			yourself)! !ActiveInstance := self!!Series methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:07'!printOn: stream	super printOn: stream.	stream		nextPutAll: ' entitled ''';		nextPutAll: title;		nextPut: $'	! !Object subclass: #Season	instanceVariableNames: 'episodes series'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!!Series methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:08' prior: 35247848!addSeason	^seasons add: (		(Season new)			series: self;			yourself)! !!Season methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:08'!series: aSeries	series := aSeries! !seasons first series: self!!Series methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:10'!seasons	^seasons! !!Season methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:10'!printOn: stream	stream		nextPutAll: 'season ';		print: (series seasons indexOf: self);		nextPutAll: ' of ';		print: series! !!Series methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:11' prior: 35250857!printOn: stream	stream nextPutAll: title	! !!Episode methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:11'!scenes	^scenes! !!Scene methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:12'!printOn: stream	stream		nextPutAll: 'scene ';		print: (episode scenes indexOf: self);		nextPutAll: ' of ';		print: episode! !!Episode methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:13'!printOn: stream	stream		nextPutAll: 'episode ';		print: (season episodes indexOf: self);		nextPutAll: ' of ';		print: season! !!Season methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:14'!episodes	^episodes! !!Episode methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:15' prior: 35252211!printOn: stream	stream		nextPutAll: 'episode ';		print: (season episodes indexOf: self);		nextPutAll: ' of ';		print: season;		nextPutAll: ' entitled ''';		nextPutAll: title;		nextPut: $'! !!Series methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:15' prior: 35251798!printOn: stream	stream print: title! !!Episode methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:16' prior: 35252528!printOn: stream	stream		nextPutAll: 'episode ';		print: (season episodes indexOf: self);		nextPutAll: ' of ';		print: season;		nextPutAll: ', entitled ''';		nextPutAll: title;		nextPut: $'! !!Episode methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:17'!index	^season episodes indexOf: self! !!Episode methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:17' prior: 35252944!printOn: stream	stream		nextPutAll: 'episode ';		print: self index;		nextPutAll: ' of ';		print: season;		nextPutAll: ', entitled ''';		nextPutAll: title;		nextPut: $'! !!Scene methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:17'!index		^episode scenes indexOf: self! !!Scene methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:17' prior: 35252007!printOn: stream	stream		nextPutAll: 'scene ';		print: self index;		nextPutAll: ' of ';		print: episode! !!Season methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:18'!index	^series seasons indexOf: self! !!Season methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:18' prior: 35251579!printOn: stream	stream		nextPutAll: 'season ';		print: self index;		nextPutAll: ' of ';		print: series! !!Netflix class methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:20'!activeInstance	^ActiveInstance! !!Scene methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:21' prior: 35249798!initialize	characters := IdentitySet new.	startingRunningTime := self currentTime! !Object subclass: #SeriesElement	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!SeriesElement subclass: #Series	instanceVariableNames: 'seasons title'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!SeriesElement subclass: #Season	instanceVariableNames: 'episodes series'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!Object subclass: #Season	instanceVariableNames: 'episodes series'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!Object subclass: #Series	instanceVariableNames: 'seasons title'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!----SNAPSHOT----{22 September 2019 . 1:22:42 am} caffeine.image priorSource: 1694037!!Scene methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:23' prior: 35254348!initialize	characters := IdentitySet new.	startingRunningTime := Netflix currentTime! !!Scene methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:24'!markEndingRunningTime	endingRunningTime := Netflix currentTime! !!Netflix class methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:26'!currentTime	^ActiveInstance currentTime! !self markEndingRunningTime!!Scene methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:27'!markStartingRunningTime	startingRunningTime := Netflix currentTime! !self markStartingRunningTime!!Episode methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:29' prior: 35249662!addScene	scenes isEmpty ifFalse: [scenes last markEndingRunningTime].		^scenes add: (		(Scene new)			episode: self;			yourself)! !!Scene methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:29'!play	Netflix seekTo: startingRunningTime! !!Scene methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:30' prior: 35256141!play	episode load.	Netflix		seekTo: startingRunningTime;		play! !!Episode methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:30'!load! !!Netflix class methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:31'!seekTo: seconds	ActiveInstance seekTo: seconds! !!Netflix class methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:31'!play	ActiveInstance play! !!Netflix class methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:31'!pause	ActiveInstance pause! !self play!!Scene methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:33'!next	^episode scenes after: self! !!Scene methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:33'!seekToEnd	Netflix seekTo: endingRunningTime! !!Scene methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:34'!pause	Netflix pause! !self pause.!self seekToEnd!self addScene!self markEndingRunningTime!!Scene methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:35'!duration	^endingRunningTime - startingRunningTime! !self duration!!Scene methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:36' prior: 35257254!duration	^(endingRunningTime - startingRunningTime) seconds! !self duration!!Scene methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:36'!previous	^episode scenes before: self! !self previous!!Episode methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 01:37' prior: 35253347!printOn: stream	stream		nextPut: $';		nextPutAll: title;		nextPutAll: ''', episode ';		print: self index;		nextPutAll: ' of ';		print: season! !----SNAPSHOT----{22 September 2019 . 1:38:31 am} caffeine.image priorSource: 1700684!Webpage exportSnapshot!Webpage zoomTo: 650@750!Webpage zoomTo: 650@800!debugger attach!!Netflix methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 15:36'!printOn: stream	super printOn: stream.	stream nextPutAll: ' player'! !!RemoteRuntimeJSObject methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 15:37' prior: 35227446!doesNotUnderstand: message	^[super doesNotUnderstand: message]		on: Error		do: [:exception |			| result |						result := (				debugger					callFunctionWithSource: (						((String new: 32) writableStream)							nextPutAll: '(receiver) => {return receiver.';							nextPutAll: (message selector copyUpTo: $:);							nextPutAll: '.apply(receiver, [';							nextPutAll: (								(message arguments isEmpty)									ifTrue: ['']									ifFalse: [										WebUtils jsonEncode: (											(Dictionary new)												addAll: message arguments onlyOne;												yourself)]);							nextPutAll: '])}';							contents)					withParameters: {self}					on: self).								(result isNil or: [(proxy at: #exceptionDetails) notNil])				ifTrue: [					"(result proxy at: #exceptionDetails) counterpart explore"					self error: 'JS debugger invocation failed']				ifFalse: [result result proxy remoteRuntimeJSObjectByDebugger: debugger]]! !self setFunctions.!self play!self pause!Webpage current containingCanvas!Webpage current containingCanvas styleAt: #border put: ''!Object subclass: #Series	instanceVariableNames: 'seasons title player'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!!Series methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 17:51'!player: thePlayer	player := thePlayer! !!Scene methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 17:51' prior: 35256273!play	episode load.	(self player)		seekTo: startingRunningTime;		play! !!Scene methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 17:52'!player	^episode player! !!Episode methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 17:52'!player	^season player! !!Season methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 17:52'!player	^series player! !!Scene methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 17:52' prior: 35257083!pause	self player pause! !!Scene methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 17:53' prior: 35256964!seekToEnd	self player seekTo: endingRunningTime! !!Scene methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 17:53' prior: 35255291!initialize	characters := IdentitySet new.	startingRunningTime := self player currentTime! !!Scene methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 17:53' prior: 35255452!markEndingRunningTime	endingRunningTime := self player currentTime! !!Scene methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 17:53' prior: 35255742!markStartingRunningTime	startingRunningTime := self player currentTime! !!Scene methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 17:54'!series	^episode series! !!Episode methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 17:54'!doesNotUnderstand: message	^message sendTo: season! !!Scene methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 17:55'!doesNotUnderstand: message	^message sendTo: episode! !Scene removeSelector: #player!Episode removeSelector: #player!!Season methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 17:55'!doesNotUnderstand: message	^message sendTo: series! !Season removeSelector: #player!Object subclass: #SceneElement	instanceVariableNames: 'name scene'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!Object subclass: #SceneElement	instanceVariableNames: 'name scene'	classVariableNames: ''	poolDictionaries: ''	category: 'Netflix'!!SceneElement methodsFor: 'no messages' stamp: 'crl 9/22/2019 17:55'!doesNotUnderstand: message	^message sendTo: scene! !!Series methodsFor: 'nil' stamp: 'crl 9/22/2019 17:58'!player	^player! !!Series methodsFor: 'as yet unclassified' stamp: 'crl 9/22/2019 17:58'!series	^self! !self series!self series player: Netflix activeInstance!self player!----SNAPSHOT----{22 September 2019 . 6:01:42 pm} caffeine.image priorSource: 1703428!----SNAPSHOT----{22 September 2019 . 6:05:13 pm} caffeine.image priorSource: 1707638!----STARTUP----{24 September 2019 . 2:13:47 am} as /Users/craig/Downloads/caffeine/backups/37 (headless)/caffeine.image!!PasteUpMorph class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 02:16' prior: 62335178!startUp	JS ifConnected: [		JS SqueakJS vm display headless = true ifTrue: [^self]].			World ifNotNil:[		World restoreMorphicDisplay.		World triggerEvent: #aboutToEnterWorld.	].! !----QUIT----{24 September 2019 . 2:16:52 am} caffeine.image priorSource: 1707725!----STARTUP----{24 September 2019 . 2:26:05 am} as /Users/craig/Downloads/caffeine/backups/37 (headless)/caffeine.image!Smalltalk!SmalltalkImage!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 03:06' prior: 33672548!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [JS at: #onmessage put: [:message | JS postMessage: 'hello from worker']].		Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----QUIT----{24 September 2019 . 3:06:54 am} caffeine.image priorSource: 1708222!----STARTUP----{24 September 2019 . 3:08:41 am} as /Users/craig/Downloads/caffeine/backups/37 (headless)/caffeine.image!!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 03:12'!ifHeadless: block	JS SqueakJS vm display headless = true ifTrue: [block value]! !!PasteUpMorph class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 03:12' prior: 35262468!startUp	JS ifConnected: [		JS ifHeadless: [^self]].			World ifNotNil:[		World restoreMorphicDisplay.		World triggerEvent: #aboutToEnterWorld.	].! !!MenuIcons class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 03:13' prior: 57081540!startUp: resuming 	resuming		ifFalse: [^ self].	JS ifConnected: [JS ifHeadless: [^self]].	self initializeTranslations	! !----QUIT----{24 September 2019 . 3:13:31 am} caffeine.image priorSource: 1708819!----STARTUP----{24 September 2019 . 3:23:11 am} as /Users/craig/Downloads/caffeine/backups/37 (headless)/caffeine.image!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 03:24' prior: 35262990!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [JS debugger; at: #onmessage put: [:message | JS postMessage: 'hello from worker']].		Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----SNAPSHOT----{24 September 2019 . 3:24:09 am} caffeine.image priorSource: 1709667!SmalltalkImage classPool at: #StartUpList!!EventSensor methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 03:29' prior: 31264194!startUp	"Run the I/O process"	self initialize.	self primSetInputSemaphore: (Smalltalk registerExternalObject: inputSemaphore).	super startUp.	JS ifConnected: [JS ifHeadless: [^self]].	self installEventTickler.	Smalltalk isMorphic ifTrue:[self flushAllButDandDEvents].	"Attempt to discover whether the input semaphore is actually being signaled."	hasInputSemaphore := false.	inputSemaphore initSignals.! !----SNAPSHOT----{24 September 2019 . 3:30:05 am} caffeine.image priorSource: 1710245!!EventSensor methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 03:31' prior: 35264902!startUp	"Run the I/O process"	self initialize.	self primSetInputSemaphore: (Smalltalk registerExternalObject: inputSemaphore).	super startUp.	self installEventTickler.	Smalltalk isMorphic ifTrue:[self flushAllButDandDEvents].	"Attempt to discover whether the input semaphore is actually being signaled."	hasInputSemaphore := false.	inputSemaphore initSignals.! !!EventSensor methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 03:31' prior: 31267784!installEventTickler	"Initialize the interrupt watcher process. Terminate the old process if any."	"Sensor installEventTickler"	EventTicklerProcess ifNotNil: [EventTicklerProcess terminate].	JS ifConnected: [JS ifHeadless: [^self]].	EventTicklerProcess := [self eventTickler] forkAt: Processor lowIOPriority.! !----SNAPSHOT----{24 September 2019 . 3:31:35 am} caffeine.image priorSource: 1710886!!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 03:33' prior: 35263537!ifHeadless: block	JS debugger.	JS SqueakJS vm display headless = true ifTrue: [block value]! !----SNAPSHOT----{24 September 2019 . 3:33:11 am} caffeine.image priorSource: 1711851!!MenuIcons class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 03:34' prior: 35263972!startUp: resuming 	JS debugger.	resuming		ifFalse: [^ self].	JS ifConnected: [JS ifHeadless: [^self]].	self initializeTranslations	! !----SNAPSHOT----{24 September 2019 . 3:34:50 am} caffeine.image priorSource: 1712130!!MenuIcons class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 03:35' prior: 35266747!startUp: resuming 	resuming		ifFalse: [^ self].	JS ifConnected: [JS ifHeadless: [^self]].	self initializeTranslations	! !!MenuIcons class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 03:37' prior: 35267074!startUp: resuming 	resuming		ifFalse: [^ self].	JS ifConnected: [JS debugger. JS ifHeadless: [^self]].	self initializeTranslations	! !!MenuIcons class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 03:38' prior: 35267299!startUp: resuming 	resuming		ifFalse: [^ self].	JS ifConnected: [JS ifHeadless: [^self]].	self initializeTranslations	! !----SNAPSHOT----{24 September 2019 . 3:38:39 am} caffeine.image priorSource: 1712457!JS!!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 03:42' prior: 33969809!ifConnected: connected ifNotConnected: notConnected	[self display]		on: Error		do: [:exception | ^notConnected value].	^connected value! !----SNAPSHOT----{24 September 2019 . 3:42:53 am} caffeine.image priorSource: 1713232!!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 03:48' prior: 35267852!ifConnected: connected ifNotConnected: notConnected	[self toString]		on: Error		do: [:exception | ^notConnected value].	^connected value! !----SNAPSHOT----{24 September 2019 . 3:48:13 am} caffeine.image priorSource: 1713563!!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 03:48' prior: 35266466!ifHeadless: block	JS SqueakJS vm display headless = true ifTrue: [block value]! !----SNAPSHOT----{24 September 2019 . 3:49:05 am} caffeine.image priorSource: 1713890!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 03:50' prior: 35264406!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [JS at: #onmessage put: [:message | JS postMessage: 'hello from worker']].		Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 03:54' prior: 35268505!ifHeadless: block	JS display headless = true ifTrue: [block value]! !----SNAPSHOT----{24 September 2019 . 3:54:33 am} caffeine.image priorSource: 1714155!!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 03:59' prior: 35158049!startUp: resuming	"After a system resumption, if the system is being run by SqueakJS in a web browser, reset constants related to that web browser's JavaScript environment."	| forceToScreen |	resuming ifTrue: [		(self == Webpage)			ifTrue: [				Fullscreen := false.								Top := TopDocument := ContainingDiv := ContainingCanvas := ContainingFrame := Current := Options := nil.				Preferences					setPreference: #fastDragWindowForMorphic					toValue: JS isConnected.								JS ifConnected: [					| url |															Top := [JS top counterpart magicWindow] on: Error do: [:exception | JS].					url := (						Top							ifNil: [String randomOfLength: 5]							ifNotNil: [								TopDocument := Top document.								Url absoluteFromText: Top location href asString]).					Options := (						(JS SqueakJS options at: #parameters)							ifNil: [nil]							ifNotNil: [JS SqueakJS options parameters counterpart]).												ContainingCanvas := JS document counterpart getElementById: 'squeak'.					ContainingCanvas						at: #width put: Options width;						at: #height put: Options height.											Top ifNotNil: [ContainingFrame := Top document getElementById: #Caffeine].					ContainingCanvas ifNotNil: [						ContainingDiv := (							ContainingFrame								ifNil: [ContainingCanvas parentNode]								ifNotNil: [									self styleAt: #transition put: 'opacity 500ms'.									ContainingFrame parentNode parentNode]).						ContainingDiv at: #onresize put: [self resize].						ContainingCanvas at: #tabIndex put: 0.						self captureCurrentExtent.						ContainingCanvas onclick: [self focus]].										forceToScreen := [:event | Display forceToScreen].					Top						at: #onresize						put: forceToScreen; 						at: #onscroll						put: forceToScreen;						at: #onorientationchange						put: [:event |							forceToScreen value: event.							self scrollToTop].															ContainingCanvas ifNotNil: [						ContainingCanvas							styleAt: 'user-select'							put: [false]].					Pages						at: url						ifAbsent: [							self								ifOptionAt: 'appID'								then: [:appID |									| appClass |																		appClass := self allSubclasses detect: [:subclass | subclass appID = appID] ifNone: [nil].									appClass										ifNil: [nil]										ifNotNil: [											Pages												at: url												put: (appClass fromURL: url)]]								else: [nil]]]]]! !----SNAPSHOT----{24 September 2019 . 3:59:23 am} caffeine.image priorSource: 1714770!!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 04:01' prior: 35269385!startUp: resuming	"After a system resumption, if the system is being run by SqueakJS in a web browser, reset constants related to that web browser's JavaScript environment."	| forceToScreen |	resuming ifTrue: [		(self == Webpage)			ifTrue: [				Fullscreen := false.								Top := TopDocument := ContainingDiv := ContainingCanvas := ContainingFrame := Current := Options := nil.				Preferences					setPreference: #fastDragWindowForMorphic					toValue: JS isConnected.				JS ifConnected: [					| url |					JS ifHeadless: [^self].					Top := [JS top counterpart magicWindow] on: Error do: [:exception | JS].					url := (						Top							ifNil: [String randomOfLength: 5]							ifNotNil: [								TopDocument := Top document.								Url absoluteFromText: Top location href asString]).					Options := (						(JS SqueakJS options at: #parameters)							ifNil: [nil]							ifNotNil: [JS SqueakJS options parameters counterpart]).												ContainingCanvas := JS document counterpart getElementById: 'squeak'.					ContainingCanvas						at: #width put: Options width;						at: #height put: Options height.											Top ifNotNil: [ContainingFrame := Top document getElementById: #Caffeine].					ContainingCanvas ifNotNil: [						ContainingDiv := (							ContainingFrame								ifNil: [ContainingCanvas parentNode]								ifNotNil: [									self styleAt: #transition put: 'opacity 500ms'.									ContainingFrame parentNode parentNode]).						ContainingDiv at: #onresize put: [self resize].						ContainingCanvas at: #tabIndex put: 0.						self captureCurrentExtent.						ContainingCanvas onclick: [self focus]].										forceToScreen := [:event | Display forceToScreen].					Top						at: #onresize						put: forceToScreen; 						at: #onscroll						put: forceToScreen;						at: #onorientationchange						put: [:event |							forceToScreen value: event.							self scrollToTop].															ContainingCanvas ifNotNil: [						ContainingCanvas							styleAt: 'user-select'							put: [false]].					Pages						at: url						ifAbsent: [							self								ifOptionAt: 'appID'								then: [:appID |									| appClass |																		appClass := self allSubclasses detect: [:subclass | subclass appID = appID] ifNone: [nil].									appClass										ifNil: [nil]										ifNotNil: [											Pages												at: url												put: (appClass fromURL: url)]]								else: [nil]]]]]! !----SNAPSHOT----{24 September 2019 . 4:01:42 am} caffeine.image priorSource: 1717398!WellKnownProcesses!WellKnownProcesses!association value!association value value !WellKnownProcesses do: [:association | association value value first = 'the UI process' ifTrue: [^association key]]!!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 11:06'!wellKnownProcessesAt: label	WellKnownProcesses do: [:association | association value value first = 'the UI process' ifTrue: [^association key]].	^nil.! !!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 11:07'!wellKnownProcessAt: label	WellKnownProcesses do: [:association | association value value first = 'the UI process' ifTrue: [^association key]].	^nil.! !ProcessBrowser class removeSelector: #wellKnownProcessesAt:!ProcessBrowser wellKnownProcessAt: 'the UI process'!Processor userSchedulingPriority!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 11:13' prior: 35268775!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS at: #onmessage put: [:message | JS postMessage: 'hello from worker'].			[				(Delay forSeconds: 5) wait.				(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate]			]				forkAt: Processor timingPriority].		Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----SNAPSHOT----{24 September 2019 . 11:14:02 am} caffeine.image priorSource: 1720042!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 11:30' prior: 35275502!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS at: #onmessage put: [:message |				JS postMessage: {					#result -> (						(message receiver)							perform: message selector							withArguments: {message argument})}].			[				(Delay forSeconds: 5) wait.				(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate]			]				forkAt: Processor timingPriority].		Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 11:30' prior: 35276140!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS at: #onmessage put: [:message |				JS postMessage: {					#result -> (						(message receiver)							perform: message selector asSymbol							withArguments: {message argument})}].			[				(Delay forSeconds: 5) wait.				(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate]			]				forkAt: Processor timingPriority].		Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----SNAPSHOT----{24 September 2019 . 11:30:44 am} caffeine.image priorSource: 1721519!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 11:36' prior: 35276795!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS at: #onmessage put: [:message |				| data |								data := message data.								JS postMessage: {					#result -> (						(data receiver)							perform: data selector asSymbol							withArguments: {data argument})}].			[				(Delay forSeconds: 5) wait.				(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate]			]				forkAt: Processor timingPriority].		Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----SNAPSHOT----{24 September 2019 . 11:36:49 am} caffeine.image priorSource: 1722926!!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 11:55' prior: 35272013!startUp: resuming	"After a system resumption, if the system is being run by SqueakJS in a web browser, reset constants related to that web browser's JavaScript environment."	| forceToScreen |	resuming ifTrue: [		(self == Webpage)			ifTrue: [				Fullscreen := false.								Top := TopDocument := ContainingDiv := ContainingCanvas := ContainingFrame := Current := Options := nil.				Preferences					setPreference: #fastDragWindowForMorphic					toValue: JS isConnected.				JS ifConnected: [					| url |					JS ifHeadless: [^self].					Top := [JS top counterpart magicWindow] on: Error do: [:exception | JS].					url := (						Top							ifNil: [String randomOfLength: 5]							ifNotNil: [								TopDocument := Top document.								Url absoluteFromText: Top location href asString]).					Options := (						(JS SqueakJS options at: #parameters)							ifNil: [nil]							ifNotNil: [JS SqueakJS options parameters counterpart]).												ContainingCanvas := JS document counterpart getElementById: 'squeak'.					[ContainingCanvas						at: #width put: Options width;						at: #height put: Options height] on: Error do: [:e | ].											Top ifNotNil: [ContainingFrame := Top document getElementById: #Caffeine].					ContainingCanvas ifNotNil: [						ContainingDiv := (							ContainingFrame								ifNil: [ContainingCanvas parentNode]								ifNotNil: [									self styleAt: #transition put: 'opacity 500ms'.									ContainingFrame parentNode parentNode]).						ContainingDiv at: #onresize put: [self resize].						ContainingCanvas at: #tabIndex put: 0.						self captureCurrentExtent.						ContainingCanvas onclick: [self focus]].										forceToScreen := [:event | Display forceToScreen].					Top						at: #onresize						put: forceToScreen; 						at: #onscroll						put: forceToScreen;						at: #onorientationchange						put: [:event |							forceToScreen value: event.							self scrollToTop].															ContainingCanvas ifNotNil: [						ContainingCanvas							styleAt: 'user-select'							put: [false]].					Pages						at: url						ifAbsent: [							self								ifOptionAt: 'appID'								then: [:appID |									| appClass |																		appClass := self allSubclasses detect: [:subclass | subclass appID = appID] ifNone: [nil].									appClass										ifNil: [nil]										ifNotNil: [											Pages												at: url												put: (appClass fromURL: url)]]								else: [nil]]]]]! !----SNAPSHOT----{24 September 2019 . 11:55:24 am} caffeine.image priorSource: 1723718!!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 11:58'!workerSource	^'/* * Copyright (c) 2013-2016 Bert Freudenberg * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. */// Set up an environment for running the SqueakJS VM headlessly in a Web Worker."use strict";//////////////////////////////////////////////////////////////////////////////// these functions fake the Lively module and class system// just enough so the loading of vm.js succeeds//////////////////////////////////////////////////////////////////////////////self.module = (function(dottedPath) {  if (dottedPath === "") return this;  var path = dottedPath.split("."),      name = path.pop(),      parent = module(path.join(".")),      self = parent[name];  if (!!self) parent[name] = self = {    loaded: false,    pending: [],    requires: function(req) {      return {        toRun: function(code) {          function load() {            code();            self.loaded = true;            self.pending.forEach(function(f){f();});          }          if (req && !!module(req).loaded) {            module(req).pending.push(load);          } else {            load();          }        }      };    },  };  return self;}).bind(self);module.bindObject.extend = function(obj /* + more args */ ) {  // skip arg 0, copy properties of other args to obj  for (var i = 1; i < arguments.length; i++)    if (typeof arguments[i] == ''object'')      for (var name in arguments[i])        obj[name] = arguments[i][name];};Function.prototype.subclass = function(classPath /* + more args */ ) {  // create subclass  var subclass = function() {    if (this.initialize) this.initialize.apply(this, arguments);    return this;  };  // set up prototype  var protoclass = function() { };  protoclass.prototype = this.prototype;  subclass.prototype = new protoclass();  // skip arg 0, copy properties of other args to prototype  for (var i = 1; i < arguments.length; i++)    Object.extend(subclass.prototype, arguments[i]);  // add class to module  var modulePath = classPath.split("."),      className = modulePath.pop();  module(modulePath.join(''.''))[className] = subclass;  return subclass;};//////////////////////////////////////////////////////////////////////////////// load vm, plugins, and other libraries//////////////////////////////////////////////////////////////////////////////(function(){  var vmDir,      toLoad;    vmDir = ''http://localhost/js/squeakjs/'';  self.importScripts(    "http://localhost/js/squeakjs/jit.js",    "http://localhost/js/squeakjs/plugins/FloatArrayPlugin.js",    "http://localhost/js/squeakjs/plugins/Flow.js",    "http://localhost/js/squeakjs/plugins/LargeIntegers.js",    "http://localhost/js/squeakjs/plugins/Matrix2x3Plugin.js",    "http://localhost/js/squeakjs/plugins/MiscPrimitivePlugin.js",    "http://localhost/js/squeakjs/plugins/StarSqueakPlugin.js",    "http://localhost/js/squeakjs/plugins/ZipPlugin.js",    "http://localhost/js/squeakjs/lib/lz-string.js",    "http://localhost/js/squeakjs/lib/jszip.js",    "http://localhost/js/squeakjs/lib/FileSaver.js",    "http://localhost/js/squeakjs/vm.js");})();module("SqueakJS").requires("users.bert.SqueakJS.vm").toRun(function() {  // if in private mode set localStorage to a regular dict  var localStorage = self.localStorage;  try {    localStorage["squeak-foo:"] = "bar";    if (localStorage["squeak-foo:"] !!== "bar") throw Error();    delete localStorage["squeak-foo:"];  } catch(e) {    localStorage = {};  }  //////////////////////////////////////////////////////////////////////////////  // main loop  //////////////////////////////////////////////////////////////////////////////  var loop; // holds timeout for main loop  SqueakJS.runImage = function(buffer, name, options) {    self.onbeforeunload = function(evt) {      var msg = SqueakJS.appName + " is still running";      evt.returnValue = msg;      return msg;    };    self.clearTimeout(loop);    self.setTimeout(function readImageAsync() {      var image = new Squeak.Image(name);	image.window = self;      image.readFromBuffer(buffer, function startRunning() {	self.quitFlag = false;        var vm = new Squeak.Interpreter(image, null);        SqueakJS.vm = vm;        localStorage["squeakImageName"] = name;        function run() {          try {            if (self.quitFlag) self.onQuit(vm, null, options);            else if (!!(self.suspend)) {	      vm.interpret(50, function runAgain(ms) {                if (ms == "sleep") ms = 200;                loop = self.setTimeout(run, ms);              })};          } catch(error) {            console.error(error);	    loop = self.setTimeout(run, 200);          }        }        self.runNow = function() {          self.clearTimeout(loop);          run();        };        self.runFor = function(milliseconds) {          var stoptime = Date.now() + milliseconds;          do {            if (self.quitFlag) return;            self.runNow();          } while (Date.now() < stoptime);        };        run();      },			   function readProgress(value) {});    }, 0);  };  function processOptions(options) {    var search = (location.hash || location.search).slice(1),        args = search && search.split("&");    if (args) for (var i = 0; i < args.length; i++) {      var keyAndVal = args[i].split("="),          key = keyAndVal[0],          val = true;      if (keyAndVal.length > 1) {        val = decodeURIComponent(keyAndVal.slice(1).join("="));        if (val.match(/^(true|false|null|[0-9"[{].*)$/))          try { val = JSON.parse(val); } catch(e) {            if (val[0] === "[") val = val.slice(1,-1).split(","); // handle string arrays            // if not JSON use string itself          }      }      options[key] = val;    }    var root = Squeak.splitFilePath(options.root || "/").fullname;    Squeak.dirCreate(root, true);    if (!!/\/$/.test(root)) root += "/";    options.root = root;    SqueakJS.options = options;  }  function fetchTemplates(options) {    if (options.templates) {      if (options.templates.constructor === Array) {        var templates = {};        options.templates.forEach(function(path){ templates[path] = path; });        options.templates = templates;      }      for (var path in options.templates) {        var dir = path[0] == "/" ? path : options.root + path,            url = Squeak.splitUrl(options.templates[path], options.url).full;        Squeak.fetchTemplateDir(dir, url);      }    }  }  function processFile(file, options, thenDo) {    Squeak.filePut(options.root + file.name, file.data, function() {      console.log("Stored " + options.root + file.name);      if (file.zip) {        processZip(file, options, thenDo);      } else {        thenDo();      }    });  }  function processZip(file, options, thenDo) {    JSZip().loadAsync(file.data).then(function(zip) {      var todo = [];      zip.forEach(function(filename){        if (!!options.image.name && filename.match(/\.image$/))          options.image.name = filename;        if (options.forceDownload || !!Squeak.fileExists(options.root + filename)) {          todo.push(filename);        } else if (options.image.name === filename) {          // image exists, need to fetch it from storage          var _thenDo = thenDo;          thenDo = function() {            Squeak.fileGet(options.root + filename, function(data) {              options.image.data = data;              return _thenDo();            }, function onError() {              Squeak.fileDelete(options.root + file.name);              return processZip(file, options, _thenDo);            });          }        }      });      if (todo.length === 0) return thenDo();      var done = 0;      todo.forEach(function(filename){        console.log("Inflating " + file.name + ": " + filename);        function progress(x) {}        zip.file(filename).async("arraybuffer", progress).then(function(buffer){          console.log("Expanded size of " + filename + ": " + buffer.byteLength);          var unzipped = {};          if (options.image.name === filename)            unzipped = options.image;          unzipped.name = filename;          unzipped.data = buffer;          processFile(unzipped, options, function() {            if (++done === todo.length) thenDo();          });        });      });    });  }  function checkExisting(file, options, ifExists, ifNotExists) {    if (!!Squeak.fileExists(options.root + file.name))      return ifNotExists();    if (file.image || file.zip) {      // if it''s the image or a zip, load from file storage      Squeak.fileGet(options.root + file.name, function(data) {        file.data = data;        if (file.zip) processZip(file, options, ifExists);        else ifExists();      }, function onError() {        // if error, download it        Squeak.fileDelete(options.root + file.name);        return ifNotExists();      });    } else {      // for all other files assume they''re okay      ifExists();    }  }  function downloadFile(file, options, thenDo) {    console.log("downloading " + file.name + "...");    var rq = new XMLHttpRequest(),        proxy = options.proxy || "";    rq.open(''GET'', proxy + file.url);    if (options.ajax) rq.setRequestHeader("X-Requested-With", "XMLHttpRequest");    rq.responseType = ''arraybuffer'';    rq.onprogress = function(e) {    };    rq.onload = function(e) {      if (this.status == 200) {        file.data = this.response;        processFile(file, options, thenDo);      }      else this.onerror(this.statusText);    };    rq.onerror = function(e) {      if (options.proxy) return alert("Failed to download:\n" + file.url);      console.warn(''Retrying with CORS proxy: '' + file.url);      var proxy = ''https://crossorigin.me/'',          retry = new XMLHttpRequest();      retry.open(''GET'', proxy + file.url);      if (options.ajax) retry.setRequestHeader("X-Requested-With", "XMLHttpRequest");      retry.responseType = rq.responseType;      retry.onprogress = rq.onprogress;      retry.onload = rq.onload;      retry.onerror = function() {alert("Failed to download:\n" + file.url)};      retry.send();    };    rq.send();  }  function fetchFiles(files, options, thenDo) {    // check if files exist locally and download if nessecary    function getNextFile() {      if (files.length === 0)        return thenDo();      var file = files.shift(),          forceDownload = options.forceDownload || file.forceDownload;      if (forceDownload) downloadFile(file, options, getNextFile);      else checkExisting(file, options,			 function ifExists() {			   getNextFile();			 },			 function ifNotExists() {			   downloadFile(file, options, getNextFile);			 });    }    getNextFile();  }  SqueakJS.runSqueak = function(imageUrl, options) {    // we need to fetch all files first, then run the image    processOptions(options);    if (!!imageUrl && options.image) imageUrl = options.image;    var baseUrl = options.url || (imageUrl && imageUrl.replace(/[^\/]*$/, "")) || "";    options.url = baseUrl;    fetchTemplates(options);    var image = {url: null, name: null, image: true, data: null},        files = [];    if (imageUrl) {      var url = Squeak.splitUrl(imageUrl, baseUrl);      image.url = url.full;      image.name = url.filename;    }    if (options.files) {      options.files.forEach(function(f) {        var url = Squeak.splitUrl(f, baseUrl);        if (image.name === url.filename) {/* pushed after other files */}        else if (!!image.url && f.match(/\.image$/)) {          image.name = url.filename;          image.url = url.full;        } else {          files.push({url: url.full, name: url.filename});        }      });    }    if (!!Squeak.fileExists(options.root + image.name)) {      // If the image file exists, assume there''s no need to check the zips.      if (options.zip) {        var zips = typeof options.zip === "string" ? [options.zip] : options.zip;        zips.forEach(function(zip) {          var url = Squeak.splitUrl(zip, baseUrl);          files.push({url: url.full, name: url.filename, zip: true});        });      }}    if (image.url) files.push(image);    if (options.document) {      var url = Squeak.splitUrl(options.document, baseUrl);      files.push({url: url.full, name: url.filename, forceDownload: options.forceDownload !!== false});    }    options.image = image;    fetchFiles(files, options, function thenDo() {      Squeak.fsck();      var image = options.image;      if (!!image.name) return console.log("could not find an image");      if (!!image.data) {	console.log("could not find image " + image.name);	document.location.reload();	return}      SqueakJS.appName = options.appName || image.name.replace(/\.image$/, "");      SqueakJS.runImage(image.data, options.root + image.name, options);    });    return self;  };  SqueakJS.quitSqueak = function() {    SqueakJS.vm.quitFlag = true;  };  SqueakJS.onQuit = function(vm, options) {    self.onbeforeunload = null;    if (options.onQuit) options.onQuit(vm, options);  };}); // end module//////////////////////////////////////////////////////////////////////////////// browser stuff//////////////////////////////////////////////////////////////////////////////if (self.applicationCache) {  applicationCache.addEventListener(''updateready'', function() {    // use original appName from options    var appName = self.SqueakJS && SqueakJS.options && SqueakJS.options.appName || "SqueakJS";    self.onbeforeunload = null;    self.location.reload();  });}SqueakJS.runSqueak(''caffeine.image'', {zip: ["http://localhost/memories/caffeine.zip", "http://localhost/sources/SqueakV46.sources.zip"]});'! !!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 12:30' prior: 35277547!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS at: #onmessage put: [:message |				| data |								data := message data.								JS postMessage: {					#result -> (						(data receiver)							perform: data selector asSymbol							withArguments: data arguments)}].			[				(Delay forSeconds: 5) wait.				(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate]			]				forkAt: Processor timingPriority].		Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 12:37' prior: 35295995!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS				at: #onmessage				put: [:message |					JS postMessage: {#result -> Compiler evaluate: message data expression}].							[				(Delay forSeconds: 5) wait.				(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate]			]				forkAt: Processor timingPriority].		Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----SNAPSHOT----{24 September 2019 . 12:37:15 pm} caffeine.image priorSource: 1726387!Compiler!Compiler evaluate: '3 + 4'!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 13:03' prior: 35296698!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS				at: #onmessage				put: [:message |					JS postMessage: {#result -> (Compiler evaluate: message data expression)}].							[				(Delay forSeconds: 5) wait.				(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate]			]				forkAt: Processor timingPriority].		Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----SNAPSHOT----{24 September 2019 . 1:03:40 pm} caffeine.image priorSource: 1742769!Event subclass: #MessageEvent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Hex-HTML5-DOM'!----SNAPSHOT----{24 September 2019 . 1:17:14 pm} caffeine.image priorSource: 1743503!Tether class removeSelector: #fusedClasses!Tether class removeSelector: #nonEssentialProcessLabels!Tether class removeSelector: #fusedMethods!Tether class removeSelector: #fusedClassHierarchyRoots!Tether class removeSelector: #frozenClassHierarchyRoots!Tether class removeSelector: #finalRemovedClassNames!----SNAPSHOT----{24 September 2019 . 1:22:27 pm} caffeine.image priorSource: 1743722!Portal subclass: #DirectMessagePortal	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Wormhole'!Smalltalk renameClassNamed: #DirectMessagePortal as: #WorkerPortal!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 13:59' prior: 35297430!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			| tether portal |						portal := WorkerPortal new.			tether := Tether through: portal.						JS				at: #onmessage				put: [:message |					portal incomingMessage: message.					tether handleEvent].							[				(Delay forSeconds: 5) wait.				(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate]			]				forkAt: Processor timingPriority].		Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----SNAPSHOT----{24 September 2019 . 1:59:36 pm} caffeine.image priorSource: 1744127!!WorkerPortal methodsFor: 'no messages' stamp: 'crl 9/24/2019 14:01'!isExit	^false! !----SNAPSHOT----{24 September 2019 . 2:01:38 pm} caffeine.image priorSource: 1745104!!WorkerPortal methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 14:04'!send	"Send the contents of the current outgoing message."	JS postMessage: self outgoingPayload! !----SNAPSHOT----{24 September 2019 . 2:04:30 pm} caffeine.image priorSource: 1745279!Tether removeSelector: #exposedAProcessAt:!Entrance subclass: #WorkerPortal	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Wormhole'!WorkerPortal removeSelector: #isExit!Entrance class removeSelector: #to:for:!!WorkerPortal methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 14:16'!connectTo: url	self shouldNotImplement! !!WorkerPortal methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 14:16'!isOpen	"Answer whether my websocket is open."	^true! !!WorkerPortal methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 14:16'!onClose: aBlockClosure	"Install aBlockClosure as a callback that my websocket should trigger when it closes."	self shouldNotImplement! !!WorkerPortal methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 14:17'!onError: aBlockClosure	"Install aBlockClosure as a callback that my websocket should trigger when it encounters an error."	3 halt! !!WorkerPortal methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 14:18'!onMessage: block	self shouldNotImplement! !!WorkerPortal methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 14:18'!onOpen: aBlockClosure	self shouldNotImplement! !!WorkerPortal methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 14:19'!readyState	"Answer my websocket's readyState (see the WebSocket RFC)."	^self shouldNotImplement! !Smalltalk renameClassNamed: #WorkerPortal as: #WorkerEntrance!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 14:19' prior: 35298951!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			| tether portal |						portal := WorkerEntrance new.			tether := Tether through: portal.						JS				at: #onmessage				put: [:message |					portal incomingMessage: message.					tether handleEvent].							[				(Delay forSeconds: 5) wait.				(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate]			]				forkAt: Processor timingPriority].		Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----SNAPSHOT----{24 September 2019 . 2:19:42 pm} caffeine.image priorSource: 1745545!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 14:23' prior: 35301605!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			| tether portal connected |						portal := WorkerEntrance new.			tether := Tether through: portal.						JS				at: #onmessage				put: [:message |					portal incomingMessage: message.					tether handleEvent].						tether waitForPeer.			connected := tether peer ping.			[				(Delay forSeconds: 5) wait.				(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate]			]				forkAt: Processor timingPriority].		Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----SNAPSHOT----{24 September 2019 . 2:23:37 pm} caffeine.image priorSource: 1747760!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 14:44' prior: 35302380!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS ifHeadless: [				| tether portal connected |							portal := WorkerEntrance new.				tether := Tether through: portal.							JS					at: #onmessage					put: [:message |						portal incomingMessage: message.						tether handleEvent].							tether waitForPeer.				connected := tether peer ping.				[					(Delay forSeconds: 5) wait.					(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate]				]					forkAt: Processor timingPriority]].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !Exit subclass: #WorkerExit	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Wormhole'!!WorkerExit methodsFor: 'no messages' stamp: 'crl 9/24/2019 14:45'!onClose: aBlockClosure	self shouldNotImplement! !!WorkerExit methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 14:45'!onError: aBlockClosure	self shouldNotImplement! !!WorkerExit methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 14:45'!onMessage: aBlockClosure	self shouldNotImplement! !!WorkerExit methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 14:46'!run	self shouldNotImplement! !!WorkerExit methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 14:46'!websocket: aWebSocket	self shouldNotImplement! !----SNAPSHOT----{24 September 2019 . 2:46:36 pm} caffeine.image priorSource: 1748602!Classes!#[137 204 79 205] inject: 0 into: [:total :next | (total bitShift: 8) + next]!#[137 204 79 205] reverse inject: 0 into: [:total :next | (total bitShift: 8) + next]!Classes!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 15:32' prior: 34846911!handleEvent	(peer recyclingHash = 0)		ifTrue: [			peer := self next..			portal isExit ifFalse: [self push: self].			peerSet signal]		ifFalse: [			| nextWord handler |						JS at: #recyclingHash put: peer recyclingHash.			JS debugger.						nextWord := portal nextWord.			handler := Classes at: nextWord ifAbsent: [3 halt].			handler				ifNil: [3 halt]				ifNotNil: [handler handleEventFrom: self]]! !----SNAPSHOT----{24 September 2019 . 3:33:12 pm} caffeine.image priorSource: 1750217!#[193 204 198 198] inject: 0 into: [:total :next | (total bitShift: 8) + next]!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 15:40' prior: 35305013!handleEvent	(peer recyclingHash = 0)		ifTrue: [			peer := self next..			portal isExit ifFalse: [self push: self].			peerSet signal]		ifFalse: [			| nextWord handler |						nextWord := portal nextWord.			handler := Classes at: nextWord ifAbsent: [3 halt].			handler				ifNil: [3 halt]				ifNotNil: [handler handleEventFrom: self]]! !SmalltalkImage classPool at: #StartUpList !!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 15:41' prior: 33671343!initialize	"Initialize myself."	"I don't recall exactly what the platform system attributes are on the non-win32 platforms."	Platforms := (		(Dictionary new)			at: 'Win32' put: Win32;			at: 'Mac OS' put: Macintosh;			at: 'unix' put: Unix;			at: 'Web' put: Web;			yourself).	Smalltalk addToStartUpList: self after: ExternalResource	"Interpreter afterResumingNotify: self"! !SmalltalkImage classPool at: #StartUpList !self add: HostPlatform!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 15:44' prior: 35303222!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS ifHeadless: [				| tether portal connected |							portal := WorkerEntrance new.				tether := Tether through: portal.							JS					at: #onmessage					put: [:message |						portal incomingMessage: message.						tether handleEvent].							tether waitForPeer.				connected := tether peer ping.				Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.				[(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate]] forkAt: Processor timingPriority]].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----SNAPSHOT----{24 September 2019 . 3:44:22 pm} caffeine.image priorSource: 1750996!Exit subclass: #WorkerExit	instanceVariableNames: 'worker'	classVariableNames: ''	poolDictionaries: ''	category: 'Wormhole'!Exit subclass: #WorkerExit	instanceVariableNames: 'worker'	classVariableNames: ''	poolDictionaries: ''	category: 'Wormhole'!!WorkerExit methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 15:49' prior: 35304363!onMessage: aBlockClosure	worker at: #onmessage put: aBlockClosure! !!WorkerExit methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 15:49'!printOn: stream	stream		nextPut: self class printString article;		space;		print: self class! !!WorkerExit methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 15:50'!send	worker postMessage: self outgoingPayload! !!WorkerExit methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 15:50'!terminate	worker terminate! !!WorkerExit methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 15:50'!worker: aWorker	worker := aWorker! !!WorkerExit class methodsFor: 'no messages' stamp: 'crl 9/24/2019 15:50'!new	^Exits add: super new! !!WorkerExit class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 15:54'!start	| exit client |		exit := (		(self new)			worker: (				(Worker genesisFunction)					call: nil					with: self workerSource);			yourself).				(Delay forSeconds: 8) wait.		client := Tether through: exit.	client push: client! !!WorkerExit class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 15:54'!workerSource	^'/* * Copyright (c) 2013-2016 Bert Freudenberg * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. */// Set up an environment for running the SqueakJS VM headlessly in a Web Worker."use strict";//////////////////////////////////////////////////////////////////////////////// these functions fake the Lively module and class system// just enough so the loading of vm.js succeeds//////////////////////////////////////////////////////////////////////////////self.module = (function(dottedPath) {  if (dottedPath === "") return this;  var path = dottedPath.split("."),      name = path.pop(),      parent = module(path.join(".")),      self = parent[name];  if (!!self) parent[name] = self = {    loaded: false,    pending: [],    requires: function(req) {      return {        toRun: function(code) {          function load() {            code();            self.loaded = true;            self.pending.forEach(function(f){f();});          }          if (req && !!module(req).loaded) {            module(req).pending.push(load);          } else {            load();          }        }      };    },  };  return self;}).bind(self);module.bindObject.extend = function(obj /* + more args */ ) {  // skip arg 0, copy properties of other args to obj  for (var i = 1; i < arguments.length; i++)    if (typeof arguments[i] == ''object'')      for (var name in arguments[i])        obj[name] = arguments[i][name];};Function.prototype.subclass = function(classPath /* + more args */ ) {  // create subclass  var subclass = function() {    if (this.initialize) this.initialize.apply(this, arguments);    return this;  };  // set up prototype  var protoclass = function() { };  protoclass.prototype = this.prototype;  subclass.prototype = new protoclass();  // skip arg 0, copy properties of other args to prototype  for (var i = 1; i < arguments.length; i++)    Object.extend(subclass.prototype, arguments[i]);  // add class to module  var modulePath = classPath.split("."),      className = modulePath.pop();  module(modulePath.join(''.''))[className] = subclass;  return subclass;};//////////////////////////////////////////////////////////////////////////////// load vm, plugins, and other libraries//////////////////////////////////////////////////////////////////////////////(function(){  var vmDir,      toLoad;    vmDir = ''http://localhost/js/squeakjs/'';  self.importScripts(    "http://localhost/js/squeakjs/jit.js",    "http://localhost/js/squeakjs/plugins/FloatArrayPlugin.js",    "http://localhost/js/squeakjs/plugins/Flow.js",    "http://localhost/js/squeakjs/plugins/LargeIntegers.js",    "http://localhost/js/squeakjs/plugins/Matrix2x3Plugin.js",    "http://localhost/js/squeakjs/plugins/MiscPrimitivePlugin.js",    "http://localhost/js/squeakjs/plugins/StarSqueakPlugin.js",    "http://localhost/js/squeakjs/plugins/ZipPlugin.js",    "http://localhost/js/squeakjs/lib/lz-string.js",    "http://localhost/js/squeakjs/lib/jszip.js",    "http://localhost/js/squeakjs/lib/FileSaver.js",    "http://localhost/js/squeakjs/vm.js");})();module("SqueakJS").requires("users.bert.SqueakJS.vm").toRun(function() {  // if in private mode set localStorage to a regular dict  var localStorage = self.localStorage;  try {    localStorage["squeak-foo:"] = "bar";    if (localStorage["squeak-foo:"] !!== "bar") throw Error();    delete localStorage["squeak-foo:"];  } catch(e) {    localStorage = {};  }  //////////////////////////////////////////////////////////////////////////////  // main loop  //////////////////////////////////////////////////////////////////////////////  var loop; // holds timeout for main loop  SqueakJS.runImage = function(buffer, name, options) {    self.onbeforeunload = function(evt) {      var msg = SqueakJS.appName + " is still running";      evt.returnValue = msg;      return msg;    };    self.clearTimeout(loop);    self.setTimeout(function readImageAsync() {      var image = new Squeak.Image(name);	image.window = self;      image.readFromBuffer(buffer, function startRunning() {	self.quitFlag = false;        var vm = new Squeak.Interpreter(image, null);        SqueakJS.vm = vm;        localStorage["squeakImageName"] = name;        function run() {          try {            if (self.quitFlag) self.onQuit(vm, null, options);            else if (!!(self.suspend)) {	      vm.interpret(50, function runAgain(ms) {                if (ms == "sleep") ms = 200;                loop = self.setTimeout(run, ms);              })};          } catch(error) {            console.error(error);	    loop = self.setTimeout(run, 200);          }        }        self.runNow = function() {          self.clearTimeout(loop);          run();        };        self.runFor = function(milliseconds) {          var stoptime = Date.now() + milliseconds;          do {            if (self.quitFlag) return;            self.runNow();          } while (Date.now() < stoptime);        };        run();      },			   function readProgress(value) {});    }, 0);  };  function processOptions(options) {    var search = (location.hash || location.search).slice(1),        args = search && search.split("&");    if (args) for (var i = 0; i < args.length; i++) {      var keyAndVal = args[i].split("="),          key = keyAndVal[0],          val = true;      if (keyAndVal.length > 1) {        val = decodeURIComponent(keyAndVal.slice(1).join("="));        if (val.match(/^(true|false|null|[0-9"[{].*)$/))          try { val = JSON.parse(val); } catch(e) {            if (val[0] === "[") val = val.slice(1,-1).split(","); // handle string arrays            // if not JSON use string itself          }      }      options[key] = val;    }    var root = Squeak.splitFilePath(options.root || "/").fullname;    Squeak.dirCreate(root, true);    if (!!/\/$/.test(root)) root += "/";    options.root = root;    SqueakJS.options = options;  }  function fetchTemplates(options) {    if (options.templates) {      if (options.templates.constructor === Array) {        var templates = {};        options.templates.forEach(function(path){ templates[path] = path; });        options.templates = templates;      }      for (var path in options.templates) {        var dir = path[0] == "/" ? path : options.root + path,            url = Squeak.splitUrl(options.templates[path], options.url).full;        Squeak.fetchTemplateDir(dir, url);      }    }  }  function processFile(file, options, thenDo) {    Squeak.filePut(options.root + file.name, file.data, function() {      console.log("Stored " + options.root + file.name);      if (file.zip) {        processZip(file, options, thenDo);      } else {        thenDo();      }    });  }  function processZip(file, options, thenDo) {    JSZip().loadAsync(file.data).then(function(zip) {      var todo = [];      zip.forEach(function(filename){        if (!!options.image.name && filename.match(/\.image$/))          options.image.name = filename;        if (options.forceDownload || !!Squeak.fileExists(options.root + filename)) {          todo.push(filename);        } else if (options.image.name === filename) {          // image exists, need to fetch it from storage          var _thenDo = thenDo;          thenDo = function() {            Squeak.fileGet(options.root + filename, function(data) {              options.image.data = data;              return _thenDo();            }, function onError() {              Squeak.fileDelete(options.root + file.name);              return processZip(file, options, _thenDo);            });          }        }      });      if (todo.length === 0) return thenDo();      var done = 0;      todo.forEach(function(filename){        console.log("Inflating " + file.name + ": " + filename);        function progress(x) {}        zip.file(filename).async("arraybuffer", progress).then(function(buffer){          console.log("Expanded size of " + filename + ": " + buffer.byteLength);          var unzipped = {};          if (options.image.name === filename)            unzipped = options.image;          unzipped.name = filename;          unzipped.data = buffer;          processFile(unzipped, options, function() {            if (++done === todo.length) thenDo();          });        });      });    });  }  function checkExisting(file, options, ifExists, ifNotExists) {    if (!!Squeak.fileExists(options.root + file.name))      return ifNotExists();    if (file.image || file.zip) {      // if it''s the image or a zip, load from file storage      Squeak.fileGet(options.root + file.name, function(data) {        file.data = data;        if (file.zip) processZip(file, options, ifExists);        else ifExists();      }, function onError() {        // if error, download it        Squeak.fileDelete(options.root + file.name);        return ifNotExists();      });    } else {      // for all other files assume they''re okay      ifExists();    }  }  function downloadFile(file, options, thenDo) {    console.log("downloading " + file.name + "...");    var rq = new XMLHttpRequest(),        proxy = options.proxy || "";    rq.open(''GET'', proxy + file.url);    if (options.ajax) rq.setRequestHeader("X-Requested-With", "XMLHttpRequest");    rq.responseType = ''arraybuffer'';    rq.onprogress = function(e) {    };    rq.onload = function(e) {      if (this.status == 200) {        file.data = this.response;        processFile(file, options, thenDo);      }      else this.onerror(this.statusText);    };    rq.onerror = function(e) {      if (options.proxy) return alert("Failed to download:\n" + file.url);      console.warn(''Retrying with CORS proxy: '' + file.url);      var proxy = ''https://crossorigin.me/'',          retry = new XMLHttpRequest();      retry.open(''GET'', proxy + file.url);      if (options.ajax) retry.setRequestHeader("X-Requested-With", "XMLHttpRequest");      retry.responseType = rq.responseType;      retry.onprogress = rq.onprogress;      retry.onload = rq.onload;      retry.onerror = function() {alert("Failed to download:\n" + file.url)};      retry.send();    };    rq.send();  }  function fetchFiles(files, options, thenDo) {    // check if files exist locally and download if nessecary    function getNextFile() {      if (files.length === 0)        return thenDo();      var file = files.shift(),          forceDownload = options.forceDownload || file.forceDownload;      if (forceDownload) downloadFile(file, options, getNextFile);      else checkExisting(file, options,			 function ifExists() {			   getNextFile();			 },			 function ifNotExists() {			   downloadFile(file, options, getNextFile);			 });    }    getNextFile();  }  SqueakJS.runSqueak = function(imageUrl, options) {    // we need to fetch all files first, then run the image    processOptions(options);    if (!!imageUrl && options.image) imageUrl = options.image;    var baseUrl = options.url || (imageUrl && imageUrl.replace(/[^\/]*$/, "")) || "";    options.url = baseUrl;    fetchTemplates(options);    var image = {url: null, name: null, image: true, data: null},        files = [];    if (imageUrl) {      var url = Squeak.splitUrl(imageUrl, baseUrl);      image.url = url.full;      image.name = url.filename;    }    if (options.files) {      options.files.forEach(function(f) {        var url = Squeak.splitUrl(f, baseUrl);        if (image.name === url.filename) {/* pushed after other files */}        else if (!!image.url && f.match(/\.image$/)) {          image.name = url.filename;          image.url = url.full;        } else {          files.push({url: url.full, name: url.filename});        }      });    }    if (!!Squeak.fileExists(options.root + image.name)) {      // If the image file exists, assume there''s no need to check the zips.      if (options.zip) {        var zips = typeof options.zip === "string" ? [options.zip] : options.zip;        zips.forEach(function(zip) {          var url = Squeak.splitUrl(zip, baseUrl);          files.push({url: url.full, name: url.filename, zip: true});        });      }}    if (image.url) files.push(image);    if (options.document) {      var url = Squeak.splitUrl(options.document, baseUrl);      files.push({url: url.full, name: url.filename, forceDownload: options.forceDownload !!== false});    }    options.image = image;    fetchFiles(files, options, function thenDo() {      Squeak.fsck();      var image = options.image;      if (!!image.name) return console.log("could not find an image");      if (!!image.data) {	console.log("could not find image " + image.name);	document.location.reload();	return}      SqueakJS.appName = options.appName || image.name.replace(/\.image$/, "");      SqueakJS.runImage(image.data, options.root + image.name, options);    });    return self;  };  SqueakJS.quitSqueak = function() {    SqueakJS.vm.quitFlag = true;  };  SqueakJS.onQuit = function(vm, options) {    self.onbeforeunload = null;    if (options.onQuit) options.onQuit(vm, options);  };}); // end module//////////////////////////////////////////////////////////////////////////////// browser stuff//////////////////////////////////////////////////////////////////////////////if (self.applicationCache) {  applicationCache.addEventListener(''updateready'', function() {    // use original appName from options    var appName = self.SqueakJS && SqueakJS.options && SqueakJS.options.appName || "SqueakJS";    self.onbeforeunload = null;    self.location.reload();  });}SqueakJS.runSqueak(''caffeine.image'', {zip: ["http://localhost/memories/caffeine.zip", "http://localhost/sources/SqueakV46.sources.zip"]});'! !Webpage class removeSelector: #workerSource!!WorkerExit class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 15:55' prior: 35308669!start	| exit client |		exit := (		(self new)			worker: (				(Worker genesisFunction)					call: nil					with: self workerSource);			yourself).				client := Tether through: exit.		exit onMessage: [:message |		exit incomingMessage: message.		client handleEvent].		(Delay forSeconds: 8) wait.		client push: client! !!WorkerExit class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 15:56' prior: 35308994!workerSource	^'/* * Copyright (c) 2013-2016 Bert Freudenberg * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. */// Set up an environment for running the SqueakJS VM headlessly in a Web Worker."use strict";//////////////////////////////////////////////////////////////////////////////// these functions fake the Lively module and class system// just enough so the loading of vm.js succeeds//////////////////////////////////////////////////////////////////////////////self.module = (function(dottedPath) {  if (dottedPath === "") return this;  var path = dottedPath.split("."),      name = path.pop(),      parent = module(path.join(".")),      self = parent[name];  if (!!self) parent[name] = self = {    loaded: false,    pending: [],    requires: function(req) {      return {        toRun: function(code) {          function load() {            code();            self.loaded = true;            self.pending.forEach(function(f){f();});          }          if (req && !!module(req).loaded) {            module(req).pending.push(load);          } else {            load();          }        }      };    },  };  return self;}).bind(self);module.bindObject.extend = function(obj /* + more args */ ) {  // skip arg 0, copy properties of other args to obj  for (var i = 1; i < arguments.length; i++)    if (typeof arguments[i] == ''object'')      for (var name in arguments[i])        obj[name] = arguments[i][name];};Function.prototype.subclass = function(classPath /* + more args */ ) {  // create subclass  var subclass = function() {    if (this.initialize) this.initialize.apply(this, arguments);    return this;  };  // set up prototype  var protoclass = function() { };  protoclass.prototype = this.prototype;  subclass.prototype = new protoclass();  // skip arg 0, copy properties of other args to prototype  for (var i = 1; i < arguments.length; i++)    Object.extend(subclass.prototype, arguments[i]);  // add class to module  var modulePath = classPath.split("."),      className = modulePath.pop();  module(modulePath.join(''.''))[className] = subclass;  return subclass;};//////////////////////////////////////////////////////////////////////////////// load vm, plugins, and other libraries//////////////////////////////////////////////////////////////////////////////(function(){  var vmDir,      toLoad;    vmDir = ''http://localhost/js/squeakjs/'';  self.importScripts(    "http://localhost/js/squeakjs/jit.js",    "http://localhost/js/squeakjs/plugins/FloatArrayPlugin.js",    "http://localhost/js/squeakjs/plugins/Flow.js",    "http://localhost/js/squeakjs/plugins/LargeIntegers.js",    "http://localhost/js/squeakjs/plugins/Matrix2x3Plugin.js",    "http://localhost/js/squeakjs/plugins/MiscPrimitivePlugin.js",    "http://localhost/js/squeakjs/plugins/StarSqueakPlugin.js",    "http://localhost/js/squeakjs/plugins/ZipPlugin.js",    "http://localhost/js/squeakjs/lib/lz-string.js",    "http://localhost/js/squeakjs/lib/jszip.js",    "http://localhost/js/squeakjs/lib/FileSaver.js",    "http://localhost/js/squeakjs/vm.js");})();module("SqueakJS").requires("users.bert.SqueakJS.vm").toRun(function() {  // if in private mode set localStorage to a regular dict  var localStorage = self.localStorage;  try {    localStorage["squeak-foo:"] = "bar";    if (localStorage["squeak-foo:"] !!== "bar") throw Error();    delete localStorage["squeak-foo:"];  } catch(e) {    localStorage = {};  }  //////////////////////////////////////////////////////////////////////////////  // main loop  //////////////////////////////////////////////////////////////////////////////  var loop; // holds timeout for main loop  SqueakJS.runImage = function(buffer, name, options) {    self.onbeforeunload = function(evt) {      var msg = SqueakJS.appName + " is still running";      evt.returnValue = msg;      return msg;    };    self.clearTimeout(loop);    self.setTimeout(function readImageAsync() {      var image = new Squeak.Image(name);	image.window = self;      image.readFromBuffer(buffer, function startRunning() {	self.quitFlag = false;        var vm = new Squeak.Interpreter(image, null);        SqueakJS.vm = vm;        localStorage["squeakImageName"] = name;        function run() {          try {            if (self.quitFlag) self.onQuit(vm, null, options);            else if (!!(self.suspend)) {	      vm.interpret(50, function runAgain(ms) {                if (ms == "sleep") ms = 200;                loop = self.setTimeout(run, ms);              })};          } catch(error) {            console.error(error);	    loop = self.setTimeout(run, 200);          }        }        self.runNow = function() {          self.clearTimeout(loop);          run();        };        self.runFor = function(milliseconds) {          var stoptime = Date.now() + milliseconds;          do {            if (self.quitFlag) return;            self.runNow();          } while (Date.now() < stoptime);        };        run();      },			   function readProgress(value) {});    }, 0);  };  function processOptions(options) {    var search = (location.hash || location.search).slice(1),        args = search && search.split("&");    if (args) for (var i = 0; i < args.length; i++) {      var keyAndVal = args[i].split("="),          key = keyAndVal[0],          val = true;      if (keyAndVal.length > 1) {        val = decodeURIComponent(keyAndVal.slice(1).join("="));        if (val.match(/^(true|false|null|[0-9"[{].*)$/))          try { val = JSON.parse(val); } catch(e) {            if (val[0] === "[") val = val.slice(1,-1).split(","); // handle string arrays            // if not JSON use string itself          }      }      options[key] = val;    }    var root = Squeak.splitFilePath(options.root || "/").fullname;    Squeak.dirCreate(root, true);    if (!!/\/$/.test(root)) root += "/";    options.root = root;    SqueakJS.options = options;  }  function fetchTemplates(options) {    if (options.templates) {      if (options.templates.constructor === Array) {        var templates = {};        options.templates.forEach(function(path){ templates[path] = path; });        options.templates = templates;      }      for (var path in options.templates) {        var dir = path[0] == "/" ? path : options.root + path,            url = Squeak.splitUrl(options.templates[path], options.url).full;        Squeak.fetchTemplateDir(dir, url);      }    }  }  function processFile(file, options, thenDo) {    Squeak.filePut(options.root + file.name, file.data, function() {      console.log("Stored " + options.root + file.name);      if (file.zip) {        processZip(file, options, thenDo);      } else {        thenDo();      }    });  }  function processZip(file, options, thenDo) {    JSZip().loadAsync(file.data).then(function(zip) {      var todo = [];      zip.forEach(function(filename){        if (!!options.image.name && filename.match(/\.image$/))          options.image.name = filename;        if (options.forceDownload || !!Squeak.fileExists(options.root + filename)) {          todo.push(filename);        } else if (options.image.name === filename) {          // image exists, need to fetch it from storage          var _thenDo = thenDo;          thenDo = function() {            Squeak.fileGet(options.root + filename, function(data) {              options.image.data = data;              return _thenDo();            }, function onError() {              Squeak.fileDelete(options.root + file.name);              return processZip(file, options, _thenDo);            });          }        }      });      if (todo.length === 0) return thenDo();      var done = 0;      todo.forEach(function(filename){        console.log("Inflating " + file.name + ": " + filename);        function progress(x) {}        zip.file(filename).async("arraybuffer", progress).then(function(buffer){          console.log("Expanded size of " + filename + ": " + buffer.byteLength);          var unzipped = {};          if (options.image.name === filename)            unzipped = options.image;          unzipped.name = filename;          unzipped.data = buffer;          processFile(unzipped, options, function() {            if (++done === todo.length) thenDo();          });        });      });    });  }  function checkExisting(file, options, ifExists, ifNotExists) {    if (!!Squeak.fileExists(options.root + file.name))      return ifNotExists();    if (file.image || file.zip) {      // if it''s the image or a zip, load from file storage      Squeak.fileGet(options.root + file.name, function(data) {        file.data = data;        if (file.zip) processZip(file, options, ifExists);        else ifExists();      }, function onError() {        // if error, download it        Squeak.fileDelete(options.root + file.name);        return ifNotExists();      });    } else {      // for all other files assume they''re okay      ifExists();    }  }  function downloadFile(file, options, thenDo) {    console.log("downloading " + file.name + "...");    var rq = new XMLHttpRequest(),        proxy = options.proxy || "";    rq.open(''GET'', proxy + file.url);    if (options.ajax) rq.setRequestHeader("X-Requested-With", "XMLHttpRequest");    rq.responseType = ''arraybuffer'';    rq.onprogress = function(e) {    };    rq.onload = function(e) {      if (this.status == 200) {        file.data = this.response;        processFile(file, options, thenDo);      }      else this.onerror(this.statusText);    };    rq.onerror = function(e) {      if (options.proxy) return alert("Failed to download:\n" + file.url);      console.warn(''Retrying with CORS proxy: '' + file.url);      var proxy = ''https://crossorigin.me/'',          retry = new XMLHttpRequest();      retry.open(''GET'', proxy + file.url);      if (options.ajax) retry.setRequestHeader("X-Requested-With", "XMLHttpRequest");      retry.responseType = rq.responseType;      retry.onprogress = rq.onprogress;      retry.onload = rq.onload;      retry.onerror = function() {alert("Failed to download:\n" + file.url)};      retry.send();    };    rq.send();  }  function fetchFiles(files, options, thenDo) {    // check if files exist locally and download if nessecary    function getNextFile() {      if (files.length === 0)        return thenDo();      var file = files.shift(),          forceDownload = options.forceDownload || file.forceDownload;      if (forceDownload) downloadFile(file, options, getNextFile);      else checkExisting(file, options,			 function ifExists() {			   getNextFile();			 },			 function ifNotExists() {			   downloadFile(file, options, getNextFile);			 });    }    getNextFile();  }  SqueakJS.runSqueak = function(imageUrl, options) {    // we need to fetch all files first, then run the image    processOptions(options);    if (!!imageUrl && options.image) imageUrl = options.image;    var baseUrl = options.url || (imageUrl && imageUrl.replace(/[^\/]*$/, "")) || "";    options.url = baseUrl;    fetchTemplates(options);    var image = {url: null, name: null, image: true, data: null},        files = [];    if (imageUrl) {      var url = Squeak.splitUrl(imageUrl, baseUrl);      image.url = url.full;      image.name = url.filename;    }    if (options.files) {      options.files.forEach(function(f) {        var url = Squeak.splitUrl(f, baseUrl);        if (image.name === url.filename) {/* pushed after other files */}        else if (!!image.url && f.match(/\.image$/)) {          image.name = url.filename;          image.url = url.full;        } else {          files.push({url: url.full, name: url.filename});        }      });    }    if (!!Squeak.fileExists(options.root + image.name)) {      // If the image file exists, assume there''s no need to check the zips.      if (options.zip) {        var zips = typeof options.zip === "string" ? [options.zip] : options.zip;        zips.forEach(function(zip) {          var url = Squeak.splitUrl(zip, baseUrl);          files.push({url: url.full, name: url.filename, zip: true});        });      }}    if (image.url) files.push(image);    if (options.document) {      var url = Squeak.splitUrl(options.document, baseUrl);      files.push({url: url.full, name: url.filename, forceDownload: options.forceDownload !!== false});    }    options.image = image;    fetchFiles(files, options, function thenDo() {      Squeak.fsck();      var image = options.image;      if (!!image.name) return console.log("could not find an image");      if (!!image.data) {	console.log("could not find image " + image.name);	document.location.reload();	return}      SqueakJS.appName = options.appName || image.name.replace(/\.image$/, "");      SqueakJS.runImage(image.data, options.root + image.name, options);    });    return self;  };  SqueakJS.quitSqueak = function() {    SqueakJS.vm.quitFlag = true;  };  SqueakJS.onQuit = function(vm, options) {    self.onbeforeunload = null;    if (options.onQuit) options.onQuit(vm, options);  };}); // end module//////////////////////////////////////////////////////////////////////////////// browser stuff//////////////////////////////////////////////////////////////////////////////if (self.applicationCache) {  applicationCache.addEventListener(''updateready'', function() {    // use original appName from options    var appName = self.SqueakJS && SqueakJS.options && SqueakJS.options.appName || "SqueakJS";    self.onbeforeunload = null;    self.location.reload();  });}SqueakJS.runSqueak(''headless.image'', {zip: ["http://localhost/memories/headless.zip", "http://localhost/sources/SqueakV46.sources.zip"]});'! !----SNAPSHOT----{24 September 2019 . 3:56:50 pm} caffeine.image priorSource: 1753019!----SNAPSHOT----{24 September 2019 . 3:57:07 pm} headless.image priorSource: 1784951!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 16:55'!snapshot	Webpage exportSnapshot! !----SNAPSHOT----{24 September 2019 . 4:55:50 pm} headless.image priorSource: 1785038!#[97 108 101 114 116 32 105 115 32 110 111 116 32 100 101 102 105 110 101 100] asString!!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 17:09' prior: 33997837!exportFile: filename	(		JS Function new: '			Squeak.fileGet(				''/', filename, ''',				function (buffer) {					var oReq = new XMLHttpRequest()					oReq.open(						''POST'',						''https://frankfurt.demo.blackpagedigital.com:8087/upload'',						true)					oReq.setRequestHeader(''filename'', ''', filename, ''')					oReq.onload = function (oEvent) {					}					oReq.send(buffer)})'			)		call! !!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 17:09' prior: 34001557!importFile: filename	(		JS Function new: '			var request = new XMLHttpRequest()						request.open(				''GET'',				''https://frankfurt.demo.blackpagedigital.com:8087/', filename, ''',				true)				request.responseType = ''blob''			request.onload = function (event) {				var blob = request.response								if (blob) {					var reader = new FileReader()							reader.onload = function () {						var buffer = this.result						console.log(							''Storing ', filename, ' ('' + buffer.byteLength + '' bytes)'')						Squeak.filePut(							''', filename, ''',							buffer,							function success() {								console.log(''', filename, ' written'')})}					reader.onerror = function() {						console.log(''Failed to read ', filename, '.'')}			 					reader.readAsArrayBuffer(blob)}}					request.send()'	)		call! !----SNAPSHOT----{24 September 2019 . 5:09:47 pm} headless.image priorSource: 1785233!'From Squeak 3.2 of 11 July 2002 [latest update: #4917] on 24 September 2019 at 5:18:04 pm'!Browser subclass: #OtherBrowser	instanceVariableNames: 'selectedClass module wormhole'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Browser'!Browser	subclass: #OtherBrowser	instanceVariableNames: 'selectedClass module wormhole '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Browser'!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 22:08'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 22:08'!addAllMethodsToCurrentChangeSet	self halt: 'nah'! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/5/2005 11:46'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/5/2005 11:46'!addCategory	"Present a choice of categories or prompt for a new category name and add it before the current selection, or at the end if no current selection"	| labels reject lines cats menuIndex oldIndex newName classOrMetaClassOrganizer |	self okToChange ifFalse: [^ self].	classListIndex = 0 ifTrue: [^ self].	labels _ OrderedCollection with: 'new...'.	reject _ Set new.	reject		addAll: self selectedClassOrMetaClass organization categories;		add: ClassOrganizer nullCategory;		add: ClassOrganizer default.	lines _ OrderedCollection new.	self selectedClassOrMetaClass allSuperclasses do: [:cls |		cls = Object ifFalse: [			cats _ cls organization categories reject:				 [:cat | reject includes: cat].			cats isEmpty ifFalse: [				lines add: labels size.				labels addAll: cats asSortedCollection.				reject addAll: cats]]].	newName _ (labels size = 1 or: [		menuIndex _ (PopUpMenu labelArray: labels lines: lines)		startUpWithCaption: 'Add Category'.		menuIndex = 0 ifTrue: [^ self].		menuIndex = 1])			ifTrue: [				self request: 'Please type new category name'					initialAnswer: 'category name']			ifFalse: [				labels at: menuIndex].	oldIndex _ messageCategoryListIndex.	newName isEmpty		ifTrue: [^ self]		ifFalse: [newName _ newName asSymbol].	classOrMetaClassOrganizer _ self remoteClassOrMetaClassOrganizer.	classOrMetaClassOrganizer		addCategory: newName		before: (messageCategoryListIndex = 0				ifTrue: [nil]				ifFalse: [self selectedMessageCategoryName]).	self changedWith: #messageCategoryList.	self messageCategoryListIndex:		(oldIndex = 0			ifTrue: [classOrMetaClassOrganizer categories size + 1]			ifFalse: [oldIndex]).	self alphabetizeMessageCategories! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 21:37'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 21:37'!alphabetizeMessageCategories	classListIndex = 0 ifTrue: [^ false].	self okToChange ifFalse: [^ false].	self classOrMetaClassOrganizer sortCategories.	self clearUserEditFlag.	self editClass.	self classListIndex: classListIndex.	self changedWith: #messageCategoryList.	^ true! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 21:30'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 21:30'!browseClassRefs	| cls |	(cls _ self selectedClass) ifNotNil: [		Smalltalk			browseAllOtherCallsOn: cls theNonMetaClass nameLiteral			wormhole: wormhole			module: module]! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 3/15/2007 10:53'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 3/15/2007 10:53'!browseClassVarRefs	| theSelectedClass lines labelStream vars allVars index owningClasses |	theSelectedClass _ self selectedClass.	lines _ OrderedCollection new.	allVars _ OrderedCollection new.	owningClasses _ OrderedCollection new.	labelStream _ WriteStream on: (String new: 200).	theSelectedClass withAllSuperclasses reverseDo:		[:class |		vars _ class classVarNames asSortedCollection.		vars do:			[:var |			labelStream nextPutAll: var; cr.			allVars add: var.			owningClasses add: class].		vars isEmpty ifFalse: [lines add: allVars size]].	labelStream contents isEmpty ifTrue: [^1 beep]. "handle nil superclass better"	labelStream skip: -1 "cut last CR".	index _ (PopUpMenu labels: labelStream contents lines: lines) startUp.	index = 0 ifTrue: [^ theSelectedClass].	Smalltalk		browseAllOtherCallsOn: ((owningClasses at: index) classVariablesPool associationAt: (allVars at: index))		wormhole: wormhole		module: module! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 21:18'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 21:18'!browseImplementors	"Create and schedule a message set browser on all implementors of the currently selected message selector. Do nothing if no message is selected."	| aMessageName |	(aMessageName _ self selectedMessageName) ifNotNil: 		[Smalltalk browseAllOtherImplementorsOf: aMessageName wormhole: wormhole module: module]! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 5/14/2007 19:34'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 5/14/2007 19:34'!browseInstVarRefs	| lines labelStream vars allVars index count offerAlpha theSelectedClass instVarName coll |	theSelectedClass _ self selectedClass.	(count _ selectedClass allInstVarNames size) = 0 ifTrue: 		[^ self inform: 'There are noinstance variables.'].	allVars _ OrderedCollection new.	lines _ OrderedCollection new.	labelStream _ WriteStream on: (String new: 200).	(offerAlpha _ count > 5)		ifTrue:			[lines add: 1.			allVars add: 'show alphabetically'.			labelStream nextPutAll: allVars first; cr].	selectedClass withAllSuperclasses reverseDo:		[:class |		vars _ class instVarNames.		vars do:			[:var |			labelStream nextPutAll: var; cr.			allVars add: var].		vars isEmpty ifFalse: [lines add: allVars size]].	labelStream skip: -1 "cut last CR".	(lines size > 0 and: [lines last = allVars size]) ifTrue:		[lines removeLast].  "dispense with inelegant line beneath last item"	index _ (PopUpMenu labels: labelStream contents lines: lines)startUpWithCaption: 'Instance variables in', self name.	index = 0 ifTrue: [^ self].	instVarName _ allVars at: index.	coll _ OrderedCollection new.	Cursor wait showWhile: [		theSelectedClass withAllSubAndSuperclassesDo: [:class | 			(class whichSelectorsAccess: instVarName) do: [:sel |				sel == #DoIt ifFalse: [					coll add: (						MethodReference new							setStandardClass: class 							methodSymbol: sel)]]]].	^ Smalltalk 		browseOtherMessageList: coll 		name: 'remote accesses to ' , instVarName 		autoSelect: instVarName		wormhole: wormhole		module: module! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 21:30'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 21:30'!browseSenders	"Create and schedule a message set browser on all senders of the currently selected message selector.  If there is no message currently selected, offer a type-in"	self		sendOtherQuery: #browseAllOtherCallsOn:wormhole:module:		with: wormhole		with: module		to: Smalltalk! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 22:10'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 22:10'!changeMessageCategories: aString	self halt: 'nah'! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/4/2005 00:20'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/4/2005 00:20'!classListIndex: anInteger 	"Set anInteger to be the index of the current class selection."	| className |	classListIndex _ anInteger.	self setClassOrganizer.	messageCategoryListIndex _ 1.	messageListIndex _ 0.	self classCommentIndicated		ifTrue: []		ifFalse: [editSelection _ anInteger = 0					ifTrue: [metaClassIndicated | (systemCategoryListIndex == 0)						ifTrue: [#none]						ifFalse: [#newClass]]					ifFalse: [#editClass]].	contents _ nil.	(self selectedClass recyclingHash = 0)		ifFalse: [className _ self selectedClass name.					(self class recentClasses includes: className)				ifTrue: [self class recentClasses remove: className].			self class recentClasses addFirst: className.			self class recentClasses size > 16				ifTrue: [self class recentClasses removeLast]].	self changedWith: #classSelectionChanged.	self changedWith: #classListIndex.	"update my selection"	self changedWith: #messageCategoryList.	self changedWith: #messageList.	self changedWith: #relabel.	self contentsChanged! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 3/20/2007 21:15'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 3/20/2007 21:15'!confirmRemovalOf: aSelector in: aBehavior	"Determine if it is okay to remove the given selector.  Answer 1 if it should be removed, 2 if it should be removed followed by a senders browse, and 3 if it should not be removed."	| count aMenu answer caption allCalls |	allCalls _ (wormhole allCallsOn: aSelector) collect: [:each | each reference].	(count _ allCalls size) == 0 ifTrue: [^ 1].  "no senders -- let the removal happen without warning"	count == 1 ifTrue: [		(allCalls first actualClass == aBehavior and: 			[allCalls first methodSymbol == aSelector]) ifTrue: [^ 1]	].   "only sender is itself"	aMenu _ PopUpMenu labels: 'Remove itRemove, then browse sendersDon''t remove, but show me those sendersForget it -- do nothing -- sorry I asked'.	caption _ 'This message has ', count printString, ' sender'.	count > 1 ifTrue:		[caption _ caption copyWith: $s].	answer _ aMenu startUpWithCaption: caption.	answer == 3 ifTrue: [		Smalltalk 			browseOtherMessageList: allCalls			name: 'remote senders of ', aSelector			autoSelect: aSelector keywords first			wormhole: wormhole			module: module	].	answer == 0 ifTrue: [answer _ 3].  "If user didn't answer, treat it as cancel"	^ answer min: 3! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2011 01:58'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 7/5/2011 01:58'!contents	"Depending on the current selection, different information is retrieved.	Answer a string description of that information. This information is the	method of the currently selected class and message."	| comment theClass latestCompiledMethod |	latestCompiledMethod _ currentCompiledMethod.	currentCompiledMethod _ nil.	editSelection == #none ifTrue: [^ ''].	editSelection == #editSystemCategories 		ifTrue: [^ systemOrganizer printString].	editSelection == #newClass 		ifTrue: [^ (selectedClass recyclingHash = 0)			ifTrue:				[Protoclass template: self selectedSystemCategoryName]			ifFalse:				[Protoclass templateForSubclassOf: selectedClass category: self selectedSystemCategoryName]].	editSelection == #editClass 		ifTrue: [^ ((theClass _ self selectedClassOrMetaClass) recyclingHash = 0)					ifTrue: [ "" ]					ifFalse: [				 		theClass id activeClass definitionST80: Preferences printAlternateSyntax not]].	editSelection == #editComment 		ifTrue: [selectedClass recyclingHash = 0 ifTrue: [^ ''].				comment _ theClass comment.				comment size = 0				ifTrue: [^ 'This class has not yet been commented.']				ifFalse: [^ comment]].	editSelection == #hierarchy 		ifTrue: [^ self selectedClassOrMetaClass printHierarchy].	editSelection == #editMessageCategories 		ifTrue: [^ self classOrMetaClassOrganizer printString].	editSelection == #newMessage		ifTrue: [ ^ (selectedClass recyclingHash = 0) 						ifTrue: [ "" ]						ifFalse: [ Object sourceCodeTemplate]].	editSelection == #editMessage		ifTrue:			[self showingByteCodes ifTrue: [^ self selectedBytecodes].			currentCompiledMethod _ latestCompiledMethod.			^contents yourselfUnlessNil: [self selectedMessage]].	self error: 'Browser internal error: unknown edit selection.'! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/4/2005 00:25'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/4/2005 00:25'!contents: input notifying: aController 	"The retrieved information has changed and its source must now be	 updated. The information can be a variety of things, depending on	 the list selections (such as templates for class or message definition,	 methods) or the user menu commands (such as definition, comment,	 hierarchy).  Answer the result of updating the source."	| aString aText |	self changedWith: #annotation.	aString _ input asString.	aText _ input asText.	editSelection == #editSystemCategories ifTrue: [^ self changeSystemCategories: aString].	editSelection == #editClass | (editSelection == #newClass) ifTrue: [^ self defineClass: aString notifying: aController].	editSelection == #editComment		ifTrue: 			[			selectedClass recyclingHash = 0 ifTrue: [self inform: 'You must select a classbefore giving it a comment.'.					^ false].			selectedClass comment: aText stamp: Utilities changeStamp.			^ true].	editSelection == #hierarchy ifTrue: [^ true].	editSelection == #editMessageCategories ifTrue: [^ self changeMessageCategories: aString].	editSelection == #editMessage | (editSelection == #newMessage)		ifTrue:			[^ self okayToAccept				ifFalse:					[false]				ifTrue:					[self compileMessage: aText notifying: aController]].	editSelection == #none		ifTrue: 			[self inform: 'This text cannot be acceptedin this part of the browser.'.			^ false].	self error: 'unacceptable accept'! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 21:47'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 21:47'!copyClass	self halt: 'I don''t do that.'! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/4/2005 00:53'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/4/2005 00:53'!decorateButtons! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/20/2012 14:12'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/20/2012 14:12'!defaultBrowserTitle	^ 'the classes in ', (MemoryControl summaryOfPeer: wormhole)! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 22:10'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 22:10'!defineClass: defString notifying: aController	self halt: 'nah'! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 6/22/2011 14:37'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 6/22/2011 14:37'!defineMessageFrom: aString notifying: aController	"Compile the expressions in aString. Notify aController if a syntax error occurs. Install the compiled method in the selected class classified under  the currently selected message category name. Answer the selector obtained if compilation succeeds, nil otherwise."	| selectedMessageName selector oldMessageList localClass methodNode method |	selectedMessageName _ self selectedMessageName.	oldMessageList _ self messageList.	contents _ nil.	localClass _ self equivalentLocalClass.	Smalltalk logChange: (		((String new: aString size + 16) writableStream)			nextPut: $';			nextPutAll: aString;			nextPutAll: '...in ';			print: localClass;			nextPutAll: ''' yourself';			contents).	methodNode _ (		Compiler new			compile: aString			in: localClass			notifying: aController			ifFail: []).	methodNode ifNil: [^self].	selector _ methodNode selector.	method _ (		(methodNode generate: #(0 1 0 0 0 0))			copyWithTempNames: (				(					(Compiler new)						parse: aString						in: localClass						notifying: aController				)					tempNames)).	module installMethodEdition: (		localClass			newEditionForMethod: method			at: selector			withSource: aString).	selector == nil ifTrue: [^ nil].	contents _ aString copy.	selector ~~ selectedMessageName		ifTrue: 			[			self setClassOrganizer.  "In case organization not cached"			(oldMessageList includes: selector)				ifFalse: [self changedWith: #messageList].			self messageListIndex: (self messageList indexOf: selector)].	^ selector! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/4/2005 00:26'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/4/2005 00:26'!doItReceiver	"This class's classPool has been jimmied to be the classPool of the class 	being browsed. A doIt in the code pane will let the user see the value of 	the class variables."	^selectedClass recyclingHash = 0 ifTrue: [FakeClassPool new]! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 22:00'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 22:00'!dstClassDstListMorph: dstListMorph	self halt: 'I don''t do that.'! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 8/25/2012 20:14'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 8/25/2012 20:14'!equivalentLocalClass	| class |	class _ Object subclassWithBaseID: selectedClass baseID.	^(self metaClassIndicated)		ifTrue: [class class]		ifFalse: [class]! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 22:10'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 22:10'!explainSpecial: string	self halt: 'nah'! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/20/2012 14:18'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/20/2012 14:18'!labelString	^(selectedClass recyclingHash = 0)		ifTrue: [self defaultBrowserTitle]		ifFalse: [			((String new: 16) writableStream)				nextPutAll: selectedClass printString;				nextPutAll: ' in ';				nextPutAll: (MemoryControl summaryOfPeer: wormhole);				contents]! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 21:18'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 21:18'!messageListKey: aChar from: view	"Respond to a Command key.  I am a model with a code pane, and I also	have a listView that has a list of methods.  The view knows how to get	the list and selection."	| sel class |	aChar == $D ifTrue: [^ self toggleDiffing].	sel _ self selectedMessageName.	aChar == $m ifTrue:  "These next two put up a type in if no message selected"		[^ self useSelector: sel orGetSelectorAndSendQuery: #browseAllOtherImplementorsOf:wormhole:module: with: wormhole with: module to: Smalltalk].	aChar == $n ifTrue: 		[^ self useSelector: sel orGetSelectorAndSendQuery: #browseAllOtherCallsOn:wormhole:module: with: wormhole with: module to: Smalltalk].	"The following require a class selection"	(class _ self selectedClassOrMetaClass) ifNil: [^ self arrowKey: aChar from: view].	aChar == $b ifTrue: [^ Browser fullOnClass: class selector: sel].	aChar == $N ifTrue: [^ self browseClassRefs].	aChar == $i ifTrue: [^ self methodHierarchy].	aChar == $h ifTrue: [^ self classHierarchy].	aChar == $p ifTrue: [^ self browseFullProtocol].	"The following require a method selection"	sel ifNotNil: 		[aChar == $o ifTrue: [^ self fileOutMessage].		aChar == $v ifTrue: [^ self browseVersions].		aChar == $O ifTrue: [^ self openSingleMessageBrowser].		aChar == $x ifTrue: [^ self removeMessage].		(aChar == $C and: [self canShowMultipleMessageCategories])			ifTrue: [^ self showHomeCategory]].	^ self arrowKey: aChar from: view! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2005 23:25'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/3/2005 23:25'!openAsMorphEditing: editString	"Create a pluggable version of all the morphs for a Browser in Morphic"	| window hSepFrac |	hSepFrac _ 0.4.	window _ (SystemWindow labelled: 'later') model: self.	window 		addMorph: self buildMorphicSystemCatList		frame: (0@0 corner: 0.25@hSepFrac).	self 		addClassAndSwitchesTo: window 		at: (0.25@0 corner: 0.5@hSepFrac)		plus: 0.	window 		addMorph: self buildMorphicMessageCatList		frame: (0.5@0 extent: 0.25@hSepFrac).	window addMorph: self buildMorphicMessageList		frame: (0.75@0 extent: 0.25@hSepFrac).	self 		addLowerPanesTo: window 		at: (0@hSepFrac corner: 1@1) 		with: editString.	^ window! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 21:51'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 21:51'!potentialClassNames	"Answer the names of all the classes that could be viewed in this browser.  This hook is provided so that HierarchyBrowsers can indicate their restricted subset.  For generic Browsers, the entire list of classes known to Smalltalk is provided, though of course that really only is accurate in the case of full system browsers."	^ wormhole classNames! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/11/2005 15:53'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/11/2005 15:53'!previouslySelectedClassName	"Answer the name of the selected class."	self metaClassIndicated		ifTrue: [^(selectedClass recyclingHash = 0) ifTrue: [nil] ifFalse: [selectedClass name]]		ifFalse: [^ selectedClass name]! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 22:07'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 22:07'!recent	self halt: 'I don''t do that.'! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 1/27/2011 00:08'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 1/27/2011 00:08'!remoteClassOrMetaClassOrganizer	"Answer the class organizer for the metaclass or class, depending on 	which (instance or class) is indicated."	^ClassOrganizer defaultList: (		(			self metaClassIndicated				ifTrue: [selectedClass class]				ifFalse: [selectedClass]		)			selectors asSortedCollection asArray)! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 22:07'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 22:07'!removeClass	"Remove the selected class from the system, at interactive user request.  Make certain the user really wants to do this, since it is not reversible.  Answer true if removal actually happened."	| message  className classToRemove result |	self okToChange ifFalse: [^ false].	classToRemove _ self selectedClassOrMetaClass ifNil: [^ self beep].	classToRemove _ classToRemove theNonMetaClass.	className _ classToRemove name.	message _ 'Are you certain that youwant to REMOVE the class ', className, 'from the system?'.	(result _ self confirm: message)		ifTrue: 			[classToRemove subclasses size > 0				ifTrue: [(self confirm: 'class has subclasses: ' , message)					ifFalse: [^ false]].			classToRemove removeFromSystem.			self changedWith: #classList.			true].	^ result! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 1/27/2011 00:09'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 1/27/2011 00:09'!removeEmptyCategories	messageCategoryListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	self setClassOrganizer.	self changedWith: #messageCategoryList! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/5/2005 10:55'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/5/2005 10:55'!removeMessage	"If a message is selected, create a Confirmer so the user can verify that 	the currently selected message should be removed from the system. If so, 	remove it.  If the Preference 'confirmMethodRemoves' is set to false, the 	confirmer is bypassed."	| messageName confirmation |	messageListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	messageName _ self selectedMessageName.	confirmation _ self confirmRemovalOf: messageName in: self selectedClassOrMetaClass.	confirmation == 3 ifTrue: [^ self].	self selectedClassOrMetaClass removeSelector: self selectedMessageName.	self messageListIndex: 0.	self setClassOrganizer.  "In case organization not cached"	self changedWith: #messageList.	confirmation == 2 ifTrue:		[Smalltalk browseAllCallsOn: messageName]! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 21:52'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 21:52'!removeSystemCategory	self halt: 'I don''t do that.'! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 22:07'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 22:07'!renameCategory	self halt: 'nah'! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 21:45'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 21:45'!renameClass	| oldName newName obs |	classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	oldName _ self selectedClass name.	newName _ self request: 'Please type new class name' initialAnswer: oldName.	newName = '' ifTrue: [^ self].  " Cancel returns '' "	newName _ newName asSymbol.	newName = oldName ifTrue: [^ self].	(wormhole includesClassNamed: newName)		ifTrue: [^ self error: newName , ' already exists'].	self selectedClass rename: newName.	self changedWith: #classList.	self classListIndex: ((systemOrganizer listAtCategoryNamed: self selectedSystemCategoryName) indexOf: newName).	obs _ wormhole allCallsOn: (wormhole classLiteralFor: newName).	obs isEmpty ifFalse: [		Smalltalk 			browseMessageList: obs			name: 'Obsolete References to ' , oldName			autoSelect: oldName	].! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 22:04'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 22:04'!selectedClass	"Answer the class that is currently selected. Answer nil if no selection 	exists."	| name |	(name _ self selectedClassName) ifNil: [^ nil].	^wormhole classNamed: name! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/4/2005 00:28'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/4/2005 00:28'!selectedClassOrMetaClass	"Answer the selected class or metaclass."	self metaClassIndicated		ifTrue: [^(selectedClass recyclingHash = 0) ifTrue: [nil] ifFalse: [selectedClass class]]		ifFalse: [^ selectedClass]! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/4/2005 00:57'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/4/2005 00:57'!selectedMessage	"Answer a copy of the source code for the selected message."	contents == nil ifFalse: [^ contents copy].	self showingDecompile ifTrue:		[^ self decompiledSourceIntoContents].	self showingDocumentation		ifFalse:			[contents _ self sourceStringPrettifiedAndDiffed]		ifTrue:			[contents _ self commentContents].	^ contents _ contents copy asText makeSelectorBoldIn: self selectedClassOrMetaClass! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 1/27/2011 00:11'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 1/27/2011 00:11'!setClassOrganizer	"Install whatever organization is appropriate"	classOrganizer _ nil.	metaClassOrganizer _ nil.	classListIndex = 0 ifTrue: [selectedClass _ nil. ^ self].	selectedClass _ wormhole classNamed: self selectedClassName.	classOrganizer _ ClassOrganizer defaultList: selectedClass selectors asSortedCollection asArray.	metaClassOrganizer _ ClassOrganizer defaultList: selectedClass class selectors asSortedCollection asArray! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 1/27/2011 12:29'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 1/27/2011 12:29'!setSelector: aSymbol	"Make the receiver point at the given selector, in the currently chosen class"	| messageCatIndex |	aSymbol ifNil: [^ self].	self setClassOrganizer.	messageCatIndex _ classOrganizer numberOfCategoryOfElement: aSymbol.	self messageCategoryListIndex: messageCatIndex + 1.	messageCatIndex = 0 ifTrue: [^ self].	self messageListIndex:			((classOrganizer listAtCategoryNumber: messageCatIndex)					indexOf: aSymbol)! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 8/26/2012 11:27'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 8/26/2012 11:27'!sourceStringPrettifiedAndDiffed	"Answer a copy of the source code for the selected message, transformed by diffing and pretty-printing exigencies"	| class selector sourceString method methodEdition |	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	methodEdition _ class activeEditionOfMethodAt: selector.	method _ "(		methodEdition			ifNil: ["class compiledMethodAt: selector"]			ifNotNil: [methodEdition method])".	(class isNil or: [selector isNil]) ifTrue: [^ 'missing'].	method == nil ifTrue: [^'swapped out'].	sourceString _ (		(Decompiler new)			decompile: selector			in: (				metaClassIndicated					ifTrue: [selectedClass class]					ifFalse: [selectedClass])			method: method) printString.	self validateMessageSource: sourceString forSelector: selector.	(#(prettyPrint colorPrint prettyDiffs altSyntax) includes: contentsSymbol) ifTrue:		[sourceString _ class compilerClass new			format: sourceString in: class notifying: nil contentsSymbol: contentsSymbol].	self showingAnyKindOfDiffs ifTrue:		[sourceString _ self diffFromPriorSourceFor: sourceString].	^ sourceString! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/4/2005 00:02'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/4/2005 00:02'!updateListsAndCodeIn: aWindow! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/4/2005 00:49'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 10/4/2005 00:49'!validateMessageSource: sourceString forSelector: aSelector	"Check whether there is evidence that method source is invalid"	| sourcesName |	((sourceString asString findString: aSelector keywords first ) ~= 1)		ifTrue: [sourcesName _ FileDirectory localNameFor: Smalltalk sourcesName.			self inform: 'There may be a problem with your sources file!!The source code for every method should (usually) start with themethod selector but this is not the case with this method!! You mayproceed with caution but it is recommended that you get a new source file.This can happen if you download the "' , sourcesName  , '" file, or the ".changes" file you use, as TEXT. It must be transfered in BINARY mode, even if it looks like a text file, to preserve the CR line ends.Mac users: This may have been caused by Stuffit Expander. To prevent the files above to be converted to Mac line ends when they are expanded, do this: Start the program, then from Preferences... in the File menu, choose the Cross Platform panel, then select "Never" and press OK. Then expand the compressed archive again.(Occasionally, the source code for a method may legitimatelystart with a non-alphabetic character -- for example, Behaviormethod #formalHeaderPartsFor:.  In such rare cases, you canhappily disregard this warning.)'].! !OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 1/26/2011 02:55'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 1/26/2011 02:55'!wormhole: aWormhole	wormhole _ aWormhole.	module _ wormhole module.	systemOrganizer _ SystemOrganizer new setDefaultList: Array new.	wormhole allClassNames do: [:name |		systemOrganizer			classify: name			under: (				(Smalltalk includesKey: name)					ifTrue: [(Smalltalk at: name) category]					ifFalse: ['New'])].	systemOrganizer sortCategories! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OtherBrowser class	instanceVariableNames: ''!OtherBrowser class methodsFor: 'as yet unclassified' stamp: 'crl 8/25/2012 17:29'!!OtherBrowser class methodsFor: 'as yet unclassified' stamp: 'crl 8/25/2012 17:29'!newOnRemoteMessagingClient: aRemoteMessagingClient	^self new wormhole: aRemoteMessagingClient! !OtherBrowser class methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 21:57'!!OtherBrowser class methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 21:57'!newOnWormhole: aWormhole	^self new wormhole: aWormhole! !OtherBrowser class methodsFor: 'as yet unclassified' stamp: 'crl 8/25/2012 17:29'!!OtherBrowser class methodsFor: 'as yet unclassified' stamp: 'crl 8/25/2012 17:29'!openOnRemoteMessagingClient: aRemoteMessagingClient	"Create and schedule a BrowserView with default browser label. The	view consists of five subviews, starting with the list view of system	categories of SystemOrganization. The initial text view part is empty."	| br |	br := self newOnRemoteMessagingClient: aRemoteMessagingClient.	self		openBrowserView: (br openEditString: nil)		label: br defaultBrowserTitle! !OtherBrowser class methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 21:57'!!OtherBrowser class methodsFor: 'as yet unclassified' stamp: 'crl 10/2/2006 21:57'!openOnWormhole: aWormhole	"Create and schedule a BrowserView with default browser label. The	view consists of five subviews, starting with the list view of system	categories of SystemOrganization. The initial text view part is empty."	| br |	br := self newOnWormhole: aWormhole.	self		openBrowserView: (br openEditString: nil)		label: br defaultBrowserTitle! !----End fileIn of /Users/craig/Downloads/caffeine/backups/37 (headless)/OtherBrowser.st----!Browser subclass: #OtherBrowser	instanceVariableNames: 'selectedClass module wormhole tether'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Browser'!!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 17:25' prior: 35344470!browseClassRefs	| cls |	(cls _ self selectedClass) ifNotNil: [		Smalltalk			browseAllOtherCallsOn: cls theNonMetaClass nameLiteral			tether: wormhole			module: module]! !!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 17:25' prior: 35344807!browseClassVarRefs	| theSelectedClass lines labelStream vars allVars index owningClasses |	theSelectedClass _ self selectedClass.	lines _ OrderedCollection new.	allVars _ OrderedCollection new.	owningClasses _ OrderedCollection new.	labelStream _ WriteStream on: (String new: 200).	theSelectedClass withAllSuperclasses reverseDo:		[:class |		vars _ class classVarNames asSortedCollection.		vars do:			[:var |			labelStream nextPutAll: var; cr.			allVars add: var.			owningClasses add: class].		vars isEmpty ifFalse: [lines add: allVars size]].	labelStream contents isEmpty ifTrue: [^1 beep]. "handle nil superclass better"	labelStream skip: -1 "cut last CR".	index _ (PopUpMenu labels: labelStream contents lines: lines) startUp.	index = 0 ifTrue: [^ theSelectedClass].	Smalltalk		browseAllOtherCallsOn: ((owningClasses at: index) classVariablesPool associationAt: (allVars at: index))		tether: tether		module: module! !!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 17:25' prior: 35374605!browseClassRefs	| cls |	(cls _ self selectedClass) ifNotNil: [		Smalltalk			browseAllOtherCallsOn: cls theNonMetaClass nameLiteral			tether: tether			module: module]! !!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 17:25' prior: 35345912!browseImplementors	"Create and schedule a message set browser on all implementors of the currently selected message selector. Do nothing if no message is selected."	| aMessageName |	(aMessageName _ self selectedMessageName) ifNotNil: 		[Smalltalk browseAllOtherImplementorsOf: aMessageName tether: tether module: module]! !!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 17:26' prior: 35346401!browseInstVarRefs	| lines labelStream vars allVars index count offerAlpha theSelectedClass instVarName coll |	theSelectedClass _ self selectedClass.	(count _ selectedClass allInstVarNames size) = 0 ifTrue: 		[^ self inform: 'There are noinstance variables.'].	allVars _ OrderedCollection new.	lines _ OrderedCollection new.	labelStream _ WriteStream on: (String new: 200).	(offerAlpha _ count > 5)		ifTrue:			[lines add: 1.			allVars add: 'show alphabetically'.			labelStream nextPutAll: allVars first; cr].	selectedClass withAllSuperclasses reverseDo:		[:class |		vars _ class instVarNames.		vars do:			[:var |			labelStream nextPutAll: var; cr.			allVars add: var].		vars isEmpty ifFalse: [lines add: allVars size]].	labelStream skip: -1 "cut last CR".	(lines size > 0 and: [lines last = allVars size]) ifTrue:		[lines removeLast].  "dispense with inelegant line beneath last item"	index _ (PopUpMenu labels: labelStream contents lines: lines)startUpWithCaption: 'Instance variables in', self name.	index = 0 ifTrue: [^ self].	instVarName _ allVars at: index.	coll _ OrderedCollection new.	Cursor wait showWhile: [		theSelectedClass withAllSubAndSuperclassesDo: [:class | 			(class whichSelectorsAccess: instVarName) do: [:sel |				sel == #DoIt ifFalse: [					coll add: (						MethodReference new							setStandardClass: class 							methodSymbol: sel)]]]].	^ Smalltalk 		browseOtherMessageList: coll 		name: 'remote accesses to ' , instVarName 		autoSelect: instVarName		tether: tether		module: module! !!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 17:26' prior: 35348117!browseSenders	"Create and schedule a message set browser on all senders of the currently selected message selector.  If there is no message currently selected, offer a type-in"	self		sendOtherQuery: #browseAllOtherCallsOn:tether:module:		with: tether		with: module		to: Smalltalk! !!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 17:26' prior: 35349961!confirmRemovalOf: aSelector in: aBehavior	"Determine if it is okay to remove the given selector.  Answer 1 if it should be removed, 2 if it should be removed followed by a senders browse, and 3 if it should not be removed."	| count aMenu answer caption allCalls |	allCalls _ (tether allCallsOn: aSelector) collect: [:each | each reference].	(count _ allCalls size) == 0 ifTrue: [^ 1].  "no senders -- let the removal happen without warning"	count == 1 ifTrue: [		(allCalls first actualClass == aBehavior and: 			[allCalls first methodSymbol == aSelector]) ifTrue: [^ 1]	].   "only sender is itself"	aMenu _ PopUpMenu labels: 'Remove itRemove, then browse sendersDon''t remove, but show me those sendersForget it -- do nothing -- sorry I asked'.	caption _ 'This message has ', count printString, ' sender'.	count > 1 ifTrue:		[caption _ caption copyWith: $s].	answer _ aMenu startUpWithCaption: caption.	answer == 3 ifTrue: [		Smalltalk 			browseOtherMessageList: allCalls			name: 'remote senders of ', aSelector			autoSelect: aSelector keywords first			tether: tether			module: module	].	answer == 0 ifTrue: [answer _ 3].  "If user didn't answer, treat it as cancel"	^ answer min: 3! !!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 17:26' prior: 35355242!defaultBrowserTitle	"^ 'the classes in ', (MemoryControl summaryOfPeer: tether)"! !!OtherBrowser methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 17:26' prior: 35379955!defaultBrowserTitle	"^ 'the classes in ', (MemoryControl summaryOfPeer: tether)"	^'remote classes'! !----QUIT/NOSAVE----{24 September 2019 . 5:26:47 pm} headless.image priorSource: 1786847!----STARTUP----{24 September 2019 . 5:27 pm} as /Users/craig/Downloads/caffeine/backups/37 (headless)/headless.image!#[105 100 70 111 114 65 99 116 105 118 101 67 108 97 115 115 87 105 116 104 66 97 115 101 73 68 58] asString!----SNAPSHOT----{24 September 2019 . 6:01:01 pm} headless.image priorSource: 1786847!Author current!Object baseID!UUID fromString: '4f0827d7-9d86-4d25-9609-9c8002d99301'!aClass baseID!aClass baseID: (UUID fromString: '4f0827d7-9d86-4d25-9609-9c8002d99301')!EditHistory rememberAllActiveClasses!----SNAPSHOT----{24 September 2019 . 6:04:15 pm} headless.image priorSource: 1826126!#[97 99 116 105 118 101 69 100 105 116 105 111 110 79 102 77 101 116 104 111 100 65 116 58] asString!!Behavior methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 19:17'!activeEditionOfMethodAt: selector	^EditHistory editionOfMethodAt: selector inClassWithBaseID: self baseID! !----SNAPSHOT----{24 September 2019 . 7:17:49 pm} headless.image priorSource: 1826434!Behavior activeEditionOfMethodAt: #activeEditionOfMethodAt:!activeClassEditions at: aUUID ifAbsent: [^nil]!Behavior edition!!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 19:38'!rememberAllMethods	Class allSubclassesDo: [:metaclass |		{			metaclass.			metaclass soleInstance		}			do: [:behavior |				behavior selectorsDo: [:selector |					behavior edition addMethodEdition: (						behavior							newEditionForMethod: (behavior compiledMethodAt: selector)							at: selector						withSource: (behavior sourceCodeAt: selector))]]]! !EditHistory activeEditionOfMethodAt: #rememberAllMethods!!EditHistory class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 19:39'!rememberAllMethods	LocalHistory rememberAllMethods! !----SNAPSHOT----{24 September 2019 . 7:39:19 pm} headless.image priorSource: 1826808!!GlobalLiteralMarker class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 19:40' prior: 34433557!canRepresent: literal inMethod: aCompiledMethod of: aClass	^(literal isKindOf: LookupKey) and: [(Smalltalk globals associationAt: literal key ifAbsent: [^false]) == literal and: [literal value isBehavior not]]! !method literals!SwapInThisMethod!----QUIT/NOSAVE----{24 September 2019 . 7:56:39 pm} headless.image priorSource: 1827665!----STARTUP----{24 September 2019 . 7:56:53 pm} as /Users/craig/Downloads/caffeine/backups/37 (headless)/headless.image!!GlobalLiteralMarker class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 19:40' prior: 34433557!canRepresent: literal inMethod: aCompiledMethod of: aClass	^(literal isKindOf: LookupKey) and: [(Smalltalk globals associationAt: literal key ifAbsent: [^false]) == literal and: [literal value isBehavior not]]! !----SNAPSHOT----{24 September 2019 . 7:57:22 pm} headless.image priorSource: 1827665!!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 20:00' prior: 35381535!rememberAllMethods	Class allSubclassesDo: [:metaclass |		{			metaclass.			metaclass soleInstance		}			do: [:behavior |				behavior selectorsDo: [:selector |					| method |										method := behavior compiledMethodAt: selector.										(method == Behavior reloadingMethod) ifFalse: [						behavior edition addMethodEdition: (							behavior								newEditionForMethod: method								at: selector							withSource: (behavior sourceCodeAt: selector))]]]]! !Error subclass: #MethodLiteralTransmissionMarkerCreationError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Exceptions-Kernel'!!MethodLiteralTransmissionMarker class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 20:06' prior: 34865103!forLiteral: literal inMethod: aCompiledMethod ofClass: aClass	"Answer an instance of the appropriate subclass for representing literal when transferring aCompiledMethod from aClass."	^(		(self allSubclasses)			detect: [:subclass |				subclass					canRepresent: literal					inMethod: aCompiledMethod					of: aClass]			ifNone: [^MethodLiteralTransmissionMarkerCreationError signal: 'I can''t transmit that literal.']	)		forLiteral: literal		inMethod: aCompiledMethod		ofClass: aClass! !!EditHistory methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 20:07' prior: 35383257!rememberAllMethods	Class allSubclassesDo: [:metaclass |		{			metaclass.			metaclass soleInstance		}			do: [:behavior |				behavior selectorsDo: [:selector |					| method |										method := behavior compiledMethodAt: selector.										(method == Behavior reloadingMethod) ifFalse: [						[							behavior edition addMethodEdition: (								behavior									newEditionForMethod: method									at: selector								withSource: (behavior sourceCodeAt: selector))						]							on: MethodLiteralTransmissionMarkerCreationError							do: [:exception | "Skip it."]]]]]! !pool!!SharedPool class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 20:21'!includesAssociation: association	^classPool includesAssociation: association! !pool includesAssociation: literal!self activeClass!EditHistory residesLocally not !			(EditHistory residesLocally not or: [EditHistory isTether])!!MetaclassEdition methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 20:30'!soleInstance	^self theNonMetaClass! !self activeClass soleInstance!(self         associationAt: anAssociation key      ifAbsent: [ ^ false ]) value!!MethodLiteralTransmissionMarker class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 20:41' prior: 35384025!forLiteral: literal inMethod: aCompiledMethod ofClass: aClass	"Answer an instance of the appropriate subclass for representing literal when transferring aCompiledMethod from aClass."	| match |		match := (		(self allSubclasses)			detect: [:subclass |				subclass					canRepresent: literal					inMethod: aCompiledMethod					of: aClass]			ifNone: [^MethodLiteralTransmissionMarkerCreationError signal: 'I can''t transmit that literal.']).				^[		match			forLiteral: literal			inMethod: aCompiledMethod			ofClass: aClass	]		on: Error		do: [:exception | MethodLiteralTransmissionMarkerCreationError signal: 'I can''t transmit that literal.']! !EditHistory rememberAllMethods!----SNAPSHOT----{24 September 2019 . 8:49:32 pm} headless.image priorSource: 1828644!----SNAPSHOT----{24 September 2019 . 8:50:42 pm} history.image priorSource: 1832147!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 21:07' prior: 35306733!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS ifHeadless: [				^[					| tether portal connected |								portal := WorkerEntrance new.					tether := Tether through: portal.								JS						at: #onmessage						put: [:message |							portal incomingMessage: message.							tether handleEvent].								tether waitForPeer.					connected := tether peer ping.					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.					(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate]				]					forkAt: Processor timingPriority]].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----SNAPSHOT----{24 September 2019 . 9:08:02 pm} history.image priorSource: 1832234!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 21:11' prior: 35386853!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS ifHeadless: [				^[					| tether portal connected |								(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.										portal := WorkerEntrance new.					tether := Tether through: portal.								JS						at: #onmessage						put: [:message |							portal incomingMessage: message.							tether handleEvent].								tether waitForPeer.					connected := tether peer ping				]					forkAt: Processor timingPriority]].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----SNAPSHOT----{24 September 2019 . 9:11:48 pm} history.image priorSource: 1833167!#[112 111 115 105 116 105 111 110] asString!!ClassDescription methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 22:03' prior: 17072419!acceptsLoggingOfCompilation	"weird name is so that it will come lexically before #compile, so that a clean build can make it through.  7/7/96 sw"	^EditHistory residesLocally not! !!ClassDescription methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 22:05' prior: 0!acceptsLoggingOfCompilation	"eep"		JS		ifConnected: [JS				ifHeadless: [^ false]].	^ true! !!ClassDescription methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 22:05' prior: 35389043!acceptsLoggingOfCompilation	"meep"		JS		ifConnected: [JS				ifHeadless: [^ false]].	^ true! !----SNAPSHOT----{24 September 2019 . 10:05:56 pm} history.image priorSource: 1834105!!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 22:07'!shakeHeadless	| fusedMethods weakArray navigation reloadingMethod numberOfClassesRemoved |		weakArray := WeakArray with: Object new.	navigation := SystemNavigation new.		fusedMethods := (		(OrderedCollection new)			addAll: {				Object compiledMethodAt: #defaultBackgroundColor.				Object compiledMethodAt: #primitiveError:.				Object compiledMethodAt: #perform:.								Object compiledMethodAt: #perform:with:.				Object compiledMethodAt: #perform:with:with:.				Object compiledMethodAt: #perform:with:with:with:.				Object compiledMethodAt: #perform:with:with:with:with:.				Object compiledMethodAt: #perform:withArguments:.						Object compiledMethodAt: #perform:withArguments:inSuperclass:.						Object compiledMethodAt: #perform:withEnoughArguments:.				Object compiledMethodAt: #isSymbol.				Behavior reloadingMethod.				EditHistory compiledMethodAt: #swapInMethodAt:in:.				Object compiledMethodAt: #currentWorld.				Object compiledMethodAt: #adaptToInteger:andSend:.				Object compiledMethodAt: #in:.				Object compiledMethodAt: #addDependent:.				Symbol compiledMethodAt: #isSymbol.				ContextPart compiledMethodAt: #selector.				ContextPart compiledMethodAt: #arguments.				CompiledMethod compiledMethodAt: #selector.				UUIDGenerator compiledMethodAt: #semaphoreForGenerator.				UUIDGenerator compiledMethodAt: #randomGenerator.				ProtoObject compiledMethodAt: #initialize.				BlockClosure compiledMethodAt: #value.				BlockContext compiledMethodAt: #value.				Semaphore compiledMethodAt: #wait.				UndefinedObject compiledMethodAt: #release.				ClassOrganizer compiledMethodAt: #traitComposition.				ByteString class compiledMethodAt: #stringHash:initialHash:};			yourself).			{		#(id isNil notNil isInteger removeFromSystem removeFromSystem: hashBytes:startingWith: size species signal resumptionTime primGetNextEvent: bitAnd: new: new negative at: at:put: bitShiftMagnitude: bitOr: < randomCounter / + asFloat bitXor: identityHash basicAt: basicAt:put: basicNew: basicNew isMethodProperties).		CompiledMethodTrailer trailerKindDecoders.	}		do: [:set |			set do: [:selector |		(navigation allImplementorsOf: selector) do: [:reference | fusedMethods add: reference compiledMethod]]].	self		fuseSingleClassesInto: fusedMethods;		fuseClassHierarchiesInto: fusedMethods.				fusedMethods do: [:method | method fuse].		Behavior setReloadingMethod.	reloadingMethod := Behavior reloadingMethod.	Shaker class swapOutMethodAt: #test:.	(Shaker test: 42) = 42 ifFalse: [self error: 'history system not working'].		"Set the selector and class-binding literals of the reloading method to things which make sense in the JS debugger."	Behavior setReloadingMethod.	LRUCache allInstancesDo: [:cache | cache reset].	ScrollBar boxOfSize: 10@10 color: Color blue.	Inspector inspect: 3.	ToolBuilder default.	WeakArray restartFinalizationProcess.	[3 error: 'ignored'] on: Error do: [:exception | ].	EventSensor install.	Delay initialize.	(Delay forSeconds: 1) wait.	Sensor fetchMoreEvents.		{		BlockClosure.		ContextPart	}		do: [:class |			class allSubInstancesDo: [:methodHolder | methodHolder fuse]].		JS at: #shaking put: true.	Smalltalk		primitiveGarbageCollect;		primitiveFusedGarbageCollect;		primitiveFusedGarbageCollect.			numberOfClassesRemoved := -1.		[numberOfClassesRemoved = 0] whileFalse: [		numberOfClassesRemoved := 0.		(Class allSubclasses asSortedCollection: [:earlier :later | earlier depth <= later depth]) asArray reversed do: [:metaclass |			(				metaclass soleInstance subclasses isEmpty not or: [					{						metaclass.						metaclass soleInstance					}						anySatisfy: [:behavior |							behavior methodDict anySatisfy: [:method | method ~~ reloadingMethod]]]			)				ifFalse: [					metaclass soleInstance removeFromSystem.					numberOfClassesRemoved := numberOfClassesRemoved + 1]]].		Smalltalk garbageCollect! !!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 22:07'!fuseHeadlessClassHierarchiesInto: fusedMethods	"Fuse entire class hierarchies."	{		FileDirectory.		PluggableListMorph.		SocketStream.		WebMessage.		Socket.		MimeConverter.		ProcessSpecificVariable.		AbstractSound.		ClassCategoryReader.		ImageReadWriter.		IndentingListItemMorph.		DirectoryEntry.		SimpleServiceEntry.		WebSocket.		InstructionClient.		SystemWindow.		FileList.		CodeHolder.		Collection.		CharacterScanner.		MorphicEvent.		Inspector.		CommandHistory.		DAVResource.		LanguageEnvironment.		BitBlt.		ParseNodeVisitor.		EncodedCharSet.		LayoutPolicy.		TTGlyph.		Envelope.		SharedPool.		BasicRequestor.
		ServiceProvider.		ServiceAction.		PreferenceBrowserMorph.		TextDiffBuilder.		HostPlatform.		FillStyle.		BorderStyle.		BlockStartLocator.		TextComposer.		AbstractResizerMorph.		DebuggerMethodMap.		AbstractFont.		ToolBuilderSpec.		ParseNode.		ToolBuilder.		UserInputEvent.		Preferences.		AbstractEvent.		Number.		InputSensor.		ContextPart.		Debugger.		Project.		Boolean.		Exception.		Collection.		Edition.		MethodLiteralTransmissionMarker.		Portal.		License.		Manifest.		BitMatchingPattern.		Inspector.		JSObject.		Canvas.		ByteTextConverter.		Form.		Color	}		do: [:class | self fuseSuperclass: class into: fusedMethods]! !!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 22:07'!fuseHeadlessSingleClassesInto: fusedMethods	{		SocketAddressInformation.		DelayWaitTimeout.		Number.		WebUtils.		ThirtyTwoBitRegister.		SecureHashAlgorithm.		DiffElement.		ProcessBrowser.		CPUWatcher.		TransferMorph.		DeepCopier.		MethodReference.		Random.		SoundService.		ExternalObjectTable.		ChangeRecord.		SystemChangeNotifier.		ClassBuilder.		Beeper.		GZipReadStream.		InternalTranslator.		ServerDirectory.		PluggableTreeItemNode.		PluggableTreeMorph.		FilePath.		MorphicEventDispatcher.		Utilities.		Command.		WebClient.		SystemProgressMorph.		InternetConfiguration.		NetNameResolver.		ChromeExtensionUrl.		SystemNavigation.		ColorTheme.		LocaleID.		XMLNamespace.		CharacterBlock.		UndefinedObject.		LimitedWriteStream.		HttpUrl.		SystemProgressBarMorph.		HaloSpec.		ResourceManager.		RemoteString.		ListChooser.		TextKern.		TTKernPair.		Clipboard.		Latin1Environment.		EventManager.		Global.		Time.		SoundPlayer.		PopUpMenu.		SelectorBrowser.		DualChangeSorter.		TextAlignment.		FMSound.		PaintBoxColorPicker.		ThreePhaseButtonMorph.		PaintInvokingMorph.		ProjectViewMorph.		ClockMorph.		EllipseMorph.		ObjectsTool.		UpdatingSimpleButtonMorph.		CurveMorph.		MagnifierMorph.		ListItemWrapper.		ObjectExplorerWrapper.		SoundRecorder.		RecordingControlsMorph.		TimeZone.		BaseSoundSystem.		DummySoundSystem.		TraitOrganizer.		ServiceShortcuts.		ServiceCancelled.		ServiceRegistry.		ServiceGui.		ServicePreferences.		TheWorldMainDockingBar.		TraitAlias.		ClassTrait.		PragmaPreference.		Workspace.		ChangeList.		ChangeSorter.		NewColorPickerMorph.		BrowseAvailableModules.		CounterpartRequest.		InstallRemoteModule.		PreferenceBrowser.		ToolIcons.		UpdatingMenuItemMorph.		PointerFinder.		ParseNodeEnumerator.		ParseNodeVisitor.		ZipWriteStream.		ZipEncoder.		TextDomainManager.		StepMessage.		SystemWindowButton.		UTF8TextConverter.		FillInTheBlankMorph.		RealEstateAgent.		TransformMorph.		PluggableTextMorphPlus.		Preference.		WindowColorSpec.		UserDialogBoxMorph.		WindowColorRegistry.		TheWorldMenu.		PluggableListMorphPlus.		PluggableTextMorph.		TextMorphForEditView.		TextLine.		DeflateStream.		AdditionalMethodState.		Compiler.		CompilationCue.		Association.		PluggableButtonMorphPlus.		PluggablePanelMorph.		SketchMorph.		LayoutFrame.		IconicButton.		SimpleButtonMorph.		StandardScriptingSystem.		MessageNames.		FileServices.		ClassBinding.		Webpage current class.		FileDirectory.		Metaclass.		ClassDescription.		Behavior.		Class.		MethodDictionary.		DisplayText.		ProtoObject.		Tether.		ExceptionMarker.		InstructionPrinter.		Author.		EditHistory.		ModuleDescription.		ModuleID.		Version.		Other.		SmalltalkImage.		Environment.		ChangeSet.		ClassChangeRecord.		MethodChangeRecord.		ToolSet.		SystemBrowser.		StandardToolSet.		Message.		MessageSend.		Process.		ProcessorScheduler.		BlockClosure.		BlockContext.		SharedQueue.		TranscriptStream.		Categorizer.		Character.		ExtendedNumberParser.		JSObjectProxy.		SystemOrganizer.		Shaker.		Decompiler.		PolygonMorph.		SmalltalkEditor.		Pragma.		BalloonEngine.		MultiByteFileStream.		BalloonEdgeData.		BalloonFillData.		UTF8ClipboardInterpreter.		BreakpointManager.		ZipConstants.		MorphicUIManager.		MenuLineMorph.		NewBalloonMorph.		BalloonMorph.		AbstractLauncher.		AutoStart.		ObjectHistory.		Parser.		MenuMorph.		AlignmentMorph.		StringMorph.		MenuItemMorph.		MorphicTransform.		MenuIcons.		LayoutCell.		TableLayoutProperties.		Rectangle.		BorderStyle.		SimpleBorder.		TextFontReference.		Browser.		Point.		HandMorph.		PasteUpMorph.		WorldState.		MessageTally.		PluggableWindowSpec.		ScrollBar.		MorphicModel.		SHParserST80.		PluggableTextSpec.		Point.		SystemWindow.		PluggableButtonMorph.		PluggableSystemWindow.		CompiledMethodTrailer.		TextEmphasis.		SHTextStylerST80.		TextMorph.		PluggableListMorph.		LazyListMorph.		ScrollPane.		Monitor.		TextColor.		MouseOverHandler.		SHRange.		CharacterScanner.		CompositionScanner.		EventHandler.		MouseClickState.		MorphExtension.		IdentityTransform.		TopGripMorph.		TextStyle.		ProportionalSplitterMorph.		NewParagraph	}		do: [:class | self fuseProtoclass: class into: fusedMethods]! !!Shaker class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 22:07'!shakeHeadless	^self new shakeHeadless! !!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 22:10' prior: 35389499!shakeHeadless	| fusedMethods weakArray navigation reloadingMethod numberOfClassesRemoved |		weakArray := WeakArray with: Object new.	navigation := SystemNavigation new.		fusedMethods := (		(OrderedCollection new)			addAll: {				Object compiledMethodAt: #primitiveError:.				Object compiledMethodAt: #perform:.								Object compiledMethodAt: #perform:with:.				Object compiledMethodAt: #perform:with:with:.				Object compiledMethodAt: #perform:with:with:with:.				Object compiledMethodAt: #perform:with:with:with:with:.				Object compiledMethodAt: #perform:withArguments:.						Object compiledMethodAt: #perform:withArguments:inSuperclass:.						Object compiledMethodAt: #perform:withEnoughArguments:.				Object compiledMethodAt: #isSymbol.				Behavior reloadingMethod.				EditHistory compiledMethodAt: #swapInMethodAt:in:.				Object compiledMethodAt: #adaptToInteger:andSend:.				Object compiledMethodAt: #in:.				Object compiledMethodAt: #addDependent:.				Symbol compiledMethodAt: #isSymbol.				ContextPart compiledMethodAt: #selector.				ContextPart compiledMethodAt: #arguments.				CompiledMethod compiledMethodAt: #selector.				UUIDGenerator compiledMethodAt: #semaphoreForGenerator.				UUIDGenerator compiledMethodAt: #randomGenerator.				ProtoObject compiledMethodAt: #initialize.				BlockClosure compiledMethodAt: #value.				BlockContext compiledMethodAt: #value.				Semaphore compiledMethodAt: #wait.				UndefinedObject compiledMethodAt: #release.				ClassOrganizer compiledMethodAt: #traitComposition.				ByteString class compiledMethodAt: #stringHash:initialHash:};			yourself).			{		#(id isNil notNil isInteger removeFromSystem removeFromSystem: hashBytes:startingWith: size species signal resumptionTime primGetNextEvent: bitAnd: new: new negative at: at:put: bitShiftMagnitude: bitOr: < randomCounter / + asFloat bitXor: identityHash basicAt: basicAt:put: basicNew: basicNew isMethodProperties).		CompiledMethodTrailer trailerKindDecoders.	}		do: [:set |			set do: [:selector |		(navigation allImplementorsOf: selector) do: [:reference | fusedMethods add: reference compiledMethod]]].	self		fuseHeadlessSingleClassesInto: fusedMethods;		fuseHeadlessClassHierarchiesInto: fusedMethods.				fusedMethods do: [:method | method fuse].		Behavior setReloadingMethod.	reloadingMethod := Behavior reloadingMethod.	Shaker class swapOutMethodAt: #test:.	(Shaker test: 42) = 42 ifFalse: [self error: 'history system not working'].		"Set the selector and class-binding literals of the reloading method to things which make sense in the JS debugger."	Behavior setReloadingMethod.	LRUCache allInstancesDo: [:cache | cache reset].	WeakArray restartFinalizationProcess.	[3 error: 'ignored'] on: Error do: [:exception | ].	Delay initialize.	(Delay forSeconds: 1) wait.		{		BlockClosure.		ContextPart	}		do: [:class |			class allSubInstancesDo: [:methodHolder | methodHolder fuse]].		JS at: #shaking put: true.	Smalltalk		primitiveGarbageCollect;		primitiveFusedGarbageCollect;		primitiveFusedGarbageCollect.			numberOfClassesRemoved := -1.		[numberOfClassesRemoved = 0] whileFalse: [		numberOfClassesRemoved := 0.		(Class allSubclasses asSortedCollection: [:earlier :later | earlier depth <= later depth]) asArray reversed do: [:metaclass |			(				metaclass soleInstance subclasses isEmpty not or: [					{						metaclass.						metaclass soleInstance					}						anySatisfy: [:behavior |							behavior methodDict anySatisfy: [:method | method ~~ reloadingMethod]]]			)				ifFalse: [					metaclass soleInstance removeFromSystem.					numberOfClassesRemoved := numberOfClassesRemoved + 1]]].		Smalltalk garbageCollect! !!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 22:12' prior: 35393506!fuseHeadlessClassHierarchiesInto: fusedMethods	"Fuse entire class hierarchies."	{		FileDirectory.		SocketStream.		WebMessage.		Socket.		MimeConverter.		ProcessSpecificVariable.		ClassCategoryReader.		DirectoryEntry.		SimpleServiceEntry.		WebSocket.		InstructionClient.		CodeHolder.		Collection.		CharacterScanner.		CommandHistory.		LanguageEnvironment.		ParseNodeVisitor.		EncodedCharSet.		SharedPool.		BasicRequestor.
		ServiceProvider.		ServiceAction.		TextDiffBuilder.		HostPlatform.		BlockStartLocator.		DebuggerMethodMap.		ParseNode.		Preferences.		Number.		ContextPart.		Project.		Boolean.		Exception.		Collection.		Edition.		MethodLiteralTransmissionMarker.		Portal.		License.		Manifest.		BitMatchingPattern.		JSObject.		ByteTextConverter.	}		do: [:class | self fuseSuperclass: class into: fusedMethods]! !!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 22:18' prior: 35394887!fuseHeadlessSingleClassesInto: fusedMethods	{		SocketAddressInformation.		DelayWaitTimeout.		Number.		WebUtils.		ThirtyTwoBitRegister.		SecureHashAlgorithm.		DiffElement.		ProcessBrowser.		CPUWatcher.		DeepCopier.		MethodReference.		Random.		ExternalObjectTable.		ChangeRecord.		SystemChangeNotifier.		ClassBuilder.		Beeper.		GZipReadStream.		InternalTranslator.		ServerDirectory.		FilePath.		Utilities.		Command.		WebClient.		InternetConfiguration.		NetNameResolver.		ChromeExtensionUrl.		SystemNavigation.		LocaleID.		XMLNamespace.		CharacterBlock.		UndefinedObject.		LimitedWriteStream.		HttpUrl.		ResourceManager.		RemoteString.		Latin1Environment.		Global.		Time.		TimeZone.		TraitOrganizer.		ServiceShortcuts.		ServiceCancelled.		ServiceRegistry.		ServicePreferences.		TraitAlias.		ClassTrait.		PragmaPreference.		BrowseAvailableModules.		CounterpartRequest.		InstallRemoteModule.		PointerFinder.		ParseNodeEnumerator.		ParseNodeVisitor.		ZipWriteStream.		ZipEncoder.		TextDomainManager.		StepMessage.		UTF8TextConverter.		Preference.		TextLine.		DeflateStream.		AdditionalMethodState.		Compiler.		CompilationCue.		Association.		StandardScriptingSystem.		MessageNames.		FileServices.		ClassBinding.		Webpage current class.		FileDirectory.		Metaclass.		ClassDescription.		Behavior.		Class.		MethodDictionary.		ProtoObject.		Tether.		ExceptionMarker.		InstructionPrinter.		Author.		EditHistory.		ModuleDescription.		ModuleID.		Version.		Other.		SmalltalkImage.		Environment.		ChangeSet.		ClassChangeRecord.		MethodChangeRecord.		ToolSet.		StandardToolSet.		Message.		MessageSend.		Process.		ProcessorScheduler.		BlockClosure.		BlockContext.		SharedQueue.		TranscriptStream.		Categorizer.		Character.		ExtendedNumberParser.		JSObjectProxy.		SystemOrganizer.		Shaker.		Decompiler.		Pragma.		MultiByteFileStream.		BreakpointManager.		ZipConstants.		AbstractLauncher.		AutoStart.		ObjectHistory.		Parser.		Point.		MessageTally.		CompiledMethodTrailer.		Monitor.		IdentityTransform.		NewParagraph	}		do: [:class | self fuseProtoclass: class into: fusedMethods]! !----SNAPSHOT----{24 September 2019 . 10:18:27 pm} history.image priorSource: 1834907!#[116 101 115 116 58] asString!#[116 101 116 104 101 114] asString!!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 22:52' prior: 35399433!shakeHeadless	| fusedMethods weakArray navigation reloadingMethod numberOfClassesRemoved |		EditHistory connectTo: 'ws://localhost:8091/tether'.	weakArray := WeakArray with: Object new.	navigation := SystemNavigation new.		fusedMethods := (		(OrderedCollection new)			addAll: {				Object compiledMethodAt: #primitiveError:.				Object compiledMethodAt: #perform:.								Object compiledMethodAt: #perform:with:.				Object compiledMethodAt: #perform:with:with:.				Object compiledMethodAt: #perform:with:with:with:.				Object compiledMethodAt: #perform:with:with:with:with:.				Object compiledMethodAt: #perform:withArguments:.						Object compiledMethodAt: #perform:withArguments:inSuperclass:.						Object compiledMethodAt: #perform:withEnoughArguments:.				Object compiledMethodAt: #isSymbol.				Behavior reloadingMethod.				EditHistory compiledMethodAt: #swapInMethodAt:in:.				Object compiledMethodAt: #adaptToInteger:andSend:.				Object compiledMethodAt: #in:.				Object compiledMethodAt: #addDependent:.				Symbol compiledMethodAt: #isSymbol.				ContextPart compiledMethodAt: #selector.				ContextPart compiledMethodAt: #arguments.				CompiledMethod compiledMethodAt: #selector.				UUIDGenerator compiledMethodAt: #semaphoreForGenerator.				UUIDGenerator compiledMethodAt: #randomGenerator.				ProtoObject compiledMethodAt: #initialize.				BlockClosure compiledMethodAt: #value.				BlockContext compiledMethodAt: #value.				Semaphore compiledMethodAt: #wait.				UndefinedObject compiledMethodAt: #release.				ClassOrganizer compiledMethodAt: #traitComposition.				ByteString class compiledMethodAt: #stringHash:initialHash:};			yourself).			{		#(id isNil notNil isInteger removeFromSystem removeFromSystem: hashBytes:startingWith: size species signal resumptionTime primGetNextEvent: bitAnd: new: new negative at: at:put: bitShiftMagnitude: bitOr: < randomCounter / + asFloat bitXor: identityHash basicAt: basicAt:put: basicNew: basicNew isMethodProperties).		CompiledMethodTrailer trailerKindDecoders.	}		do: [:set |			set do: [:selector |		(navigation allImplementorsOf: selector) do: [:reference | fusedMethods add: reference compiledMethod]]].	self		fuseHeadlessSingleClassesInto: fusedMethods;		fuseHeadlessClassHierarchiesInto: fusedMethods.				fusedMethods do: [:method | method fuse].		Behavior setReloadingMethod.	reloadingMethod := Behavior reloadingMethod.	Shaker class swapOutMethodAt: #test:.	(Shaker test: 42) = 42 ifFalse: [self error: 'history system not working'].		"Set the selector and class-binding literals of the reloading method to things which make sense in the JS debugger."	Behavior setReloadingMethod.	LRUCache allInstancesDo: [:cache | cache reset].	WeakArray restartFinalizationProcess.	[3 error: 'ignored'] on: Error do: [:exception | ].	Delay initialize.	(Delay forSeconds: 1) wait.		{		BlockClosure.		ContextPart	}		do: [:class |			class allSubInstancesDo: [:methodHolder | methodHolder fuse]].		JS at: #shaking put: true.	Smalltalk		primitiveGarbageCollect;		primitiveFusedGarbageCollect;		primitiveFusedGarbageCollect.			numberOfClassesRemoved := -1.		[numberOfClassesRemoved = 0] whileFalse: [		numberOfClassesRemoved := 0.		(Class allSubclasses asSortedCollection: [:earlier :later | earlier depth <= later depth]) asArray reversed do: [:metaclass |			(				metaclass soleInstance subclasses isEmpty not or: [					{						metaclass.						metaclass soleInstance					}						anySatisfy: [:behavior |							behavior methodDict anySatisfy: [:method | method ~~ reloadingMethod]]]			)				ifFalse: [					metaclass soleInstance removeFromSystem.					numberOfClassesRemoved := numberOfClassesRemoved + 1]]].		Smalltalk garbageCollect! !!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 22:52' prior: 34278756!shake	| fusedMethods weakArray navigation reloadingMethod numberOfClassesRemoved |		EditHistory connectTo: 'ws://localhost:8091/tether'.	weakArray := WeakArray with: Object new.	navigation := SystemNavigation new.		fusedMethods := (		(OrderedCollection new)			addAll: {				Object compiledMethodAt: #defaultBackgroundColor.				Object compiledMethodAt: #primitiveError:.				Object compiledMethodAt: #perform:.								Object compiledMethodAt: #perform:with:.				Object compiledMethodAt: #perform:with:with:.				Object compiledMethodAt: #perform:with:with:with:.				Object compiledMethodAt: #perform:with:with:with:with:.				Object compiledMethodAt: #perform:withArguments:.						Object compiledMethodAt: #perform:withArguments:inSuperclass:.						Object compiledMethodAt: #perform:withEnoughArguments:.				Object compiledMethodAt: #isSymbol.				Behavior reloadingMethod.				EditHistory compiledMethodAt: #swapInMethodAt:in:.				Object compiledMethodAt: #currentWorld.				Object compiledMethodAt: #adaptToInteger:andSend:.				Object compiledMethodAt: #in:.				Object compiledMethodAt: #addDependent:.				Symbol compiledMethodAt: #isSymbol.				ContextPart compiledMethodAt: #selector.				ContextPart compiledMethodAt: #arguments.				CompiledMethod compiledMethodAt: #selector.				UUIDGenerator compiledMethodAt: #semaphoreForGenerator.				UUIDGenerator compiledMethodAt: #randomGenerator.				ProtoObject compiledMethodAt: #initialize.				BlockClosure compiledMethodAt: #value.				BlockContext compiledMethodAt: #value.				Semaphore compiledMethodAt: #wait.				UndefinedObject compiledMethodAt: #release.				ClassOrganizer compiledMethodAt: #traitComposition.				ByteString class compiledMethodAt: #stringHash:initialHash:};			yourself).			{		#(id isNil notNil isInteger removeFromSystem removeFromSystem: hashBytes:startingWith: size species signal resumptionTime primGetNextEvent: bitAnd: new: new negative at: at:put: bitShiftMagnitude: bitOr: < randomCounter / + asFloat bitXor: identityHash basicAt: basicAt:put: basicNew: basicNew isMethodProperties).		CompiledMethodTrailer trailerKindDecoders.	}		do: [:set |			set do: [:selector |		(navigation allImplementorsOf: selector) do: [:reference | fusedMethods add: reference compiledMethod]]].	self		fuseSingleClassesInto: fusedMethods;		fuseClassHierarchiesInto: fusedMethods.				fusedMethods do: [:method | method fuse].		Behavior setReloadingMethod.	reloadingMethod := Behavior reloadingMethod.	Shaker class swapOutMethodAt: #test:.	(Shaker test: 42) = 42 ifFalse: [self error: 'history system not working'].		"Set the selector and class-binding literals of the reloading method to things which make sense in the JS debugger."	Behavior setReloadingMethod.	LRUCache allInstancesDo: [:cache | cache reset].	ScrollBar boxOfSize: 10@10 color: Color blue.	Inspector inspect: 3.	ToolBuilder default.	WeakArray restartFinalizationProcess.	[3 error: 'ignored'] on: Error do: [:exception | ].	EventSensor install.	Delay initialize.	(Delay forSeconds: 1) wait.	Sensor fetchMoreEvents.		{		BlockClosure.		ContextPart	}		do: [:class |			class allSubInstancesDo: [:methodHolder | methodHolder fuse]].		JS at: #shaking put: true.	Smalltalk		primitiveGarbageCollect;		primitiveFusedGarbageCollect;		primitiveFusedGarbageCollect.			numberOfClassesRemoved := -1.		[numberOfClassesRemoved = 0] whileFalse: [		numberOfClassesRemoved := 0.		(Class allSubclasses asSortedCollection: [:earlier :later | earlier depth <= later depth]) asArray reversed do: [:metaclass |			(				metaclass soleInstance subclasses isEmpty not or: [					{						metaclass.						metaclass soleInstance					}						anySatisfy: [:behavior |							behavior methodDict anySatisfy: [:method | method ~~ reloadingMethod]]]			)				ifFalse: [					metaclass soleInstance removeFromSystem.					numberOfClassesRemoved := numberOfClassesRemoved + 1]]].		Smalltalk garbageCollect! !----SNAPSHOT----{24 September 2019 . 10:52:23 pm} history.image priorSource: 1851938!!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 23:00' prior: 35404182!fuseHeadlessSingleClassesInto: fusedMethods	{		BindingPolicy.		SocketAddressInformation.		DelayWaitTimeout.		Number.		WebUtils.		ThirtyTwoBitRegister.		SecureHashAlgorithm.		DiffElement.		ProcessBrowser.		CPUWatcher.		DeepCopier.		MethodReference.		Random.		ExternalObjectTable.		ChangeRecord.		SystemChangeNotifier.		ClassBuilder.		Beeper.		GZipReadStream.		InternalTranslator.		ServerDirectory.		FilePath.		Utilities.		Command.		WebClient.		InternetConfiguration.		NetNameResolver.		ChromeExtensionUrl.		SystemNavigation.		LocaleID.		XMLNamespace.		CharacterBlock.		UndefinedObject.		LimitedWriteStream.		HttpUrl.		ResourceManager.		RemoteString.		Latin1Environment.		Global.		Time.		TimeZone.		TraitOrganizer.		ServiceShortcuts.		ServiceCancelled.		ServiceRegistry.		ServicePreferences.		TraitAlias.		ClassTrait.		PragmaPreference.		BrowseAvailableModules.		CounterpartRequest.		InstallRemoteModule.		PointerFinder.		ParseNodeEnumerator.		ParseNodeVisitor.		ZipWriteStream.		ZipEncoder.		TextDomainManager.		StepMessage.		UTF8TextConverter.		Preference.		TextLine.		DeflateStream.		AdditionalMethodState.		Compiler.		CompilationCue.		Association.		StandardScriptingSystem.		MessageNames.		FileServices.		ClassBinding.		Webpage current class.		FileDirectory.		Metaclass.		ClassDescription.		Behavior.		Class.		MethodDictionary.		ProtoObject.		Tether.		ExceptionMarker.		InstructionPrinter.		Author.		EditHistory.		ModuleDescription.		ModuleID.		Version.		Other.		SmalltalkImage.		Environment.		ChangeSet.		ClassChangeRecord.		MethodChangeRecord.		ToolSet.		StandardToolSet.		Message.		MessageSend.		Process.		ProcessorScheduler.		BlockClosure.		BlockContext.		SharedQueue.		TranscriptStream.		Categorizer.		Character.		ExtendedNumberParser.		JSObjectProxy.		SystemOrganizer.		Shaker.		Decompiler.		Pragma.		MultiByteFileStream.		BreakpointManager.		ZipConstants.		AbstractLauncher.		AutoStart.		ObjectHistory.		Parser.		Point.		MessageTally.		CompiledMethodTrailer.		Monitor.		IdentityTransform.		NewParagraph	}		do: [:class | self fuseProtoclass: class into: fusedMethods]! !!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 23:00' prior: 34274142!fuseSingleClassesInto: fusedMethods	{		BindingPolicy.		SocketAddressInformation.		DelayWaitTimeout.		Number.		WebUtils.		ThirtyTwoBitRegister.		SecureHashAlgorithm.		DiffElement.		ProcessBrowser.		CPUWatcher.		TransferMorph.		DeepCopier.		MethodReference.		Random.		SoundService.		ExternalObjectTable.		ChangeRecord.		SystemChangeNotifier.		ClassBuilder.		Beeper.		GZipReadStream.		InternalTranslator.		ServerDirectory.		PluggableTreeItemNode.		PluggableTreeMorph.		FilePath.		MorphicEventDispatcher.		Utilities.		Command.		WebClient.		SystemProgressMorph.		InternetConfiguration.		NetNameResolver.		ChromeExtensionUrl.		SystemNavigation.		ColorTheme.		LocaleID.		XMLNamespace.		CharacterBlock.		UndefinedObject.		LimitedWriteStream.		HttpUrl.		SystemProgressBarMorph.		HaloSpec.		ResourceManager.		RemoteString.		ListChooser.		TextKern.		TTKernPair.		Clipboard.		Latin1Environment.		EventManager.		Global.		Time.		SoundPlayer.		PopUpMenu.		SelectorBrowser.		DualChangeSorter.		TextAlignment.		FMSound.		PaintBoxColorPicker.		ThreePhaseButtonMorph.		PaintInvokingMorph.		ProjectViewMorph.		ClockMorph.		EllipseMorph.		ObjectsTool.		UpdatingSimpleButtonMorph.		CurveMorph.		MagnifierMorph.		ListItemWrapper.		ObjectExplorerWrapper.		SoundRecorder.		RecordingControlsMorph.		TimeZone.		BaseSoundSystem.		DummySoundSystem.		TraitOrganizer.		ServiceShortcuts.		ServiceCancelled.		ServiceRegistry.		ServiceGui.		ServicePreferences.		TheWorldMainDockingBar.		TraitAlias.		ClassTrait.		PragmaPreference.		Workspace.		ChangeList.		ChangeSorter.		NewColorPickerMorph.		BrowseAvailableModules.		CounterpartRequest.		InstallRemoteModule.		PreferenceBrowser.		ToolIcons.		UpdatingMenuItemMorph.		PointerFinder.		ParseNodeEnumerator.		ParseNodeVisitor.		ZipWriteStream.		ZipEncoder.		TextDomainManager.		StepMessage.		SystemWindowButton.		UTF8TextConverter.		FillInTheBlankMorph.		RealEstateAgent.		TransformMorph.		PluggableTextMorphPlus.		Preference.		WindowColorSpec.		UserDialogBoxMorph.		WindowColorRegistry.		TheWorldMenu.		PluggableListMorphPlus.		PluggableTextMorph.		TextMorphForEditView.		TextLine.		DeflateStream.		AdditionalMethodState.		Compiler.		CompilationCue.		Association.		PluggableButtonMorphPlus.		PluggablePanelMorph.		SketchMorph.		LayoutFrame.		IconicButton.		SimpleButtonMorph.		StandardScriptingSystem.		MessageNames.		FileServices.		ClassBinding.		Webpage current class.		FileDirectory.		Metaclass.		ClassDescription.		Behavior.		Class.		MethodDictionary.		DisplayText.		ProtoObject.		Tether.		ExceptionMarker.		InstructionPrinter.		Author.		EditHistory.		ModuleDescription.		ModuleID.		Version.		Other.		SmalltalkImage.		Environment.		ChangeSet.		ClassChangeRecord.		MethodChangeRecord.		ToolSet.		SystemBrowser.		StandardToolSet.		Message.		MessageSend.		Process.		ProcessorScheduler.		BlockClosure.		BlockContext.		SharedQueue.		TranscriptStream.		Categorizer.		Character.		ExtendedNumberParser.		JSObjectProxy.		SystemOrganizer.		Shaker.		Decompiler.		PolygonMorph.		SmalltalkEditor.		Pragma.		BalloonEngine.		MultiByteFileStream.		BalloonEdgeData.		BalloonFillData.		UTF8ClipboardInterpreter.		BreakpointManager.		ZipConstants.		MorphicUIManager.		MenuLineMorph.		NewBalloonMorph.		BalloonMorph.		AbstractLauncher.		AutoStart.		ObjectHistory.		Parser.		MenuMorph.		AlignmentMorph.		StringMorph.		MenuItemMorph.		MorphicTransform.		MenuIcons.		LayoutCell.		TableLayoutProperties.		Rectangle.		BorderStyle.		SimpleBorder.		TextFontReference.		Browser.		Point.		HandMorph.		PasteUpMorph.		WorldState.		MessageTally.		PluggableWindowSpec.		ScrollBar.		MorphicModel.		SHParserST80.		PluggableTextSpec.		Point.		SystemWindow.		PluggableButtonMorph.		PluggableSystemWindow.		CompiledMethodTrailer.		TextEmphasis.		SHTextStylerST80.		TextMorph.		PluggableListMorph.		LazyListMorph.		ScrollPane.		Monitor.		TextColor.		MouseOverHandler.		SHRange.		CharacterScanner.		CompositionScanner.		EventHandler.		MouseClickState.		MorphExtension.		IdentityTransform.		TopGripMorph.		TextStyle.		ProportionalSplitterMorph.		NewParagraph	}		do: [:class | self fuseProtoclass: class into: fusedMethods]! !----SNAPSHOT----{24 September 2019 . 11:00:46 pm} history.image priorSource: 1860021!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 23:09' prior: 34850861!portal: aPortal	portal := aPortal! !!Tether class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 23:11' prior: 34863377!to: url	| entrance tether |		entrance := Entrance to: url.	tether := self through: entrance.		entrance onMessage: [:message |		entrance incomingMessage: message.		tether handleEvent]..		tether waitForPeer.	^tether! !----SNAPSHOT----{24 September 2019 . 11:16:38 pm} history.image priorSource: 1866837!----SNAPSHOT----{24 September 2019 . 11:17:01 pm} history.image priorSource: 1867372!!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 23:19' prior: 35406617!shakeHeadless	| fusedMethods weakArray navigation reloadingMethod numberOfClassesRemoved |		JS debugger.	EditHistory connectTo: 'ws://localhost:8091/tether'.	weakArray := WeakArray with: Object new.	navigation := SystemNavigation new.		fusedMethods := (		(OrderedCollection new)			addAll: {				Object compiledMethodAt: #primitiveError:.				Object compiledMethodAt: #perform:.								Object compiledMethodAt: #perform:with:.				Object compiledMethodAt: #perform:with:with:.				Object compiledMethodAt: #perform:with:with:with:.				Object compiledMethodAt: #perform:with:with:with:with:.				Object compiledMethodAt: #perform:withArguments:.						Object compiledMethodAt: #perform:withArguments:inSuperclass:.						Object compiledMethodAt: #perform:withEnoughArguments:.				Object compiledMethodAt: #isSymbol.				Behavior reloadingMethod.				EditHistory compiledMethodAt: #swapInMethodAt:in:.				Object compiledMethodAt: #adaptToInteger:andSend:.				Object compiledMethodAt: #in:.				Object compiledMethodAt: #addDependent:.				Symbol compiledMethodAt: #isSymbol.				ContextPart compiledMethodAt: #selector.				ContextPart compiledMethodAt: #arguments.				CompiledMethod compiledMethodAt: #selector.				UUIDGenerator compiledMethodAt: #semaphoreForGenerator.				UUIDGenerator compiledMethodAt: #randomGenerator.				ProtoObject compiledMethodAt: #initialize.				BlockClosure compiledMethodAt: #value.				BlockContext compiledMethodAt: #value.				Semaphore compiledMethodAt: #wait.				UndefinedObject compiledMethodAt: #release.				ClassOrganizer compiledMethodAt: #traitComposition.				ByteString class compiledMethodAt: #stringHash:initialHash:};			yourself).			{		#(id isNil notNil isInteger removeFromSystem removeFromSystem: hashBytes:startingWith: size species signal resumptionTime primGetNextEvent: bitAnd: new: new negative at: at:put: bitShiftMagnitude: bitOr: < randomCounter / + asFloat bitXor: identityHash basicAt: basicAt:put: basicNew: basicNew isMethodProperties).		CompiledMethodTrailer trailerKindDecoders.	}		do: [:set |			set do: [:selector |		(navigation allImplementorsOf: selector) do: [:reference | fusedMethods add: reference compiledMethod]]].	self		fuseHeadlessSingleClassesInto: fusedMethods;		fuseHeadlessClassHierarchiesInto: fusedMethods.				fusedMethods do: [:method | method fuse].		Behavior setReloadingMethod.	reloadingMethod := Behavior reloadingMethod.	Shaker class swapOutMethodAt: #test:.	(Shaker test: 42) = 42 ifFalse: [self error: 'history system not working'].		"Set the selector and class-binding literals of the reloading method to things which make sense in the JS debugger."	Behavior setReloadingMethod.	LRUCache allInstancesDo: [:cache | cache reset].	WeakArray restartFinalizationProcess.	[3 error: 'ignored'] on: Error do: [:exception | ].	Delay initialize.	(Delay forSeconds: 1) wait.		{		BlockClosure.		ContextPart	}		do: [:class |			class allSubInstancesDo: [:methodHolder | methodHolder fuse]].		JS at: #shaking put: true.	Smalltalk		primitiveGarbageCollect;		primitiveFusedGarbageCollect;		primitiveFusedGarbageCollect.			numberOfClassesRemoved := -1.		[numberOfClassesRemoved = 0] whileFalse: [		numberOfClassesRemoved := 0.		(Class allSubclasses asSortedCollection: [:earlier :later | earlier depth <= later depth]) asArray reversed do: [:metaclass |			(				metaclass soleInstance subclasses isEmpty not or: [					{						metaclass.						metaclass soleInstance					}						anySatisfy: [:behavior |							behavior methodDict anySatisfy: [:method | method ~~ reloadingMethod]]]			)				ifFalse: [					metaclass soleInstance removeFromSystem.					numberOfClassesRemoved := numberOfClassesRemoved + 1]]].		Smalltalk garbageCollect! !----SNAPSHOT----{24 September 2019 . 11:20:05 pm} history.image priorSource: 1867459!!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 23:21' prior: 35422067!shakeHeadless	| fusedMethods weakArray navigation reloadingMethod numberOfClassesRemoved |		EditHistory connectTo: 'ws://localhost:8091/tether'.	weakArray := WeakArray with: Object new.	navigation := SystemNavigation new.		fusedMethods := (		(OrderedCollection new)			addAll: {				Object compiledMethodAt: #primitiveError:.				Object compiledMethodAt: #perform:.								Object compiledMethodAt: #perform:with:.				Object compiledMethodAt: #perform:with:with:.				Object compiledMethodAt: #perform:with:with:with:.				Object compiledMethodAt: #perform:with:with:with:with:.				Object compiledMethodAt: #perform:withArguments:.						Object compiledMethodAt: #perform:withArguments:inSuperclass:.						Object compiledMethodAt: #perform:withEnoughArguments:.				Object compiledMethodAt: #isSymbol.				Behavior reloadingMethod.				EditHistory compiledMethodAt: #swapInMethodAt:in:.				Object compiledMethodAt: #adaptToInteger:andSend:.				Object compiledMethodAt: #in:.				Object compiledMethodAt: #addDependent:.				Symbol compiledMethodAt: #isSymbol.				ContextPart compiledMethodAt: #selector.				ContextPart compiledMethodAt: #arguments.				CompiledMethod compiledMethodAt: #selector.				UUIDGenerator compiledMethodAt: #semaphoreForGenerator.				UUIDGenerator compiledMethodAt: #randomGenerator.				ProtoObject compiledMethodAt: #initialize.				BlockClosure compiledMethodAt: #value.				BlockContext compiledMethodAt: #value.				Semaphore compiledMethodAt: #wait.				UndefinedObject compiledMethodAt: #release.				ClassOrganizer compiledMethodAt: #traitComposition.				ByteString class compiledMethodAt: #stringHash:initialHash:};			yourself).			{		#(id isNil notNil isInteger removeFromSystem removeFromSystem: hashBytes:startingWith: size species signal resumptionTime primGetNextEvent: bitAnd: new: new negative at: at:put: bitShiftMagnitude: bitOr: < randomCounter / + asFloat bitXor: identityHash basicAt: basicAt:put: basicNew: basicNew isMethodProperties).		CompiledMethodTrailer trailerKindDecoders.	}		do: [:set |			set do: [:selector |		(navigation allImplementorsOf: selector) do: [:reference | fusedMethods add: reference compiledMethod]]].	self		fuseHeadlessSingleClassesInto: fusedMethods;		fuseHeadlessClassHierarchiesInto: fusedMethods.				fusedMethods do: [:method | method fuse].		Behavior setReloadingMethod.	reloadingMethod := Behavior reloadingMethod.	Shaker class swapOutMethodAt: #test:.	(Shaker test: 42) = 42 ifFalse: [self error: 'history system not working'].		"Set the selector and class-binding literals of the reloading method to things which make sense in the JS debugger."	Behavior setReloadingMethod.	LRUCache allInstancesDo: [:cache | cache reset].	WeakArray restartFinalizationProcess.	[3 error: 'ignored'] on: Error do: [:exception | ].	Delay initialize.	(Delay forSeconds: 1) wait.		{		BlockClosure.		ContextPart	}		do: [:class |			class allSubInstancesDo: [:methodHolder | methodHolder fuse]].		JS at: #shaking put: true.	Smalltalk		primitiveGarbageCollect;		primitiveFusedGarbageCollect;		primitiveFusedGarbageCollect.			numberOfClassesRemoved := -1.		[numberOfClassesRemoved = 0] whileFalse: [		numberOfClassesRemoved := 0.		(Class allSubclasses asSortedCollection: [:earlier :later | earlier depth <= later depth]) asArray reversed do: [:metaclass |			(				metaclass soleInstance subclasses isEmpty not or: [					{						metaclass.						metaclass soleInstance					}						anySatisfy: [:behavior |							behavior methodDict anySatisfy: [:method | method ~~ reloadingMethod]]]			)				ifFalse: [					metaclass soleInstance removeFromSystem.					numberOfClassesRemoved := numberOfClassesRemoved + 1]]].		Smalltalk garbageCollect! !----QUIT----{24 September 2019 . 11:39:34 pm} history.image priorSource: 1871416!----STARTUP----{24 September 2019 . 11:50:14 pm} as /Users/craig/Downloads/caffeine/backups/37 (headless)/history.image!----SNAPSHOT----{24 September 2019 . 11:50:28 pm} history.image priorSource: 1875359!EditHistory local!EditHistory new.!EditHistory rememberAllActiveClasses.!EditHistory rememberAllMethods!EditHistory local!----SNAPSHOT----{24 September 2019 . 11:54:23 pm} history.image priorSource: 1875565!!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 00:04' prior: 35403235!fuseHeadlessClassHierarchiesInto: fusedMethods	"Fuse entire class hierarchies."	{		NamePolicy.		FileDirectory.		SocketStream.		WebMessage.		Socket.		MimeConverter.		ProcessSpecificVariable.		ClassCategoryReader.		DirectoryEntry.		SimpleServiceEntry.		WebSocket.		InstructionClient.		CodeHolder.		Collection.		CharacterScanner.		CommandHistory.		LanguageEnvironment.		ParseNodeVisitor.		EncodedCharSet.		SharedPool.		BasicRequestor.
		ServiceProvider.		ServiceAction.		TextDiffBuilder.		HostPlatform.		BlockStartLocator.		DebuggerMethodMap.		ParseNode.		Preferences.		Number.		ContextPart.		Project.		Boolean.		Exception.		Collection.		Edition.		MethodLiteralTransmissionMarker.		Portal.		License.		Manifest.		BitMatchingPattern.		JSObject.		ByteTextConverter.	}		do: [:class | self fuseSuperclass: class into: fusedMethods]! !!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 00:04' prior: 34272256!fuseClassHierarchiesInto: fusedMethods	"Fuse entire class hierarchies."	{		NamePolicy.		FileDirectory.		PluggableListMorph.		SocketStream.		WebMessage.		Socket.		MimeConverter.		ProcessSpecificVariable.		AbstractSound.		ClassCategoryReader.		ImageReadWriter.		IndentingListItemMorph.		DirectoryEntry.		SimpleServiceEntry.		WebSocket.		InstructionClient.		SystemWindow.		FileList.		CodeHolder.		Collection.		CharacterScanner.		MorphicEvent.		Inspector.		CommandHistory.		DAVResource.		LanguageEnvironment.		BitBlt.		ParseNodeVisitor.		EncodedCharSet.		LayoutPolicy.		TTGlyph.		Envelope.		SharedPool.		BasicRequestor.
		ServiceProvider.		ServiceAction.		PreferenceBrowserMorph.		TextDiffBuilder.		HostPlatform.		FillStyle.		BorderStyle.		BlockStartLocator.		TextComposer.		AbstractResizerMorph.		DebuggerMethodMap.		AbstractFont.		ToolBuilderSpec.		ParseNode.		ToolBuilder.		UserInputEvent.		Preferences.		AbstractEvent.		Number.		InputSensor.		ContextPart.		Debugger.		Project.		Boolean.		Exception.		Collection.		Edition.		MethodLiteralTransmissionMarker.		Portal.		License.		Manifest.		BitMatchingPattern.		Inspector.		JSObject.		Canvas.		ByteTextConverter.		Form.		Color	}		do: [:class | self fuseSuperclass: class into: fusedMethods]! !----SNAPSHOT----{25 September 2019 . 12:04:32 am} history.image priorSource: 1875784!	SmalltalkImage classPool at: #ShutDownList.!	SmalltalkImage classPool at: #ShutDownList.!!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 01:13' prior: 35426024!shakeHeadless	| fusedMethods weakArray navigation reloadingMethod numberOfClassesRemoved |		(SmalltalkImage classPool)		at: #ShutDownList		put: #(#TTFileDescription #InternetConfiguration #TTCFont #ArchiveViewer #CPUWatcher #ProcessBrowser #ExternalSettings #Symbol #SecurityManager #AutoStart #FileStream #CommandHistory #StrikeFontSet #MessageTally #ImageSegment #Password #HttpUrl #SoundPlayer #FileDirectory #Color #StrikeFont #PasteUpMorph #ControlManager #InputSensor #DisplayScreen #Delay) asOrderedCollection.			EditHistory connectTo: 'ws://localhost:8091/tether'.	weakArray := WeakArray with: Object new.	navigation := SystemNavigation new.		fusedMethods := (		(OrderedCollection new)			addAll: {				Object compiledMethodAt: #primitiveError:.				Object compiledMethodAt: #perform:.								Object compiledMethodAt: #perform:with:.				Object compiledMethodAt: #perform:with:with:.				Object compiledMethodAt: #perform:with:with:with:.				Object compiledMethodAt: #perform:with:with:with:with:.				Object compiledMethodAt: #perform:withArguments:.						Object compiledMethodAt: #perform:withArguments:inSuperclass:.						Object compiledMethodAt: #perform:withEnoughArguments:.				Object compiledMethodAt: #isSymbol.				Behavior reloadingMethod.				EditHistory compiledMethodAt: #swapInMethodAt:in:.				Object compiledMethodAt: #adaptToInteger:andSend:.				Object compiledMethodAt: #in:.				Object compiledMethodAt: #addDependent:.				Symbol compiledMethodAt: #isSymbol.				ContextPart compiledMethodAt: #selector.				ContextPart compiledMethodAt: #arguments.				CompiledMethod compiledMethodAt: #selector.				UUIDGenerator compiledMethodAt: #semaphoreForGenerator.				UUIDGenerator compiledMethodAt: #randomGenerator.				ProtoObject compiledMethodAt: #initialize.				BlockClosure compiledMethodAt: #value.				BlockContext compiledMethodAt: #value.				Semaphore compiledMethodAt: #wait.				UndefinedObject compiledMethodAt: #release.				ClassOrganizer compiledMethodAt: #traitComposition.				ByteString class compiledMethodAt: #stringHash:initialHash:};			yourself).			{		#(id isNil notNil isInteger removeFromSystem removeFromSystem: hashBytes:startingWith: size species signal resumptionTime primGetNextEvent: bitAnd: new: new negative at: at:put: bitShiftMagnitude: bitOr: < randomCounter / + asFloat bitXor: identityHash basicAt: basicAt:put: basicNew: basicNew isMethodProperties).		CompiledMethodTrailer trailerKindDecoders.	}		do: [:set |			set do: [:selector |		(navigation allImplementorsOf: selector) do: [:reference | fusedMethods add: reference compiledMethod]]].	self		fuseHeadlessSingleClassesInto: fusedMethods;		fuseHeadlessClassHierarchiesInto: fusedMethods.				fusedMethods do: [:method | method fuse].		Behavior setReloadingMethod.	reloadingMethod := Behavior reloadingMethod.	Shaker class swapOutMethodAt: #test:.	(Shaker test: 42) = 42 ifFalse: [self error: 'history system not working'].		"Set the selector and class-binding literals of the reloading method to things which make sense in the JS debugger."	Behavior setReloadingMethod.	LRUCache allInstancesDo: [:cache | cache reset].	WeakArray restartFinalizationProcess.	[3 error: 'ignored'] on: Error do: [:exception | ].	Delay initialize.	(Delay forSeconds: 1) wait.		{		BlockClosure.		ContextPart	}		do: [:class |			class allSubInstancesDo: [:methodHolder | methodHolder fuse]].		JS at: #shaking put: true.	Smalltalk		primitiveGarbageCollect;		primitiveFusedGarbageCollect;		primitiveFusedGarbageCollect.			numberOfClassesRemoved := -1.		[numberOfClassesRemoved = 0] whileFalse: [		numberOfClassesRemoved := 0.		(Class allSubclasses asSortedCollection: [:earlier :later | earlier depth <= later depth]) asArray reversed do: [:metaclass |			(				metaclass soleInstance subclasses isEmpty not or: [					{						metaclass.						metaclass soleInstance					}						anySatisfy: [:behavior |							behavior methodDict anySatisfy: [:method | method ~~ reloadingMethod]]]			)				ifFalse: [					metaclass soleInstance removeFromSystem.					numberOfClassesRemoved := numberOfClassesRemoved + 1]]].		Smalltalk garbageCollect! !----SNAPSHOT----{25 September 2019 . 1:14:40 am} history.image priorSource: 1878235!!SmalltalkImage methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 01:21' prior: 18804579!snapshot: save andQuit: quit withExitCode: exitCode embedded: embeddedFlag	"Mark the changes file and close all files as part of #processShutdownList.	If save is true, save the current state of this Smalltalk in the image file.	If quit is true, then exit to the outer OS shell.	If exitCode is not nil, then use it as exit code.	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."	| resuming msg |	Object flushDependents.	Object flushEvents.	(SourceFiles at: 2) ifNotNil:[		msg := String streamContents: [ :s |			s nextPutAll: '----';			nextPutAll: (save ifTrue: [ quit ifTrue: [ 'QUIT' ] ifFalse: [ 'SNAPSHOT' ] ]							ifFalse: [quit ifTrue: [ 'QUIT/NOSAVE' ] ifFalse: [ 'NOP' ]]);			nextPutAll: '----';			print: Date dateAndTimeNow; space;			nextPutAll: (FileDirectory default localNameFor: self imageName);			nextPutAll: ' priorSource: ';			print: LastQuitLogPosition ].		self assureStartupStampLogged.		save ifTrue: [ LastQuitLogPosition := (SourceFiles at: 2) setToEnd; position ].		self logChange: msg.		Transcript cr; show: msg	].	Smalltalk processShutDownList: quit.	Cursor write show.	save ifTrue: [resuming := embeddedFlag 					ifTrue: [self snapshotEmbeddedPrimitive] 					ifFalse: [self snapshotPrimitive].  "<-- PC frozen here on image file"				resuming == false "guard against failure" ifTrue:					[]]		ifFalse: [resuming := false].	quit & (resuming == false) ifTrue: [		exitCode			ifNil: [ self quitPrimitive ]			ifNotNil: [ self quitPrimitive: exitCode ] ].	Cursor normal show.	Smalltalk setGCParameters.	resuming == true ifTrue: [Smalltalk clearExternalObjects].	Smalltalk processStartUpList: resuming == true.	resuming == true ifTrue:[		self setPlatformPreferences.		self recordStartupStamp].	Project current wakeUpTopWindow.	"Now it's time to raise an error"	resuming == nil ifTrue: [self error:'Failed to write image file (disk full?)'].	^ resuming! !----SNAPSHOT----{25 September 2019 . 1:22:01 am} history.image priorSource: 1882704!!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 01:42' prior: 35414629!fuseHeadlessSingleClassesInto: fusedMethods	{		Date.		BindingPolicy.		SocketAddressInformation.		DelayWaitTimeout.		Number.		WebUtils.		ThirtyTwoBitRegister.		SecureHashAlgorithm.		DiffElement.		ProcessBrowser.		CPUWatcher.		DeepCopier.		MethodReference.		Random.		ExternalObjectTable.		ChangeRecord.		SystemChangeNotifier.		ClassBuilder.		Beeper.		GZipReadStream.		InternalTranslator.		ServerDirectory.		FilePath.		Utilities.		Command.		WebClient.		InternetConfiguration.		NetNameResolver.		ChromeExtensionUrl.		SystemNavigation.		LocaleID.		XMLNamespace.		CharacterBlock.		UndefinedObject.		LimitedWriteStream.		HttpUrl.		ResourceManager.		RemoteString.		Latin1Environment.		Global.		Time.		TimeZone.		TraitOrganizer.		ServiceShortcuts.		ServiceCancelled.		ServiceRegistry.		ServicePreferences.		TraitAlias.		ClassTrait.		PragmaPreference.		BrowseAvailableModules.		CounterpartRequest.		InstallRemoteModule.		PointerFinder.		ParseNodeEnumerator.		ParseNodeVisitor.		ZipWriteStream.		ZipEncoder.		TextDomainManager.		StepMessage.		UTF8TextConverter.		Preference.		TextLine.		DeflateStream.		AdditionalMethodState.		Compiler.		CompilationCue.		Association.		StandardScriptingSystem.		MessageNames.		FileServices.		ClassBinding.		Webpage current class.		FileDirectory.		Metaclass.		ClassDescription.		Behavior.		Class.		MethodDictionary.		ProtoObject.		Tether.		ExceptionMarker.		InstructionPrinter.		Author.		EditHistory.		ModuleDescription.		ModuleID.		Version.		Other.		SmalltalkImage.		Environment.		ChangeSet.		ClassChangeRecord.		MethodChangeRecord.		ToolSet.		StandardToolSet.		Message.		MessageSend.		Process.		ProcessorScheduler.		BlockClosure.		BlockContext.		SharedQueue.		TranscriptStream.		Categorizer.		Character.		ExtendedNumberParser.		JSObjectProxy.		SystemOrganizer.		Shaker.		Decompiler.		Pragma.		MultiByteFileStream.		BreakpointManager.		ZipConstants.		AbstractLauncher.		AutoStart.		ObjectHistory.		Parser.		Point.		MessageTally.		CompiledMethodTrailer.		Monitor.		IdentityTransform.		NewParagraph	}		do: [:class | self fuseProtoclass: class into: fusedMethods]! !!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 01:42' prior: 35416923!fuseSingleClassesInto: fusedMethods	{		Date.		BindingPolicy.		SocketAddressInformation.		DelayWaitTimeout.		Number.		WebUtils.		ThirtyTwoBitRegister.		SecureHashAlgorithm.		DiffElement.		ProcessBrowser.		CPUWatcher.		TransferMorph.		DeepCopier.		MethodReference.		Random.		SoundService.		ExternalObjectTable.		ChangeRecord.		SystemChangeNotifier.		ClassBuilder.		Beeper.		GZipReadStream.		InternalTranslator.		ServerDirectory.		PluggableTreeItemNode.		PluggableTreeMorph.		FilePath.		MorphicEventDispatcher.		Utilities.		Command.		WebClient.		SystemProgressMorph.		InternetConfiguration.		NetNameResolver.		ChromeExtensionUrl.		SystemNavigation.		ColorTheme.		LocaleID.		XMLNamespace.		CharacterBlock.		UndefinedObject.		LimitedWriteStream.		HttpUrl.		SystemProgressBarMorph.		HaloSpec.		ResourceManager.		RemoteString.		ListChooser.		TextKern.		TTKernPair.		Clipboard.		Latin1Environment.		EventManager.		Global.		Time.		SoundPlayer.		PopUpMenu.		SelectorBrowser.		DualChangeSorter.		TextAlignment.		FMSound.		PaintBoxColorPicker.		ThreePhaseButtonMorph.		PaintInvokingMorph.		ProjectViewMorph.		ClockMorph.		EllipseMorph.		ObjectsTool.		UpdatingSimpleButtonMorph.		CurveMorph.		MagnifierMorph.		ListItemWrapper.		ObjectExplorerWrapper.		SoundRecorder.		RecordingControlsMorph.		TimeZone.		BaseSoundSystem.		DummySoundSystem.		TraitOrganizer.		ServiceShortcuts.		ServiceCancelled.		ServiceRegistry.		ServiceGui.		ServicePreferences.		TheWorldMainDockingBar.		TraitAlias.		ClassTrait.		PragmaPreference.		Workspace.		ChangeList.		ChangeSorter.		NewColorPickerMorph.		BrowseAvailableModules.		CounterpartRequest.		InstallRemoteModule.		PreferenceBrowser.		ToolIcons.		UpdatingMenuItemMorph.		PointerFinder.		ParseNodeEnumerator.		ParseNodeVisitor.		ZipWriteStream.		ZipEncoder.		TextDomainManager.		StepMessage.		SystemWindowButton.		UTF8TextConverter.		FillInTheBlankMorph.		RealEstateAgent.		TransformMorph.		PluggableTextMorphPlus.		Preference.		WindowColorSpec.		UserDialogBoxMorph.		WindowColorRegistry.		TheWorldMenu.		PluggableListMorphPlus.		PluggableTextMorph.		TextMorphForEditView.		TextLine.		DeflateStream.		AdditionalMethodState.		Compiler.		CompilationCue.		Association.		PluggableButtonMorphPlus.		PluggablePanelMorph.		SketchMorph.		LayoutFrame.		IconicButton.		SimpleButtonMorph.		StandardScriptingSystem.		MessageNames.		FileServices.		ClassBinding.		Webpage current class.		FileDirectory.		Metaclass.		ClassDescription.		Behavior.		Class.		MethodDictionary.		DisplayText.		ProtoObject.		Tether.		ExceptionMarker.		InstructionPrinter.		Author.		EditHistory.		ModuleDescription.		ModuleID.		Version.		Other.		SmalltalkImage.		Environment.		ChangeSet.		ClassChangeRecord.		MethodChangeRecord.		ToolSet.		SystemBrowser.		StandardToolSet.		Message.		MessageSend.		Process.		ProcessorScheduler.		BlockClosure.		BlockContext.		SharedQueue.		TranscriptStream.		Categorizer.		Character.		ExtendedNumberParser.		JSObjectProxy.		SystemOrganizer.		Shaker.		Decompiler.		PolygonMorph.		SmalltalkEditor.		Pragma.		BalloonEngine.		MultiByteFileStream.		BalloonEdgeData.		BalloonFillData.		UTF8ClipboardInterpreter.		BreakpointManager.		ZipConstants.		MorphicUIManager.		MenuLineMorph.		NewBalloonMorph.		BalloonMorph.		AbstractLauncher.		AutoStart.		ObjectHistory.		Parser.		MenuMorph.		AlignmentMorph.		StringMorph.		MenuItemMorph.		MorphicTransform.		MenuIcons.		LayoutCell.		TableLayoutProperties.		Rectangle.		BorderStyle.		SimpleBorder.		TextFontReference.		Browser.		Point.		HandMorph.		PasteUpMorph.		WorldState.		MessageTally.		PluggableWindowSpec.		ScrollBar.		MorphicModel.		SHParserST80.		PluggableTextSpec.		Point.		SystemWindow.		PluggableButtonMorph.		PluggableSystemWindow.		CompiledMethodTrailer.		TextEmphasis.		SHTextStylerST80.		TextMorph.		PluggableListMorph.		LazyListMorph.		ScrollPane.		Monitor.		TextColor.		MouseOverHandler.		SHRange.		CharacterScanner.		CompositionScanner.		EventHandler.		MouseClickState.		MorphExtension.		IdentityTransform.		TopGripMorph.		TextStyle.		ProportionalSplitterMorph.		NewParagraph	}		do: [:class | self fuseProtoclass: class into: fusedMethods]! !----SNAPSHOT----{25 September 2019 . 1:42:45 am} history.image priorSource: 1884906!!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 01:52' prior: 35439513!fuseHeadlessSingleClassesInto: fusedMethods	{		WeakKeyAssociation.		WeakFinalizationList.		EnvironmentInfo.		WeakFinalizerItem.		Date.		BindingPolicy.		SocketAddressInformation.		DelayWaitTimeout.		Number.		WebUtils.		ThirtyTwoBitRegister.		SecureHashAlgorithm.		DiffElement.		ProcessBrowser.		CPUWatcher.		DeepCopier.		MethodReference.		Random.		ExternalObjectTable.		ChangeRecord.		SystemChangeNotifier.		ClassBuilder.		Beeper.		GZipReadStream.		InternalTranslator.		ServerDirectory.		FilePath.		Utilities.		Command.		WebClient.		InternetConfiguration.		NetNameResolver.		ChromeExtensionUrl.		SystemNavigation.		LocaleID.		XMLNamespace.		CharacterBlock.		UndefinedObject.		LimitedWriteStream.		HttpUrl.		ResourceManager.		RemoteString.		Latin1Environment.		Global.		Time.		TimeZone.		TraitOrganizer.		ServiceShortcuts.		ServiceCancelled.		ServiceRegistry.		ServicePreferences.		TraitAlias.		ClassTrait.		PragmaPreference.		BrowseAvailableModules.		CounterpartRequest.		InstallRemoteModule.		PointerFinder.		ParseNodeEnumerator.		ParseNodeVisitor.		ZipWriteStream.		ZipEncoder.		TextDomainManager.		StepMessage.		UTF8TextConverter.		Preference.		TextLine.		DeflateStream.		AdditionalMethodState.		Compiler.		CompilationCue.		Association.		StandardScriptingSystem.		MessageNames.		FileServices.		ClassBinding.		Webpage current class.		FileDirectory.		Metaclass.		ClassDescription.		Behavior.		Class.		MethodDictionary.		ProtoObject.		Tether.		ExceptionMarker.		InstructionPrinter.		Author.		EditHistory.		ModuleDescription.		ModuleID.		Version.		Other.		SmalltalkImage.		Environment.		ChangeSet.		ClassChangeRecord.		MethodChangeRecord.		ToolSet.		StandardToolSet.		Message.		MessageSend.		Process.		ProcessorScheduler.		BlockClosure.		BlockContext.		SharedQueue.		TranscriptStream.		Categorizer.		Character.		ExtendedNumberParser.		JSObjectProxy.		SystemOrganizer.		Shaker.		Decompiler.		Pragma.		MultiByteFileStream.		BreakpointManager.		ZipConstants.		AbstractLauncher.		AutoStart.		ObjectHistory.		Parser.		Point.		MessageTally.		CompiledMethodTrailer.		Monitor.		IdentityTransform.		NewParagraph	}		do: [:class | self fuseProtoclass: class into: fusedMethods]! !!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 01:53' prior: 35441815!fuseSingleClassesInto: fusedMethods	{		WeakKeyAssociation.		WeakFinalizationList.		EnvironmentInfo.		WeakFinalizerItem.		Date.		BindingPolicy.		SocketAddressInformation.		DelayWaitTimeout.		Number.		WebUtils.		ThirtyTwoBitRegister.		SecureHashAlgorithm.		DiffElement.		ProcessBrowser.		CPUWatcher.		TransferMorph.		DeepCopier.		MethodReference.		Random.		SoundService.		ExternalObjectTable.		ChangeRecord.		SystemChangeNotifier.		ClassBuilder.		Beeper.		GZipReadStream.		InternalTranslator.		ServerDirectory.		PluggableTreeItemNode.		PluggableTreeMorph.		FilePath.		MorphicEventDispatcher.		Utilities.		Command.		WebClient.		SystemProgressMorph.		InternetConfiguration.		NetNameResolver.		ChromeExtensionUrl.		SystemNavigation.		ColorTheme.		LocaleID.		XMLNamespace.		CharacterBlock.		UndefinedObject.		LimitedWriteStream.		HttpUrl.		SystemProgressBarMorph.		HaloSpec.		ResourceManager.		RemoteString.		ListChooser.		TextKern.		TTKernPair.		Clipboard.		Latin1Environment.		EventManager.		Global.		Time.		SoundPlayer.		PopUpMenu.		SelectorBrowser.		DualChangeSorter.		TextAlignment.		FMSound.		PaintBoxColorPicker.		ThreePhaseButtonMorph.		PaintInvokingMorph.		ProjectViewMorph.		ClockMorph.		EllipseMorph.		ObjectsTool.		UpdatingSimpleButtonMorph.		CurveMorph.		MagnifierMorph.		ListItemWrapper.		ObjectExplorerWrapper.		SoundRecorder.		RecordingControlsMorph.		TimeZone.		BaseSoundSystem.		DummySoundSystem.		TraitOrganizer.		ServiceShortcuts.		ServiceCancelled.		ServiceRegistry.		ServiceGui.		ServicePreferences.		TheWorldMainDockingBar.		TraitAlias.		ClassTrait.		PragmaPreference.		Workspace.		ChangeList.		ChangeSorter.		NewColorPickerMorph.		BrowseAvailableModules.		CounterpartRequest.		InstallRemoteModule.		PreferenceBrowser.		ToolIcons.		UpdatingMenuItemMorph.		PointerFinder.		ParseNodeEnumerator.		ParseNodeVisitor.		ZipWriteStream.		ZipEncoder.		TextDomainManager.		StepMessage.		SystemWindowButton.		UTF8TextConverter.		FillInTheBlankMorph.		RealEstateAgent.		TransformMorph.		PluggableTextMorphPlus.		Preference.		WindowColorSpec.		UserDialogBoxMorph.		WindowColorRegistry.		TheWorldMenu.		PluggableListMorphPlus.		PluggableTextMorph.		TextMorphForEditView.		TextLine.		DeflateStream.		AdditionalMethodState.		Compiler.		CompilationCue.		Association.		PluggableButtonMorphPlus.		PluggablePanelMorph.		SketchMorph.		LayoutFrame.		IconicButton.		SimpleButtonMorph.		StandardScriptingSystem.		MessageNames.		FileServices.		ClassBinding.		Webpage current class.		FileDirectory.		Metaclass.		ClassDescription.		Behavior.		Class.		MethodDictionary.		DisplayText.		ProtoObject.		Tether.		ExceptionMarker.		InstructionPrinter.		Author.		EditHistory.		ModuleDescription.		ModuleID.		Version.		Other.		SmalltalkImage.		Environment.		ChangeSet.		ClassChangeRecord.		MethodChangeRecord.		ToolSet.		SystemBrowser.		StandardToolSet.		Message.		MessageSend.		Process.		ProcessorScheduler.		BlockClosure.		BlockContext.		SharedQueue.		TranscriptStream.		Categorizer.		Character.		ExtendedNumberParser.		JSObjectProxy.		SystemOrganizer.		Shaker.		Decompiler.		PolygonMorph.		SmalltalkEditor.		Pragma.		BalloonEngine.		MultiByteFileStream.		BalloonEdgeData.		BalloonFillData.		UTF8ClipboardInterpreter.		BreakpointManager.		ZipConstants.		MorphicUIManager.		MenuLineMorph.		NewBalloonMorph.		BalloonMorph.		AbstractLauncher.		AutoStart.		ObjectHistory.		Parser.		MenuMorph.		AlignmentMorph.		StringMorph.		MenuItemMorph.		MorphicTransform.		MenuIcons.		LayoutCell.		TableLayoutProperties.		Rectangle.		BorderStyle.		SimpleBorder.		TextFontReference.		Browser.		Point.		HandMorph.		PasteUpMorph.		WorldState.		MessageTally.		PluggableWindowSpec.		ScrollBar.		MorphicModel.		SHParserST80.		PluggableTextSpec.		Point.		SystemWindow.		PluggableButtonMorph.		PluggableSystemWindow.		CompiledMethodTrailer.		TextEmphasis.		SHTextStylerST80.		TextMorph.		PluggableListMorph.		LazyListMorph.		ScrollPane.		Monitor.		TextColor.		MouseOverHandler.		SHRange.		CharacterScanner.		CompositionScanner.		EventHandler.		MouseClickState.		MorphExtension.		IdentityTransform.		TopGripMorph.		TextStyle.		ProportionalSplitterMorph.		NewParagraph	}		do: [:class | self fuseProtoclass: class into: fusedMethods]! !!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 01:54' prior: 35432937!shakeHeadless	| fusedMethods weakArray navigation reloadingMethod numberOfClassesRemoved |		(SmalltalkImage classPool)		at: #ShutDownList		put: #(#TTFileDescription #InternetConfiguration #TTCFont #ArchiveViewer #CPUWatcher #ProcessBrowser #ExternalSettings #Symbol #SecurityManager #AutoStart #FileStream #CommandHistory #StrikeFontSet #MessageTally #ImageSegment #Password #HttpUrl #SoundPlayer #FileDirectory #Color #StrikeFont #PasteUpMorph #ControlManager #DisplayScreen #Delay) asOrderedCollection.			EditHistory connectTo: 'ws://localhost:8091/tether'.	weakArray := WeakArray with: Object new.	navigation := SystemNavigation new.		fusedMethods := (		(OrderedCollection new)			addAll: {				Object compiledMethodAt: #primitiveError:.				Object compiledMethodAt: #perform:.								Object compiledMethodAt: #perform:with:.				Object compiledMethodAt: #perform:with:with:.				Object compiledMethodAt: #perform:with:with:with:.				Object compiledMethodAt: #perform:with:with:with:with:.				Object compiledMethodAt: #perform:withArguments:.						Object compiledMethodAt: #perform:withArguments:inSuperclass:.						Object compiledMethodAt: #perform:withEnoughArguments:.				Object compiledMethodAt: #isSymbol.				Behavior reloadingMethod.				EditHistory compiledMethodAt: #swapInMethodAt:in:.				Object compiledMethodAt: #adaptToInteger:andSend:.				Object compiledMethodAt: #in:.				Object compiledMethodAt: #addDependent:.				Symbol compiledMethodAt: #isSymbol.				ContextPart compiledMethodAt: #selector.				ContextPart compiledMethodAt: #arguments.				CompiledMethod compiledMethodAt: #selector.				UUIDGenerator compiledMethodAt: #semaphoreForGenerator.				UUIDGenerator compiledMethodAt: #randomGenerator.				ProtoObject compiledMethodAt: #initialize.				BlockClosure compiledMethodAt: #value.				BlockContext compiledMethodAt: #value.				Semaphore compiledMethodAt: #wait.				UndefinedObject compiledMethodAt: #release.				ClassOrganizer compiledMethodAt: #traitComposition.				ByteString class compiledMethodAt: #stringHash:initialHash:};			yourself).			{		#(id isNil notNil isInteger removeFromSystem removeFromSystem: hashBytes:startingWith: size species signal resumptionTime primGetNextEvent: bitAnd: new: new negative at: at:put: bitShiftMagnitude: bitOr: < randomCounter / + asFloat bitXor: identityHash basicAt: basicAt:put: basicNew: basicNew isMethodProperties).		CompiledMethodTrailer trailerKindDecoders.	}		do: [:set |			set do: [:selector |		(navigation allImplementorsOf: selector) do: [:reference | fusedMethods add: reference compiledMethod]]].	self		fuseHeadlessSingleClassesInto: fusedMethods;		fuseHeadlessClassHierarchiesInto: fusedMethods.				fusedMethods do: [:method | method fuse].		Behavior setReloadingMethod.	reloadingMethod := Behavior reloadingMethod.	Shaker class swapOutMethodAt: #test:.	(Shaker test: 42) = 42 ifFalse: [self error: 'history system not working'].		"Set the selector and class-binding literals of the reloading method to things which make sense in the JS debugger."	Behavior setReloadingMethod.	LRUCache allInstancesDo: [:cache | cache reset].	WeakArray restartFinalizationProcess.	[3 error: 'ignored'] on: Error do: [:exception | ].	Delay initialize.	(Delay forSeconds: 1) wait.		{		BlockClosure.		ContextPart	}		do: [:class |			class allSubInstancesDo: [:methodHolder | methodHolder fuse]].		JS at: #shaking put: true.	Smalltalk		primitiveGarbageCollect;		primitiveFusedGarbageCollect;		primitiveFusedGarbageCollect.			numberOfClassesRemoved := -1.		[numberOfClassesRemoved = 0] whileFalse: [		numberOfClassesRemoved := 0.		(Class allSubclasses asSortedCollection: [:earlier :later | earlier depth <= later depth]) asArray reversed do: [:metaclass |			(				metaclass soleInstance subclasses isEmpty not or: [					{						metaclass.						metaclass soleInstance					}						anySatisfy: [:behavior |							behavior methodDict anySatisfy: [:method | method ~~ reloadingMethod]]]			)				ifFalse: [					metaclass soleInstance removeFromSystem.					numberOfClassesRemoved := numberOfClassesRemoved + 1]]].		Smalltalk garbageCollect! !----SNAPSHOT----{25 September 2019 . 1:54:38 am} history.image priorSource: 1891737!(SmalltalkImage classPool)		at: #StartUpList!!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 02:14' prior: 35453261!shakeHeadless	| fusedMethods weakArray navigation reloadingMethod numberOfClassesRemoved |		(SmalltalkImage classPool)		at: #ShutDownList		put: #(#TTFileDescription #InternetConfiguration #TTCFont #ArchiveViewer #CPUWatcher #ProcessBrowser #ExternalSettings #Symbol #SecurityManager #AutoStart #FileStream #CommandHistory #StrikeFontSet #MessageTally #ImageSegment #Password #HttpUrl #SoundPlayer #FileDirectory #Color #StrikeFont #PasteUpMorph #ControlManager #DisplayScreen #Delay) asOrderedCollection.			(SmalltalkImage classPool)		at: #StartUpList		put: #(#SmallInteger #Delay #Other #HostPlatform #WebEntrance #ProcessorScheduler #FileDirectory #ShortIntegerArray #ShortRunArray #MessageTally #NaturalLanguageTranslator #LanguageEnvironment #PowerManagement #ExternalSettings #SecurityManager #FileStream #UUIDGenerator #CPUWatcher #DateAndTime #SmalltalkImage #Utilities #WeakArray #MultiByteFileStream #InternetConfiguration #Locale #Collection #HostWindowProxy #NetNameResolver #Caffeine #Worker #Webpage #ExternalResource) asOrderedCollection.	EditHistory connectTo: 'ws://localhost:8091/tether'.	weakArray := WeakArray with: Object new.	navigation := SystemNavigation new.		fusedMethods := (		(OrderedCollection new)			addAll: {				Object compiledMethodAt: #primitiveError:.				Object compiledMethodAt: #perform:.								Object compiledMethodAt: #perform:with:.				Object compiledMethodAt: #perform:with:with:.				Object compiledMethodAt: #perform:with:with:with:.				Object compiledMethodAt: #perform:with:with:with:with:.				Object compiledMethodAt: #perform:withArguments:.						Object compiledMethodAt: #perform:withArguments:inSuperclass:.						Object compiledMethodAt: #perform:withEnoughArguments:.				Object compiledMethodAt: #isSymbol.				Behavior reloadingMethod.				EditHistory compiledMethodAt: #swapInMethodAt:in:.				Object compiledMethodAt: #adaptToInteger:andSend:.				Object compiledMethodAt: #in:.				Object compiledMethodAt: #addDependent:.				Symbol compiledMethodAt: #isSymbol.				ContextPart compiledMethodAt: #selector.				ContextPart compiledMethodAt: #arguments.				CompiledMethod compiledMethodAt: #selector.				UUIDGenerator compiledMethodAt: #semaphoreForGenerator.				UUIDGenerator compiledMethodAt: #randomGenerator.				ProtoObject compiledMethodAt: #initialize.				BlockClosure compiledMethodAt: #value.				BlockContext compiledMethodAt: #value.				Semaphore compiledMethodAt: #wait.				UndefinedObject compiledMethodAt: #release.				ClassOrganizer compiledMethodAt: #traitComposition.				ByteString class compiledMethodAt: #stringHash:initialHash:};			yourself).			{		#(id isNil notNil isInteger removeFromSystem removeFromSystem: hashBytes:startingWith: size species signal resumptionTime primGetNextEvent: bitAnd: new: new negative at: at:put: bitShiftMagnitude: bitOr: < randomCounter / + asFloat bitXor: identityHash basicAt: basicAt:put: basicNew: basicNew isMethodProperties).		CompiledMethodTrailer trailerKindDecoders.	}		do: [:set |			set do: [:selector |		(navigation allImplementorsOf: selector) do: [:reference | fusedMethods add: reference compiledMethod]]].	self		fuseHeadlessSingleClassesInto: fusedMethods;		fuseHeadlessClassHierarchiesInto: fusedMethods.				fusedMethods do: [:method | method fuse].		Behavior setReloadingMethod.	reloadingMethod := Behavior reloadingMethod.	Shaker class swapOutMethodAt: #test:.	(Shaker test: 42) = 42 ifFalse: [self error: 'history system not working'].		"Set the selector and class-binding literals of the reloading method to things which make sense in the JS debugger."	Behavior setReloadingMethod.	LRUCache allInstancesDo: [:cache | cache reset].	WeakArray restartFinalizationProcess.	[3 error: 'ignored'] on: Error do: [:exception | ].	Delay initialize.	(Delay forSeconds: 1) wait.		{		BlockClosure.		ContextPart	}		do: [:class |			class allSubInstancesDo: [:methodHolder | methodHolder fuse]].		JS at: #shaking put: true.	Smalltalk		primitiveGarbageCollect;		primitiveFusedGarbageCollect;		primitiveFusedGarbageCollect.			numberOfClassesRemoved := -1.		[numberOfClassesRemoved = 0] whileFalse: [		numberOfClassesRemoved := 0.		(Class allSubclasses asSortedCollection: [:earlier :later | earlier depth <= later depth]) asArray reversed do: [:metaclass |			(				metaclass soleInstance subclasses isEmpty not or: [					{						metaclass.						metaclass soleInstance					}						anySatisfy: [:behavior |							behavior methodDict anySatisfy: [:method | method ~~ reloadingMethod]]]			)				ifFalse: [					metaclass soleInstance removeFromSystem.					numberOfClassesRemoved := numberOfClassesRemoved + 1]]].		Smalltalk garbageCollect! !----SNAPSHOT----{25 September 2019 . 2:14:35 am} history.image priorSource: 1903015!!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 02:23' prior: 35430392!fuseHeadlessClassHierarchiesInto: fusedMethods	"Fuse entire class hierarchies."	{		UUID.		UUIDGenerator.		NamePolicy.		FileDirectory.		SocketStream.		WebMessage.		Socket.		MimeConverter.		ProcessSpecificVariable.		ClassCategoryReader.		DirectoryEntry.		SimpleServiceEntry.		WebSocket.		InstructionClient.		CodeHolder.		Collection.		CharacterScanner.		CommandHistory.		LanguageEnvironment.		ParseNodeVisitor.		EncodedCharSet.		SharedPool.		BasicRequestor.
		ServiceProvider.		ServiceAction.		TextDiffBuilder.		HostPlatform.		BlockStartLocator.		DebuggerMethodMap.		ParseNode.		Preferences.		Number.		ContextPart.		Project.		Boolean.		Exception.		Collection.		Edition.		MethodLiteralTransmissionMarker.		Portal.		License.		Manifest.		BitMatchingPattern.		JSObject.		ByteTextConverter.	}		do: [:class | self fuseSuperclass: class into: fusedMethods]! !!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 02:23' prior: 35462581!fuseHeadlessClassHierarchiesInto: fusedMethods	"Fuse entire class hierarchies."	{		NamePolicy.		FileDirectory.		SocketStream.		WebMessage.		Socket.		MimeConverter.		ProcessSpecificVariable.		ClassCategoryReader.		DirectoryEntry.		SimpleServiceEntry.		WebSocket.		InstructionClient.		CodeHolder.		Collection.		CharacterScanner.		CommandHistory.		LanguageEnvironment.		ParseNodeVisitor.		EncodedCharSet.		SharedPool.		BasicRequestor.
		ServiceProvider.		ServiceAction.		TextDiffBuilder.		HostPlatform.		BlockStartLocator.		DebuggerMethodMap.		ParseNode.		Preferences.		Number.		ContextPart.		Project.		Boolean.		Exception.		Collection.		Edition.		MethodLiteralTransmissionMarker.		Portal.		License.		Manifest.		BitMatchingPattern.		JSObject.		ByteTextConverter.	}		do: [:class | self fuseSuperclass: class into: fusedMethods]! !!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 02:23' prior: 35446344!fuseHeadlessSingleClassesInto: fusedMethods	{		UUID.		UUIDGenerator.		WeakKeyAssociation.		WeakFinalizationList.		EnvironmentInfo.		WeakFinalizerItem.		Date.		BindingPolicy.		SocketAddressInformation.		DelayWaitTimeout.		Number.		WebUtils.		ThirtyTwoBitRegister.		SecureHashAlgorithm.		DiffElement.		ProcessBrowser.		CPUWatcher.		DeepCopier.		MethodReference.		Random.		ExternalObjectTable.		ChangeRecord.		SystemChangeNotifier.		ClassBuilder.		Beeper.		GZipReadStream.		InternalTranslator.		ServerDirectory.		FilePath.		Utilities.		Command.		WebClient.		InternetConfiguration.		NetNameResolver.		ChromeExtensionUrl.		SystemNavigation.		LocaleID.		XMLNamespace.		CharacterBlock.		UndefinedObject.		LimitedWriteStream.		HttpUrl.		ResourceManager.		RemoteString.		Latin1Environment.		Global.		Time.		TimeZone.		TraitOrganizer.		ServiceShortcuts.		ServiceCancelled.		ServiceRegistry.		ServicePreferences.		TraitAlias.		ClassTrait.		PragmaPreference.		BrowseAvailableModules.		CounterpartRequest.		InstallRemoteModule.		PointerFinder.		ParseNodeEnumerator.		ParseNodeVisitor.		ZipWriteStream.		ZipEncoder.		TextDomainManager.		StepMessage.		UTF8TextConverter.		Preference.		TextLine.		DeflateStream.		AdditionalMethodState.		Compiler.		CompilationCue.		Association.		StandardScriptingSystem.		MessageNames.		FileServices.		ClassBinding.		Webpage current class.		FileDirectory.		Metaclass.		ClassDescription.		Behavior.		Class.		MethodDictionary.		ProtoObject.		Tether.		ExceptionMarker.		InstructionPrinter.		Author.		EditHistory.		ModuleDescription.		ModuleID.		Version.		Other.		SmalltalkImage.		Environment.		ChangeSet.		ClassChangeRecord.		MethodChangeRecord.		ToolSet.		StandardToolSet.		Message.		MessageSend.		Process.		ProcessorScheduler.		BlockClosure.		BlockContext.		SharedQueue.		TranscriptStream.		Categorizer.		Character.		ExtendedNumberParser.		JSObjectProxy.		SystemOrganizer.		Shaker.		Decompiler.		Pragma.		MultiByteFileStream.		BreakpointManager.		ZipConstants.		AbstractLauncher.		AutoStart.		ObjectHistory.		Parser.		Point.		MessageTally.		CompiledMethodTrailer.		Monitor.		IdentityTransform.		NewParagraph	}		do: [:class | self fuseProtoclass: class into: fusedMethods]! !!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 02:23' prior: 35448732!fuseSingleClassesInto: fusedMethods	{		UUID.		UUIDGenerator.		WeakKeyAssociation.		WeakFinalizationList.		EnvironmentInfo.		WeakFinalizerItem.		Date.		BindingPolicy.		SocketAddressInformation.		DelayWaitTimeout.		Number.		WebUtils.		ThirtyTwoBitRegister.		SecureHashAlgorithm.		DiffElement.		ProcessBrowser.		CPUWatcher.		TransferMorph.		DeepCopier.		MethodReference.		Random.		SoundService.		ExternalObjectTable.		ChangeRecord.		SystemChangeNotifier.		ClassBuilder.		Beeper.		GZipReadStream.		InternalTranslator.		ServerDirectory.		PluggableTreeItemNode.		PluggableTreeMorph.		FilePath.		MorphicEventDispatcher.		Utilities.		Command.		WebClient.		SystemProgressMorph.		InternetConfiguration.		NetNameResolver.		ChromeExtensionUrl.		SystemNavigation.		ColorTheme.		LocaleID.		XMLNamespace.		CharacterBlock.		UndefinedObject.		LimitedWriteStream.		HttpUrl.		SystemProgressBarMorph.		HaloSpec.		ResourceManager.		RemoteString.		ListChooser.		TextKern.		TTKernPair.		Clipboard.		Latin1Environment.		EventManager.		Global.		Time.		SoundPlayer.		PopUpMenu.		SelectorBrowser.		DualChangeSorter.		TextAlignment.		FMSound.		PaintBoxColorPicker.		ThreePhaseButtonMorph.		PaintInvokingMorph.		ProjectViewMorph.		ClockMorph.		EllipseMorph.		ObjectsTool.		UpdatingSimpleButtonMorph.		CurveMorph.		MagnifierMorph.		ListItemWrapper.		ObjectExplorerWrapper.		SoundRecorder.		RecordingControlsMorph.		TimeZone.		BaseSoundSystem.		DummySoundSystem.		TraitOrganizer.		ServiceShortcuts.		ServiceCancelled.		ServiceRegistry.		ServiceGui.		ServicePreferences.		TheWorldMainDockingBar.		TraitAlias.		ClassTrait.		PragmaPreference.		Workspace.		ChangeList.		ChangeSorter.		NewColorPickerMorph.		BrowseAvailableModules.		CounterpartRequest.		InstallRemoteModule.		PreferenceBrowser.		ToolIcons.		UpdatingMenuItemMorph.		PointerFinder.		ParseNodeEnumerator.		ParseNodeVisitor.		ZipWriteStream.		ZipEncoder.		TextDomainManager.		StepMessage.		SystemWindowButton.		UTF8TextConverter.		FillInTheBlankMorph.		RealEstateAgent.		TransformMorph.		PluggableTextMorphPlus.		Preference.		WindowColorSpec.		UserDialogBoxMorph.		WindowColorRegistry.		TheWorldMenu.		PluggableListMorphPlus.		PluggableTextMorph.		TextMorphForEditView.		TextLine.		DeflateStream.		AdditionalMethodState.		Compiler.		CompilationCue.		Association.		PluggableButtonMorphPlus.		PluggablePanelMorph.		SketchMorph.		LayoutFrame.		IconicButton.		SimpleButtonMorph.		StandardScriptingSystem.		MessageNames.		FileServices.		ClassBinding.		Webpage current class.		FileDirectory.		Metaclass.		ClassDescription.		Behavior.		Class.		MethodDictionary.		DisplayText.		ProtoObject.		Tether.		ExceptionMarker.		InstructionPrinter.		Author.		EditHistory.		ModuleDescription.		ModuleID.		Version.		Other.		SmalltalkImage.		Environment.		ChangeSet.		ClassChangeRecord.		MethodChangeRecord.		ToolSet.		SystemBrowser.		StandardToolSet.		Message.		MessageSend.		Process.		ProcessorScheduler.		BlockClosure.		BlockContext.		SharedQueue.		TranscriptStream.		Categorizer.		Character.		ExtendedNumberParser.		JSObjectProxy.		SystemOrganizer.		Shaker.		Decompiler.		PolygonMorph.		SmalltalkEditor.		Pragma.		BalloonEngine.		MultiByteFileStream.		BalloonEdgeData.		BalloonFillData.		UTF8ClipboardInterpreter.		BreakpointManager.		ZipConstants.		MorphicUIManager.		MenuLineMorph.		NewBalloonMorph.		BalloonMorph.		AbstractLauncher.		AutoStart.		ObjectHistory.		Parser.		MenuMorph.		AlignmentMorph.		StringMorph.		MenuItemMorph.		MorphicTransform.		MenuIcons.		LayoutCell.		TableLayoutProperties.		Rectangle.		BorderStyle.		SimpleBorder.		TextFontReference.		Browser.		Point.		HandMorph.		PasteUpMorph.		WorldState.		MessageTally.		PluggableWindowSpec.		ScrollBar.		MorphicModel.		SHParserST80.		PluggableTextSpec.		Point.		SystemWindow.		PluggableButtonMorph.		PluggableSystemWindow.		CompiledMethodTrailer.		TextEmphasis.		SHTextStylerST80.		TextMorph.		PluggableListMorph.		LazyListMorph.		ScrollPane.		Monitor.		TextColor.		MouseOverHandler.		SHRange.		CharacterScanner.		CompositionScanner.		EventHandler.		MouseClickState.		MorphExtension.		IdentityTransform.		TopGripMorph.		TextStyle.		ProportionalSplitterMorph.		NewParagraph	}		do: [:class | self fuseProtoclass: class into: fusedMethods]! !----SNAPSHOT----{25 September 2019 . 2:23:31 am} history.image priorSource: 1907974!!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 02:33' prior: 35464528!fuseHeadlessSingleClassesInto: fusedMethods	{		Locale.		UUID.		UUIDGenerator.		WeakKeyAssociation.		WeakFinalizationList.		EnvironmentInfo.		WeakFinalizerItem.		Date.		BindingPolicy.		SocketAddressInformation.		DelayWaitTimeout.		Number.		WebUtils.		ThirtyTwoBitRegister.		SecureHashAlgorithm.		DiffElement.		ProcessBrowser.		CPUWatcher.		DeepCopier.		MethodReference.		Random.		ExternalObjectTable.		ChangeRecord.		SystemChangeNotifier.		ClassBuilder.		Beeper.		GZipReadStream.		InternalTranslator.		ServerDirectory.		FilePath.		Utilities.		Command.		WebClient.		InternetConfiguration.		NetNameResolver.		ChromeExtensionUrl.		SystemNavigation.		LocaleID.		XMLNamespace.		CharacterBlock.		UndefinedObject.		LimitedWriteStream.		HttpUrl.		ResourceManager.		RemoteString.		Latin1Environment.		Global.		Time.		TimeZone.		TraitOrganizer.		ServiceShortcuts.		ServiceCancelled.		ServiceRegistry.		ServicePreferences.		TraitAlias.		ClassTrait.		PragmaPreference.		BrowseAvailableModules.		CounterpartRequest.		InstallRemoteModule.		PointerFinder.		ParseNodeEnumerator.		ParseNodeVisitor.		ZipWriteStream.		ZipEncoder.		TextDomainManager.		StepMessage.		UTF8TextConverter.		Preference.		TextLine.		DeflateStream.		AdditionalMethodState.		Compiler.		CompilationCue.		Association.		StandardScriptingSystem.		MessageNames.		FileServices.		ClassBinding.		Webpage current class.		FileDirectory.		Metaclass.		ClassDescription.		Behavior.		Class.		MethodDictionary.		ProtoObject.		Tether.		ExceptionMarker.		InstructionPrinter.		Author.		EditHistory.		ModuleDescription.		ModuleID.		Version.		Other.		SmalltalkImage.		Environment.		ChangeSet.		ClassChangeRecord.		MethodChangeRecord.		ToolSet.		StandardToolSet.		Message.		MessageSend.		Process.		ProcessorScheduler.		BlockClosure.		BlockContext.		SharedQueue.		TranscriptStream.		Categorizer.		Character.		ExtendedNumberParser.		JSObjectProxy.		SystemOrganizer.		Shaker.		Decompiler.		Pragma.		MultiByteFileStream.		BreakpointManager.		ZipConstants.		AbstractLauncher.		AutoStart.		ObjectHistory.		Parser.		Point.		MessageTally.		CompiledMethodTrailer.		Monitor.		IdentityTransform.		NewParagraph	}		do: [:class | self fuseProtoclass: class into: fusedMethods]! !!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 02:33' prior: 35466941!fuseSingleClassesInto: fusedMethods	{		Locale.		UUID.		UUIDGenerator.		WeakKeyAssociation.		WeakFinalizationList.		EnvironmentInfo.		WeakFinalizerItem.		Date.		BindingPolicy.		SocketAddressInformation.		DelayWaitTimeout.		Number.		WebUtils.		ThirtyTwoBitRegister.		SecureHashAlgorithm.		DiffElement.		ProcessBrowser.		CPUWatcher.		TransferMorph.		DeepCopier.		MethodReference.		Random.		SoundService.		ExternalObjectTable.		ChangeRecord.		SystemChangeNotifier.		ClassBuilder.		Beeper.		GZipReadStream.		InternalTranslator.		ServerDirectory.		PluggableTreeItemNode.		PluggableTreeMorph.		FilePath.		MorphicEventDispatcher.		Utilities.		Command.		WebClient.		SystemProgressMorph.		InternetConfiguration.		NetNameResolver.		ChromeExtensionUrl.		SystemNavigation.		ColorTheme.		LocaleID.		XMLNamespace.		CharacterBlock.		UndefinedObject.		LimitedWriteStream.		HttpUrl.		SystemProgressBarMorph.		HaloSpec.		ResourceManager.		RemoteString.		ListChooser.		TextKern.		TTKernPair.		Clipboard.		Latin1Environment.		EventManager.		Global.		Time.		SoundPlayer.		PopUpMenu.		SelectorBrowser.		DualChangeSorter.		TextAlignment.		FMSound.		PaintBoxColorPicker.		ThreePhaseButtonMorph.		PaintInvokingMorph.		ProjectViewMorph.		ClockMorph.		EllipseMorph.		ObjectsTool.		UpdatingSimpleButtonMorph.		CurveMorph.		MagnifierMorph.		ListItemWrapper.		ObjectExplorerWrapper.		SoundRecorder.		RecordingControlsMorph.		TimeZone.		BaseSoundSystem.		DummySoundSystem.		TraitOrganizer.		ServiceShortcuts.		ServiceCancelled.		ServiceRegistry.		ServiceGui.		ServicePreferences.		TheWorldMainDockingBar.		TraitAlias.		ClassTrait.		PragmaPreference.		Workspace.		ChangeList.		ChangeSorter.		NewColorPickerMorph.		BrowseAvailableModules.		CounterpartRequest.		InstallRemoteModule.		PreferenceBrowser.		ToolIcons.		UpdatingMenuItemMorph.		PointerFinder.		ParseNodeEnumerator.		ParseNodeVisitor.		ZipWriteStream.		ZipEncoder.		TextDomainManager.		StepMessage.		SystemWindowButton.		UTF8TextConverter.		FillInTheBlankMorph.		RealEstateAgent.		TransformMorph.		PluggableTextMorphPlus.		Preference.		WindowColorSpec.		UserDialogBoxMorph.		WindowColorRegistry.		TheWorldMenu.		PluggableListMorphPlus.		PluggableTextMorph.		TextMorphForEditView.		TextLine.		DeflateStream.		AdditionalMethodState.		Compiler.		CompilationCue.		Association.		PluggableButtonMorphPlus	}		do: [:class | self fuseProtoclass: class into: fusedMethods]! !!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 02:34'!fuseSingleClasses2Into: fusedMethods	{		PluggablePanelMorph.		SketchMorph.		LayoutFrame.		IconicButton.		SimpleButtonMorph.		StandardScriptingSystem.		MessageNames.		FileServices.		ClassBinding.		Webpage current class.		FileDirectory.		Metaclass.		ClassDescription.		Behavior.		Class.		MethodDictionary.		DisplayText.		ProtoObject.		Tether.		ExceptionMarker.		InstructionPrinter.		Author.		EditHistory.		ModuleDescription.		ModuleID.		Version.		Other.		SmalltalkImage.		Environment.		ChangeSet.		ClassChangeRecord.		MethodChangeRecord.		ToolSet.		SystemBrowser.		StandardToolSet.		Message.		MessageSend.		Process.		ProcessorScheduler.		BlockClosure.		BlockContext.		SharedQueue.		TranscriptStream.		Categorizer.		Character.		ExtendedNumberParser.		JSObjectProxy.		SystemOrganizer.		Shaker.		Decompiler.		PolygonMorph.		SmalltalkEditor.		Pragma.		BalloonEngine.		MultiByteFileStream.		BalloonEdgeData.		BalloonFillData.		UTF8ClipboardInterpreter.		BreakpointManager.		ZipConstants.		MorphicUIManager.		MenuLineMorph.		NewBalloonMorph.		BalloonMorph.		AbstractLauncher.		AutoStart.		ObjectHistory.		Parser.		MenuMorph.		AlignmentMorph.		StringMorph.		MenuItemMorph.		MorphicTransform.		MenuIcons.		LayoutCell.		TableLayoutProperties.		Rectangle.		BorderStyle.		SimpleBorder.		TextFontReference.		Browser.		Point.		HandMorph.		PasteUpMorph.		WorldState.		MessageTally.		PluggableWindowSpec.		ScrollBar.		MorphicModel.		SHParserST80.		PluggableTextSpec.		Point.		SystemWindow.		PluggableButtonMorph.		PluggableSystemWindow.		CompiledMethodTrailer.		TextEmphasis.		SHTextStylerST80.		TextMorph.		PluggableListMorph.		LazyListMorph.		ScrollPane.		Monitor.		TextColor.		MouseOverHandler.		SHRange.		CharacterScanner.		CompositionScanner.		EventHandler.		MouseClickState.		MorphExtension.		IdentityTransform.		TopGripMorph.		TextStyle.		ProportionalSplitterMorph.		NewParagraph	}		do: [:class | self fuseProtoclass: class into: fusedMethods]! !!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 02:34' prior: 35474004!fuseSingleClassesInto: fusedMethods	{		Locale.		UUID.		UUIDGenerator.		WeakKeyAssociation.		WeakFinalizationList.		EnvironmentInfo.		WeakFinalizerItem.		Date.		BindingPolicy.		SocketAddressInformation.		DelayWaitTimeout.		Number.		WebUtils.		ThirtyTwoBitRegister.		SecureHashAlgorithm.		DiffElement.		ProcessBrowser.		CPUWatcher.		TransferMorph.		DeepCopier.		MethodReference.		Random.		SoundService.		ExternalObjectTable.		ChangeRecord.		SystemChangeNotifier.		ClassBuilder.		Beeper.		GZipReadStream.		InternalTranslator.		ServerDirectory.		PluggableTreeItemNode.		PluggableTreeMorph.		FilePath.		MorphicEventDispatcher.		Utilities.		Command.		WebClient.		SystemProgressMorph.		InternetConfiguration.		NetNameResolver.		ChromeExtensionUrl.		SystemNavigation.		ColorTheme.		LocaleID.		XMLNamespace.		CharacterBlock.		UndefinedObject.		LimitedWriteStream.		HttpUrl.		SystemProgressBarMorph.		HaloSpec.		ResourceManager.		RemoteString.		ListChooser.		TextKern.		TTKernPair.		Clipboard.		Latin1Environment.		EventManager.		Global.		Time.		SoundPlayer.		PopUpMenu.		SelectorBrowser.		DualChangeSorter.		TextAlignment.		FMSound.		PaintBoxColorPicker.		ThreePhaseButtonMorph.		PaintInvokingMorph.		ProjectViewMorph.		ClockMorph.		EllipseMorph.		ObjectsTool.		UpdatingSimpleButtonMorph.		CurveMorph.		MagnifierMorph.		ListItemWrapper.		ObjectExplorerWrapper.		SoundRecorder.		RecordingControlsMorph.		TimeZone.		BaseSoundSystem.		DummySoundSystem.		TraitOrganizer.		ServiceShortcuts.		ServiceCancelled.		ServiceRegistry.		ServiceGui.		ServicePreferences.		TheWorldMainDockingBar.		TraitAlias.		ClassTrait.		PragmaPreference.		Workspace.		ChangeList.		ChangeSorter.		NewColorPickerMorph.		BrowseAvailableModules.		CounterpartRequest.		InstallRemoteModule.		PreferenceBrowser.		ToolIcons.		UpdatingMenuItemMorph.		PointerFinder.		ParseNodeEnumerator.		ParseNodeVisitor.		ZipWriteStream.		ZipEncoder.		TextDomainManager.		StepMessage.		SystemWindowButton.		UTF8TextConverter.		FillInTheBlankMorph.		RealEstateAgent.		TransformMorph.		PluggableTextMorphPlus.		Preference.		WindowColorSpec.		UserDialogBoxMorph.		WindowColorRegistry.		TheWorldMenu.		PluggableListMorphPlus.		PluggableTextMorph.		TextMorphForEditView.		TextLine.		DeflateStream.		AdditionalMethodState.		Compiler.		CompilationCue.		Association.		PluggableButtonMorphPlus	}		do: [:class | self fuseProtoclass: class into: fusedMethods].			self fuseSingleClasses2Into: fusedMethods! !----SNAPSHOT----{25 September 2019 . 2:34:54 am} history.image priorSource: 1916974!----SNAPSHOT----{25 September 2019 . 2:35:50 am} history.image priorSource: 1926890!!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 02:45' prior: 35457670!shakeHeadless	| fusedMethods weakArray navigation reloadingMethod numberOfClassesRemoved |		(SmalltalkImage classPool)		at: #ShutDownList		put: #(#TTFileDescription #InternetConfiguration #TTCFont #ArchiveViewer #CPUWatcher #ProcessBrowser #ExternalSettings #Symbol #SecurityManager #AutoStart #FileStream #CommandHistory #StrikeFontSet #MessageTally #ImageSegment #Password #HttpUrl #SoundPlayer #FileDirectory #Color #StrikeFont #PasteUpMorph #ControlManager #DisplayScreen #Delay) asOrderedCollection.		SmalltalkImage compile: 'snapshot: save andQuit: quit withExitCode: exitCode embedded: embeddedFlag	"Mark the changes file and close all files as part of #processShutdownList.	If save is true, save the current state of this Smalltalk in the image file.	If quit is true, then exit to the outer OS shell.	If exitCode is not nil, then use it as exit code.	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."	| resuming msg |	Object flushDependents.	Object flushEvents.	(SourceFiles at: 2) ifNotNil:[		msg := String streamContents: [ :s |			s nextPutAll: ''----'';			nextPutAll: (save ifTrue: [ quit ifTrue: [ ''QUIT'' ] ifFalse: [ ''SNAPSHOT'' ] ]							ifFalse: [quit ifTrue: [ ''QUIT/NOSAVE'' ] ifFalse: [ ''NOP'' ]]);			nextPutAll: ''----'';			print: Date dateAndTimeNow; space;			nextPutAll: (FileDirectory default localNameFor: self imageName);			nextPutAll: '' priorSource: '';			print: LastQuitLogPosition ].		self assureStartupStampLogged.		save ifTrue: [ LastQuitLogPosition := (SourceFiles at: 2) setToEnd; position ].		self logChange: msg.		Transcript cr; show: msg	].	Smalltalk processShutDownList: quit.	Cursor write show.	save ifTrue: [resuming := embeddedFlag 					ifTrue: [self snapshotEmbeddedPrimitive] 					ifFalse: [self snapshotPrimitive].  "<-- PC frozen here on image file"				resuming == false "guard against failure" ifTrue:					[]]		ifFalse: [resuming := false].	quit & (resuming == false) ifTrue: [		exitCode			ifNil: [ self quitPrimitive ]			ifNotNil: [ self quitPrimitive: exitCode ] ].	Cursor normal show.	Smalltalk setGCParameters.	resuming == true ifTrue: [Smalltalk clearExternalObjects].	Smalltalk processStartUpList: resuming == true.	resuming == true ifTrue:[		self setPlatformPreferences.		self recordStartupStamp].	"Now it''s time to raise an error"	resuming == nil ifTrue: [self error:''Failed to write image file (disk full?)''].	^ resuming' classified: 'whatever'.		(SmalltalkImage classPool)		at: #StartUpList		put: #(#SmallInteger #Delay #Other #HostPlatform #WebEntrance #ProcessorScheduler #FileDirectory #ShortIntegerArray #ShortRunArray #MessageTally #NaturalLanguageTranslator #LanguageEnvironment #PowerManagement #ExternalSettings #SecurityManager #FileStream #UUIDGenerator #CPUWatcher #DateAndTime #SmalltalkImage #Utilities #WeakArray #MultiByteFileStream #InternetConfiguration #Locale #Collection #HostWindowProxy #NetNameResolver #Caffeine #Worker #Webpage #ExternalResource) asOrderedCollection.	EditHistory connectTo: 'ws://localhost:8091/tether'.	weakArray := WeakArray with: Object new.	navigation := SystemNavigation new.		fusedMethods := (		(OrderedCollection new)			addAll: {				Object compiledMethodAt: #primitiveError:.				Object compiledMethodAt: #perform:.								Object compiledMethodAt: #perform:with:.				Object compiledMethodAt: #perform:with:with:.				Object compiledMethodAt: #perform:with:with:with:.				Object compiledMethodAt: #perform:with:with:with:with:.				Object compiledMethodAt: #perform:withArguments:.						Object compiledMethodAt: #perform:withArguments:inSuperclass:.						Object compiledMethodAt: #perform:withEnoughArguments:.				Object compiledMethodAt: #isSymbol.				Behavior reloadingMethod.				EditHistory compiledMethodAt: #swapInMethodAt:in:.				Object compiledMethodAt: #adaptToInteger:andSend:.				Object compiledMethodAt: #in:.				Object compiledMethodAt: #addDependent:.				Symbol compiledMethodAt: #isSymbol.				ContextPart compiledMethodAt: #selector.				ContextPart compiledMethodAt: #arguments.				CompiledMethod compiledMethodAt: #selector.				UUIDGenerator compiledMethodAt: #semaphoreForGenerator.				UUIDGenerator compiledMethodAt: #randomGenerator.				ProtoObject compiledMethodAt: #initialize.				BlockClosure compiledMethodAt: #value.				BlockContext compiledMethodAt: #value.				Semaphore compiledMethodAt: #wait.				UndefinedObject compiledMethodAt: #release.				ClassOrganizer compiledMethodAt: #traitComposition.				ByteString class compiledMethodAt: #stringHash:initialHash:};			yourself).			{		#(id isNil notNil isInteger removeFromSystem removeFromSystem: hashBytes:startingWith: size species signal resumptionTime primGetNextEvent: bitAnd: new: new negative at: at:put: bitShiftMagnitude: bitOr: < randomCounter / + asFloat bitXor: identityHash basicAt: basicAt:put: basicNew: basicNew isMethodProperties).		CompiledMethodTrailer trailerKindDecoders.	}		do: [:set |			set do: [:selector |		(navigation allImplementorsOf: selector) do: [:reference | fusedMethods add: reference compiledMethod]]].	self		fuseHeadlessSingleClassesInto: fusedMethods;		fuseHeadlessClassHierarchiesInto: fusedMethods.				fusedMethods do: [:method | method fuse].		Behavior setReloadingMethod.	reloadingMethod := Behavior reloadingMethod.	Shaker class swapOutMethodAt: #test:.	(Shaker test: 42) = 42 ifFalse: [self error: 'history system not working'].		"Set the selector and class-binding literals of the reloading method to things which make sense in the JS debugger."	Behavior setReloadingMethod.	LRUCache allInstancesDo: [:cache | cache reset].	WeakArray restartFinalizationProcess.	[3 error: 'ignored'] on: Error do: [:exception | ].	Delay initialize.	(Delay forSeconds: 1) wait.		{		BlockClosure.		ContextPart	}		do: [:class |			class allSubInstancesDo: [:methodHolder | methodHolder fuse]].		JS at: #shaking put: true.	Smalltalk		primitiveGarbageCollect;		primitiveFusedGarbageCollect;		primitiveFusedGarbageCollect.			numberOfClassesRemoved := -1.		[numberOfClassesRemoved = 0] whileFalse: [		numberOfClassesRemoved := 0.		(Class allSubclasses asSortedCollection: [:earlier :later | earlier depth <= later depth]) asArray reversed do: [:metaclass |			(				metaclass soleInstance subclasses isEmpty not or: [					{						metaclass.						metaclass soleInstance					}						anySatisfy: [:behavior |							behavior methodDict anySatisfy: [:method | method ~~ reloadingMethod]]]			)				ifFalse: [					metaclass soleInstance removeFromSystem.					numberOfClassesRemoved := numberOfClassesRemoved + 1]]].		Smalltalk garbageCollect! !----SNAPSHOT----{25 September 2019 . 2:45:21 am} history.image priorSource: 1926976!#[112 114 105 110 116 83 116 114 105 110 103] asString!!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 13:10' prior: 35481583!shakeHeadless	| fusedMethods weakArray navigation reloadingMethod numberOfClassesRemoved |		(SmalltalkImage classPool)		at: #ShutDownList		put: #(#TTFileDescription #InternetConfiguration #TTCFont #ArchiveViewer #CPUWatcher #ProcessBrowser #ExternalSettings #Symbol #SecurityManager #AutoStart #FileStream #CommandHistory #StrikeFontSet #MessageTally #ImageSegment #Password #HttpUrl #SoundPlayer #FileDirectory #Color #StrikeFont #PasteUpMorph #ControlManager #DisplayScreen #Delay) asOrderedCollection.		SmalltalkImage compile: 'snapshot: save andQuit: quit withExitCode: exitCode embedded: embeddedFlag	"Mark the changes file and close all files as part of #processShutdownList.	If save is true, save the current state of this Smalltalk in the image file.	If quit is true, then exit to the outer OS shell.	If exitCode is not nil, then use it as exit code.	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."	| resuming msg |	Object flushDependents.	Object flushEvents.	(SourceFiles at: 2) ifNotNil:[		msg := String streamContents: [ :s |			s nextPutAll: ''----'';			nextPutAll: (save ifTrue: [ quit ifTrue: [ ''QUIT'' ] ifFalse: [ ''SNAPSHOT'' ] ]							ifFalse: [quit ifTrue: [ ''QUIT/NOSAVE'' ] ifFalse: [ ''NOP'' ]]);			nextPutAll: ''----'';			print: Date dateAndTimeNow; space;			nextPutAll: (FileDirectory default localNameFor: self imageName);			nextPutAll: '' priorSource: '';			print: LastQuitLogPosition ].		self assureStartupStampLogged.		save ifTrue: [ LastQuitLogPosition := (SourceFiles at: 2) setToEnd; position ].		self logChange: msg.		Transcript cr; show: msg	].	Smalltalk processShutDownList: quit.	Cursor write show.	save ifTrue: [resuming := embeddedFlag 					ifTrue: [self snapshotEmbeddedPrimitive] 					ifFalse: [self snapshotPrimitive].  "<-- PC frozen here on image file"				resuming == false "guard against failure" ifTrue:					[]]		ifFalse: [resuming := false].	quit & (resuming == false) ifTrue: [		exitCode			ifNil: [ self quitPrimitive ]			ifNotNil: [ self quitPrimitive: exitCode ] ].	Cursor normal show.	Smalltalk setGCParameters.	resuming == true ifTrue: [Smalltalk clearExternalObjects].	Smalltalk processStartUpList: resuming == true.	resuming == true ifTrue:[		self setPlatformPreferences.		self recordStartupStamp].	"Now it''s time to raise an error"	resuming == nil ifTrue: [self error:''Failed to write image file (disk full?)''].	^ resuming' classified: 'whatever'.		(SmalltalkImage classPool)		at: #StartUpList		put: #(#SmallInteger #Delay #Other #HostPlatform #WebEntrance #ProcessorScheduler #FileDirectory #ShortIntegerArray #ShortRunArray #MessageTally #NaturalLanguageTranslator #LanguageEnvironment #PowerManagement #ExternalSettings #SecurityManager #FileStream #UUIDGenerator #CPUWatcher #DateAndTime #SmalltalkImage #Utilities #WeakArray #MultiByteFileStream #InternetConfiguration #Locale #Collection #HostWindowProxy #NetNameResolver #Caffeine #Worker #Webpage #ExternalResource) asOrderedCollection.	EditHistory connectTo: 'ws://localhost:8091/tether'.	weakArray := WeakArray with: Object new.	navigation := SystemNavigation new.		fusedMethods := (		(OrderedCollection new)			addAll: {				Object compiledMethodAt: #primitiveError:.				Object compiledMethodAt: #perform:.								Object compiledMethodAt: #perform:with:.				Object compiledMethodAt: #perform:with:with:.				Object compiledMethodAt: #perform:with:with:with:.				Object compiledMethodAt: #perform:with:with:with:with:.				Object compiledMethodAt: #perform:withArguments:.						Object compiledMethodAt: #perform:withArguments:inSuperclass:.						Object compiledMethodAt: #perform:withEnoughArguments:.				Object compiledMethodAt: #isSymbol.				Behavior reloadingMethod.				EditHistory compiledMethodAt: #swapInMethodAt:in:.				Object compiledMethodAt: #adaptToInteger:andSend:.				Object compiledMethodAt: #in:.				Object compiledMethodAt: #addDependent:.				Symbol compiledMethodAt: #isSymbol.				ContextPart compiledMethodAt: #selector.				ContextPart compiledMethodAt: #arguments.				CompiledMethod compiledMethodAt: #selector.				UUIDGenerator compiledMethodAt: #semaphoreForGenerator.				UUIDGenerator compiledMethodAt: #randomGenerator.				ProtoObject compiledMethodAt: #initialize.				BlockClosure compiledMethodAt: #value.				BlockContext compiledMethodAt: #value.				Semaphore compiledMethodAt: #wait.				UndefinedObject compiledMethodAt: #release.				ClassOrganizer compiledMethodAt: #traitComposition.				ByteString class compiledMethodAt: #stringHash:initialHash:};			yourself).			{		#(id isNil notNil isInteger removeFromSystem removeFromSystem: hashBytes:startingWith: size species signal resumptionTime primGetNextEvent: bitAnd: new: new negative at: at:put: bitShiftMagnitude: bitOr: < randomCounter / + asFloat bitXor: identityHash basicAt: basicAt:put: basicNew: basicNew isMethodProperties printString).		CompiledMethodTrailer trailerKindDecoders.	}		do: [:set |			set do: [:selector |		(navigation allImplementorsOf: selector) do: [:reference | fusedMethods add: reference compiledMethod]]].	self		fuseHeadlessSingleClassesInto: fusedMethods;		fuseHeadlessClassHierarchiesInto: fusedMethods.				fusedMethods do: [:method | method fuse].		Behavior setReloadingMethod.	reloadingMethod := Behavior reloadingMethod.	Shaker class swapOutMethodAt: #test:.	(Shaker test: 42) = 42 ifFalse: [self error: 'history system not working'].		"Set the selector and class-binding literals of the reloading method to things which make sense in the JS debugger."	Behavior setReloadingMethod.	LRUCache allInstancesDo: [:cache | cache reset].	WeakArray restartFinalizationProcess.	[3 error: 'ignored'] on: Error do: [:exception | ].	Delay initialize.	(Delay forSeconds: 1) wait.		{		BlockClosure.		ContextPart	}		do: [:class |			class allSubInstancesDo: [:methodHolder | methodHolder fuse]].		JS at: #shaking put: true.	Smalltalk		primitiveGarbageCollect;		primitiveFusedGarbageCollect;		primitiveFusedGarbageCollect.			numberOfClassesRemoved := -1.		[numberOfClassesRemoved = 0] whileFalse: [		numberOfClassesRemoved := 0.		(Class allSubclasses asSortedCollection: [:earlier :later | earlier depth <= later depth]) asArray reversed do: [:metaclass |			(				metaclass soleInstance subclasses isEmpty not or: [					{						metaclass.						metaclass soleInstance					}						anySatisfy: [:behavior |							behavior methodDict anySatisfy: [:method | method ~~ reloadingMethod]]]			)				ifFalse: [					metaclass soleInstance removeFromSystem.					numberOfClassesRemoved := numberOfClassesRemoved + 1]]].		Smalltalk garbageCollect! !EditHistory local!EditHistory!----SNAPSHOT----{25 September 2019 . 1:10:38 pm} history.image priorSource: 1933939!----SNAPSHOT----{25 September 2019 . 1:17:28 pm} history.image priorSource: 1941005!!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 13:19' prior: 35471581!fuseHeadlessSingleClassesInto: fusedMethods	{		WeakMessageSend.		ExternalResource.		DateAndTime.		Locale.		UUID.		UUIDGenerator.		WeakKeyAssociation.		WeakFinalizationList.		EnvironmentInfo.		WeakFinalizerItem.		Date.		BindingPolicy.		SocketAddressInformation.		DelayWaitTimeout.		Number.		WebUtils.		ThirtyTwoBitRegister.		SecureHashAlgorithm.		DiffElement.		ProcessBrowser.		CPUWatcher.		DeepCopier.		MethodReference.		Random.		ExternalObjectTable.		ChangeRecord.		SystemChangeNotifier.		ClassBuilder.		Beeper.		GZipReadStream.		InternalTranslator.		ServerDirectory.		FilePath.		Utilities.		Command.		WebClient.		InternetConfiguration.		NetNameResolver.		ChromeExtensionUrl.		SystemNavigation.		LocaleID.		XMLNamespace.		CharacterBlock.		UndefinedObject.		LimitedWriteStream.		HttpUrl.		ResourceManager.		RemoteString.		Latin1Environment.		Global.		Time.		TimeZone.		TraitOrganizer.		ServiceShortcuts.		ServiceCancelled.		ServiceRegistry.		ServicePreferences.		TraitAlias.		ClassTrait.		PragmaPreference.		BrowseAvailableModules.		CounterpartRequest.		InstallRemoteModule.		PointerFinder.		ParseNodeEnumerator.		ParseNodeVisitor.		ZipWriteStream.		ZipEncoder.		TextDomainManager.		StepMessage.		UTF8TextConverter.		Preference.		TextLine.		DeflateStream.		AdditionalMethodState.		Compiler.		CompilationCue.		Association.		StandardScriptingSystem.		MessageNames.		FileServices.		ClassBinding.		Webpage current class.		FileDirectory.		Metaclass.		ClassDescription.		Behavior.		Class.		MethodDictionary.		ProtoObject.		Tether.		ExceptionMarker.		InstructionPrinter.		Author.		EditHistory.		ModuleDescription.		ModuleID.		Version.		Other.		SmalltalkImage.		Environment.		ChangeSet.		ClassChangeRecord.		MethodChangeRecord.		ToolSet.		StandardToolSet.		Message.		MessageSend.		Process.		ProcessorScheduler.		BlockClosure.		BlockContext.		SharedQueue.		TranscriptStream.		Categorizer.		Character.		ExtendedNumberParser.		JSObjectProxy.		SystemOrganizer.		Shaker.		Decompiler.		Pragma.		MultiByteFileStream.		BreakpointManager.		ZipConstants.		AbstractLauncher.		AutoStart.		ObjectHistory.		Parser.		Point.		MessageTally.		CompiledMethodTrailer.		Monitor.		IdentityTransform.		NewParagraph	}		do: [:class | self fuseProtoclass: class into: fusedMethods]! !!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 13:19' prior: 35476604!fuseSingleClasses2Into: fusedMethods	{		WeakMessageSend.		ExternalResource.		DateAndTime.		PluggablePanelMorph.		SketchMorph.		LayoutFrame.		IconicButton.		SimpleButtonMorph.		StandardScriptingSystem.		MessageNames.		FileServices.		ClassBinding.		Webpage current class.		FileDirectory.		Metaclass.		ClassDescription.		Behavior.		Class.		MethodDictionary.		DisplayText.		ProtoObject.		Tether.		ExceptionMarker.		InstructionPrinter.		Author.		EditHistory.		ModuleDescription.		ModuleID.		Version.		Other.		SmalltalkImage.		Environment.		ChangeSet.		ClassChangeRecord.		MethodChangeRecord.		ToolSet.		SystemBrowser.		StandardToolSet.		Message.		MessageSend.		Process.		ProcessorScheduler.		BlockClosure.		BlockContext.		SharedQueue.		TranscriptStream.		Categorizer.		Character.		ExtendedNumberParser.		JSObjectProxy.		SystemOrganizer.		Shaker.		Decompiler.		PolygonMorph.		SmalltalkEditor.		Pragma.		BalloonEngine.		MultiByteFileStream.		BalloonEdgeData.		BalloonFillData.		UTF8ClipboardInterpreter.		BreakpointManager.		ZipConstants.		MorphicUIManager.		MenuLineMorph.		NewBalloonMorph.		BalloonMorph.		AbstractLauncher.		AutoStart.		ObjectHistory.		Parser.		MenuMorph.		AlignmentMorph.		StringMorph.		MenuItemMorph.		MorphicTransform.		MenuIcons.		LayoutCell.		TableLayoutProperties.		Rectangle.		BorderStyle.		SimpleBorder.		TextFontReference.		Browser.		Point.		HandMorph.		PasteUpMorph.		WorldState.		MessageTally.		PluggableWindowSpec.		ScrollBar.		MorphicModel.		SHParserST80.		PluggableTextSpec.		Point.		SystemWindow.		PluggableButtonMorph.		PluggableSystemWindow.		CompiledMethodTrailer.		TextEmphasis.		SHTextStylerST80.		TextMorph.		PluggableListMorph.		LazyListMorph.		ScrollPane.		Monitor.		TextColor.		MouseOverHandler.		SHRange.		CharacterScanner.		CompositionScanner.		EventHandler.		MouseClickState.		MorphExtension.		IdentityTransform.		TopGripMorph.		TextStyle.		ProportionalSplitterMorph.		NewParagraph	}		do: [:class | self fuseProtoclass: class into: fusedMethods]! !----SNAPSHOT----{25 September 2019 . 1:19:50 pm} history.image priorSource: 1941091!----SNAPSHOT----{25 September 2019 . 1:23:11 pm} history.image priorSource: 1945852!#[101 109 112 116 121 67 111 108 108 101 99 116 105 111 110 58] asString!----STARTUP----{25 September 2019 . 1:33:54 pm} as /Users/craig/Downloads/caffeine/backups/37 (headless)/history.image!!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 13:34' prior: 35463567!fuseHeadlessClassHierarchiesInto: fusedMethods	"Fuse entire class hierarchies."	{		PositionableStream.		NamePolicy.		FileDirectory.		SocketStream.		WebMessage.		Socket.		MimeConverter.		ProcessSpecificVariable.		ClassCategoryReader.		DirectoryEntry.		SimpleServiceEntry.		WebSocket.		InstructionClient.		CodeHolder.		Collection.		CharacterScanner.		CommandHistory.		LanguageEnvironment.		ParseNodeVisitor.		EncodedCharSet.		SharedPool.		BasicRequestor.
		ServiceProvider.		ServiceAction.		TextDiffBuilder.		HostPlatform.		BlockStartLocator.		DebuggerMethodMap.		ParseNode.		Preferences.		Number.		ContextPart.		Project.		Boolean.		Exception.		Collection.		Edition.		MethodLiteralTransmissionMarker.		Portal.		License.		Manifest.		BitMatchingPattern.		JSObject.		ByteTextConverter.	}		do: [:class | self fuseSuperclass: class into: fusedMethods]! !!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 13:34' prior: 35431353!fuseClassHierarchiesInto: fusedMethods	"Fuse entire class hierarchies."	{		PositionableStream.		NamePolicy.		FileDirectory.		PluggableListMorph.		SocketStream.		WebMessage.		Socket.		MimeConverter.		ProcessSpecificVariable.		AbstractSound.		ClassCategoryReader.		ImageReadWriter.		IndentingListItemMorph.		DirectoryEntry.		SimpleServiceEntry.		WebSocket.		InstructionClient.		SystemWindow.		FileList.		CodeHolder.		Collection.		CharacterScanner.		MorphicEvent.		Inspector.		CommandHistory.		DAVResource.		LanguageEnvironment.		BitBlt.		ParseNodeVisitor.		EncodedCharSet.		LayoutPolicy.		TTGlyph.		Envelope.		SharedPool.		BasicRequestor.
		ServiceProvider.		ServiceAction.		PreferenceBrowserMorph.		TextDiffBuilder.		HostPlatform.		FillStyle.		BorderStyle.		BlockStartLocator.		TextComposer.		AbstractResizerMorph.		DebuggerMethodMap.		AbstractFont.		ToolBuilderSpec.		ParseNode.		ToolBuilder.		UserInputEvent.		Preferences.		AbstractEvent.		Number.		InputSensor.		ContextPart.		Debugger.		Project.		Boolean.		Exception.		Collection.		Edition.		MethodLiteralTransmissionMarker.		Portal.		License.		Manifest.		BitMatchingPattern.		Inspector.		JSObject.		Canvas.		ByteTextConverter.		Form.		Color	}		do: [:class | self fuseSuperclass: class into: fusedMethods]! !----SNAPSHOT----{25 September 2019 . 1:34:18 pm} history.image priorSource: 1945938!#[104 97 108 116 58] asString!----STARTUP----{25 September 2019 . 1:44:47 pm} as /Users/craig/Downloads/caffeine/backups/37 (headless)/history.image!!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 13:45' prior: 35488603!shakeHeadless	| fusedMethods weakArray navigation reloadingMethod numberOfClassesRemoved |		(SmalltalkImage classPool)		at: #ShutDownList		put: #(#TTFileDescription #InternetConfiguration #TTCFont #ArchiveViewer #CPUWatcher #ProcessBrowser #ExternalSettings #Symbol #SecurityManager #AutoStart #FileStream #CommandHistory #StrikeFontSet #MessageTally #ImageSegment #Password #HttpUrl #SoundPlayer #FileDirectory #Color #StrikeFont #PasteUpMorph #ControlManager #DisplayScreen #Delay) asOrderedCollection.		SmalltalkImage compile: 'snapshot: save andQuit: quit withExitCode: exitCode embedded: embeddedFlag	"Mark the changes file and close all files as part of #processShutdownList.	If save is true, save the current state of this Smalltalk in the image file.	If quit is true, then exit to the outer OS shell.	If exitCode is not nil, then use it as exit code.	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."	| resuming msg |	Object flushDependents.	Object flushEvents.	(SourceFiles at: 2) ifNotNil:[		msg := String streamContents: [ :s |			s nextPutAll: ''----'';			nextPutAll: (save ifTrue: [ quit ifTrue: [ ''QUIT'' ] ifFalse: [ ''SNAPSHOT'' ] ]							ifFalse: [quit ifTrue: [ ''QUIT/NOSAVE'' ] ifFalse: [ ''NOP'' ]]);			nextPutAll: ''----'';			print: Date dateAndTimeNow; space;			nextPutAll: (FileDirectory default localNameFor: self imageName);			nextPutAll: '' priorSource: '';			print: LastQuitLogPosition ].		self assureStartupStampLogged.		save ifTrue: [ LastQuitLogPosition := (SourceFiles at: 2) setToEnd; position ].		self logChange: msg.		Transcript cr; show: msg	].	Smalltalk processShutDownList: quit.	Cursor write show.	save ifTrue: [resuming := embeddedFlag 					ifTrue: [self snapshotEmbeddedPrimitive] 					ifFalse: [self snapshotPrimitive].  "<-- PC frozen here on image file"				resuming == false "guard against failure" ifTrue:					[]]		ifFalse: [resuming := false].	quit & (resuming == false) ifTrue: [		exitCode			ifNil: [ self quitPrimitive ]			ifNotNil: [ self quitPrimitive: exitCode ] ].	Cursor normal show.	Smalltalk setGCParameters.	resuming == true ifTrue: [Smalltalk clearExternalObjects].	Smalltalk processStartUpList: resuming == true.	resuming == true ifTrue:[		self setPlatformPreferences.		self recordStartupStamp].	"Now it''s time to raise an error"	resuming == nil ifTrue: [self error:''Failed to write image file (disk full?)''].	^ resuming' classified: 'whatever'.		(SmalltalkImage classPool)		at: #StartUpList		put: #(#SmallInteger #Delay #Other #HostPlatform #WebEntrance #ProcessorScheduler #FileDirectory #ShortIntegerArray #ShortRunArray #MessageTally #NaturalLanguageTranslator #LanguageEnvironment #PowerManagement #ExternalSettings #SecurityManager #FileStream #UUIDGenerator #CPUWatcher #DateAndTime #SmalltalkImage #Utilities #WeakArray #MultiByteFileStream #InternetConfiguration #Locale #Collection #HostWindowProxy #NetNameResolver #Caffeine #Worker #Webpage #ExternalResource) asOrderedCollection.	EditHistory connectTo: 'ws://localhost:8091/tether'.	weakArray := WeakArray with: Object new.	navigation := SystemNavigation new.		fusedMethods := (		(OrderedCollection new)			addAll: {				Object compiledMethodAt: #halt:.				Object compiledMethodAt: #primitiveError:.				Object compiledMethodAt: #perform:.								Object compiledMethodAt: #perform:with:.				Object compiledMethodAt: #perform:with:with:.				Object compiledMethodAt: #perform:with:with:with:.				Object compiledMethodAt: #perform:with:with:with:with:.				Object compiledMethodAt: #perform:withArguments:.						Object compiledMethodAt: #perform:withArguments:inSuperclass:.						Object compiledMethodAt: #perform:withEnoughArguments:.				Object compiledMethodAt: #isSymbol.				Behavior reloadingMethod.				EditHistory compiledMethodAt: #swapInMethodAt:in:.				Object compiledMethodAt: #adaptToInteger:andSend:.				Object compiledMethodAt: #in:.				Object compiledMethodAt: #addDependent:.				Symbol compiledMethodAt: #isSymbol.				ContextPart compiledMethodAt: #selector.				ContextPart compiledMethodAt: #arguments.				CompiledMethod compiledMethodAt: #selector.				UUIDGenerator compiledMethodAt: #semaphoreForGenerator.				UUIDGenerator compiledMethodAt: #randomGenerator.				ProtoObject compiledMethodAt: #initialize.				BlockClosure compiledMethodAt: #value.				BlockContext compiledMethodAt: #value.				Semaphore compiledMethodAt: #wait.				UndefinedObject compiledMethodAt: #release.				ClassOrganizer compiledMethodAt: #traitComposition.				ByteString class compiledMethodAt: #stringHash:initialHash:};			yourself).			{		#(id isNil notNil isInteger removeFromSystem removeFromSystem: hashBytes:startingWith: size species signal resumptionTime primGetNextEvent: bitAnd: new: new negative at: at:put: bitShiftMagnitude: bitOr: < randomCounter / + asFloat bitXor: identityHash basicAt: basicAt:put: basicNew: basicNew isMethodProperties printString).		CompiledMethodTrailer trailerKindDecoders.	}		do: [:set |			set do: [:selector |		(navigation allImplementorsOf: selector) do: [:reference | fusedMethods add: reference compiledMethod]]].	self		fuseHeadlessSingleClassesInto: fusedMethods;		fuseHeadlessClassHierarchiesInto: fusedMethods.				fusedMethods do: [:method | method fuse].		Behavior setReloadingMethod.	reloadingMethod := Behavior reloadingMethod.	Shaker class swapOutMethodAt: #test:.	(Shaker test: 42) = 42 ifFalse: [self error: 'history system not working'].		"Set the selector and class-binding literals of the reloading method to things which make sense in the JS debugger."	Behavior setReloadingMethod.	LRUCache allInstancesDo: [:cache | cache reset].	WeakArray restartFinalizationProcess.	[3 error: 'ignored'] on: Error do: [:exception | ].	Delay initialize.	(Delay forSeconds: 1) wait.		{		BlockClosure.		ContextPart	}		do: [:class |			class allSubInstancesDo: [:methodHolder | methodHolder fuse]].		JS at: #shaking put: true.	Smalltalk		primitiveGarbageCollect;		primitiveFusedGarbageCollect;		primitiveFusedGarbageCollect.			numberOfClassesRemoved := -1.		[numberOfClassesRemoved = 0] whileFalse: [		numberOfClassesRemoved := 0.		(Class allSubclasses asSortedCollection: [:earlier :later | earlier depth <= later depth]) asArray reversed do: [:metaclass |			(				metaclass soleInstance subclasses isEmpty not or: [					{						metaclass.						metaclass soleInstance					}						anySatisfy: [:behavior |							behavior methodDict anySatisfy: [:method | method ~~ reloadingMethod]]]			)				ifFalse: [					metaclass soleInstance removeFromSystem.					numberOfClassesRemoved := numberOfClassesRemoved + 1]]].		Smalltalk garbageCollect! !----SNAPSHOT----{25 September 2019 . 1:45:09 pm} history.image priorSource: 1948629!#[101 120 101 99 117 116 111 114] asString!----STARTUP----{25 September 2019 . 1:56:58 pm} as /Users/craig/Downloads/caffeine/backups/37 (headless)/history.image!'From Squeak4.6 of 8 July 2015 [latest update: #15102] on 25 September 2019 at 1:58:02 pm'!Object weakSubclass: #WeakFinalizerItem	instanceVariableNames: 'list next executor'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Finalization'!Object weakSubclass: #WeakFinalizerItem	instanceVariableNames: 'list next executor'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Finalization'!WeakFinalizerItem methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/22/2010 21:06'!!WeakFinalizerItem methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/22/2010 21:06' prior: 16833408!add: newExecutor	executor 		ifNil: [ executor := newExecutor ]		ifNotNil: [			executor hasMultipleExecutors				ifTrue: [ executor add: newExecutor]				ifFalse: [ executor := ObjectFinalizerCollection with: executor with: newExecutor ]		]! !WeakFinalizerItem methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/22/2010 21:06'!!WeakFinalizerItem methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/22/2010 21:06' prior: 34996997!clear	list := next := nil.! !WeakFinalizerItem methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/22/2010 21:06'!!WeakFinalizerItem methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/22/2010 21:06' prior: 34996997!copyWithList: aList	^ self copy list: aList! !WeakFinalizerItem methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/22/2010 21:06'!!WeakFinalizerItem methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/22/2010 21:06' prior: 34996997!executor	^ executor! !WeakFinalizerItem methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/22/2010 21:06'!!WeakFinalizerItem methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/22/2010 21:06' prior: 16837482!finalizeValues	" cleanup the receiver, so it could be reused "	| ex |	ex := executor.	executor := nil.	next := nil.	ex finalize.! !WeakFinalizerItem methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/22/2010 21:06'!!WeakFinalizerItem methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/22/2010 21:06' prior: 34996997!list	^ list! !WeakFinalizerItem methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/22/2010 21:06'!!WeakFinalizerItem methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/22/2010 21:06' prior: 34996997!list: aList	list := aList! !WeakFinalizerItem methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/22/2010 21:06'!!WeakFinalizerItem methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/22/2010 21:06' prior: 16838280!list: weakFinalizationList object: anObject	self assert: (weakFinalizationList class == WeakFinalizationList).	list := weakFinalizationList.	self at: 1 put: anObject.! !WeakFinalizerItem methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/22/2010 21:06'!!WeakFinalizerItem methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/22/2010 21:06' prior: 34996997!list: weakFinalizationList object: anObject executor: anExecutor	self assert: (weakFinalizationList class == WeakFinalizationList).	list := weakFinalizationList.	self at: 1 put: anObject.	executor := anExecutor! !WeakFinalizerItem methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/22/2010 21:06'!!WeakFinalizerItem methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/22/2010 21:06' prior: 16835412!next	^ next! !WeakFinalizerItem methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/22/2010 21:06'!!WeakFinalizerItem methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 9/22/2010 21:06' prior: 34996997!object	^ self at: 1! !WeakFinalizerItem methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 10/11/2010 15:06'!!WeakFinalizerItem methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 10/11/2010 15:06' prior: 34996997!postCopy	executor hasMultipleExecutors ifTrue: [ executor := executor copy ].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WeakFinalizerItem class	instanceVariableNames: ''!WeakFinalizerItem class methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 3/8/2010 21:00'!!WeakFinalizerItem class methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 3/8/2010 21:00' prior: 16839914!new	^ self basicNew: 1! !----End fileIn of /Users/craig/Downloads/caffeine/backups/28 (history server)/WeakFinalizerItem.st----!----SNAPSHOT----{25 September 2019 . 1:59:16 pm} history.image priorSource: 1955795!#[101 120 101 99 117 116 111 114] asString!----STARTUP----{25 September 2019 . 2:19:26 pm} as /Users/craig/Downloads/caffeine/backups/37 (headless)/history.image!!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 14:19' prior: 35503390!shakeHeadless	| fusedMethods weakArray navigation reloadingMethod numberOfClassesRemoved |		(SmalltalkImage classPool)		at: #ShutDownList		put: #(#TTFileDescription #InternetConfiguration #TTCFont #ArchiveViewer #CPUWatcher #ProcessBrowser #ExternalSettings #Symbol #SecurityManager #AutoStart #FileStream #CommandHistory #StrikeFontSet #MessageTally #ImageSegment #Password #HttpUrl #SoundPlayer #FileDirectory #Color #StrikeFont #PasteUpMorph #ControlManager #DisplayScreen #Delay) asOrderedCollection.		SmalltalkImage compile: 'snapshot: save andQuit: quit withExitCode: exitCode embedded: embeddedFlag	"Mark the changes file and close all files as part of #processShutdownList.	If save is true, save the current state of this Smalltalk in the image file.	If quit is true, then exit to the outer OS shell.	If exitCode is not nil, then use it as exit code.	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."	| resuming msg |	Object flushDependents.	Object flushEvents.	(SourceFiles at: 2) ifNotNil:[		msg := String streamContents: [ :s |			s nextPutAll: ''----'';			nextPutAll: (save ifTrue: [ quit ifTrue: [ ''QUIT'' ] ifFalse: [ ''SNAPSHOT'' ] ]							ifFalse: [quit ifTrue: [ ''QUIT/NOSAVE'' ] ifFalse: [ ''NOP'' ]]);			nextPutAll: ''----'';			print: Date dateAndTimeNow; space;			nextPutAll: (FileDirectory default localNameFor: self imageName);			nextPutAll: '' priorSource: '';			print: LastQuitLogPosition ].		self assureStartupStampLogged.		save ifTrue: [ LastQuitLogPosition := (SourceFiles at: 2) setToEnd; position ].		self logChange: msg.		Transcript cr; show: msg	].	Smalltalk processShutDownList: quit.	Cursor write show.	save ifTrue: [resuming := embeddedFlag 					ifTrue: [self snapshotEmbeddedPrimitive] 					ifFalse: [self snapshotPrimitive].  "<-- PC frozen here on image file"				resuming == false "guard against failure" ifTrue:					[]]		ifFalse: [resuming := false].	quit & (resuming == false) ifTrue: [		exitCode			ifNil: [ self quitPrimitive ]			ifNotNil: [ self quitPrimitive: exitCode ] ].	Cursor normal show.	Smalltalk setGCParameters.	resuming == true ifTrue: [Smalltalk clearExternalObjects].	Smalltalk processStartUpList: resuming == true.	resuming == true ifTrue:[		self setPlatformPreferences.		self recordStartupStamp].	"Now it''s time to raise an error"	resuming == nil ifTrue: [self error:''Failed to write image file (disk full?)''].	^ resuming' classified: 'whatever'.		(SmalltalkImage classPool)		at: #StartUpList		put: #(#SmallInteger #Delay #Other #HostPlatform #WebEntrance #ProcessorScheduler #FileDirectory #ShortIntegerArray #ShortRunArray #MessageTally #NaturalLanguageTranslator #LanguageEnvironment #PowerManagement #ExternalSettings #SecurityManager #FileStream #UUIDGenerator #CPUWatcher #DateAndTime #SmalltalkImage #Utilities #WeakArray #MultiByteFileStream #InternetConfiguration #Locale #Collection #HostWindowProxy #NetNameResolver #Caffeine #Worker #Webpage #ExternalResource) asOrderedCollection.	EditHistory connectTo: 'ws://localhost:8091/tether'.	weakArray := WeakArray with: Object new.	navigation := SystemNavigation new.		fusedMethods := (		(OrderedCollection new)			addAll: {				Object compiledMethodAt: #executor.				Object compiledMethodAt: #halt:.				Object compiledMethodAt: #primitiveError:.				Object compiledMethodAt: #perform:.								Object compiledMethodAt: #perform:with:.				Object compiledMethodAt: #perform:with:with:.				Object compiledMethodAt: #perform:with:with:with:.				Object compiledMethodAt: #perform:with:with:with:with:.				Object compiledMethodAt: #perform:withArguments:.						Object compiledMethodAt: #perform:withArguments:inSuperclass:.						Object compiledMethodAt: #perform:withEnoughArguments:.				Object compiledMethodAt: #isSymbol.				Behavior reloadingMethod.				EditHistory compiledMethodAt: #swapInMethodAt:in:.				Object compiledMethodAt: #adaptToInteger:andSend:.				Object compiledMethodAt: #in:.				Object compiledMethodAt: #addDependent:.				Symbol compiledMethodAt: #isSymbol.				ContextPart compiledMethodAt: #selector.				ContextPart compiledMethodAt: #arguments.				CompiledMethod compiledMethodAt: #selector.				UUIDGenerator compiledMethodAt: #semaphoreForGenerator.				UUIDGenerator compiledMethodAt: #randomGenerator.				ProtoObject compiledMethodAt: #initialize.				BlockClosure compiledMethodAt: #value.				BlockContext compiledMethodAt: #value.				Semaphore compiledMethodAt: #wait.				UndefinedObject compiledMethodAt: #release.				ClassOrganizer compiledMethodAt: #traitComposition.				ByteString class compiledMethodAt: #stringHash:initialHash:};			yourself).			{		#(id isNil notNil isInteger removeFromSystem removeFromSystem: hashBytes:startingWith: size species signal resumptionTime primGetNextEvent: bitAnd: new: new negative at: at:put: bitShiftMagnitude: bitOr: < randomCounter / + asFloat bitXor: identityHash basicAt: basicAt:put: basicNew: basicNew isMethodProperties printString).		CompiledMethodTrailer trailerKindDecoders.	}		do: [:set |			set do: [:selector |		(navigation allImplementorsOf: selector) do: [:reference | fusedMethods add: reference compiledMethod]]].	self		fuseHeadlessSingleClassesInto: fusedMethods;		fuseHeadlessClassHierarchiesInto: fusedMethods.				fusedMethods do: [:method | method fuse].		Behavior setReloadingMethod.	reloadingMethod := Behavior reloadingMethod.	Shaker class swapOutMethodAt: #test:.	(Shaker test: 42) = 42 ifFalse: [self error: 'history system not working'].		"Set the selector and class-binding literals of the reloading method to things which make sense in the JS debugger."	Behavior setReloadingMethod.	LRUCache allInstancesDo: [:cache | cache reset].	WeakArray restartFinalizationProcess.	[3 error: 'ignored'] on: Error do: [:exception | ].	Delay initialize.	(Delay forSeconds: 1) wait.		{		BlockClosure.		ContextPart	}		do: [:class |			class allSubInstancesDo: [:methodHolder | methodHolder fuse]].		JS at: #shaking put: true.	Smalltalk		primitiveGarbageCollect;		primitiveFusedGarbageCollect;		primitiveFusedGarbageCollect.			numberOfClassesRemoved := -1.		[numberOfClassesRemoved = 0] whileFalse: [		numberOfClassesRemoved := 0.		(Class allSubclasses asSortedCollection: [:earlier :later | earlier depth <= later depth]) asArray reversed do: [:metaclass |			(				metaclass soleInstance subclasses isEmpty not or: [					{						metaclass.						metaclass soleInstance					}						anySatisfy: [:behavior |							behavior methodDict anySatisfy: [:method | method ~~ reloadingMethod]]]			)				ifFalse: [					metaclass soleInstance removeFromSystem.					numberOfClassesRemoved := numberOfClassesRemoved + 1]]].		Smalltalk garbageCollect! !----QUIT----{25 September 2019 . 2:20:03 pm} history.image priorSource: 1960406!----STARTUP----{25 September 2019 . 2:38:53 pm} as /Users/craig/Downloads/caffeine/backups/37 (headless)/history.image!!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 14:39' prior: 35515180!shakeHeadless	| fusedMethods weakArray navigation reloadingMethod numberOfClassesRemoved |		(SmalltalkImage classPool)		at: #ShutDownList		put: #(#TTFileDescription #InternetConfiguration #TTCFont #ArchiveViewer #CPUWatcher #ProcessBrowser #ExternalSettings #Symbol #SecurityManager #AutoStart #FileStream #CommandHistory #StrikeFontSet #MessageTally #ImageSegment #Password #HttpUrl #SoundPlayer #FileDirectory #Color #StrikeFont #PasteUpMorph #ControlManager #DisplayScreen #Delay) asOrderedCollection.		SmalltalkImage compile: 'snapshot: save andQuit: quit withExitCode: exitCode embedded: embeddedFlag	"Mark the changes file and close all files as part of #processShutdownList.	If save is true, save the current state of this Smalltalk in the image file.	If quit is true, then exit to the outer OS shell.	If exitCode is not nil, then use it as exit code.	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."	| resuming msg |	Object flushDependents.	Object flushEvents.	(SourceFiles at: 2) ifNotNil:[		msg := String streamContents: [ :s |			s nextPutAll: ''----'';			nextPutAll: (save ifTrue: [ quit ifTrue: [ ''QUIT'' ] ifFalse: [ ''SNAPSHOT'' ] ]							ifFalse: [quit ifTrue: [ ''QUIT/NOSAVE'' ] ifFalse: [ ''NOP'' ]]);			nextPutAll: ''----'';			print: Date dateAndTimeNow; space;			nextPutAll: (FileDirectory default localNameFor: self imageName);			nextPutAll: '' priorSource: '';			print: LastQuitLogPosition ].		self assureStartupStampLogged.		save ifTrue: [ LastQuitLogPosition := (SourceFiles at: 2) setToEnd; position ].		self logChange: msg.		Transcript cr; show: msg	].	Smalltalk processShutDownList: quit.	Cursor write show.	save ifTrue: [resuming := embeddedFlag 					ifTrue: [self snapshotEmbeddedPrimitive] 					ifFalse: [self snapshotPrimitive].  "<-- PC frozen here on image file"				resuming == false "guard against failure" ifTrue:					[]]		ifFalse: [resuming := false].	quit & (resuming == false) ifTrue: [		exitCode			ifNil: [ self quitPrimitive ]			ifNotNil: [ self quitPrimitive: exitCode ] ].	Cursor normal show.	Smalltalk setGCParameters.	resuming == true ifTrue: [Smalltalk clearExternalObjects].	Smalltalk processStartUpList: resuming == true.	resuming == true ifTrue:[		self setPlatformPreferences.		self recordStartupStamp].	"Now it''s time to raise an error"	resuming == nil ifTrue: [self error:''Failed to write image file (disk full?)''].	^ resuming' classified: 'whatever'.		(SmalltalkImage classPool)		at: #StartUpList		put: #(#SmallInteger #Delay #Other #HostPlatform #WebEntrance #ProcessorScheduler #FileDirectory #ShortIntegerArray #ShortRunArray #MessageTally #NaturalLanguageTranslator #LanguageEnvironment #PowerManagement #ExternalSettings #SecurityManager #FileStream #UUIDGenerator #CPUWatcher #DateAndTime #SmalltalkImage #Utilities #WeakArray #MultiByteFileStream #InternetConfiguration #Locale #Collection #HostWindowProxy #NetNameResolver #Caffeine #Worker #Webpage #ExternalResource) asOrderedCollection.	EditHistory connectTo: 'ws://localhost:8091/tether'.	weakArray := WeakArray with: Object new.	navigation := SystemNavigation new.		fusedMethods := (		(OrderedCollection new)			addAll: {				Object compiledMethodAt: #isPseudoContext.				Object compiledMethodAt: #executor.				Object compiledMethodAt: #halt:.				Object compiledMethodAt: #primitiveError:.				Object compiledMethodAt: #perform:.								Object compiledMethodAt: #perform:with:.				Object compiledMethodAt: #perform:with:with:.				Object compiledMethodAt: #perform:with:with:with:.				Object compiledMethodAt: #perform:with:with:with:with:.				Object compiledMethodAt: #perform:withArguments:.						Object compiledMethodAt: #perform:withArguments:inSuperclass:.						Object compiledMethodAt: #perform:withEnoughArguments:.				Object compiledMethodAt: #isSymbol.				Behavior reloadingMethod.				EditHistory compiledMethodAt: #swapInMethodAt:in:.				Object compiledMethodAt: #adaptToInteger:andSend:.				Object compiledMethodAt: #in:.				Object compiledMethodAt: #addDependent:.				Symbol compiledMethodAt: #isSymbol.				ContextPart compiledMethodAt: #selector.				ContextPart compiledMethodAt: #arguments.				CompiledMethod compiledMethodAt: #selector.				UUIDGenerator compiledMethodAt: #semaphoreForGenerator.				UUIDGenerator compiledMethodAt: #randomGenerator.				ProtoObject compiledMethodAt: #initialize.				BlockClosure compiledMethodAt: #value.				BlockContext compiledMethodAt: #value.				Semaphore compiledMethodAt: #wait.				UndefinedObject compiledMethodAt: #release.				ClassOrganizer compiledMethodAt: #traitComposition.				ByteString class compiledMethodAt: #stringHash:initialHash:};			yourself).			{		#(id isNil notNil isInteger removeFromSystem removeFromSystem: hashBytes:startingWith: size species signal resumptionTime primGetNextEvent: bitAnd: new: new negative at: at:put: bitShiftMagnitude: bitOr: < randomCounter / + asFloat bitXor: identityHash basicAt: basicAt:put: basicNew: basicNew isMethodProperties printString).		CompiledMethodTrailer trailerKindDecoders.	}		do: [:set |			set do: [:selector |		(navigation allImplementorsOf: selector) do: [:reference | fusedMethods add: reference compiledMethod]]].	self		fuseHeadlessSingleClassesInto: fusedMethods;		fuseHeadlessClassHierarchiesInto: fusedMethods.				fusedMethods do: [:method | method fuse].		Behavior setReloadingMethod.	reloadingMethod := Behavior reloadingMethod.	Shaker class swapOutMethodAt: #test:.	(Shaker test: 42) = 42 ifFalse: [self error: 'history system not working'].		"Set the selector and class-binding literals of the reloading method to things which make sense in the JS debugger."	Behavior setReloadingMethod.	LRUCache allInstancesDo: [:cache | cache reset].	WeakArray restartFinalizationProcess.	[3 error: 'ignored'] on: Error do: [:exception | ].	Delay initialize.	(Delay forSeconds: 1) wait.		{		BlockClosure.		ContextPart	}		do: [:class |			class allSubInstancesDo: [:methodHolder | methodHolder fuse]].		JS at: #shaking put: true.	Smalltalk		primitiveGarbageCollect;		primitiveFusedGarbageCollect;		primitiveFusedGarbageCollect.			numberOfClassesRemoved := -1.		[numberOfClassesRemoved = 0] whileFalse: [		numberOfClassesRemoved := 0.		(Class allSubclasses asSortedCollection: [:earlier :later | earlier depth <= later depth]) asArray reversed do: [:metaclass |			(				metaclass soleInstance subclasses isEmpty not or: [					{						metaclass.						metaclass soleInstance					}						anySatisfy: [:behavior |							behavior methodDict anySatisfy: [:method | method ~~ reloadingMethod]]]			)				ifFalse: [					metaclass soleInstance removeFromSystem.					numberOfClassesRemoved := numberOfClassesRemoved + 1]]].		Smalltalk garbageCollect! !----QUIT----{25 September 2019 . 2:39:39 pm} history.image priorSource: 1967625!----STARTUP----{25 September 2019 . 2:45:24 pm} as /Users/craig/Downloads/caffeine/backups/37 (headless)/history.image!#[97 99 116 65 115 69 120 101 99 117 116 111 114] asString!!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 14:47' prior: 35522350!shakeHeadless	| fusedMethods weakArray navigation reloadingMethod numberOfClassesRemoved |		(SmalltalkImage classPool)		at: #ShutDownList		put: #(#TTFileDescription #InternetConfiguration #TTCFont #ArchiveViewer #CPUWatcher #ProcessBrowser #ExternalSettings #Symbol #SecurityManager #AutoStart #FileStream #CommandHistory #StrikeFontSet #MessageTally #ImageSegment #Password #HttpUrl #SoundPlayer #FileDirectory #Color #StrikeFont #PasteUpMorph #ControlManager #DisplayScreen #Delay) asOrderedCollection.		SmalltalkImage compile: 'snapshot: save andQuit: quit withExitCode: exitCode embedded: embeddedFlag	"Mark the changes file and close all files as part of #processShutdownList.	If save is true, save the current state of this Smalltalk in the image file.	If quit is true, then exit to the outer OS shell.	If exitCode is not nil, then use it as exit code.	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."	| resuming msg |	Object flushDependents.	Object flushEvents.	(SourceFiles at: 2) ifNotNil:[		msg := String streamContents: [ :s |			s nextPutAll: ''----'';			nextPutAll: (save ifTrue: [ quit ifTrue: [ ''QUIT'' ] ifFalse: [ ''SNAPSHOT'' ] ]							ifFalse: [quit ifTrue: [ ''QUIT/NOSAVE'' ] ifFalse: [ ''NOP'' ]]);			nextPutAll: ''----'';			print: Date dateAndTimeNow; space;			nextPutAll: (FileDirectory default localNameFor: self imageName);			nextPutAll: '' priorSource: '';			print: LastQuitLogPosition ].		self assureStartupStampLogged.		save ifTrue: [ LastQuitLogPosition := (SourceFiles at: 2) setToEnd; position ].		self logChange: msg.		Transcript cr; show: msg	].	Smalltalk processShutDownList: quit.	Cursor write show.	save ifTrue: [resuming := embeddedFlag 					ifTrue: [self snapshotEmbeddedPrimitive] 					ifFalse: [self snapshotPrimitive].  "<-- PC frozen here on image file"				resuming == false "guard against failure" ifTrue:					[]]		ifFalse: [resuming := false].	quit & (resuming == false) ifTrue: [		exitCode			ifNil: [ self quitPrimitive ]			ifNotNil: [ self quitPrimitive: exitCode ] ].	Cursor normal show.	Smalltalk setGCParameters.	resuming == true ifTrue: [Smalltalk clearExternalObjects].	Smalltalk processStartUpList: resuming == true.	resuming == true ifTrue:[		self setPlatformPreferences.		self recordStartupStamp].	"Now it''s time to raise an error"	resuming == nil ifTrue: [self error:''Failed to write image file (disk full?)''].	^ resuming' classified: 'whatever'.		(SmalltalkImage classPool)		at: #StartUpList		put: #(#SmallInteger #Delay #Other #HostPlatform #WebEntrance #ProcessorScheduler #FileDirectory #ShortIntegerArray #ShortRunArray #MessageTally #NaturalLanguageTranslator #LanguageEnvironment #PowerManagement #ExternalSettings #SecurityManager #FileStream #UUIDGenerator #CPUWatcher #DateAndTime #SmalltalkImage #Utilities #WeakArray #MultiByteFileStream #InternetConfiguration #Locale #Collection #HostWindowProxy #NetNameResolver #Caffeine #Worker #Webpage #ExternalResource) asOrderedCollection.	EditHistory connectTo: 'ws://localhost:8091/tether'.	weakArray := WeakArray with: Object new.	navigation := SystemNavigation new.		fusedMethods := (		(OrderedCollection new)			addAll: {				Object compiledMethodAt: #actAsExecutor.				Object compiledMethodAt: #isPseudoContext.				Object compiledMethodAt: #executor.				Object compiledMethodAt: #halt:.				Object compiledMethodAt: #primitiveError:.				Object compiledMethodAt: #perform:.								Object compiledMethodAt: #perform:with:.				Object compiledMethodAt: #perform:with:with:.				Object compiledMethodAt: #perform:with:with:with:.				Object compiledMethodAt: #perform:with:with:with:with:.				Object compiledMethodAt: #perform:withArguments:.						Object compiledMethodAt: #perform:withArguments:inSuperclass:.						Object compiledMethodAt: #perform:withEnoughArguments:.				Object compiledMethodAt: #isSymbol.				Behavior reloadingMethod.				EditHistory compiledMethodAt: #swapInMethodAt:in:.				Object compiledMethodAt: #adaptToInteger:andSend:.				Object compiledMethodAt: #in:.				Object compiledMethodAt: #addDependent:.				Symbol compiledMethodAt: #isSymbol.				ContextPart compiledMethodAt: #selector.				ContextPart compiledMethodAt: #arguments.				CompiledMethod compiledMethodAt: #selector.				UUIDGenerator compiledMethodAt: #semaphoreForGenerator.				UUIDGenerator compiledMethodAt: #randomGenerator.				ProtoObject compiledMethodAt: #initialize.				BlockClosure compiledMethodAt: #value.				BlockContext compiledMethodAt: #value.				Semaphore compiledMethodAt: #wait.				UndefinedObject compiledMethodAt: #release.				ClassOrganizer compiledMethodAt: #traitComposition.				ByteString class compiledMethodAt: #stringHash:initialHash:};			yourself).			{		#(id isNil notNil isInteger removeFromSystem removeFromSystem: hashBytes:startingWith: size species signal resumptionTime primGetNextEvent: bitAnd: new: new negative at: at:put: bitShiftMagnitude: bitOr: < randomCounter / + asFloat bitXor: identityHash basicAt: basicAt:put: basicNew: basicNew isMethodProperties printString).		CompiledMethodTrailer trailerKindDecoders.	}		do: [:set |			set do: [:selector |		(navigation allImplementorsOf: selector) do: [:reference | fusedMethods add: reference compiledMethod]]].	self		fuseHeadlessSingleClassesInto: fusedMethods;		fuseHeadlessClassHierarchiesInto: fusedMethods.				fusedMethods do: [:method | method fuse].		Behavior setReloadingMethod.	reloadingMethod := Behavior reloadingMethod.	Shaker class swapOutMethodAt: #test:.	(Shaker test: 42) = 42 ifFalse: [self error: 'history system not working'].		"Set the selector and class-binding literals of the reloading method to things which make sense in the JS debugger."	Behavior setReloadingMethod.	LRUCache allInstancesDo: [:cache | cache reset].	WeakArray restartFinalizationProcess.	[3 error: 'ignored'] on: Error do: [:exception | ].	Delay initialize.	(Delay forSeconds: 1) wait.		{		BlockClosure.		ContextPart	}		do: [:class |			class allSubInstancesDo: [:methodHolder | methodHolder fuse]].		JS at: #shaking put: true.	Smalltalk		primitiveGarbageCollect;		primitiveFusedGarbageCollect;		primitiveFusedGarbageCollect.			numberOfClassesRemoved := -1.		[numberOfClassesRemoved = 0] whileFalse: [		numberOfClassesRemoved := 0.		(Class allSubclasses asSortedCollection: [:earlier :later | earlier depth <= later depth]) asArray reversed do: [:metaclass |			(				metaclass soleInstance subclasses isEmpty not or: [					{						metaclass.						metaclass soleInstance					}						anySatisfy: [:behavior |							behavior methodDict anySatisfy: [:method | method ~~ reloadingMethod]]]			)				ifFalse: [					metaclass soleInstance removeFromSystem.					numberOfClassesRemoved := numberOfClassesRemoved + 1]]].		Smalltalk garbageCollect! !----QUIT----{25 September 2019 . 2:47:08 pm} history.image priorSource: 1974842!----STARTUP----{25 September 2019 . 3:12:42 pm} as /Users/craig/Downloads/caffeine/backups/37 (headless)/history.image!!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 15:14' prior: 35529628!shakeHeadless	| fusedMethods weakArray navigation reloadingMethod numberOfClassesRemoved |		(SmalltalkImage classPool)		at: #ShutDownList		put: #(#TTFileDescription #InternetConfiguration #TTCFont #ArchiveViewer #CPUWatcher #ProcessBrowser #ExternalSettings #Symbol #SecurityManager #AutoStart #FileStream #CommandHistory #StrikeFontSet #MessageTally #ImageSegment #Password #HttpUrl #SoundPlayer #FileDirectory #Color #StrikeFont #PasteUpMorph #ControlManager #DisplayScreen #Delay) asOrderedCollection.		SmalltalkImage compile: 'snapshot: save andQuit: quit withExitCode: exitCode embedded: embeddedFlag	"Mark the changes file and close all files as part of #processShutdownList.	If save is true, save the current state of this Smalltalk in the image file.	If quit is true, then exit to the outer OS shell.	If exitCode is not nil, then use it as exit code.	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."	| resuming msg |	Object flushDependents.	Object flushEvents.	(SourceFiles at: 2) ifNotNil:[		msg := String streamContents: [ :s |			s nextPutAll: ''----'';			nextPutAll: (save ifTrue: [ quit ifTrue: [ ''QUIT'' ] ifFalse: [ ''SNAPSHOT'' ] ]							ifFalse: [quit ifTrue: [ ''QUIT/NOSAVE'' ] ifFalse: [ ''NOP'' ]]);			nextPutAll: ''----'';			print: Date dateAndTimeNow; space;			nextPutAll: (FileDirectory default localNameFor: self imageName);			nextPutAll: '' priorSource: '';			print: LastQuitLogPosition ].		self assureStartupStampLogged.		save ifTrue: [ LastQuitLogPosition := (SourceFiles at: 2) setToEnd; position ].		self logChange: msg.		Transcript cr; show: msg	].	Smalltalk processShutDownList: quit.	Cursor write show.	save ifTrue: [resuming := embeddedFlag 					ifTrue: [self snapshotEmbeddedPrimitive] 					ifFalse: [self snapshotPrimitive].  "<-- PC frozen here on image file"				resuming == false "guard against failure" ifTrue:					[]]		ifFalse: [resuming := false].	quit & (resuming == false) ifTrue: [		exitCode			ifNil: [ self quitPrimitive ]			ifNotNil: [ self quitPrimitive: exitCode ] ].	Cursor normal show.	Smalltalk setGCParameters.	resuming == true ifTrue: [Smalltalk clearExternalObjects].	Smalltalk processStartUpList: resuming == true.	resuming == true ifTrue:[		self setPlatformPreferences.		self recordStartupStamp].	"Now it''s time to raise an error"	resuming == nil ifTrue: [self error:''Failed to write image file (disk full?)''].	^ resuming' classified: 'whatever'.		(SmalltalkImage classPool)		at: #StartUpList		put: #(#SmallInteger #Delay #Other #HostPlatform #WebEntrance #ProcessorScheduler #FileDirectory #ShortIntegerArray #ShortRunArray #MessageTally #NaturalLanguageTranslator #LanguageEnvironment #PowerManagement #ExternalSettings #SecurityManager #FileStream #UUIDGenerator #CPUWatcher #DateAndTime #SmalltalkImage #Utilities #WeakArray #MultiByteFileStream #InternetConfiguration #Locale #Collection #HostWindowProxy #NetNameResolver #Caffeine #Worker #Webpage #ExternalResource) asOrderedCollection.	EditHistory connectTo: 'ws://localhost:8091/tether'.	weakArray := WeakArray with: Object new.	navigation := SystemNavigation new.		fusedMethods := (		(OrderedCollection new)			addAll: {				Object compiledMethodAt: #breakDependents.				Object compiledMethodAt: #actAsExecutor.				Object compiledMethodAt: #isPseudoContext.				Object compiledMethodAt: #executor.				Object compiledMethodAt: #halt:.				Object compiledMethodAt: #primitiveError:.				Object compiledMethodAt: #perform:.								Object compiledMethodAt: #perform:with:.				Object compiledMethodAt: #perform:with:with:.				Object compiledMethodAt: #perform:with:with:with:.				Object compiledMethodAt: #perform:with:with:with:with:.				Object compiledMethodAt: #perform:withArguments:.						Object compiledMethodAt: #perform:withArguments:inSuperclass:.						Object compiledMethodAt: #perform:withEnoughArguments:.				Object compiledMethodAt: #isSymbol.				Behavior reloadingMethod.				EditHistory compiledMethodAt: #swapInMethodAt:in:.				Object compiledMethodAt: #adaptToInteger:andSend:.				Object compiledMethodAt: #in:.				Object compiledMethodAt: #addDependent:.				Symbol compiledMethodAt: #isSymbol.				ContextPart compiledMethodAt: #selector.				ContextPart compiledMethodAt: #arguments.				CompiledMethod compiledMethodAt: #selector.				UUIDGenerator compiledMethodAt: #semaphoreForGenerator.				UUIDGenerator compiledMethodAt: #randomGenerator.				ProtoObject compiledMethodAt: #initialize.				BlockClosure compiledMethodAt: #value.				BlockContext compiledMethodAt: #value.				Semaphore compiledMethodAt: #wait.				UndefinedObject compiledMethodAt: #release.				ClassOrganizer compiledMethodAt: #traitComposition.				ByteString class compiledMethodAt: #stringHash:initialHash:};			yourself).			{		#(id isNil notNil isInteger removeFromSystem removeFromSystem: hashBytes:startingWith: size species signal resumptionTime primGetNextEvent: bitAnd: new: new negative at: at:put: bitShiftMagnitude: bitOr: < randomCounter / + asFloat bitXor: identityHash basicAt: basicAt:put: basicNew: basicNew isMethodProperties printString).		CompiledMethodTrailer trailerKindDecoders.	}		do: [:set |			set do: [:selector |		(navigation allImplementorsOf: selector) do: [:reference | fusedMethods add: reference compiledMethod]]].	self		fuseHeadlessSingleClassesInto: fusedMethods;		fuseHeadlessClassHierarchiesInto: fusedMethods.				fusedMethods do: [:method | method fuse].		Behavior setReloadingMethod.	reloadingMethod := Behavior reloadingMethod.	Shaker class swapOutMethodAt: #test:.	(Shaker test: 42) = 42 ifFalse: [self error: 'history system not working'].		"Set the selector and class-binding literals of the reloading method to things which make sense in the JS debugger."	Behavior setReloadingMethod.	LRUCache allInstancesDo: [:cache | cache reset].	WeakArray restartFinalizationProcess.	[3 error: 'ignored'] on: Error do: [:exception | ].	Delay initialize.	(Delay forSeconds: 1) wait.	Object new breakDependents.		{		BlockClosure.		ContextPart	}		do: [:class |			class allSubInstancesDo: [:methodHolder | methodHolder fuse]].		JS at: #shaking put: true.	Smalltalk		primitiveGarbageCollect;		primitiveFusedGarbageCollect;		primitiveFusedGarbageCollect.			numberOfClassesRemoved := -1.		[numberOfClassesRemoved = 0] whileFalse: [		numberOfClassesRemoved := 0.		(Class allSubclasses asSortedCollection: [:earlier :later | earlier depth <= later depth]) asArray reversed do: [:metaclass |			(				metaclass soleInstance subclasses isEmpty not or: [					{						metaclass.						metaclass soleInstance					}						anySatisfy: [:behavior |							behavior methodDict anySatisfy: [:method | method ~~ reloadingMethod]]]			)				ifFalse: [					metaclass soleInstance removeFromSystem.					numberOfClassesRemoved := numberOfClassesRemoved + 1]]].		Smalltalk garbageCollect! !----QUIT----{25 September 2019 . 3:14:28 pm} history.image priorSource: 1982165!----STARTUP----{25 September 2019 . 3:20:34 pm} as /Users/craig/Downloads/caffeine/backups/37 (headless)/history.image!!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 15:21' prior: 35536890!shakeHeadless	| fusedMethods weakArray navigation reloadingMethod numberOfClassesRemoved |		(SmalltalkImage classPool)		at: #ShutDownList		put: #(#TTFileDescription #InternetConfiguration #TTCFont #ArchiveViewer #CPUWatcher #ProcessBrowser #ExternalSettings #Symbol #SecurityManager #AutoStart #FileStream #CommandHistory #StrikeFontSet #MessageTally #ImageSegment #Password #HttpUrl #SoundPlayer #FileDirectory #Color #StrikeFont #PasteUpMorph #ControlManager #DisplayScreen #Delay) asOrderedCollection.		SmalltalkImage compile: 'snapshot: save andQuit: quit withExitCode: exitCode embedded: embeddedFlag	"Mark the changes file and close all files as part of #processShutdownList.	If save is true, save the current state of this Smalltalk in the image file.	If quit is true, then exit to the outer OS shell.	If exitCode is not nil, then use it as exit code.	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."	| resuming msg |	Object flushDependents.	Object flushEvents.	(SourceFiles at: 2) ifNotNil:[		msg := String streamContents: [ :s |			s nextPutAll: ''----'';			nextPutAll: (save ifTrue: [ quit ifTrue: [ ''QUIT'' ] ifFalse: [ ''SNAPSHOT'' ] ]							ifFalse: [quit ifTrue: [ ''QUIT/NOSAVE'' ] ifFalse: [ ''NOP'' ]]);			nextPutAll: ''----'';			print: Date dateAndTimeNow; space;			nextPutAll: (FileDirectory default localNameFor: self imageName);			nextPutAll: '' priorSource: '';			print: LastQuitLogPosition ].		self assureStartupStampLogged.		save ifTrue: [ LastQuitLogPosition := (SourceFiles at: 2) setToEnd; position ].		self logChange: msg.		Transcript cr; show: msg	].	Smalltalk processShutDownList: quit.	Cursor write show.	save ifTrue: [resuming := embeddedFlag 					ifTrue: [self snapshotEmbeddedPrimitive] 					ifFalse: [self snapshotPrimitive].  "<-- PC frozen here on image file"				resuming == false "guard against failure" ifTrue:					[]]		ifFalse: [resuming := false].	quit & (resuming == false) ifTrue: [		exitCode			ifNil: [ self quitPrimitive ]			ifNotNil: [ self quitPrimitive: exitCode ] ].	Cursor normal show.	Smalltalk setGCParameters.	resuming == true ifTrue: [Smalltalk clearExternalObjects].	Smalltalk processStartUpList: resuming == true.	resuming == true ifTrue:[		self setPlatformPreferences.		self recordStartupStamp].	"Now it''s time to raise an error"	resuming == nil ifTrue: [self error:''Failed to write image file (disk full?)''].	^ resuming' classified: 'whatever'.		(SmalltalkImage classPool)		at: #StartUpList		put: #(#SmallInteger #Delay #Other #HostPlatform #WebEntrance #ProcessorScheduler #FileDirectory #ShortIntegerArray #ShortRunArray #MessageTally #NaturalLanguageTranslator #LanguageEnvironment #PowerManagement #ExternalSettings #SecurityManager #FileStream #UUIDGenerator #CPUWatcher #DateAndTime #SmalltalkImage #Utilities #WeakArray #MultiByteFileStream #InternetConfiguration #Locale #Collection #HostWindowProxy #NetNameResolver #Caffeine #Worker #Webpage #ExternalResource) asOrderedCollection.	EditHistory connectTo: 'ws://localhost:8091/tether'.	weakArray := WeakArray with: Object new.	navigation := SystemNavigation new.		fusedMethods := (		(OrderedCollection new)			addAll: {				Object compiledMethodAt: #breakDependents.				Object compiledMethodAt: #actAsExecutor.				Object compiledMethodAt: #isPseudoContext.				Object compiledMethodAt: #executor.				Object compiledMethodAt: #halt:.				Object compiledMethodAt: #primitiveError:.				Object compiledMethodAt: #perform:.								Object compiledMethodAt: #perform:with:.				Object compiledMethodAt: #perform:with:with:.				Object compiledMethodAt: #perform:with:with:with:.				Object compiledMethodAt: #perform:with:with:with:with:.				Object compiledMethodAt: #perform:withArguments:.						Object compiledMethodAt: #perform:withArguments:inSuperclass:.						Object compiledMethodAt: #perform:withEnoughArguments:.				Object compiledMethodAt: #isSymbol.				Behavior reloadingMethod.				EditHistory compiledMethodAt: #swapInMethodAt:in:.				Object compiledMethodAt: #adaptToInteger:andSend:.				Object compiledMethodAt: #in:.				Object compiledMethodAt: #addDependent:.				Symbol compiledMethodAt: #isSymbol.				ContextPart compiledMethodAt: #selector.				ContextPart compiledMethodAt: #arguments.				CompiledMethod compiledMethodAt: #selector.				UUIDGenerator compiledMethodAt: #semaphoreForGenerator.				UUIDGenerator compiledMethodAt: #randomGenerator.				ProtoObject compiledMethodAt: #initialize.				BlockClosure compiledMethodAt: #value.				BlockContext compiledMethodAt: #value.				Semaphore compiledMethodAt: #wait.				UndefinedObject compiledMethodAt: #release.				ClassOrganizer compiledMethodAt: #traitComposition.				ByteString class compiledMethodAt: #stringHash:initialHash:};			yourself).			{		#(id isNil notNil isInteger removeFromSystem removeFromSystem: hashBytes:startingWith: size species signal resumptionTime primGetNextEvent: bitAnd: new: new negative at: at:put: bitShiftMagnitude: bitOr: < randomCounter / + asFloat bitXor: identityHash basicAt: basicAt:put: basicNew: basicNew isMethodProperties printString).		CompiledMethodTrailer trailerKindDecoders.	}		do: [:set |			set do: [:selector |		(navigation allImplementorsOf: selector) do: [:reference | fusedMethods add: reference compiledMethod]]].	self		fuseHeadlessSingleClassesInto: fusedMethods;		fuseHeadlessClassHierarchiesInto: fusedMethods.				fusedMethods do: [:method | method fuse].		Behavior setReloadingMethod.	reloadingMethod := Behavior reloadingMethod.	Shaker class swapOutMethodAt: #test:.	(Shaker test: 42) = 42 ifFalse: [self error: 'history system not working'].		"Set the selector and class-binding literals of the reloading method to things which make sense in the JS debugger."	Behavior setReloadingMethod.	LRUCache allInstancesDo: [:cache | cache reset].	WeakArray restartFinalizationProcess.	[3 error: 'ignored'] on: Error do: [:exception | ].	Delay initialize.	(Delay forSeconds: 1) wait.	Object new breakDependents.	NaturalLanguageTranslator privateStartUp.		{		BlockClosure.		ContextPart	}		do: [:class |			class allSubInstancesDo: [:methodHolder | methodHolder fuse]].		JS at: #shaking put: true.	Smalltalk		primitiveGarbageCollect;		primitiveFusedGarbageCollect;		primitiveFusedGarbageCollect.			numberOfClassesRemoved := -1.		[numberOfClassesRemoved = 0] whileFalse: [		numberOfClassesRemoved := 0.		(Class allSubclasses asSortedCollection: [:earlier :later | earlier depth <= later depth]) asArray reversed do: [:metaclass |			(				metaclass soleInstance subclasses isEmpty not or: [					{						metaclass.						metaclass soleInstance					}						anySatisfy: [:behavior |							behavior methodDict anySatisfy: [:method | method ~~ reloadingMethod]]]			)				ifFalse: [					metaclass soleInstance removeFromSystem.					numberOfClassesRemoved := numberOfClassesRemoved + 1]]].		Smalltalk garbageCollect! !----QUIT----{25 September 2019 . 3:22 pm} history.image priorSource: 1989503!----STARTUP----{25 September 2019 . 3:56:01 pm} as /Users/craig/Downloads/caffeine/backups/37 (headless)/history.image!#[115 116 97 114 116 85 112] asString!#[69 120 116 101 114 110 97 108 83 101 116 116 105 110 103 115] asString!!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 15:58' prior: 35495698!fuseHeadlessSingleClassesInto: fusedMethods	{		ExternalSettings.		WeakMessageSend.		ExternalResource.		DateAndTime.		Locale.		UUID.		UUIDGenerator.		WeakKeyAssociation.		WeakFinalizationList.		EnvironmentInfo.		WeakFinalizerItem.		Date.		BindingPolicy.		SocketAddressInformation.		DelayWaitTimeout.		Number.		WebUtils.		ThirtyTwoBitRegister.		SecureHashAlgorithm.		DiffElement.		ProcessBrowser.		CPUWatcher.		DeepCopier.		MethodReference.		Random.		ExternalObjectTable.		ChangeRecord.		SystemChangeNotifier.		ClassBuilder.		Beeper.		GZipReadStream.		InternalTranslator.		ServerDirectory.		FilePath.		Utilities.		Command.		WebClient.		InternetConfiguration.		NetNameResolver.		ChromeExtensionUrl.		SystemNavigation.		LocaleID.		XMLNamespace.		CharacterBlock.		UndefinedObject.		LimitedWriteStream.		HttpUrl.		ResourceManager.		RemoteString.		Latin1Environment.		Global.		Time.		TimeZone.		TraitOrganizer.		ServiceShortcuts.		ServiceCancelled.		ServiceRegistry.		ServicePreferences.		TraitAlias.		ClassTrait.		PragmaPreference.		BrowseAvailableModules.		CounterpartRequest.		InstallRemoteModule.		PointerFinder.		ParseNodeEnumerator.		ParseNodeVisitor.		ZipWriteStream.		ZipEncoder.		TextDomainManager.		StepMessage.		UTF8TextConverter.		Preference.		TextLine.		DeflateStream.		AdditionalMethodState.		Compiler.		CompilationCue.		Association.		StandardScriptingSystem.		MessageNames.		FileServices.		ClassBinding.		Webpage current class.		FileDirectory.		Metaclass.		ClassDescription.		Behavior.		Class.		MethodDictionary.		ProtoObject.		Tether.		ExceptionMarker.		InstructionPrinter.		Author.		EditHistory.		ModuleDescription.		ModuleID.		Version.		Other.		SmalltalkImage.		Environment.		ChangeSet.		ClassChangeRecord.		MethodChangeRecord.		ToolSet.		StandardToolSet.		Message.		MessageSend.		Process.		ProcessorScheduler.		BlockClosure.		BlockContext.		SharedQueue.		TranscriptStream.		Categorizer.		Character.		ExtendedNumberParser.		JSObjectProxy.		SystemOrganizer.		Shaker.		Decompiler.		Pragma.		MultiByteFileStream.		BreakpointManager.		ZipConstants.		AbstractLauncher.		AutoStart.		ObjectHistory.		Parser.		Point.		MessageTally.		CompiledMethodTrailer.		Monitor.		IdentityTransform.		NewParagraph	}		do: [:class | self fuseProtoclass: class into: fusedMethods]! !!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 15:58' prior: 35498175!fuseSingleClasses2Into: fusedMethods	{		ExternalSettings.		WeakMessageSend.		ExternalResource.		DateAndTime.		PluggablePanelMorph.		SketchMorph.		LayoutFrame.		IconicButton.		SimpleButtonMorph.		StandardScriptingSystem.		MessageNames.		FileServices.		ClassBinding.		Webpage current class.		FileDirectory.		Metaclass.		ClassDescription.		Behavior.		Class.		MethodDictionary.		DisplayText.		ProtoObject.		Tether.		ExceptionMarker.		InstructionPrinter.		Author.		EditHistory.		ModuleDescription.		ModuleID.		Version.		Other.		SmalltalkImage.		Environment.		ChangeSet.		ClassChangeRecord.		MethodChangeRecord.		ToolSet.		SystemBrowser.		StandardToolSet.		Message.		MessageSend.		Process.		ProcessorScheduler.		BlockClosure.		BlockContext.		SharedQueue.		TranscriptStream.		Categorizer.		Character.		ExtendedNumberParser.		JSObjectProxy.		SystemOrganizer.		Shaker.		Decompiler.		PolygonMorph.		SmalltalkEditor.		Pragma.		BalloonEngine.		MultiByteFileStream.		BalloonEdgeData.		BalloonFillData.		UTF8ClipboardInterpreter.		BreakpointManager.		ZipConstants.		MorphicUIManager.		MenuLineMorph.		NewBalloonMorph.		BalloonMorph.		AbstractLauncher.		AutoStart.		ObjectHistory.		Parser.		MenuMorph.		AlignmentMorph.		StringMorph.		MenuItemMorph.		MorphicTransform.		MenuIcons.		LayoutCell.		TableLayoutProperties.		Rectangle.		BorderStyle.		SimpleBorder.		TextFontReference.		Browser.		Point.		HandMorph.		PasteUpMorph.		WorldState.		MessageTally.		PluggableWindowSpec.		ScrollBar.		MorphicModel.		SHParserST80.		PluggableTextSpec.		Point.		SystemWindow.		PluggableButtonMorph.		PluggableSystemWindow.		CompiledMethodTrailer.		TextEmphasis.		SHTextStylerST80.		TextMorph.		PluggableListMorph.		LazyListMorph.		ScrollPane.		Monitor.		TextColor.		MouseOverHandler.		SHRange.		CharacterScanner.		CompositionScanner.		EventHandler.		MouseClickState.		MorphExtension.		IdentityTransform.		TopGripMorph.		TextStyle.		ProportionalSplitterMorph.		NewParagraph	}		do: [:class | self fuseProtoclass: class into: fusedMethods]! !----QUIT----{25 September 2019 . 3:58:23 pm} history.image priorSource: 1996884!----STARTUP----{25 September 2019 . 4:11:56 pm} as /Users/craig/Downloads/caffeine/backups/37 (headless)/history.image!!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 16:12' prior: 35544228!shakeHeadless	| fusedMethods weakArray navigation reloadingMethod numberOfClassesRemoved |		(SmalltalkImage classPool)		at: #ShutDownList		put: #(#TTFileDescription #InternetConfiguration #TTCFont #ArchiveViewer #CPUWatcher #ProcessBrowser #ExternalSettings #Symbol #SecurityManager #AutoStart #FileStream #CommandHistory #StrikeFontSet #MessageTally #ImageSegment #Password #HttpUrl #SoundPlayer #FileDirectory #Color #StrikeFont #PasteUpMorph #ControlManager #DisplayScreen #Delay) asOrderedCollection.		SmalltalkImage compile: 'snapshot: save andQuit: quit withExitCode: exitCode embedded: embeddedFlag	"Mark the changes file and close all files as part of #processShutdownList.	If save is true, save the current state of this Smalltalk in the image file.	If quit is true, then exit to the outer OS shell.	If exitCode is not nil, then use it as exit code.	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."	| resuming msg |	Object flushDependents.	Object flushEvents.	(SourceFiles at: 2) ifNotNil:[		msg := String streamContents: [ :s |			s nextPutAll: ''----'';			nextPutAll: (save ifTrue: [ quit ifTrue: [ ''QUIT'' ] ifFalse: [ ''SNAPSHOT'' ] ]							ifFalse: [quit ifTrue: [ ''QUIT/NOSAVE'' ] ifFalse: [ ''NOP'' ]]);			nextPutAll: ''----'';			print: Date dateAndTimeNow; space;			nextPutAll: (FileDirectory default localNameFor: self imageName);			nextPutAll: '' priorSource: '';			print: LastQuitLogPosition ].		self assureStartupStampLogged.		save ifTrue: [ LastQuitLogPosition := (SourceFiles at: 2) setToEnd; position ].		self logChange: msg.		Transcript cr; show: msg	].	Smalltalk processShutDownList: quit.	Cursor write show.	save ifTrue: [resuming := embeddedFlag 					ifTrue: [self snapshotEmbeddedPrimitive] 					ifFalse: [self snapshotPrimitive].  "<-- PC frozen here on image file"				resuming == false "guard against failure" ifTrue:					[]]		ifFalse: [resuming := false].	quit & (resuming == false) ifTrue: [		exitCode			ifNil: [ self quitPrimitive ]			ifNotNil: [ self quitPrimitive: exitCode ] ].	Cursor normal show.	Smalltalk setGCParameters.	resuming == true ifTrue: [Smalltalk clearExternalObjects].	Smalltalk processStartUpList: resuming == true.	resuming == true ifTrue:[		self setPlatformPreferences.		self recordStartupStamp].	"Now it''s time to raise an error"	resuming == nil ifTrue: [self error:''Failed to write image file (disk full?)''].	^ resuming' classified: 'whatever'.		(SmalltalkImage classPool)		at: #StartUpList		put: #(#SmallInteger #Delay #Other #HostPlatform #WebEntrance #ProcessorScheduler #FileDirectory #ShortIntegerArray #ShortRunArray #MessageTally #NaturalLanguageTranslator #LanguageEnvironment #PowerManagement #ExternalSettings #SecurityManager #FileStream #UUIDGenerator #CPUWatcher #DateAndTime #SmalltalkImage #Utilities #WeakArray #MultiByteFileStream #InternetConfiguration #Locale #Collection #HostWindowProxy #NetNameResolver #Caffeine #Worker #Webpage #ExternalResource) asOrderedCollection.	EditHistory connectTo: 'ws://localhost:8091/tether'.	weakArray := WeakArray with: Object new.	navigation := SystemNavigation new.		fusedMethods := (		(OrderedCollection new)			addAll: {				Object compiledMethodAt: #breakDependents.				Object compiledMethodAt: #actAsExecutor.				Object compiledMethodAt: #isPseudoContext.				Object compiledMethodAt: #executor.				Object compiledMethodAt: #halt:.				Object compiledMethodAt: #primitiveError:.				Object compiledMethodAt: #perform:.								Object compiledMethodAt: #perform:with:.				Object compiledMethodAt: #perform:with:with:.				Object compiledMethodAt: #perform:with:with:with:.				Object compiledMethodAt: #perform:with:with:with:with:.				Object compiledMethodAt: #perform:withArguments:.						Object compiledMethodAt: #perform:withArguments:inSuperclass:.						Object compiledMethodAt: #perform:withEnoughArguments:.				Object compiledMethodAt: #isSymbol.				Behavior reloadingMethod.				EditHistory compiledMethodAt: #swapInMethodAt:in:.				Object compiledMethodAt: #adaptToInteger:andSend:.				Object compiledMethodAt: #in:.				Object compiledMethodAt: #addDependent:.				Symbol compiledMethodAt: #isSymbol.				ContextPart compiledMethodAt: #selector.				ContextPart compiledMethodAt: #arguments.				CompiledMethod compiledMethodAt: #selector.				UUIDGenerator compiledMethodAt: #semaphoreForGenerator.				UUIDGenerator compiledMethodAt: #randomGenerator.				ProtoObject compiledMethodAt: #initialize.				BlockClosure compiledMethodAt: #value.				BlockContext compiledMethodAt: #value.				Semaphore compiledMethodAt: #wait.				UndefinedObject compiledMethodAt: #release.				ClassOrganizer compiledMethodAt: #traitComposition.				ByteString class compiledMethodAt: #stringHash:initialHash:};			yourself).			{		#(id isNil notNil isInteger removeFromSystem removeFromSystem: hashBytes:startingWith: size species signal resumptionTime primGetNextEvent: bitAnd: new: new negative at: at:put: bitShiftMagnitude: bitOr: < randomCounter / + asFloat bitXor: identityHash basicAt: basicAt:put: basicNew: basicNew isMethodProperties printString).		CompiledMethodTrailer trailerKindDecoders.	}		do: [:set |			set do: [:selector |		(navigation allImplementorsOf: selector) do: [:reference | fusedMethods add: reference compiledMethod]]].	self		fuseHeadlessSingleClassesInto: fusedMethods;		fuseHeadlessClassHierarchiesInto: fusedMethods.				fusedMethods do: [:method | method fuse].		Behavior setReloadingMethod.	reloadingMethod := Behavior reloadingMethod.	Shaker class swapOutMethodAt: #test:.	(Shaker test: 42) = 42 ifFalse: [self error: 'history system not working'].		"Set the selector and class-binding literals of the reloading method to things which make sense in the JS debugger."	Behavior setReloadingMethod.	LRUCache allInstancesDo: [:cache | cache reset].	WeakArray restartFinalizationProcess.	[3 error: 'ignored'] on: Error do: [:exception | ].	Delay initialize.	(Delay forSeconds: 1) wait.	Object new breakDependents.	NaturalLanguageTranslator privateStartUp.	ExternalSettings startUp.		{		BlockClosure.		ContextPart	}		do: [:class |			class allSubInstancesDo: [:methodHolder | methodHolder fuse]].		JS at: #shaking put: true.	Smalltalk		primitiveGarbageCollect;		primitiveFusedGarbageCollect;		primitiveFusedGarbageCollect.			numberOfClassesRemoved := -1.		[numberOfClassesRemoved = 0] whileFalse: [		numberOfClassesRemoved := 0.		(Class allSubclasses asSortedCollection: [:earlier :later | earlier depth <= later depth]) asArray reversed do: [:metaclass |			(				metaclass soleInstance subclasses isEmpty not or: [					{						metaclass.						metaclass soleInstance					}						anySatisfy: [:behavior |							behavior methodDict anySatisfy: [:method | method ~~ reloadingMethod]]]			)				ifFalse: [					metaclass soleInstance removeFromSystem.					numberOfClassesRemoved := numberOfClassesRemoved + 1]]].		Smalltalk garbageCollect! !----QUIT----{25 September 2019 . 4:12:36 pm} history.image priorSource: 2001915!----STARTUP----{25 September 2019 . 4:17:57 pm} as /Users/craig/Downloads/caffeine/backups/37 (headless)/history.image!#[115 121 115 116 101 109 69 118 101 110 116 115] asString!!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 16:19' prior: 35556640!shakeHeadless	| fusedMethods weakArray navigation reloadingMethod numberOfClassesRemoved |		(SmalltalkImage classPool)		at: #ShutDownList		put: #(#TTFileDescription #InternetConfiguration #TTCFont #ArchiveViewer #CPUWatcher #ProcessBrowser #ExternalSettings #Symbol #SecurityManager #AutoStart #FileStream #CommandHistory #StrikeFontSet #MessageTally #ImageSegment #Password #HttpUrl #SoundPlayer #FileDirectory #Color #StrikeFont #PasteUpMorph #ControlManager #DisplayScreen #Delay) asOrderedCollection.		SmalltalkImage compile: 'snapshot: save andQuit: quit withExitCode: exitCode embedded: embeddedFlag	"Mark the changes file and close all files as part of #processShutdownList.	If save is true, save the current state of this Smalltalk in the image file.	If quit is true, then exit to the outer OS shell.	If exitCode is not nil, then use it as exit code.	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."	| resuming msg |	Object flushDependents.	Object flushEvents.	(SourceFiles at: 2) ifNotNil:[		msg := String streamContents: [ :s |			s nextPutAll: ''----'';			nextPutAll: (save ifTrue: [ quit ifTrue: [ ''QUIT'' ] ifFalse: [ ''SNAPSHOT'' ] ]							ifFalse: [quit ifTrue: [ ''QUIT/NOSAVE'' ] ifFalse: [ ''NOP'' ]]);			nextPutAll: ''----'';			print: Date dateAndTimeNow; space;			nextPutAll: (FileDirectory default localNameFor: self imageName);			nextPutAll: '' priorSource: '';			print: LastQuitLogPosition ].		self assureStartupStampLogged.		save ifTrue: [ LastQuitLogPosition := (SourceFiles at: 2) setToEnd; position ].		self logChange: msg.		Transcript cr; show: msg	].	Smalltalk processShutDownList: quit.	Cursor write show.	save ifTrue: [resuming := embeddedFlag 					ifTrue: [self snapshotEmbeddedPrimitive] 					ifFalse: [self snapshotPrimitive].  "<-- PC frozen here on image file"				resuming == false "guard against failure" ifTrue:					[]]		ifFalse: [resuming := false].	quit & (resuming == false) ifTrue: [		exitCode			ifNil: [ self quitPrimitive ]			ifNotNil: [ self quitPrimitive: exitCode ] ].	Cursor normal show.	Smalltalk setGCParameters.	resuming == true ifTrue: [Smalltalk clearExternalObjects].	Smalltalk processStartUpList: resuming == true.	resuming == true ifTrue:[		self setPlatformPreferences.		self recordStartupStamp].	"Now it''s time to raise an error"	resuming == nil ifTrue: [self error:''Failed to write image file (disk full?)''].	^ resuming' classified: 'whatever'.		(SmalltalkImage classPool)		at: #StartUpList		put: #(#SmallInteger #Delay #Other #HostPlatform #WebEntrance #ProcessorScheduler #FileDirectory #ShortIntegerArray #ShortRunArray #MessageTally #NaturalLanguageTranslator #LanguageEnvironment #PowerManagement #ExternalSettings #SecurityManager #FileStream #UUIDGenerator #CPUWatcher #DateAndTime #SmalltalkImage #Utilities #WeakArray #MultiByteFileStream #InternetConfiguration #Locale #Collection #HostWindowProxy #NetNameResolver #Caffeine #Worker #Webpage #ExternalResource) asOrderedCollection.	EditHistory connectTo: 'ws://localhost:8091/tether'.	weakArray := WeakArray with: Object new.	navigation := SystemNavigation new.		fusedMethods := (		(OrderedCollection new)			addAll: {				Object compiledMethodAt: #breakDependents.				Object compiledMethodAt: #actAsExecutor.				Object compiledMethodAt: #isPseudoContext.				Object compiledMethodAt: #executor.				Object compiledMethodAt: #halt:.				Object compiledMethodAt: #primitiveError:.				Object compiledMethodAt: #perform:.								Object compiledMethodAt: #perform:with:.				Object compiledMethodAt: #perform:with:with:.				Object compiledMethodAt: #perform:with:with:with:.				Object compiledMethodAt: #perform:with:with:with:with:.				Object compiledMethodAt: #perform:withArguments:.						Object compiledMethodAt: #perform:withArguments:inSuperclass:.						Object compiledMethodAt: #perform:withEnoughArguments:.				Object compiledMethodAt: #isSymbol.				Behavior reloadingMethod.				EditHistory compiledMethodAt: #swapInMethodAt:in:.				Object compiledMethodAt: #adaptToInteger:andSend:.				Object compiledMethodAt: #in:.				Object compiledMethodAt: #addDependent:.				Symbol compiledMethodAt: #isSymbol.				ContextPart compiledMethodAt: #selector.				ContextPart compiledMethodAt: #arguments.				CompiledMethod compiledMethodAt: #selector.				UUIDGenerator compiledMethodAt: #semaphoreForGenerator.				UUIDGenerator compiledMethodAt: #randomGenerator.				ProtoObject compiledMethodAt: #initialize.				BlockClosure compiledMethodAt: #value.				BlockContext compiledMethodAt: #value.				Semaphore compiledMethodAt: #wait.				UndefinedObject compiledMethodAt: #release.				ClassOrganizer compiledMethodAt: #traitComposition.				ByteString class compiledMethodAt: #stringHash:initialHash:};			yourself).			{		#(id isNil notNil isInteger removeFromSystem removeFromSystem: hashBytes:startingWith: size species signal resumptionTime primGetNextEvent: bitAnd: new: new negative at: at:put: bitShiftMagnitude: bitOr: < randomCounter / + asFloat bitXor: identityHash basicAt: basicAt:put: basicNew: basicNew isMethodProperties printString).		CompiledMethodTrailer trailerKindDecoders.	}		do: [:set |			set do: [:selector |		(navigation allImplementorsOf: selector) do: [:reference | fusedMethods add: reference compiledMethod]]].	self		fuseHeadlessSingleClassesInto: fusedMethods;		fuseHeadlessClassHierarchiesInto: fusedMethods.				fusedMethods do: [:method | method fuse].		Behavior setReloadingMethod.	reloadingMethod := Behavior reloadingMethod.	Shaker class swapOutMethodAt: #test:.	(Shaker test: 42) = 42 ifFalse: [self error: 'history system not working'].		"Set the selector and class-binding literals of the reloading method to things which make sense in the JS debugger."	Behavior setReloadingMethod.	LRUCache allInstancesDo: [:cache | cache reset].	WeakArray restartFinalizationProcess.	[3 error: 'ignored'] on: Error do: [:exception | ].	Delay initialize.	(Delay forSeconds: 1) wait.	Object new breakDependents.	NaturalLanguageTranslator privateStartUp.	ExternalSettings startUp.	SmalltalkImage startUp.		{		BlockClosure.		ContextPart	}		do: [:class |			class allSubInstancesDo: [:methodHolder | methodHolder fuse]].		JS at: #shaking put: true.	Smalltalk		primitiveGarbageCollect;		primitiveFusedGarbageCollect;		primitiveFusedGarbageCollect.			numberOfClassesRemoved := -1.		[numberOfClassesRemoved = 0] whileFalse: [		numberOfClassesRemoved := 0.		(Class allSubclasses asSortedCollection: [:earlier :later | earlier depth <= later depth]) asArray reversed do: [:metaclass |			(				metaclass soleInstance subclasses isEmpty not or: [					{						metaclass.						metaclass soleInstance					}						anySatisfy: [:behavior |							behavior methodDict anySatisfy: [:method | method ~~ reloadingMethod]]]			)				ifFalse: [					metaclass soleInstance removeFromSystem.					numberOfClassesRemoved := numberOfClassesRemoved + 1]]].		Smalltalk garbageCollect! !----QUIT----{25 September 2019 . 4:19:08 pm} history.image priorSource: 2009323!----STARTUP----{25 September 2019 . 4:25:07 pm} as /Users/craig/Downloads/caffeine/backups/37 (headless)/history.image!!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 16:26' prior: 35564109!shakeHeadless	| fusedMethods weakArray navigation reloadingMethod numberOfClassesRemoved |		(SmalltalkImage classPool)		at: #ShutDownList		put: #(#TTFileDescription #InternetConfiguration #TTCFont #ArchiveViewer #CPUWatcher #ProcessBrowser #ExternalSettings #Symbol #SecurityManager #AutoStart #FileStream #CommandHistory #StrikeFontSet #MessageTally #ImageSegment #Password #HttpUrl #SoundPlayer #FileDirectory #Color #StrikeFont #PasteUpMorph #ControlManager #DisplayScreen #Delay) asOrderedCollection.		SmalltalkImage compile: 'snapshot: save andQuit: quit withExitCode: exitCode embedded: embeddedFlag	"Mark the changes file and close all files as part of #processShutdownList.	If save is true, save the current state of this Smalltalk in the image file.	If quit is true, then exit to the outer OS shell.	If exitCode is not nil, then use it as exit code.	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."	| resuming msg |	Object flushDependents.	Object flushEvents.	(SourceFiles at: 2) ifNotNil:[		msg := String streamContents: [ :s |			s nextPutAll: ''----'';			nextPutAll: (save ifTrue: [ quit ifTrue: [ ''QUIT'' ] ifFalse: [ ''SNAPSHOT'' ] ]							ifFalse: [quit ifTrue: [ ''QUIT/NOSAVE'' ] ifFalse: [ ''NOP'' ]]);			nextPutAll: ''----'';			print: Date dateAndTimeNow; space;			nextPutAll: (FileDirectory default localNameFor: self imageName);			nextPutAll: '' priorSource: '';			print: LastQuitLogPosition ].		self assureStartupStampLogged.		save ifTrue: [ LastQuitLogPosition := (SourceFiles at: 2) setToEnd; position ].		self logChange: msg.		Transcript cr; show: msg	].	Smalltalk processShutDownList: quit.	Cursor write show.	save ifTrue: [resuming := embeddedFlag 					ifTrue: [self snapshotEmbeddedPrimitive] 					ifFalse: [self snapshotPrimitive].  "<-- PC frozen here on image file"				resuming == false "guard against failure" ifTrue:					[]]		ifFalse: [resuming := false].	quit & (resuming == false) ifTrue: [		exitCode			ifNil: [ self quitPrimitive ]			ifNotNil: [ self quitPrimitive: exitCode ] ].	Cursor normal show.	Smalltalk setGCParameters.	resuming == true ifTrue: [Smalltalk clearExternalObjects].	Smalltalk processStartUpList: resuming == true.	resuming == true ifTrue:[		self setPlatformPreferences.		self recordStartupStamp].	"Now it''s time to raise an error"	resuming == nil ifTrue: [self error:''Failed to write image file (disk full?)''].	^ resuming' classified: 'whatever'.		(SmalltalkImage classPool)		at: #StartUpList		put: #(#SmallInteger #Delay #Other #HostPlatform #WebEntrance #ProcessorScheduler #FileDirectory #ShortIntegerArray #ShortRunArray #MessageTally #NaturalLanguageTranslator #LanguageEnvironment #PowerManagement #ExternalSettings #SecurityManager #FileStream #UUIDGenerator #CPUWatcher #DateAndTime #SmalltalkImage #Utilities #WeakArray #MultiByteFileStream #InternetConfiguration #Locale #Collection #HostWindowProxy #NetNameResolver #Caffeine #Worker #Webpage #ExternalResource) asOrderedCollection.	EditHistory connectTo: 'ws://localhost:8091/tether'.	weakArray := WeakArray with: Object new.	navigation := SystemNavigation new.		fusedMethods := (		(OrderedCollection new)			addAll: {				Object compiledMethodAt: #breakDependents.				Object compiledMethodAt: #actAsExecutor.				Object compiledMethodAt: #isPseudoContext.				Object compiledMethodAt: #executor.				Object compiledMethodAt: #halt:.				Object compiledMethodAt: #primitiveError:.				Object compiledMethodAt: #perform:.								Object compiledMethodAt: #perform:with:.				Object compiledMethodAt: #perform:with:with:.				Object compiledMethodAt: #perform:with:with:with:.				Object compiledMethodAt: #perform:with:with:with:with:.				Object compiledMethodAt: #perform:withArguments:.						Object compiledMethodAt: #perform:withArguments:inSuperclass:.						Object compiledMethodAt: #perform:withEnoughArguments:.				Object compiledMethodAt: #isSymbol.				Behavior reloadingMethod.				EditHistory compiledMethodAt: #swapInMethodAt:in:.				Object compiledMethodAt: #adaptToInteger:andSend:.				Object compiledMethodAt: #in:.				Object compiledMethodAt: #addDependent:.				Symbol compiledMethodAt: #isSymbol.				ContextPart compiledMethodAt: #selector.				ContextPart compiledMethodAt: #arguments.				CompiledMethod compiledMethodAt: #selector.				UUIDGenerator compiledMethodAt: #semaphoreForGenerator.				UUIDGenerator compiledMethodAt: #randomGenerator.				ProtoObject compiledMethodAt: #initialize.				BlockClosure compiledMethodAt: #value.				BlockContext compiledMethodAt: #value.				Semaphore compiledMethodAt: #wait.				UndefinedObject compiledMethodAt: #release.				ClassOrganizer compiledMethodAt: #traitComposition.				ByteString class compiledMethodAt: #stringHash:initialHash:};			yourself).			{		#(id isNil notNil isInteger removeFromSystem removeFromSystem: hashBytes:startingWith: size species signal resumptionTime primGetNextEvent: bitAnd: new: new negative at: at:put: bitShiftMagnitude: bitOr: < randomCounter / + asFloat bitXor: identityHash basicAt: basicAt:put: basicNew: basicNew isMethodProperties printString).		CompiledMethodTrailer trailerKindDecoders.	}		do: [:set |			set do: [:selector |		(navigation allImplementorsOf: selector) do: [:reference | fusedMethods add: reference compiledMethod]]].	self		fuseHeadlessSingleClassesInto: fusedMethods;		fuseHeadlessClassHierarchiesInto: fusedMethods.				fusedMethods do: [:method | method fuse].		Behavior setReloadingMethod.	reloadingMethod := Behavior reloadingMethod.	Shaker class swapOutMethodAt: #test:.	(Shaker test: 42) = 42 ifFalse: [self error: 'history system not working'].		"Set the selector and class-binding literals of the reloading method to things which make sense in the JS debugger."	Behavior setReloadingMethod.	LRUCache allInstancesDo: [:cache | cache reset].	WeakArray restartFinalizationProcess.	[3 error: 'ignored'] on: Error do: [:exception | ].	Delay initialize.	(Delay forSeconds: 1) wait.	Object new breakDependents.	NaturalLanguageTranslator privateStartUp.	ExternalSettings startUp.	SmalltalkImage startUp.	NetNameResolver startUp: true.		{		BlockClosure.		ContextPart	}		do: [:class |			class allSubInstancesDo: [:methodHolder | methodHolder fuse]].		JS at: #shaking put: true.	Smalltalk		primitiveGarbageCollect;		primitiveFusedGarbageCollect;		primitiveFusedGarbageCollect.			numberOfClassesRemoved := -1.		[numberOfClassesRemoved = 0] whileFalse: [		numberOfClassesRemoved := 0.		(Class allSubclasses asSortedCollection: [:earlier :later | earlier depth <= later depth]) asArray reversed do: [:metaclass |			(				metaclass soleInstance subclasses isEmpty not or: [					{						metaclass.						metaclass soleInstance					}						anySatisfy: [:behavior |							behavior methodDict anySatisfy: [:method | method ~~ reloadingMethod]]]			)				ifFalse: [					metaclass soleInstance removeFromSystem.					numberOfClassesRemoved := numberOfClassesRemoved + 1]]].		Smalltalk garbageCollect! !----QUIT----{25 September 2019 . 4:26:43 pm} history.image priorSource: 2016817!----STARTUP----{25 September 2019 . 4:37:32 pm} as /Users/craig/Downloads/caffeine/backups/37 (headless)/history.image!	Date fromSeconds: Time totalSeconds!!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 16:43' prior: 35571542!shakeHeadless	| fusedMethods weakArray navigation reloadingMethod numberOfClassesRemoved |		(SmalltalkImage classPool)		at: #ShutDownList		put: #(#TTFileDescription #InternetConfiguration #TTCFont #ArchiveViewer #CPUWatcher #ProcessBrowser #ExternalSettings #Symbol #SecurityManager #AutoStart #FileStream #CommandHistory #StrikeFontSet #MessageTally #ImageSegment #Password #HttpUrl #SoundPlayer #FileDirectory #Color #StrikeFont #PasteUpMorph #ControlManager #DisplayScreen #Delay) asOrderedCollection.		SmalltalkImage compile: 'snapshot: save andQuit: quit withExitCode: exitCode embedded: embeddedFlag	"Mark the changes file and close all files as part of #processShutdownList.	If save is true, save the current state of this Smalltalk in the image file.	If quit is true, then exit to the outer OS shell.	If exitCode is not nil, then use it as exit code.	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."	| resuming msg |	Object flushDependents.	Object flushEvents.	(SourceFiles at: 2) ifNotNil:[		msg := String streamContents: [ :s |			s nextPutAll: ''----'';			nextPutAll: (save ifTrue: [ quit ifTrue: [ ''QUIT'' ] ifFalse: [ ''SNAPSHOT'' ] ]							ifFalse: [quit ifTrue: [ ''QUIT/NOSAVE'' ] ifFalse: [ ''NOP'' ]]);			nextPutAll: ''----'';			print: Date dateAndTimeNow; space;			nextPutAll: (FileDirectory default localNameFor: self imageName);			nextPutAll: '' priorSource: '';			print: LastQuitLogPosition ].		self assureStartupStampLogged.		save ifTrue: [ LastQuitLogPosition := (SourceFiles at: 2) setToEnd; position ].		self logChange: msg.		Transcript cr; show: msg	].	Smalltalk processShutDownList: quit.	Cursor write show.	save ifTrue: [resuming := embeddedFlag 					ifTrue: [self snapshotEmbeddedPrimitive] 					ifFalse: [self snapshotPrimitive].  "<-- PC frozen here on image file"				resuming == false "guard against failure" ifTrue:					[]]		ifFalse: [resuming := false].	quit & (resuming == false) ifTrue: [		exitCode			ifNil: [ self quitPrimitive ]			ifNotNil: [ self quitPrimitive: exitCode ] ].	Cursor normal show.	Smalltalk setGCParameters.	resuming == true ifTrue: [Smalltalk clearExternalObjects].	Smalltalk processStartUpList: resuming == true.	resuming == true ifTrue:[		self setPlatformPreferences.		self recordStartupStamp].	"Now it''s time to raise an error"	resuming == nil ifTrue: [self error:''Failed to write image file (disk full?)''].	^ resuming' classified: 'whatever'.		(SmalltalkImage classPool)		at: #StartUpList		put: #(#SmallInteger #Delay #Other #HostPlatform #WebEntrance #ProcessorScheduler #FileDirectory #ShortIntegerArray #ShortRunArray #MessageTally #NaturalLanguageTranslator #LanguageEnvironment #PowerManagement #ExternalSettings #SecurityManager #FileStream #UUIDGenerator #CPUWatcher #DateAndTime #SmalltalkImage #Utilities #WeakArray #MultiByteFileStream #InternetConfiguration #Locale #Collection #HostWindowProxy #NetNameResolver #Caffeine #Worker #Webpage #ExternalResource) asOrderedCollection.	EditHistory connectTo: 'ws://localhost:8091/tether'.	weakArray := WeakArray with: Object new.	navigation := SystemNavigation new.		fusedMethods := (		(OrderedCollection new)			addAll: {				Object compiledMethodAt: #breakDependents.				Object compiledMethodAt: #actAsExecutor.				Object compiledMethodAt: #isPseudoContext.				Object compiledMethodAt: #executor.				Object compiledMethodAt: #halt:.				Object compiledMethodAt: #primitiveError:.				Object compiledMethodAt: #perform:.								Object compiledMethodAt: #perform:with:.				Object compiledMethodAt: #perform:with:with:.				Object compiledMethodAt: #perform:with:with:with:.				Object compiledMethodAt: #perform:with:with:with:with:.				Object compiledMethodAt: #perform:withArguments:.						Object compiledMethodAt: #perform:withArguments:inSuperclass:.						Object compiledMethodAt: #perform:withEnoughArguments:.				Object compiledMethodAt: #isSymbol.				Behavior reloadingMethod.				EditHistory compiledMethodAt: #swapInMethodAt:in:.				Object compiledMethodAt: #adaptToInteger:andSend:.				Object compiledMethodAt: #in:.				Object compiledMethodAt: #addDependent:.				Symbol compiledMethodAt: #isSymbol.				ContextPart compiledMethodAt: #selector.				ContextPart compiledMethodAt: #arguments.				CompiledMethod compiledMethodAt: #selector.				UUIDGenerator compiledMethodAt: #semaphoreForGenerator.				UUIDGenerator compiledMethodAt: #randomGenerator.				ProtoObject compiledMethodAt: #initialize.				BlockClosure compiledMethodAt: #value.				BlockContext compiledMethodAt: #value.				Semaphore compiledMethodAt: #wait.				UndefinedObject compiledMethodAt: #release.				ClassOrganizer compiledMethodAt: #traitComposition.				ByteString class compiledMethodAt: #stringHash:initialHash:};			yourself).			{		#(id isNil notNil isInteger removeFromSystem removeFromSystem: hashBytes:startingWith: size species signal resumptionTime primGetNextEvent: bitAnd: new: new negative at: at:put: bitShiftMagnitude: bitOr: < randomCounter / + asFloat bitXor: identityHash basicAt: basicAt:put: basicNew: basicNew isMethodProperties printString).		CompiledMethodTrailer trailerKindDecoders.	}		do: [:set |			set do: [:selector |		(navigation allImplementorsOf: selector) do: [:reference | fusedMethods add: reference compiledMethod]]].	self		fuseHeadlessSingleClassesInto: fusedMethods;		fuseHeadlessClassHierarchiesInto: fusedMethods.				fusedMethods do: [:method | method fuse].		Behavior setReloadingMethod.	reloadingMethod := Behavior reloadingMethod.	Shaker class swapOutMethodAt: #test:.	(Shaker test: 42) = 42 ifFalse: [self error: 'history system not working'].		"Set the selector and class-binding literals of the reloading method to things which make sense in the JS debugger."	Behavior setReloadingMethod.	LRUCache allInstancesDo: [:cache | cache reset].	WeakArray restartFinalizationProcess.	[3 error: 'ignored'] on: Error do: [:exception | ].	Delay initialize.	(Delay forSeconds: 1) wait.	Object new breakDependents.	NaturalLanguageTranslator privateStartUp.	ExternalSettings startUp.	SmalltalkImage startUp.	NetNameResolver startUp: true.	Date fromSeconds: Time totalSeconds.		{		BlockClosure.		ContextPart	}		do: [:class |			class allSubInstancesDo: [:methodHolder | methodHolder fuse]].		JS at: #shaking put: true.	Smalltalk		primitiveGarbageCollect;		primitiveFusedGarbageCollect;		primitiveFusedGarbageCollect.			numberOfClassesRemoved := -1.		[numberOfClassesRemoved = 0] whileFalse: [		numberOfClassesRemoved := 0.		(Class allSubclasses asSortedCollection: [:earlier :later | earlier depth <= later depth]) asArray reversed do: [:metaclass |			(				metaclass soleInstance subclasses isEmpty not or: [					{						metaclass.						metaclass soleInstance					}						anySatisfy: [:behavior |							behavior methodDict anySatisfy: [:method | method ~~ reloadingMethod]]]			)				ifFalse: [					metaclass soleInstance removeFromSystem.					numberOfClassesRemoved := numberOfClassesRemoved + 1]]].		Smalltalk garbageCollect! !----QUIT----{25 September 2019 . 4:43:59 pm} history.image priorSource: 2024282!----STARTUP----{25 September 2019 . 4:49:05 pm} as /Users/craig/Downloads/caffeine/backups/37 (headless)/history.image!!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 16:50' prior: 35579046!shakeHeadless	| fusedMethods weakArray navigation reloadingMethod numberOfClassesRemoved |		(SmalltalkImage classPool)		at: #ShutDownList		put: #(#TTFileDescription #InternetConfiguration #TTCFont #ArchiveViewer #CPUWatcher #ProcessBrowser #ExternalSettings #Symbol #SecurityManager #AutoStart #FileStream #CommandHistory #StrikeFontSet #MessageTally #ImageSegment #Password #HttpUrl #SoundPlayer #FileDirectory #Color #StrikeFont #PasteUpMorph #ControlManager #DisplayScreen #Delay) asOrderedCollection.		SmalltalkImage compile: 'snapshot: save andQuit: quit withExitCode: exitCode embedded: embeddedFlag	"Mark the changes file and close all files as part of #processShutdownList.	If save is true, save the current state of this Smalltalk in the image file.	If quit is true, then exit to the outer OS shell.	If exitCode is not nil, then use it as exit code.	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."	| resuming msg |	Object flushDependents.	Object flushEvents.	(SourceFiles at: 2) ifNotNil:[		msg := String streamContents: [ :s |			s nextPutAll: ''----'';			nextPutAll: (save ifTrue: [ quit ifTrue: [ ''QUIT'' ] ifFalse: [ ''SNAPSHOT'' ] ]							ifFalse: [quit ifTrue: [ ''QUIT/NOSAVE'' ] ifFalse: [ ''NOP'' ]]);			nextPutAll: ''----'';			print: Date dateAndTimeNow; space;			nextPutAll: (FileDirectory default localNameFor: self imageName);			nextPutAll: '' priorSource: '';			print: LastQuitLogPosition ].		self assureStartupStampLogged.		save ifTrue: [ LastQuitLogPosition := (SourceFiles at: 2) setToEnd; position ].		self logChange: msg.		Transcript cr; show: msg	].	Smalltalk processShutDownList: quit.	Cursor write show.	save ifTrue: [resuming := embeddedFlag 					ifTrue: [self snapshotEmbeddedPrimitive] 					ifFalse: [self snapshotPrimitive].  "<-- PC frozen here on image file"				resuming == false "guard against failure" ifTrue:					[]]		ifFalse: [resuming := false].	quit & (resuming == false) ifTrue: [		exitCode			ifNil: [ self quitPrimitive ]			ifNotNil: [ self quitPrimitive: exitCode ] ].	Cursor normal show.	Smalltalk setGCParameters.	resuming == true ifTrue: [Smalltalk clearExternalObjects].	Smalltalk processStartUpList: resuming == true.	resuming == true ifTrue:[		self setPlatformPreferences.		self recordStartupStamp].	"Now it''s time to raise an error"	resuming == nil ifTrue: [self error:''Failed to write image file (disk full?)''].	^ resuming' classified: 'whatever'.		(SmalltalkImage classPool)		at: #StartUpList		put: #(#SmallInteger #Delay #Other #HostPlatform #WebEntrance #ProcessorScheduler #FileDirectory #ShortIntegerArray #ShortRunArray #MessageTally #NaturalLanguageTranslator #LanguageEnvironment #PowerManagement #ExternalSettings #SecurityManager #FileStream #UUIDGenerator #CPUWatcher #DateAndTime #SmalltalkImage #Utilities #WeakArray #MultiByteFileStream #InternetConfiguration #Locale #Collection #HostWindowProxy #NetNameResolver #Caffeine #Worker #Webpage #ExternalResource) asOrderedCollection.	EditHistory connectTo: 'ws://localhost:8091/tether'.	weakArray := WeakArray with: Object new.	navigation := SystemNavigation new.		fusedMethods := (		(OrderedCollection new)			addAll: {				Object compiledMethodAt: #breakDependents.				Object compiledMethodAt: #actAsExecutor.				Object compiledMethodAt: #isPseudoContext.				Object compiledMethodAt: #executor.				Object compiledMethodAt: #halt:.				Object compiledMethodAt: #primitiveError:.				Object compiledMethodAt: #perform:.								Object compiledMethodAt: #perform:with:.				Object compiledMethodAt: #perform:with:with:.				Object compiledMethodAt: #perform:with:with:with:.				Object compiledMethodAt: #perform:with:with:with:with:.				Object compiledMethodAt: #perform:withArguments:.						Object compiledMethodAt: #perform:withArguments:inSuperclass:.						Object compiledMethodAt: #perform:withEnoughArguments:.				Object compiledMethodAt: #isSymbol.				Behavior reloadingMethod.				EditHistory compiledMethodAt: #swapInMethodAt:in:.				Object compiledMethodAt: #adaptToInteger:andSend:.				Object compiledMethodAt: #in:.				Object compiledMethodAt: #addDependent:.				Symbol compiledMethodAt: #isSymbol.				ContextPart compiledMethodAt: #selector.				ContextPart compiledMethodAt: #arguments.				CompiledMethod compiledMethodAt: #selector.				UUIDGenerator compiledMethodAt: #semaphoreForGenerator.				UUIDGenerator compiledMethodAt: #randomGenerator.				ProtoObject compiledMethodAt: #initialize.				BlockClosure compiledMethodAt: #value.				BlockContext compiledMethodAt: #value.				Semaphore compiledMethodAt: #wait.				UndefinedObject compiledMethodAt: #release.				ClassOrganizer compiledMethodAt: #traitComposition.				ByteString class compiledMethodAt: #stringHash:initialHash:};			yourself).			{		#(id isNil notNil isInteger removeFromSystem removeFromSystem: hashBytes:startingWith: size species signal resumptionTime primGetNextEvent: bitAnd: new: new negative at: at:put: bitShiftMagnitude: bitOr: < randomCounter / + asFloat bitXor: identityHash basicAt: basicAt:put: basicNew: basicNew isMethodProperties printString).		CompiledMethodTrailer trailerKindDecoders.	}		do: [:set |			set do: [:selector |		(navigation allImplementorsOf: selector) do: [:reference | fusedMethods add: reference compiledMethod]]].	self		fuseHeadlessSingleClassesInto: fusedMethods;		fuseHeadlessClassHierarchiesInto: fusedMethods.				fusedMethods do: [:method | method fuse].		Behavior setReloadingMethod.	reloadingMethod := Behavior reloadingMethod.	Shaker class swapOutMethodAt: #test:.	(Shaker test: 42) = 42 ifFalse: [self error: 'history system not working'].		"Set the selector and class-binding literals of the reloading method to things which make sense in the JS debugger."	Behavior setReloadingMethod.	LRUCache allInstancesDo: [:cache | cache reset].	WeakArray restartFinalizationProcess.	[3 error: 'ignored'] on: Error do: [:exception | ].	Delay initialize.	(Delay forSeconds: 1) wait.	Object new breakDependents.	NaturalLanguageTranslator privateStartUp.	ExternalSettings startUp.	SmalltalkImage startUp.	NetNameResolver startUp: true.	Date fromSeconds: Time totalSeconds.	Smalltalk recordStartupStamp.		{		BlockClosure.		ContextPart	}		do: [:class |			class allSubInstancesDo: [:methodHolder | methodHolder fuse]].		JS at: #shaking put: true.	Smalltalk		primitiveGarbageCollect;		primitiveFusedGarbageCollect;		primitiveFusedGarbageCollect.			numberOfClassesRemoved := -1.		[numberOfClassesRemoved = 0] whileFalse: [		numberOfClassesRemoved := 0.		(Class allSubclasses asSortedCollection: [:earlier :later | earlier depth <= later depth]) asArray reversed do: [:metaclass |			(				metaclass soleInstance subclasses isEmpty not or: [					{						metaclass.						metaclass soleInstance					}						anySatisfy: [:behavior |							behavior methodDict anySatisfy: [:method | method ~~ reloadingMethod]]]			)				ifFalse: [					metaclass soleInstance removeFromSystem.					numberOfClassesRemoved := numberOfClassesRemoved + 1]]].		Smalltalk garbageCollect! !----QUIT----{25 September 2019 . 4:50:29 pm} history.image priorSource: 2031824!----STARTUP----{25 September 2019 . 4:56:22 pm} as /Users/craig/Downloads/caffeine/backups/37 (headless)/history.image!!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 16:58' prior: 35586549!shakeHeadless	| fusedMethods weakArray navigation reloadingMethod numberOfClassesRemoved |		(SmalltalkImage classPool)		at: #ShutDownList		put: #(#TTFileDescription #InternetConfiguration #TTCFont #ArchiveViewer #CPUWatcher #ProcessBrowser #ExternalSettings #Symbol #SecurityManager #AutoStart #FileStream #CommandHistory #StrikeFontSet #MessageTally #ImageSegment #Password #HttpUrl #SoundPlayer #FileDirectory #Color #StrikeFont #PasteUpMorph #ControlManager #DisplayScreen #Delay) asOrderedCollection.		SmalltalkImage compile: 'snapshot: save andQuit: quit withExitCode: exitCode embedded: embeddedFlag	"Mark the changes file and close all files as part of #processShutdownList.	If save is true, save the current state of this Smalltalk in the image file.	If quit is true, then exit to the outer OS shell.	If exitCode is not nil, then use it as exit code.	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."	| resuming msg |	Object flushDependents.	Object flushEvents.	(SourceFiles at: 2) ifNotNil:[		msg := String streamContents: [ :s |			s nextPutAll: ''----'';			nextPutAll: (save ifTrue: [ quit ifTrue: [ ''QUIT'' ] ifFalse: [ ''SNAPSHOT'' ] ]							ifFalse: [quit ifTrue: [ ''QUIT/NOSAVE'' ] ifFalse: [ ''NOP'' ]]);			nextPutAll: ''----'';			print: Date dateAndTimeNow; space;			nextPutAll: (FileDirectory default localNameFor: self imageName);			nextPutAll: '' priorSource: '';			print: LastQuitLogPosition ].		self assureStartupStampLogged.		save ifTrue: [ LastQuitLogPosition := (SourceFiles at: 2) setToEnd; position ].		self logChange: msg.		Transcript cr; show: msg	].	Smalltalk processShutDownList: quit.	Cursor write show.	save ifTrue: [resuming := embeddedFlag 					ifTrue: [self snapshotEmbeddedPrimitive] 					ifFalse: [self snapshotPrimitive].  "<-- PC frozen here on image file"				resuming == false "guard against failure" ifTrue:					[]]		ifFalse: [resuming := false].	quit & (resuming == false) ifTrue: [		exitCode			ifNil: [ self quitPrimitive ]			ifNotNil: [ self quitPrimitive: exitCode ] ].	Cursor normal show.	Smalltalk setGCParameters.	resuming == true ifTrue: [Smalltalk clearExternalObjects].	Smalltalk processStartUpList: resuming == true.	resuming == true ifTrue:[		self setPlatformPreferences.		self recordStartupStamp].	"Now it''s time to raise an error"	resuming == nil ifTrue: [self error:''Failed to write image file (disk full?)''].	^ resuming' classified: 'whatever'.		(SmalltalkImage classPool)		at: #StartUpList		put: #(#SmallInteger #Delay #Other #HostPlatform #WebEntrance #ProcessorScheduler #FileDirectory #ShortIntegerArray #ShortRunArray #MessageTally #NaturalLanguageTranslator #LanguageEnvironment #PowerManagement #ExternalSettings #SecurityManager #FileStream #UUIDGenerator #CPUWatcher #DateAndTime #SmalltalkImage #Utilities #WeakArray #MultiByteFileStream #InternetConfiguration #Locale #Collection #HostWindowProxy #NetNameResolver #Caffeine #Worker #Webpage #ExternalResource) asOrderedCollection.	EditHistory connectTo: 'ws://localhost:8091/tether'.	weakArray := WeakArray with: Object new.	navigation := SystemNavigation new.		fusedMethods := (		(OrderedCollection new)			addAll: {				Object compiledMethodAt: #breakDependents.				Object compiledMethodAt: #actAsExecutor.				Object compiledMethodAt: #isPseudoContext.				Object compiledMethodAt: #executor.				Object compiledMethodAt: #halt:.				Object compiledMethodAt: #primitiveError:.				Object compiledMethodAt: #perform:.								Object compiledMethodAt: #perform:with:.				Object compiledMethodAt: #perform:with:with:.				Object compiledMethodAt: #perform:with:with:with:.				Object compiledMethodAt: #perform:with:with:with:with:.				Object compiledMethodAt: #perform:withArguments:.						Object compiledMethodAt: #perform:withArguments:inSuperclass:.						Object compiledMethodAt: #perform:withEnoughArguments:.				Object compiledMethodAt: #isSymbol.				Behavior reloadingMethod.				EditHistory compiledMethodAt: #swapInMethodAt:in:.				Object compiledMethodAt: #adaptToInteger:andSend:.				Object compiledMethodAt: #in:.				Object compiledMethodAt: #addDependent:.				Symbol compiledMethodAt: #isSymbol.				ContextPart compiledMethodAt: #selector.				ContextPart compiledMethodAt: #arguments.				CompiledMethod compiledMethodAt: #selector.				UUIDGenerator compiledMethodAt: #semaphoreForGenerator.				UUIDGenerator compiledMethodAt: #randomGenerator.				ProtoObject compiledMethodAt: #initialize.				BlockClosure compiledMethodAt: #value.				BlockContext compiledMethodAt: #value.				Semaphore compiledMethodAt: #wait.				UndefinedObject compiledMethodAt: #release.				ClassOrganizer compiledMethodAt: #traitComposition.				ByteString class compiledMethodAt: #stringHash:initialHash:};			yourself).			{		#(id isNil notNil isInteger removeFromSystem removeFromSystem: hashBytes:startingWith: size species signal resumptionTime primGetNextEvent: bitAnd: new: new negative at: at:put: bitShiftMagnitude: bitOr: < randomCounter / + asFloat bitXor: identityHash basicAt: basicAt:put: basicNew: basicNew isMethodProperties printString).		CompiledMethodTrailer trailerKindDecoders.	}		do: [:set |			set do: [:selector |		(navigation allImplementorsOf: selector) do: [:reference | fusedMethods add: reference compiledMethod]]].	self		fuseHeadlessSingleClassesInto: fusedMethods;		fuseHeadlessClassHierarchiesInto: fusedMethods.				fusedMethods do: [:method | method fuse].		Behavior setReloadingMethod.	reloadingMethod := Behavior reloadingMethod.	Shaker class swapOutMethodAt: #test:.	(Shaker test: 42) = 42 ifFalse: [self error: 'history system not working'].		"Set the selector and class-binding literals of the reloading method to things which make sense in the JS debugger."	Behavior setReloadingMethod.	LRUCache allInstancesDo: [:cache | cache reset].	WeakArray restartFinalizationProcess.	[3 error: 'ignored'] on: Error do: [:exception | ].	Delay initialize.	(Delay forSeconds: 1) wait.	Object new breakDependents.	NaturalLanguageTranslator privateStartUp.	ExternalSettings startUp.	SmalltalkImage startUp.	NetNameResolver startUp: true.	Date fromSeconds: Time totalSeconds.	Smalltalk recordStartupStamp.	DateAndTime startUp: true.		{		BlockClosure.		ContextPart	}		do: [:class |			class allSubInstancesDo: [:methodHolder | methodHolder fuse]].		JS at: #shaking put: true.	Smalltalk		primitiveGarbageCollect;		primitiveFusedGarbageCollect;		primitiveFusedGarbageCollect.			numberOfClassesRemoved := -1.		[numberOfClassesRemoved = 0] whileFalse: [		numberOfClassesRemoved := 0.		(Class allSubclasses asSortedCollection: [:earlier :later | earlier depth <= later depth]) asArray reversed do: [:metaclass |			(				metaclass soleInstance subclasses isEmpty not or: [					{						metaclass.						metaclass soleInstance					}						anySatisfy: [:behavior |							behavior methodDict anySatisfy: [:method | method ~~ reloadingMethod]]]			)				ifFalse: [					metaclass soleInstance removeFromSystem.					numberOfClassesRemoved := numberOfClassesRemoved + 1]]].		Smalltalk garbageCollect! !----QUIT----{25 September 2019 . 4:58:58 pm} history.image priorSource: 2039358!----STARTUP----{25 September 2019 . 5:05:52 pm} as /Users/craig/Downloads/caffeine/backups/37 (headless)/history.image!!Shaker methodsFor: 'as yet unclassified' stamp: 'crl 9/25/2019 17:09' prior: 35594083!shakeHeadless	| fusedMethods weakArray navigation reloadingMethod numberOfClassesRemoved |		(SmalltalkImage classPool)		at: #ShutDownList		put: #(#TTFileDescription #InternetConfiguration #TTCFont #ArchiveViewer #CPUWatcher #ProcessBrowser #ExternalSettings #Symbol #SecurityManager #AutoStart #FileStream #CommandHistory #StrikeFontSet #MessageTally #ImageSegment #Password #HttpUrl #SoundPlayer #FileDirectory #Color #StrikeFont #PasteUpMorph #ControlManager #DisplayScreen #Delay) asOrderedCollection.		SmalltalkImage compile: 'snapshot: save andQuit: quit withExitCode: exitCode embedded: embeddedFlag	"Mark the changes file and close all files as part of #processShutdownList.	If save is true, save the current state of this Smalltalk in the image file.	If quit is true, then exit to the outer OS shell.	If exitCode is not nil, then use it as exit code.	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."	| resuming msg |	Object flushDependents.	Object flushEvents.	(SourceFiles at: 2) ifNotNil:[		msg := String streamContents: [ :s |			s nextPutAll: ''----'';			nextPutAll: (save ifTrue: [ quit ifTrue: [ ''QUIT'' ] ifFalse: [ ''SNAPSHOT'' ] ]							ifFalse: [quit ifTrue: [ ''QUIT/NOSAVE'' ] ifFalse: [ ''NOP'' ]]);			nextPutAll: ''----'';			print: Date dateAndTimeNow; space;			nextPutAll: (FileDirectory default localNameFor: self imageName);			nextPutAll: '' priorSource: '';			print: LastQuitLogPosition ].		self assureStartupStampLogged.		save ifTrue: [ LastQuitLogPosition := (SourceFiles at: 2) setToEnd; position ].		self logChange: msg.		Transcript cr; show: msg	].	Smalltalk processShutDownList: quit.	Cursor write show.	save ifTrue: [resuming := embeddedFlag 					ifTrue: [self snapshotEmbeddedPrimitive] 					ifFalse: [self snapshotPrimitive].  "<-- PC frozen here on image file"				resuming == false "guard against failure" ifTrue:					[]]		ifFalse: [resuming := false].	quit & (resuming == false) ifTrue: [		exitCode			ifNil: [ self quitPrimitive ]			ifNotNil: [ self quitPrimitive: exitCode ] ].	Cursor normal show.	Smalltalk setGCParameters.	resuming == true ifTrue: [Smalltalk clearExternalObjects].	Smalltalk processStartUpList: resuming == true.	resuming == true ifTrue:[		self setPlatformPreferences.		self recordStartupStamp].	"Now it''s time to raise an error"	resuming == nil ifTrue: [self error:''Failed to write image file (disk full?)''].	^ resuming' classified: 'whatever'.		(SmalltalkImage classPool)		at: #StartUpList		put: #(#SmallInteger #Delay #Other #HostPlatform #WebEntrance #ProcessorScheduler #FileDirectory #ShortIntegerArray #ShortRunArray #MessageTally #NaturalLanguageTranslator #LanguageEnvironment #PowerManagement #ExternalSettings #SecurityManager #FileStream #UUIDGenerator #CPUWatcher #DateAndTime #SmalltalkImage #Utilities #WeakArray #MultiByteFileStream #InternetConfiguration #Locale #Collection #HostWindowProxy #NetNameResolver #Caffeine #Worker #Webpage #ExternalResource) asOrderedCollection.	EditHistory connectTo: 'ws://localhost:8091/tether'.	weakArray := WeakArray with: Object new.	navigation := SystemNavigation new.		fusedMethods := (		(OrderedCollection new)			addAll: {				Object compiledMethodAt: #breakDependents.				Object compiledMethodAt: #actAsExecutor.				Object compiledMethodAt: #isPseudoContext.				Object compiledMethodAt: #executor.				Object compiledMethodAt: #halt:.				Object compiledMethodAt: #primitiveError:.				Object compiledMethodAt: #perform:.								Object compiledMethodAt: #perform:with:.				Object compiledMethodAt: #perform:with:with:.				Object compiledMethodAt: #perform:with:with:with:.				Object compiledMethodAt: #perform:with:with:with:with:.				Object compiledMethodAt: #perform:withArguments:.						Object compiledMethodAt: #perform:withArguments:inSuperclass:.						Object compiledMethodAt: #perform:withEnoughArguments:.				Object compiledMethodAt: #isSymbol.				Behavior reloadingMethod.				EditHistory compiledMethodAt: #swapInMethodAt:in:.				Object compiledMethodAt: #adaptToInteger:andSend:.				Object compiledMethodAt: #in:.				Object compiledMethodAt: #addDependent:.				Symbol compiledMethodAt: #isSymbol.				ContextPart compiledMethodAt: #selector.				ContextPart compiledMethodAt: #arguments.				CompiledMethod compiledMethodAt: #selector.				UUIDGenerator compiledMethodAt: #semaphoreForGenerator.				UUIDGenerator compiledMethodAt: #randomGenerator.				ProtoObject compiledMethodAt: #initialize.				BlockClosure compiledMethodAt: #value.				BlockContext compiledMethodAt: #value.				Semaphore compiledMethodAt: #wait.				UndefinedObject compiledMethodAt: #release.				ClassOrganizer compiledMethodAt: #traitComposition.				ByteString class compiledMethodAt: #stringHash:initialHash:};			yourself).			{		#(id isNil notNil isInteger removeFromSystem removeFromSystem: hashBytes:startingWith: size species signal resumptionTime primGetNextEvent: bitAnd: new: new negative at: at:put: bitShiftMagnitude: bitOr: < randomCounter / + asFloat bitXor: identityHash basicAt: basicAt:put: basicNew: basicNew isMethodProperties printString).		CompiledMethodTrailer trailerKindDecoders.	}		do: [:set |			set do: [:selector |		(navigation allImplementorsOf: selector) do: [:reference | fusedMethods add: reference compiledMethod]]].	self		fuseHeadlessSingleClassesInto: fusedMethods;		fuseHeadlessClassHierarchiesInto: fusedMethods.				fusedMethods do: [:method | method fuse].		Behavior setReloadingMethod.	reloadingMethod := Behavior reloadingMethod.	Shaker class swapOutMethodAt: #test:.	(Shaker test: 42) = 42 ifFalse: [self error: 'history system not working'].		"Set the selector and class-binding literals of the reloading method to things which make sense in the JS debugger."	Behavior setReloadingMethod.	LRUCache allInstancesDo: [:cache | cache reset].	WeakArray restartFinalizationProcess.	[3 error: 'ignored'] on: Error do: [:exception | ].	Delay initialize.	(Delay forSeconds: 1) wait.	Object new breakDependents.	NaturalLanguageTranslator privateStartUp.	ExternalSettings startUp.	SmalltalkImage startUp.	NetNameResolver startUp: true.	Date fromSeconds: Time totalSeconds.	Smalltalk recordStartupStamp.	DateAndTime initializeOffsets; startUp: true.		{		BlockClosure.		ContextPart	}		do: [:class |			class allSubInstancesDo: [:methodHolder | methodHolder fuse]].		JS at: #shaking put: true.	Smalltalk		primitiveGarbageCollect;		primitiveFusedGarbageCollect;		primitiveFusedGarbageCollect.			numberOfClassesRemoved := -1.		[numberOfClassesRemoved = 0] whileFalse: [		numberOfClassesRemoved := 0.		(Class allSubclasses asSortedCollection: [:earlier :later | earlier depth <= later depth]) asArray reversed do: [:metaclass |			(				metaclass soleInstance subclasses isEmpty not or: [					{						metaclass.						metaclass soleInstance					}						anySatisfy: [:behavior |							behavior methodDict anySatisfy: [:method | method ~~ reloadingMethod]]]			)				ifFalse: [					metaclass soleInstance removeFromSystem.					numberOfClassesRemoved := numberOfClassesRemoved + 1]]].		Smalltalk garbageCollect! !----QUIT----{25 September 2019 . 5:09:15 pm} history.image priorSource: 2046920!----STARTUP----{25 September 2019 . 5:56:43 pm} as /Users/craig/Downloads/caffeine/backups/37 (headless)/history.image!EditHistory new.EditHistory rememberAllActiveClasses.EditHistory rememberAllMethods!----QUIT----{25 September 2019 . 5:57:13 pm} history.image priorSource: 2054501!----STARTUP----{25 October 2019 . 12:38:30 am} as /Users/craig/Downloads/caffeine/backups/37 (headless)/history.image!			Classes keyAtValue: RemoteMessageAnswer!InstructionsBase!OtherMarkerTagBase!SmallIntegerTagBase!ClassTagsBase!Classes at: 1073741841!Classes keys max!Classes keys max log: 2!Classes keys max!2 raisedTo: 30!2 raisedTo: 31!SpecialVariables values max!SpecialVariables!SmallIntegerTagBase!2147483648 log: 2!SpecialVariables!1073741825 log: 2!(2 raisedTo: 31) - 1073741825!(2 raisedTo: 30) - 1073741825!1073741825 bitShift: -24!SmallIntegerTagBase!ClassTagsBase!Classes!SpecialVariables!2 raisedTo: 28!SmalltalkImage classPool at: #StartUpList!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 10/25/2019 21:58' prior: 35387786!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS ifHeadless: [				^[					| tether portal connected |								(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.										portal := WorkerEntrance new.					tether := Tether through: portal.								JS						at: #onmessage						put: [:message |							JS debugger.							portal incomingMessage: message.							tether handleEvent].								tether waitForPeer.					connected := tether peer ping				]					forkAt: Processor timingPriority]].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----SNAPSHOT----{25 October 2019 . 9:58:18 pm} history.image priorSource: 2054793!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 10/25/2019 22:06' prior: 35610125!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS ifHeadless: [				^[					| tether portal connected |								(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.										portal := WorkerEntrance new.					tether := Tether through: portal.								JS						at: #onmessage						put: [:message |							portal incomingMessage: message.							tether handleEvent].								tether waitForPeer.					connected := tether peer ping				]					forkAt: Processor timingPriority]].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----SNAPSHOT----{25 October 2019 . 10:06:58 pm} history.image priorSource: 2056464!UUIDGenerator default generateRandomBitsOfLength: 28!	^UUIDGenerator default generateRandomBitsOfLength: 28!	^UUIDGenerator default generateRandomBitsOfLength: 28!	^UUIDGenerator default generateRandomBitsOfLength: 28!OtherMarkerTagBase!									(OtherMarkerTagBase + ((2 raisedTo: 29) - 1)) hex!									(OtherMarkerTagBase + ((2 raisedTo: 29) - 1)) log: 2!									(OtherMarkerTagBase + ((2 raisedTo: 28) - 1)) log: 2!									(OtherMarkerTagBase + ((2 raisedTo: 27) - 1)) log: 2!									(OtherMarkerTagBase + ((2 raisedTo: 26) - 1)) log: 2!									(OtherMarkerTagBase + ((2 raisedTo: 20) - 1)) log: 2!(2 raisedTo: 31) - OtherMarkerTagBase!									(((2 raisedTo: 32) - 1) - OtherMarkerTagBase) log: 2!OtherMarkerTagBase!!TetherConstants class methodsFor: 'as yet unclassified' stamp: 'crl 10/25/2019 22:32' prior: 35016980!initialize	"Initialize myself."	| tagNames |	tagNames := #(		TrueTag		FalseTag		NilTag		SymbolTag		StringTag		CounterpartRequestTag		MessageSendTag		ArrayTag		MethodTag		FloatTag		CharacterTag		AssociationTag		MethodDictionaryTag		NegativeNumberTag		LargePositiveIntegerTag		LargeNegativeIntegerTag		UUIDTag		MethodIDTag		SetTag		ClassLiteralMarkerTag		ClassVariableLiteralMarkerTag		MetaSuperSendLiteralMarkerTag		UndeclaredLiteralMarkerTag		GlobalLiteralMarkerTag		PositiveManifestTag		NegativeManifestTag		ByteArrayTag		ExceptionMarkerTag		AnswerTag		OrderedCollectionTag		IntervalTag		SortedCollectionTag		MessageTag		ClassIDTag		DictionaryTag		PublishedVariableLiteralMarkerTag		InstallRemoteModuleTag		BrowseAvailableModulesTag		ModuleDescriptionTag		AuthorIDTag		VersionTag		GPLTag		ApacheTag		SqueakTag		MITTag		GPL3Tag		MethodEditionTag		ProtoclassEditionTag		MetaclassEditionTag		IdentityLiteralMarkerTag		EditTag		AuthorTag		CommentEditionTag		TagsEditionTag		CheckpointTag		PublishedVariableDictionaryLiteralMarkerTag		ModuleIDTag		ModuleEditionTag		MemoryProfileTag		ScaledDecimalTag		FractionTag		WideSymbolTag		WideStringTag).	InstructionsBase := 2r01110000000000000000000000000000.	OtherMarkerTagBase := 2r01100000000000000000000000000001.	SmallIntegerTagBase := 2r01000000000000000000000000000000.	ClassTagsBase := 2r00100000000000000000000000000000.	1		to: tagNames size		do: [:index |			classPool				at: (tagNames at: index)				put: 2r01000000000000000000000000000000 + index].				SpecialVariables := (		(Dictionary new)			at: true put: TrueTag;			at: false put: FalseTag;			at: nil put: NilTag;			yourself).	Classes := (		(Dictionary new)			at: SymbolTag put: Symbol;			at: StringTag put: String;			at: MessageSendTag put: Tether;			at: CounterpartRequestTag put: CounterpartRequest;			at: ArrayTag put: Array;			at: MethodTag put: CompiledMethod;			at: FloatTag put: Float;			at: CharacterTag put: Character;			at: AssociationTag put: Association;			at: MethodDictionaryTag put: MethodDictionary;			at: NegativeNumberTag put: Number;			at: LargePositiveIntegerTag put: LargePositiveInteger;			at: LargeNegativeIntegerTag put: LargeNegativeInteger;			at: UUIDTag put: UUID;			at: ClassIDTag put: ClassID;			at: MethodIDTag put: MethodID;			at: SetTag put: Set;			at: ClassLiteralMarkerTag put: ClassLiteralMarker;			at: ClassVariableLiteralMarkerTag put: ClassVariableLiteralMarker;			at: MetaSuperSendLiteralMarkerTag put: MetaSuperSendLiteralMarker;			at: UndeclaredLiteralMarkerTag put: UndeclaredLiteralMarker;			at: GlobalLiteralMarkerTag put: GlobalLiteralMarker;			at: PositiveManifestTag put: PositiveManifest;			at: NegativeManifestTag put: NegativeManifest;			at: ByteArrayTag put: ByteArray;			at: ExceptionMarkerTag put: ExceptionMarker;			at: AnswerTag put: RemoteMessageAnswer;			at: OrderedCollectionTag put: OrderedCollection;			at: IntervalTag put: Interval;			at: SortedCollectionTag put: SortedCollection;			at: MessageTag put: Message;			at: DictionaryTag put: Dictionary;			at: PublishedVariableLiteralMarkerTag put: PublishedVariableLiteralMarker;			at: InstallRemoteModuleTag put: InstallRemoteModule;			at: BrowseAvailableModulesTag put: BrowseAvailableModules;			at: ModuleDescriptionTag put: ModuleDescription;			at: VersionTag put: Version;			at: GPLTag put: GPL;			at: GPL3Tag put: GPL3;			at: ApacheTag put: Apache;			at: MITTag put: MIT;			at: SqueakTag put: SqueakLicense;			at: MethodEditionTag put: MethodEdition;			at: ProtoclassEditionTag put: ProtoclassEdition;			at: MetaclassEditionTag put: MetaclassEdition;			at: IdentityLiteralMarkerTag put: IdentityLiteralMarker;			at: EditTag put: Edit;			at: AuthorTag put: Author;			at: CommentEditionTag put: CommentEdition;			at: TagsEditionTag put: TagsEdition;			at: CheckpointTag put: Checkpoint;			at: PublishedVariableDictionaryLiteralMarkerTag put: PublishedVariableDictionaryLiteralMarker;			at: ModuleIDTag put: ModuleID;			at: ModuleEditionTag put: ModuleEdition;			at: MemoryProfileTag put: MemoryProfile;			at: ScaledDecimalTag put: ScaledDecimal;			at: FractionTag put: Fraction;			at: WideSymbolTag put: WideSymbol;			at: WideStringTag put: WideString;			yourself)! !self initialize!(OtherMarkerTagBase + ((2 raisedTo: 29) - 1)) log: 2!!Object methodsFor: 'as yet unclassified' stamp: 'crl 10/25/2019 22:33' prior: 34557313!exposureHash	^UUIDGenerator default generateRandomBitsOfLength: 27! !(2 raisedTo: 28) - 1!InstructionsBase!OtherMarkerTagBase!SmallIntegerTagBase!ClassTagsBase!!Object methodsFor: 'as yet unclassified' stamp: 'crl 10/25/2019 22:36' prior: 35617270!exposureHash	^UUIDGenerator default generateRandomBitsOfLength: 27! !----SNAPSHOT----{25 October 2019 . 10:36:30 pm} history.image priorSource: 2057401!Classes!Classes at: 1073741831!SpecialVariables!Classes!----QUIT----{26 October 2019 . 3:26 am} history.image priorSource: 2063169!----STARTUP----{26 October 2019 . 10:05:18 am} as /Users/craig/Downloads/caffeine/backups/37 (headless)/history.image!| shift |shift := 32.#[64 0 0 33]	inject: 0	into: [:subtotal :next |		shift := shift - 8.		subtotal + (next bitShift: shift)]!	Classes!| shift |shift := 32.#[64 0 0 7]	inject: 0	into: [:subtotal :next |		shift := shift - 8.		subtotal + (next bitShift: shift)]!| shift |shift := 32.#[64 0 0 4]	inject: 0	into: [:subtotal :next |		shift := shift - 8.		subtotal + (next bitShift: shift)]!| shift |shift := 32.#[64 0 0 8]	inject: 0	into: [:subtotal :next |		shift := shift - 8.		subtotal + (next bitShift: shift)]!| shift |shift := 32.#[64 0 0 17]	inject: 0	into: [:subtotal :next |		shift := shift - 8.		subtotal + (next bitShift: shift)]!| shift |shift := 32.#[64 0 0 8]	inject: 0	into: [:subtotal :next |		shift := shift - 8.		subtotal + (next bitShift: shift)]!UUID new size!#[64 0 0 7 64 0 0 33 64 0 0 4 0 0 0 4 112 105 110 103 64 0 0 8 0 0 0 0 3 194 148 195 130 194 152 64 0 0 17 0 0 0 16 38 195 141 97 194 184 194 188 195 187 69 195 128 194 168 51 6 194 153 194 171 194 158 194 132 195 163]!156299393 hex!156299393 hex!16r50!16rF0!16r81!194 hex!!WorkerEntrance methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2019 13:18' prior: 35299877!send	"Send the contents of the current outgoing message."	JS postMessage: (JS JSON stringify: self outgoingPayload)! !----SNAPSHOT----{26 October 2019 . 1:19:03 pm} history.image priorSource: 2063318!!WorkerEntrance methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2019 13:28' prior: 35619172!send	"Send the contents of the current outgoing message."	| payload |		payload := self outgoingPayload.		JS postMessage: payload with: {payload}! !----SNAPSHOT----{26 October 2019 . 1:28:48 pm} history.image priorSource: 2064861!!WorkerEntrance methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2019 13:18' prior: 35619475!send	"Send the contents of the current outgoing message."	JS postMessage: (JS JSON stringify: self outgoingPayload)! !!WorkerEntrance methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2019 13:35' prior: 35619811!send	"Send the contents of the current outgoing message."	JS postMessage: (JS JSON stringify: {#payload -> self outgoingPayload})! !----SNAPSHOT----{26 October 2019 . 1:35:59 pm} history.image priorSource: 2065197!SmallIntegerTagBase!2r10000000000000000000000000000000!2r01100000000000000000000000000001!2r00100000000000000000000000000000!self initialize!Classes!!TetherConstants class methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2019 13:50' prior: 35612776!initialize	"Initialize myself."	| tagNames |	tagNames := #(		TrueTag		FalseTag		NilTag		SymbolTag		StringTag		CounterpartRequestTag		MessageSendTag		ArrayTag		MethodTag		FloatTag		CharacterTag		AssociationTag		MethodDictionaryTag		NegativeNumberTag		LargePositiveIntegerTag		LargeNegativeIntegerTag		UUIDTag		MethodIDTag		SetTag		ClassLiteralMarkerTag		ClassVariableLiteralMarkerTag		MetaSuperSendLiteralMarkerTag		UndeclaredLiteralMarkerTag		GlobalLiteralMarkerTag		PositiveManifestTag		NegativeManifestTag		ByteArrayTag		ExceptionMarkerTag		AnswerTag		OrderedCollectionTag		IntervalTag		SortedCollectionTag		MessageTag		ClassIDTag		DictionaryTag		PublishedVariableLiteralMarkerTag		InstallRemoteModuleTag		BrowseAvailableModulesTag		ModuleDescriptionTag		AuthorIDTag		VersionTag		GPLTag		ApacheTag		SqueakTag		MITTag		GPL3Tag		MethodEditionTag		ProtoclassEditionTag		MetaclassEditionTag		IdentityLiteralMarkerTag		EditTag		AuthorTag		CommentEditionTag		TagsEditionTag		CheckpointTag		PublishedVariableDictionaryLiteralMarkerTag		ModuleIDTag		ModuleEditionTag		MemoryProfileTag		ScaledDecimalTag		FractionTag		WideSymbolTag		WideStringTag).	InstructionsBase := 2r01110000000000000000000000000000.	OtherMarkerTagBase := 2r01100000000000000000000000000001.	SmallIntegerTagBase := 2r01000000000000000000000000000000.	ClassTagsBase := 2r00100000000000000000000000000000.	1		to: tagNames size		do: [:index |			classPool				at: (tagNames at: index)				put: ClassTagsBase + index].				SpecialVariables := (		(Dictionary new)			at: true put: TrueTag;			at: false put: FalseTag;			at: nil put: NilTag;			yourself).	Classes := (		(Dictionary new)			at: SymbolTag put: Symbol;			at: StringTag put: String;			at: MessageSendTag put: Tether;			at: CounterpartRequestTag put: CounterpartRequest;			at: ArrayTag put: Array;			at: MethodTag put: CompiledMethod;			at: FloatTag put: Float;			at: CharacterTag put: Character;			at: AssociationTag put: Association;			at: MethodDictionaryTag put: MethodDictionary;			at: NegativeNumberTag put: Number;			at: LargePositiveIntegerTag put: LargePositiveInteger;			at: LargeNegativeIntegerTag put: LargeNegativeInteger;			at: UUIDTag put: UUID;			at: ClassIDTag put: ClassID;			at: MethodIDTag put: MethodID;			at: SetTag put: Set;			at: ClassLiteralMarkerTag put: ClassLiteralMarker;			at: ClassVariableLiteralMarkerTag put: ClassVariableLiteralMarker;			at: MetaSuperSendLiteralMarkerTag put: MetaSuperSendLiteralMarker;			at: UndeclaredLiteralMarkerTag put: UndeclaredLiteralMarker;			at: GlobalLiteralMarkerTag put: GlobalLiteralMarker;			at: PositiveManifestTag put: PositiveManifest;			at: NegativeManifestTag put: NegativeManifest;			at: ByteArrayTag put: ByteArray;			at: ExceptionMarkerTag put: ExceptionMarker;			at: AnswerTag put: RemoteMessageAnswer;			at: OrderedCollectionTag put: OrderedCollection;			at: IntervalTag put: Interval;			at: SortedCollectionTag put: SortedCollection;			at: MessageTag put: Message;			at: DictionaryTag put: Dictionary;			at: PublishedVariableLiteralMarkerTag put: PublishedVariableLiteralMarker;			at: InstallRemoteModuleTag put: InstallRemoteModule;			at: BrowseAvailableModulesTag put: BrowseAvailableModules;			at: ModuleDescriptionTag put: ModuleDescription;			at: VersionTag put: Version;			at: GPLTag put: GPL;			at: GPL3Tag put: GPL3;			at: ApacheTag put: Apache;			at: MITTag put: MIT;			at: SqueakTag put: SqueakLicense;			at: MethodEditionTag put: MethodEdition;			at: ProtoclassEditionTag put: ProtoclassEdition;			at: MetaclassEditionTag put: MetaclassEdition;			at: IdentityLiteralMarkerTag put: IdentityLiteralMarker;			at: EditTag put: Edit;			at: AuthorTag put: Author;			at: CommentEditionTag put: CommentEdition;			at: TagsEditionTag put: TagsEdition;			at: CheckpointTag put: Checkpoint;			at: PublishedVariableDictionaryLiteralMarkerTag put: PublishedVariableDictionaryLiteralMarker;			at: ModuleIDTag put: ModuleID;			at: ModuleEditionTag put: ModuleEdition;			at: MemoryProfileTag put: MemoryProfile;			at: ScaledDecimalTag put: ScaledDecimal;			at: FractionTag put: Fraction;			at: WideSymbolTag put: WideSymbol;			at: WideStringTag put: WideString;			yourself)! !self initialize!Classes!----SNAPSHOT----{26 October 2019 . 1:50:41 pm} history.image priorSource: 2065733!SpecialVariables!self keyAtValue: RemoteMessageAnswer!self keyAtValue: UUID!self keyAtValue: Tether!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2019 15:28' prior: 35611082!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS ifHeadless: [				^[					| tether portal connected |								(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.										portal := WorkerEntrance new.					tether := Tether through: portal.								JS						at: #onmessage						put: [:message |							portal incomingMessage: message.							tether handleEvent].								tether waitForPeer.					connected := tether peer ping.					JS debugger				]					forkAt: Processor timingPriority]].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----SNAPSHOT----{26 October 2019 . 3:28:29 pm} history.image priorSource: 2070421!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2019 15:33' prior: 35625147!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS ifHeadless: [				^[					| tether portal connected |								(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.										portal := WorkerEntrance new.					tether := Tether through: portal.								JS						at: #onmessage						put: [:message |							portal incomingMessage: message.							tether handleEvent].								tether waitForPeer.					connected := tether peer ping.					JS at: #fribbly put: connected.					JS debugger				]					forkAt: Processor timingPriority]].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----SNAPSHOT----{26 October 2019 . 3:33:59 pm} history.image priorSource: 2071484!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2019 15:38' prior: 35626102!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS ifHeadless: [				^[					| tether portal connected |								(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.										portal := WorkerEntrance new.					tether := Tether through: portal.								JS						at: #onmessage						put: [:message |							portal incomingMessage: message.							tether handleEvent].								tether waitForPeer.					connected := tether peer ping.					JS postMessage: (JS JSON stringify: {#note -> connected})				]					forkAt: Processor timingPriority]].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----SNAPSHOT----{26 October 2019 . 3:38:53 pm} history.image priorSource: 2072476!SmallIntegerTagBase!!Object methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2019 16:22' prior: 34996997!browseAllCallsOn: selectorSymbol	"Models get the first chance to handle this, so a message-tracer can be built..  Not all Tool 'models' inherit from Model, otherwise this would be there."	self systemNavigation browseAllCallsOn: selectorSymbol! !					#[65 66 67] asString!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2019 16:47' prior: 35305685!handleEvent	(peer recyclingHash = 0)		ifTrue: [			peer := self next..			portal isExit ifFalse: [self push: self].			peerSet signal]		ifFalse: [			| nextWord handler |						nextWord := portal nextWord.			JS ifConnected: [				(nextWord = 1337) ifTrue: [					"This is a message from a JavaScript system."					^JS postMessage: (						JS JSON stringify: {#note -> self perform: (portal next: portal nextWord) asSymbol})]].						handler := Classes at: nextWord ifAbsent: [3 halt].			handler				ifNil: [3 halt]				ifNotNil: [handler handleEventFrom: self]]! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2019 16:47'!rawk	^42! !----SNAPSHOT----{26 October 2019 . 4:48:03 pm} history.image priorSource: 2073477!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2019 17:02' prior: 35627094!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS ifHeadless: [				^[					| tether portal connected |								(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.										portal := WorkerEntrance new.					tether := Tether through: portal.								JS						at: #onmessage						put: [:message |							portal incomingMessage: message data asString asByteArray.							tether handleEvent].								tether waitForPeer.					connected := tether peer ping.					JS postMessage: (JS JSON stringify: {#note -> connected})				]					forkAt: Processor timingPriority]].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----SNAPSHOT----{26 October 2019 . 5:03:03 pm} history.image priorSource: 2074696!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2019 17:04' prior: 35629314!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS ifHeadless: [				^[					| tether portal connected |								(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.										portal := WorkerEntrance new.					tether := Tether through: portal.								JS						at: #onmessage						put: [:message |							portal incomingMessage: message data counterpart simplestRepresentation.							tether handleEvent].								tether waitForPeer.					connected := tether peer ping.					JS postMessage: (JS JSON stringify: {#note -> connected})				]					forkAt: Processor timingPriority]].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !!Portal methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2019 17:05' prior: 33642562!incomingMessage: message	incomingMessage := message asByteArray readStream! !----SNAPSHOT----{26 October 2019 . 5:05:16 pm} history.image priorSource: 2075723!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2019 17:07' prior: 35630341!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS ifHeadless: [				^[					| tether portal connected |								(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.										portal := WorkerEntrance new.					tether := Tether through: portal.								JS						at: #onmessage						put: [:message |							portal incomingMessage: message data asString.							tether handleEvent].								tether waitForPeer.					connected := tether peer ping.					JS postMessage: (JS JSON stringify: {#note -> connected})				]					forkAt: Processor timingPriority]].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----SNAPSHOT----{26 October 2019 . 5:07:07 pm} history.image priorSource: 2076932!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2019 17:04' prior: 35631550!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS ifHeadless: [				^[					| tether portal connected |								(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.										portal := WorkerEntrance new.					tether := Tether through: portal.								JS						at: #onmessage						put: [:message |							portal incomingMessage: message data counterpart simplestRepresentation.							tether handleEvent].								tether waitForPeer.					connected := tether peer ping.					JS postMessage: (JS JSON stringify: {#note -> connected})				]					forkAt: Processor timingPriority]].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----SNAPSHOT----{26 October 2019 . 5:20:30 pm} history.image priorSource: 2077947!!Portal methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2019 17:22' prior: 35631286!incomingMessage: message	incomingMessage := (		(			JS				ifConnected: [message]				ifNotConnected: [message asByteArray]		)			readStream)! !----SNAPSHOT----{26 October 2019 . 5:22:58 pm} history.image priorSource: 2078988!#[97 115 83 121 109 98 111 108] asString!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2019 17:27' prior: 35628470!handleEvent	(peer recyclingHash = 0)		ifTrue: [			peer := self next..			portal isExit ifFalse: [self push: self].			peerSet signal]		ifFalse: [			| nextWord handler |						nextWord := portal nextWord.			JS ifConnected: [				(nextWord = 1337) ifTrue: [					"This is a message from a JavaScript system."					^JS postMessage: (						JS JSON stringify: {#note -> self perform: (portal next: portal nextWord) asString asSymbol})]].						handler := Classes at: nextWord ifAbsent: [3 halt].			handler				ifNil: [3 halt]				ifNotNil: [handler handleEventFrom: self]]! !----SNAPSHOT----{26 October 2019 . 5:27:43 pm} history.image priorSource: 2079309!#[110 111 116 101] asString!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2019 17:30' prior: 35633958!handleEvent	(peer recyclingHash = 0)		ifTrue: [			peer := self next..			portal isExit ifFalse: [self push: self].			peerSet signal]		ifFalse: [			| nextWord handler |						nextWord := portal nextWord.			JS ifConnected: [				(nextWord = 1337) ifTrue: [					"This is a message from a JavaScript system."					^JS postMessage: (						JS JSON stringify: {#note -> (self perform: (portal next: portal nextWord) asString asSymbol)})]].						handler := Classes at: nextWord ifAbsent: [3 halt].			handler				ifNil: [3 halt]				ifNotNil: [handler handleEventFrom: self]]! !----SNAPSHOT----{26 October 2019 . 5:30:18 pm} history.image priorSource: 2080107!#[123 97 32 74 83 83 116 114 105 110 103 32 102 111 114 32 39 114 39 32 46 32 97 32 74 83 83 116 114 105 110 103 32 102 111 114 32 39 97 39 32 46 32 97 32 74 83 83 116 114 105 110 103 32 102 111 114 32 39 119 39 32 46 32 97 32 74 83 83 116 114 105 110 103 32 102 111 114 32 39 107 39 125] asString!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2019 17:36' prior: 35634743!handleEvent	(peer recyclingHash = 0)		ifTrue: [			peer := self next..			portal isExit ifFalse: [self push: self].			peerSet signal]		ifFalse: [			| nextWord handler |						nextWord := portal nextWord.			JS ifConnected: [				(nextWord = 1337) ifTrue: [					"This is a message from a JavaScript system."					^JS postMessage: (						JS JSON stringify: {#note -> (self perform: (portal next: portal nextWord) proxy asString asSymbol)})]].						handler := Classes at: nextWord ifAbsent: [3 halt].			handler				ifNil: [3 halt]				ifNotNil: [handler handleEventFrom: self]]! !----SNAPSHOT----{26 October 2019 . 5:36:10 pm} history.image priorSource: 2080894!#[112 114 111 120 121] asString!!Portal methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2019 17:54'!incomingMessage	^incomingMessage! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2019 17:54' prior: 35635800!handleEvent	(peer recyclingHash = 0)		ifTrue: [			peer := self next..			portal isExit ifFalse: [self push: self].			peerSet signal]		ifFalse: [			| nextWord handler |						nextWord := portal nextWord.			JS ifConnected: [				(nextWord = 1337) ifTrue: [					"This is a message from a JavaScript system."					3 halt: portal incomingMessage.					^JS postMessage: (						JS JSON stringify: {#note -> (self perform: (portal next: portal nextWord) proxy asString asSymbol)})]].						handler := Classes at: nextWord ifAbsent: [3 halt].			handler				ifNil: [3 halt]				ifNotNil: [handler handleEventFrom: self]]! !----SNAPSHOT----{26 October 2019 . 5:54:56 pm} history.image priorSource: 2081957!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2019 18:06' prior: 35636707!handleEvent	(peer recyclingHash = 0)		ifTrue: [			peer := self next..			portal isExit ifFalse: [self push: self].			peerSet signal]		ifFalse: [			| nextWord handler |						nextWord := portal nextWord.			JS ifConnected: [				(nextWord = 1337) ifTrue: [					"This is a message from a JavaScript system."										| selector |										selector := (String new: 16) writeStream.										(portal next: portal nextWord) do: [:jsString | selector nextPutAll: jsString asString].																	^JS postMessage: (						JS JSON stringify: {#note -> (self perform: selector contents asSymbol)})]].						handler := Classes at: nextWord ifAbsent: [3 halt].			handler				ifNil: [3 halt]				ifNotNil: [handler handleEventFrom: self]]! !----SNAPSHOT----{26 October 2019 . 6:06:18 pm} history.image priorSource: 2082901!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2019 19:17' prior: 35637507!handleEvent	(peer recyclingHash = 0)		ifTrue: [			peer := self next..			portal isExit ifFalse: [self push: self].			peerSet signal]		ifFalse: [			| nextWord handler |						nextWord := portal nextWord.			JS ifConnected: [				(nextWord = 1337) ifTrue: [					"This is a message from a JavaScript system."										^JS postMessage: (						JS JSON stringify: {#note -> (self perform: (portal next: portal nextWord) asString asSymbol)})]].						handler := Classes at: nextWord ifAbsent: [3 halt].			handler				ifNil: [3 halt]				ifNotNil: [handler handleEventFrom: self]]! !----SNAPSHOT----{26 October 2019 . 7:17:25 pm} history.image priorSource: 2083827!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2019 19:24' prior: 35638433!handleEvent	(peer recyclingHash = 0)		ifTrue: [			peer := self next..			portal isExit ifFalse: [self push: self].			peerSet signal]		ifFalse: [			| nextWord handler |						nextWord := portal nextWord.			JS ifConnected: [				(nextWord = 1337) ifTrue: [					"This is a message from a JavaScript system."										^JS postMessage: (						JS JSON stringify: {							#result -> (self perform: (portal next: portal nextWord) asString asSymbol).							#exposureHash -> portal nextWord})]].						handler := Classes at: nextWord ifAbsent: [3 halt].			handler				ifNil: [3 halt]				ifNotNil: [handler handleEventFrom: self]]! !----SNAPSHOT----{26 October 2019 . 7:24:37 pm} history.image priorSource: 2084590!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2019 19:28' prior: 35632565!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS ifHeadless: [				^[					| tether portal connected |								(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.										portal := WorkerEntrance new.					tether := Tether through: portal.								JS						at: #onmessage						put: [:message |							portal incomingMessage: message data counterpart simplestRepresentation.							tether handleEvent].								tether waitForPeer.					connected := tether peer ping				]					forkAt: Processor timingPriority]].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----SNAPSHOT----{26 October 2019 . 7:28:20 pm} history.image priorSource: 2085404!#[35 40 48 32 48 32 48 32 52 32 49 49 52 32 57 55 32 49 49 57 32 49 48 55 41] asString!#(0 0 0 4 114 97 119 107) asString!#(0 0 0 4 114 97 119 107) asByteArray asString!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2019 19:35' prior: 35639196!handleEvent	(peer recyclingHash = 0)		ifTrue: [			peer := self next..			portal isExit ifFalse: [self push: self].			peerSet signal]		ifFalse: [			| nextWord handler |						nextWord := portal nextWord.			JS ifConnected: [				(nextWord = 1337) ifTrue: [					"This is a message from a JavaScript system."										^JS postMessage: (						JS JSON stringify: {							#result -> (self perform: (portal next: portal nextWord) asByteArray asString asSymbol).							#exposureHash -> portal nextWord})]].						handler := Classes at: nextWord ifAbsent: [3 halt].			handler				ifNil: [3 halt]				ifNotNil: [handler handleEventFrom: self]]! !----SNAPSHOT----{26 October 2019 . 7:35:36 pm} history.image priorSource: 2086381!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2019 19:53' prior: 35641162!handleEvent	(peer recyclingHash = 0)		ifTrue: [			peer := self next..			portal isExit ifFalse: [self push: self].			peerSet signal]		ifFalse: [			| nextWord handler |						nextWord := portal nextWord.			JS ifConnected: [				(nextWord = 1337) ifTrue: [					"This is a message from a JavaScript system."										| exposureHash |										exposureHash := portal nextWord.										^JS postMessage: (						JS JSON stringify: {							#result -> (self perform: (portal next: portal nextWord) asByteArray asString asSymbol).							#exposureHash -> exposureHash})]].						handler := Classes at: nextWord ifAbsent: [3 halt].			handler				ifNil: [3 halt]				ifNotNil: [handler handleEventFrom: self]]! !----SNAPSHOT----{26 October 2019 . 7:53:08 pm} history.image priorSource: 2087382!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2019 20:03' prior: 35641988!handleEvent	(peer recyclingHash = 0)		ifTrue: [			peer := self next..			portal isExit ifFalse: [self push: self].			peerSet signal]		ifFalse: [			| nextWord handler |						nextWord := portal nextWord.			JS ifConnected: [				(nextWord = 1337) ifTrue: [					"This is a message from a JavaScript system."										| exposureHash parameters |										exposureHash := portal nextWord.					parameters := JS JSON parse: (portal next: portal nextWord) asByteArray asString.										^JS postMessage: (						JS JSON stringify: {							#result -> (								self									perform: parameters selector asString asSymbol									withArguments: parameters arguments).							#exposureHash -> exposureHash})]].						handler := Classes at: nextWord ifAbsent: [3 halt].			handler				ifNil: [3 halt]				ifNotNil: [handler handleEventFrom: self]]! !----SNAPSHOT----{26 October 2019 . 8:03:29 pm} history.image priorSource: 2088277!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2019 20:11'!echo: something	^something! !----SNAPSHOT----{26 October 2019 . 8:11:48 pm} history.image priorSource: 2089310!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 10/26/2019 20:16' prior: 35642883!handleEvent	(peer recyclingHash = 0)		ifTrue: [			peer := self next..			portal isExit ifFalse: [self push: self].			peerSet signal]		ifFalse: [			| nextWord handler |						nextWord := portal nextWord.			JS ifConnected: [				(nextWord = 1337) ifTrue: [					"This is a message from a JavaScript system."										| exposureHash parameters |										exposureHash := portal nextWord.					parameters := JS JSON parse: (portal next: portal nextWord) asByteArray asString.										^JS postMessage: (						JS JSON stringify: {							#result -> (								self									perform: parameters selector asString asSymbol									withArguments: parameters arguments asArray).							#exposureHash -> exposureHash})]].						handler := Classes at: nextWord ifAbsent: [3 halt].			handler				ifNil: [3 halt]				ifNotNil: [handler handleEventFrom: self]]! !----SNAPSHOT----{26 October 2019 . 8:16:09 pm} history.image priorSource: 2089498!----STARTUP----{6 November 2019 . 10:57:14 am} as /Users/craig/Downloads/caffeine/backups/37 (headless)/pod.image!!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 11/6/2019 11:58'!ifNode: block	JS display isNode = true ifTrue: [block value]! !!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 11/6/2019 11:58' prior: 35640022!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS ifHeadless: [				JS ifNode: [^Exit start].								^[					| tether portal connected |								(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.										portal := WorkerEntrance new.					tether := Tether through: portal.								JS						at: #onmessage						put: [:message |							portal incomingMessage: message data counterpart simplestRepresentation.							tether handleEvent].								tether waitForPeer.					connected := tether peer ping				]					forkAt: Processor timingPriority]].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----SNAPSHOT----{6 November 2019 . 11:58:16 am} pod.image priorSource: 2090539!'From Squeak4.6 of 8 July 2015 [latest update: #15102] on 6 November 2019 at 1:18:36 pm'!Object subclass: #WebServer	instanceVariableNames: 'listenerSocket listenerProcess interface port mutex connections entryPoints vault logAction nonceCache sessions serverString errorHandler accessLog certName siteUrl'	classVariableNames: 'Default Registry'	poolDictionaries: ''	category: 'WebClient-Core'!Object subclass: #WebServer	instanceVariableNames: 'listenerSocket listenerProcess interface port mutex connections entryPoints vault logAction nonceCache sessions serverString errorHandler accessLog certName siteUrl'	classVariableNames: 'Default Registry'	poolDictionaries: ''	category: 'WebClient-Core'!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 7/28/2010 19:56'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 7/28/2010 19:56' prior: 34996997!accessLog	"The standard access log. Can be either a stream or a string; if the access log	is a string then the string is assumed to be a file name and the file will be opened 	and closed for each request."	^accessLog! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 7/28/2010 19:56'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 7/28/2010 19:56' prior: 34996997!accessLog: aStreamOrFilename	"The standard access log. Can be either a stream or a string; if the access log	is a string then the string is assumed to be a file name and the file will be opened 	and closed for each request."	accessLog := aStreamOrFilename! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2010 20:10'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2010 20:10' prior: 34996997!addService: entryPoint action: aBlockOrMessage	"Add a service to the web server. The service is specified by an entryPoint, 	denoting the url under which the service can be requested 	(such as /my/great/service) and an action which is a message 	send taking a single argument, the WebRequest."	^self addService: entryPoint 		action: aBlockOrMessage 		methods: self defaultHttpMethods.! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2010 20:10'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2010 20:10' prior: 34996997!addService: entryPoint action: aBlockOrMessage methods: methods	"Add a service to the web server. The service is specified by an entryPoint, 	denoting the url under which the service can be requested 	(such as /my/great/service) and an action which is a message 	send taking a single argument, the WebRequest.		The list of methods describes what HTTP methods the given url supports."	mutex critical:[		entryPoints at: entryPoint asLowercase put: {methods. aBlockOrMessage}.	].! !WebServer methodsFor: 'as yet unclassified' stamp: 'ul 7/3/2014 23:56'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ul 7/3/2014 23:56' prior: 34996997!asyncHandleConnectionFrom: aSocket	"Handle an incoming connection asynchronously to avoid blocking the listener."	| handlerProcess |	handlerProcess := [		[ [ self handleConnectionFrom: aSocket ] 			on: Error do: [ :ex | aSocket destroy ] ]			ensure: [				aSocket destroy.				mutex critical: [ 					"If we get here, then handlerProcess is initialized, so it's safe to use that variable. Using Processor activeProcess is not possible, because this block may be evaluated by another process. Doing this outside the #ensure: block is not safe."					connections remove: handlerProcess ifAbsent: [ ] ] ] ] newProcess.	mutex critical:[connections add: handlerProcess].	handlerProcess resume.! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 3/30/2010 20:43'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 3/30/2010 20:43' prior: 34996997!authAccept: method request: request realm: realm header: authHeader	"Performs the requested authentication method. 	Returns true if successfully authenticated.	Subclasses can extend this method to support more auth methods."	^method asLowercase caseOf: {		['basic'] 	-> [self basicAuth: request realm: realm header: authHeader].		['digest'] 	-> [self digestAuth: request realm: realm header: authHeader].	} otherwise:[false].! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 3/30/2010 20:43'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 3/30/2010 20:43' prior: 34996997!authHeader: method request: request realm: realm	"Answer the authentication header for the given method.	Subclasses can extend this method to support more auth methods."	^method asLowercase caseOf: {		['basic'] 	-> ['Basic realm="', realm,'"'].		['digest'] 	-> ['Digest realm="', realm,'", nonce="', self newNonce,'", qop="auth"'].	} otherwise:[nil].		! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 3/30/2010 20:43'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 3/30/2010 20:43' prior: 34996997!authenticate: request realm: realm methods: accepted do: aBlock	"Authenticates an incoming request using one of the accepted methods.	Evaluates aBlock upon successful authentication. Responds with a 401	(Unauthorized) if the authentication fails."	| method resp |	request headersAt: 'Authorization' do:[:authHeader|		method := authHeader copyUpTo: Character space.		(accepted anySatisfy:[:auth| auth sameAs: method]) ifTrue:[			(self authAccept: method request: request realm: realm header: authHeader)				ifTrue:[^aBlock value].		].	].	"Send a 401 (unauthorized) response"	resp := request newResponse protocol: 'HTTP/1.1' code: 401.	resp headerAt: 'Content-Type' put: 'text/html; charset=utf-8'.	accepted do:[:auth| | hdr |		hdr := self authHeader: auth request: request realm: realm.		hdr ifNotNil:[resp addHeader: 'WWW-Authenticate' value: hdr].	].	request sendResponse: resp content: '<html><head><title>401 Unauthorized</title></head><body><h1>401 Unauthorized</h1><p>You are not authorized to access the requested URL</p></body></html>'.! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 3/30/2010 20:38'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 3/30/2010 20:38' prior: 34996997!basicAuth: request realm: realm header: authHeader	"Perform Basic auth for the given request"	| data user pass hash |	data := (authHeader copyAfter: $ ) base64Decoded.	user := data copyUpTo: $:.	pass := data copyAfter: $:.	data atAllPut: $*. data := nil.	hash := self hashUser: user password: pass realm: realm.	pass atAllPut: $*. pass := nil.	^(self passwordHashAt: user, ':', realm) = hash! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2010 20:10'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2010 20:10' prior: 34996997!builtinHttpMethods	"Returns the list of HTTP methods that the server handles built-in,	i.e., without passing them to the registered service."	^#('HEAD' 'TRACE' 'OPTIONS')! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 7/29/2010 18:49'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 7/29/2010 18:49' prior: 34996997!certName	"The cert name to use for a secure (SSL/TLS) web server."	^certName! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 7/29/2010 18:49'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 7/29/2010 18:49' prior: 34996997!certName: aString	"The cert name to use for a secure (SSL/TLS) web server."	certName := aString.! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2010 20:22'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2010 20:22' prior: 34996997!connections	"The active connection processes. Can only be examined after aquiring	the WebServer's mutex."	^connections! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 12:10'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 12:10' prior: 34996997!critical: aBlock	"Evaluate aBlock protected byt the server's mutex.	Necessary if code needs to manipulate internal server state."	^mutex critical: aBlock! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2010 20:10'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2010 20:10' prior: 34996997!defaultHttpMethods	"Answer the list of HTTP methods that should be be supported by default.	The methods must be implemented by the request handler."	^#('GET' 'POST')! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 11/1/2010 21:07'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 11/1/2010 21:07' prior: 34996997!destroy	"Destroys the receiver"	self stopListener.	self destroyConnections.	listenerSocket ifNotNil:[listenerSocket destroy].	"De-register the WebServer"	(self class forUrl: self siteUrl ifAbsent:[self]) == self 		ifTrue:[self class removeUrl: siteUrl]! !WebServer methodsFor: 'as yet unclassified' stamp: 'ul 10/16/2014 13:16'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ul 10/16/2014 13:16' prior: 34996997!destroyConnections	"Destroy all current connections."	| copy |	copy := mutex critical: [ connections copy ].	" #terminate will trigger the #ensure: block in #asyncHandleConnectionFrom:, which will block if we don't release the mutex "	copy do: [ :p | p terminate ].	" make sure all of them were really removed "	mutex critical: [ connections removeAll ]! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 3/30/2010 20:35'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 3/30/2010 20:35' prior: 34996997!digestAuth: request realm: realm header: authHeader	"Authenticates an incoming request using Digest auth."	| user nonce uri response ha1 ha2 md5 qop nc cnonce 	  nonceData nonceCounter nonceTimeout params |	params := WebUtils parseAuthParams: authHeader.	"Flush the nonce cache randomly about every 100 auth attempts"	100 atRandom = 42 ifTrue:[self flushNonceCache].	user := params at: 'username' ifAbsent:[''].	nonce := params at: 'nonce' ifAbsent:[''].	uri := params at: 'uri' ifAbsent:[request url].	response := params at: 'response' ifAbsent:[''].		qop := params at: 'qop' ifAbsent:[''].	qop = 'auth' ifFalse:[^false]. "we require qop=auth"	nc := params at: 'nc' ifAbsent:[''].	cnonce := params at: 'cnonce' ifAbsent:[''].		"Verify that this is a nonce that we have handed out, that it isn't expired	and that the nc counter has increased from the last use."	mutex critical:[		nonceData := nonceCache at: nonce ifAbsent:[^false].	].	nonceCounter := nonceData first.		"last used nc"	nonceTimeout := nonceData second.	"timeout for nonce"	nc <= nonceCounter ifTrue:[^false]. 	"nc must increase"	Time totalSeconds > nonceTimeout ifTrue:[^false]. "nonce expired"	nonceData at: 1 put: nc.	ha1 := self passwordHashAt: user, ':', realm.	ha2 := WebUtils md5Digest: request method, ':', uri.	md5 := WebUtils md5Digest: ha1, ':', nonce, ':', nc, ':', cnonce, ':', qop, ':', ha2.	^md5 = response! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 22:34'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 22:34' prior: 34996997!dispatchRequest: request	"Look up the handler for a given request and dispatch to it"	^self dispatchRequest: request url: request url! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 7/28/2010 20:11'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 7/28/2010 20:11' prior: 34996997!dispatchRequest: request url: dispatchUrl	"Look up the handler for a given url and dispatch to it"	| entryUrl action |	"Handle TRACE requests right away"	request method = 'TRACE' ifTrue:[		^request send200Response: request asString contentType: 'message/http'.	].	"Look up the entry point for the request"	action := nil.	entryUrl := dispatchUrl asLowercase.	(entryUrl beginsWith: '/') ifFalse:[entryUrl := '/', entryUrl].	mutex critical:[		[entryUrl notEmpty and:[action == nil]] whileTrue: [			action := entryPoints at: entryUrl ifAbsent:[nil].			entryUrl := entryUrl copyUpToLast: $/.		].		action ifNil:[action := entryPoints at: '/' ifAbsent:[nil]].	].	"Handle OPTIONS requests"	request method = 'OPTIONS' ifTrue:[		"HEAD, TRACE, and OPTIONS are always supported"		request sendOptionsResponse: self builtinHttpMethods,			(action ifNil:[self defaultHttpMethods] ifNotNil:[action first])	].	"Handle 404 not found"	action ifNil:[^request send404Response].	"Handle 405 method not allowed"	(request method = 'HEAD' "builtin" 		or:[(action at: 1) includes: request method]) ifFalse:[			^request send405Response: self builtinHttpMethods, action first.		].	^[self invokeAction: (action at: 2) request: request] 		on: Error do:[:ex|			errorHandler 				ifNil:[self handleError: ex request: request]				ifNotNil:[errorHandler value: ex value: request]		].! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 7/28/2010 20:24'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 7/28/2010 20:24' prior: 34996997!errorHandler	"The user-supplied error handler. If present the handler takes two arguments:		* The error being caught by WebServer		* The request the error occurred in.	The user-supplied error handler can do whatever it wants, including calling	WebServer's #handleError:request: method which is the default."	^errorHandler! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 7/28/2010 20:24'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 7/28/2010 20:24' prior: 34996997!errorHandler: aBlock	"The user-supplied error handler. If present the handler takes two arguments:		* The error being caught by WebServer		* The request the error occurred in.	The user-supplied error handler can do whatever it wants, including calling	WebServer's #handleError:request: method which is the default."	errorHandler := aBlock.! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 10:35'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 10:35' prior: 34996997!errorReportFor: anError	"Provide a report for an error that's been caught during processing"	^[		String streamContents:[:s| 			self errorReportFor: anError 				stack: ([anError signalerContext stackOfSize: 2000] 							on: Error do:[:ex| ex return: #()])				on: s		].	] on: Error do: [:ex| ex pass. 'error reporting failed'].! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 10:35'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 10:35' prior: 34996997!errorReportFor: anError stack: preStack on: strm	"Provide a report for an error that's been caught during processing"	self errorStackFor: anError stack: preStack on: strm.	strm cr; nextPutAll: '-----------------------------------------------------------------'; cr; cr.	self systemInfoOn: strm.! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 10:35'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 10:35' prior: 34996997!errorStackFor: anError stack: preStack on: strm	"Provide a report for an error that's been caught during processing"	| cnt |	cnt := 0.	(preStack copyFrom: 1 to: (5 min: preStack size)) do:[:ctx|		ctx printDetails: strm.	"variable values"		strm cr.	].	strm cr; nextPutAll: '--- The full stack ---'; cr.	cnt := 0.	preStack do:[:ctx|		cnt := cnt + 1.		cnt = 5 ifTrue: [			strm nextPutAll: ' - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -'; cr].		strm print: ctx; cr.  "just class>>selector"	].! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 09:26'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 09:26' prior: 34996997!flushNonceCache	"Flushes expired nonces from the cache"	| deadline |	deadline := Time totalSeconds.	mutex critical:[		nonceCache := nonceCache reject:[:nonceData| deadline > nonceData second]	].! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 7/29/2010 18:46'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 7/29/2010 18:46' prior: 34996997!handleConnectionFrom: aSocket	"Synchronously handle an incoming socket connection."	| stream request |	"Give the process a pretty name"	Processor activeProcess name: (String streamContents:[:s|		aSocket remoteAddress do:[:b| s print: b] separatedBy:[s nextPut: $.].		s nextPut: $:; print: aSocket remotePort.		s nextPutAll: ' - ', self class name, ' request handler'.	]).	"Read the request from the socket, and dispatch it.	Since we've been forked already it's okay to block."	[		certName ifNil:["Regular request"			stream := SocketStream on: aSocket.		] ifNotNil:["SSL/TLS"			| ssl |			ssl := Smalltalk at: #SqueakSSL ifAbsent:[self error: 'SqueakSSL not installed'].			stream := ssl secureSocketStream on: aSocket.			[stream sslAccept: certName] on: Error do:[^stream destroy].		].		[aSocket isConnected] whileTrue:[			"Read the next request from the connection. If the connection is closed,			or if a network error occurs, or the read times out, just close the connection			without further ado (rather than logging an error). Any other error resulting			from parsing the input is treated as a 400 bad request."			stream peek ifNil:[^aSocket destroy].			request := self newRequest.			[request readFrom: stream] on: Error do:[:ex| 				(ex isKindOf: NetworkError) ifFalse:[					[request send400Response] on: Error do:[:ignore].				].				^aSocket destroy].			self dispatchRequest: request.		].	] on: Error do:[:ex|		(ex isKindOf: NetworkError) ifFalse:[			self log: 'Error in request handling: ', ex description.			self log: (self errorReportFor: ex).		].	].! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 7/28/2010 20:35'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 7/28/2010 20:35' prior: 34996997!handleError: ex request: aRequest	"The default error handling during processing. Sends a 500 response."	| errLabel errReport |	errLabel := [ex description] on: Error do:[:ex2| 		ex2 return: ex class name	].	errReport := [self errorReportFor: ex] on: Error do:[:ex2|		ex2 return: '<error report failed>'.	].	[self log: errLabel] on: Error do:[:ex2| ex return].	[self log: String cr, errReport] on: Error do:[:ex2| ex return].	aRequest send500Response: errReport. ! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 3/30/2010 20:36'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 3/30/2010 20:36' prior: 34996997!hashUser: user password: pass realm: realm	"Creates a hash for the given username password pair.	This method is the ha1 part of digest auth and can be used for both digest	as well as basic auth."	^WebUtils md5Digest: user, ':', realm, ':', pass! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2010 20:21'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2010 20:21' prior: 85206369!initialize	"Initialize the receiver"	mutex := Mutex new.	entryPoints := Dictionary new.	connections := IdentitySet new.	vault := Dictionary new.	nonceCache := Dictionary new.	sessions := Dictionary new.	self logAction:[:aString| Transcript cr; show: aString].! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 14:30'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 14:30' prior: 34996997!invokeAction: action request: request	"Invokes the given action. Subclasses can override this method to serialize	actions if necessary. At this point, the request header has been read from	the network, but not its content."	^action valueWithArguments: {request}! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 3/30/2010 22:09'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 3/30/2010 22:09' prior: 34996997!isRunning	"Is the server still running?"	^self isStopped not! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 3/30/2010 22:09'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 3/30/2010 22:09' prior: 34996997!isStopped	"Is the server still running?"	^listenerProcess == nil or:[listenerProcess isTerminated]! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 10:27'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 10:27' prior: 34996997!listenOn: aPort	"Starts the server listening on the given port"	^self listenOn: aPort interface: nil! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 10:28'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 10:28' prior: 34996997!listenOn: aPort interface: anInterface	"Starts the server listening on the given port / network interface"	^self listenOn: aPort interface: anInterface backlogSize: 8! !WebServer methodsFor: 'as yet unclassified' stamp: 'SvenVanCaekenberghe 6/14/2010 15:48'!!WebServer methodsFor: 'as yet unclassified' stamp: 'SvenVanCaekenberghe 6/14/2010 15:48' prior: 34996997!listenOn: aPort interface: anInterface backlogSize: backlog	"Starts the server listening on the given port / network interface"		| ipString |	interface := anInterface.	port := aPort.	ipString := interface ifNil:['*'] ifNotNil:[		String streamContents:[:s| interface do:[:b| s print: b] separatedBy:[s nextPut:$.]]].	self log: 'listener starting (interface: ', ipString, ' port: ', port asString, ')'.	listenerSocket := Socket newTCP.	interface 		ifNil:[listenerSocket listenOn: port backlogSize: backlog]		ifNotNil:[listenerSocket listenOn: port backlogSize: backlog interface: interface].	listenerSocket isWaitingForConnection ifFalse:[		self error: 'Failed to listen(interface: ', interface printString, ' port: ', aPort printString,' )'.	].	self startListener.! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/22/2010 03:01'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/22/2010 03:01' prior: 34996997!listenerInterface	"Returns the listener interface for the server"	^interface! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/22/2010 03:01'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/22/2010 03:01' prior: 34996997!listenerPort	"Returns the listener port for the server"	^port! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/22/2010 03:00'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/22/2010 03:00' prior: 34996997!listenerProcess	"Returns the socket listener process for the server."	^listenerProcess! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 10:28'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 10:28' prior: 34996997!listenerProcessPriority	"The priority at which the listener process should run"	^Processor lowIOPriority! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/22/2010 03:00'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/22/2010 03:00' prior: 34996997!listenerSocket	"Returns the listener socket for the server."	^listenerSocket! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/22/2010 05:35'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/22/2010 05:35' prior: 34996997!log: aString	"Log the given information."	logAction ifNotNil:[logAction valueWithArguments: {aString}].! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/22/2010 05:35'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/22/2010 05:35' prior: 34996997!logAction	"The current log action (a block or message)"	^logAction! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/22/2010 05:36'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/22/2010 05:36' prior: 34996997!logAction: aBlockOrMessage	"The current log action (a block or message).	Example:		WebServer new logAction: [:aString| Transcript show: aString].		WebServer new logAction: (MessageSend receiver: Transcript selector: #show).	"	logAction := aBlockOrMessage! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 7/28/2010 20:02'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 7/28/2010 20:02' prior: 34996997!logRequest: request response: response	"Log a request after it has been successfully processed"	accessLog ifNil:[^self].	"Do not use the standard exception handler for errors logging; 	it would possibly send a 500 response. Really this should be handled	by a different process with its own error handler."	[WebUtils logRequest: request response: response on: accessLog]		on: Error do:[:ex| self log: 'Error in logging: ', ex description].! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 09:18'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 09:18' prior: 34996997!newNonce	"Create a new nonce to be used for a client authentication session"	| nonce |	nonce := UUID new hex.	mutex critical:[		nonceCache at: nonce put: {''. Time totalSeconds + self nonceDeadline}.	].	^nonce! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 7/28/2010 20:27'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 7/28/2010 20:27' prior: 34996997!newRequest	"Answer a new request.	Subclasses should override this method to use a different request class."	^(WebRequest new)		server: self;		yourself! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 09:20'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 09:20' prior: 34996997!nonceDeadline	"Answer the number of seconds a nonce is considered valid for digest auth	by the server. After this period, the client will have to reauthenticate.	The default is 30 minutes."	^30*60 ! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 12:54'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 12:54' prior: 34996997!passwordAt: username realm: realm put: password	"Store the password hash for the key."	| hash |	hash := self hashUser: username password: password realm: realm.	self passwordHashAt: (username,':',realm) put: hash! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 12:51'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 12:51' prior: 34996997!passwordHashAt: key	"Answer the password hash for the given key"	^vault at: key ifAbsent:['']! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 12:01'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 12:01' prior: 34996997!passwordHashAt: key put: hash	"Store the password hash for the key."	^vault at: key put: hash! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/22/2010 02:52'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/22/2010 02:52' prior: 34996997!removeService: entryPoint 	"Remove a service from the HTTP service provider.  See #addService:action:"	mutex critical:[		entryPoints removeKey: entryPoint asLowercase ifAbsent: [].	].! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 5/4/2010 09:22'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 5/4/2010 09:22' prior: 34996997!runListener	"Runs the server's listener loop. 	Accepts incoming connections and handles them asynchronously"	| connectionSocket |	[[[listenerSocket notNil and:[listenerSocket isValid]] whileTrue:[		"Waiting for five seconds means that WebServer will be		back up after roughly five seconds when the system restarts."		connectionSocket := listenerSocket waitForAcceptFor: 5.		"Fork this off since or else errors in acceptClient: kill the listener"		connectionSocket ifNotNil:[self asyncHandleConnectionFrom: connectionSocket].	]] ensure:[		"Logging here is only for the purpose of catching sockets going randomly bad"		self log: 'listener terminating, socket: ', (listenerSocket ifNotNil:[:s| s statusString]).		"Try to restart the listener"		(listenerSocket notNil and:[listenerSocket isValid not]) ifTrue:[			listenerSocket destroy.			listenerProcess := nil.			"Wait a little before retrying"			(Delay forSeconds: 2) wait.			^self listenOn: port interface: interface		].	]] on: Error do:[:ex| self log: ex].! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 6/14/2010 20:53'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 6/14/2010 20:53' prior: 34996997!serverDate	"Returns the date string to be used in responses"	^self class serverDate! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 6/14/2010 20:54'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 6/14/2010 20:54' prior: 34996997!serverString	"Returns the server string to be used in responses.	The response is cached for efficiency."	^serverString ifNil:[serverString := self class serverString].! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 6/14/2010 20:57'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 6/14/2010 20:57' prior: 34996997!serverString: aString	"Set the server string to be used in responses"	^serverString := aString! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 12:09'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 12:09' prior: 34996997!sessionAt: key	"Answer the session associated with the given key"	^mutex critical:[sessions at: key ifAbsent:[nil]].! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 12:10'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 12:10' prior: 34996997!sessionAt: key ifAbsentPut: session	"Answer the session associated with the given key"	^mutex critical:[sessions at: key ifAbsentPut:[session]].! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2010 23:34'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2010 23:34' prior: 34996997!sessionAt: key put: session	"Store the session associated with the given key"	^mutex critical:[sessions at: key put: session].! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 12:11'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 12:11' prior: 34996997!sessions	"The sessions associated with the WebServer. These are not used by the server	directly but rather provided so that client code has a convenient place to store	session data."		^sessions! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 12:11'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 12:11' prior: 34996997!sessions: aDictionary	"The sessions associated with the WebServer. These are not used by the server	directly but rather provided so that client code has a convenient place to store	session data."		sessions := aDictionary! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 11/1/2010 21:01'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 11/1/2010 21:01' prior: 34996997!siteUrl	"The site URL for WebServer, i.e., http://www.mysite.com or http://www.mysite.com/server (when used in a proxied environment) or https://www.mysite.com (when using SSL). Used to allow a client to derive the 'correct' full URL for a running server instance."	^siteUrl! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 11/1/2010 21:13'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 11/1/2010 21:13' prior: 34996997!siteUrl: aString	"The site URL for WebServer, i.e., http://www.mysite.com or http://www.mysite.com/server (when used in a proxied environment) or https://www.mysite.com (when using SSL). Used to allow a client to derive the 'correct' full URL for a running server instance."	siteUrl := aString! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 10:29'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 10:29' prior: 34996997!startListener	"Starts the server's listener process"	self stopListener.	listenerProcess := [self runListener] newProcess.	listenerProcess priority: self listenerProcessPriority.	listenerProcess name: self class name, '''s listener process'.	listenerProcess resume.! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 10:29'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 10:29' prior: 34996997!stopListener	"Stops the server's listener process"	listenerProcess ifNotNil:[listenerProcess terminate].	listenerProcess := nil.! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 11/17/2011 10:16'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 11/17/2011 10:16' prior: 34996997!systemInfoOn: strm	"Provides system information for a server error report"	strm nextPutAll: 'VM: ';		nextPutAll:  WebUtils platformName;		nextPutAll: ' - ';		nextPutAll: WebUtils vmVersion;		cr.	strm nextPutAll: 'Image: ';		nextPutAll:  SystemVersion current version asString;		nextPutAll: ' [';		nextPutAll: SmalltalkImage current lastUpdateString asString;		nextPutAll: ']';		cr.	strm cr.	SecurityManager default printStateOn: strm.	"Additional info available from the windows VM"	WebUtils platformName = 'Win32' ifTrue:[		10001 to: 10003 do:[:i| | info |			info := (SmalltalkImage current getSystemAttribute: i) ifNil:[''].			info := info copyReplaceAll: String lf with: String cr.			info isEmpty ifFalse:[strm cr; nextPutAll: info]]].! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 12:03'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 12:03' prior: 34996997!vault	"The vault used for storing password hashes."	^vault! !WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/22/2010 02:51'!!WebServer methodsFor: 'as yet unclassified' stamp: 'ar 2/22/2010 02:51' prior: 34996997!vault: anObject	"The vault used for storing password hashes.	Clients can provide their own storage mechanism. 	Subclasses can also override the lookup and authentication mechanism."	vault := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WebServer class	instanceVariableNames: ''!WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 5/4/2010 20:01'!!WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 5/4/2010 20:01' prior: 34996997!benchmark	"Runs a WebClient/WebServer streaming benchmark to measure throughput"	"		WebServer benchmark		MessageTally spyOn:[WebServer benchmark]	"	| amount time resp port |	port := 8888.	amount := 128 * 1024 * 1024.	WebServer reset default listenOn: port.	WebServer default addService: '/streaming' action:[:req|		req stream200Response: NullStream new size: amount.	].	time := [		resp := WebClient httpGet: 'http://localhost:', port, '/streaming'.		resp isSuccess ifFalse:[self error: resp status].		resp streamTo: NullStream new size: resp contentLength progress: nil.		resp close.	] timeToRun.	WebServer reset.	^(amount  * 1000 // time) asStringWithCommas, ' bytes/sec'! !WebServer class methodsFor: 'as yet unclassified' stamp: 'SvenVanCaekenberghe 6/14/2010 20:32'!!WebServer class methodsFor: 'as yet unclassified' stamp: 'SvenVanCaekenberghe 6/14/2010 20:32' prior: 34996997!browseDir: directory request: request	"Responds with a directory listing back to the original request"	| entries listing url |	url := request url.	(url endsWith: '/') ifTrue:[url := url allButLast].	entries := directory entries sort:[:e1 :e2|		e1 isDirectory = e2 isDirectory 			ifTrue:[e1 name <= e2 name]			ifFalse:[e2 isDirectory]].	listing := String streamContents:[:s|		s nextPutAll:'<html><head><title>Index of ', request url,'</title></head><body>'.		s nextPutAll:'<h1>Index of ', request url,'</h1>'.		s nextPutAll:'<pre>      Name                      Last modified      Size  Description<hr>'.		s nextPutAll: '[up]  <a href="', (url copyUpToLast: $/),'">parent</a>'; crlf.		entries do:[:e|			s nextPutAll:(e isDirectory ifTrue:['[dir] '] ifFalse:['      ']).			s nextPutAll: '<a href="', url, '/', e name, '">'.			s nextPutAll: (e name truncateTo: 30).			s nextPutAll: '</a>'.			e name size < 30 ifTrue:[s nextPutAll: (String new: 30 - e name size withAll: $ )].			s nextPutAll: (e modificationDateAndTime asString padded: #right to: 20 with: $ ).			s nextPutAll: (e fileSize asString padded: #right to: 20 with: $ ).			s crlf.		]. 	].	request 		send200Response: (listing convertToWithConverter: UTF8TextConverter new) 		contentType: 'text/html; charset=utf-8'.! !WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 2/25/2010 16:33'!!WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 2/25/2010 16:33' prior: 34996997!browseFile: file request: request	"Responds with a file back to the original request"	| fileSize mimeTypes resp |	file binary.	fileSize := file size.	mimeTypes := file mimeTypes ifNil:[#('application/octet-stream')].	resp := request newResponse protocol: 'HTTP/1.1' code: 200.	resp headerAt: 'Content-Type' put: mimeTypes first.	request sendResponse: resp contentStream: file size: fileSize.! !WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 8/26/2010 07:49'!!WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 8/26/2010 07:49' prior: 34996997!browseRequest: request	"Handle an HTTP request for browsing some resource"	| path fd entry file |	"Extract the file path from the request"	path := request url findTokens: '/'.	path ifEmpty:[^self browseDir: FileDirectory default request: request.].	"Find the directory entry for the resource"	fd := path allButLast inject: FileDirectory default into:[:dir :part| dir directoryNamed: part].	entry := fd entryAt: path last ifAbsent:[^request send404Response].	"Reply with the proper resource"	entry isDirectory ifTrue:[		"Send file listing. We handle this synchronously for simplicity."		self browseDir: (fd directoryNamed: entry name) request: request.	] ifFalse:[		"Send file content. Since files can be large, we fork this off.		However, since we forked it, we need to handle two different		possible conditions:			- closing the file in case of error			- handling errors when sending it		This makes the code below a bit ugly"		[[			file := fd readOnlyFileNamed: entry name.			[self browseFile: file request: request.] 				ensure:[file close] 	"close file even in case of error"		] on: Error do:[]				"ignore errors altogether"		] fork. 						"fork it"	].! !WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 09:29'!!WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 09:29' prior: 34996997!default	"A default WebServer instance. Mostly for the examples."	^Default ifNil:[Default := self new].! !WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 09:30'!!WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 09:30' prior: 34996997!exampleAuth		"WebServer exampleAuth"	"Simple example requiring basic auth"	| server port realm |	port := 9999.	server := WebServer reset default.		"The realm to use for the server"	realm := 'Example Realm'.	"Add a sample user (note: password is hashed, not stored verbatim)"	server passwordAt: 'squeak' realm: realm put: 'squeak'.	server listenOn: port.	server addService: '/' action:[:req| 		server 			authenticate: req 			realm: realm			methods: #(digest basic) 			do:[self browseRequest: req]].! !WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 14:54'!!WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 2/20/2010 14:54' prior: 34996997!exampleBrowse	"WebServer exampleBrowse"	"This example implements a simple http server allowing to view 	and download files (like browsing ftp sites etc)."	| server port |	port := 9999.	server := WebServer reset default.	server listenOn: port.	server addService: '/' action:[:req| self browseRequest: req].! !WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 2/22/2010 05:41'!!WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 2/22/2010 05:41' prior: 34996997!exampleDoIt		"WebServer exampleDoIt"	"This example executes doIts from a POST request.	It's the simplest possible RPC interface to Squeak."	| server port |	port := 9999.	server := WebServer reset default.	server listenOn: port.	server addService: '/' action:[:req| 		| data result |		req isPostRequest ifTrue:[			"We fetch all of the data instead of streaming it"			data := req content.			"Compute the result"			result := [Compiler evaluate: data] on: Error do:[:ex| ex return: ex asString].			req send200Response: result asString 		] ifFalse:[req send404Response].	].! !WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 7/29/2010 18:49'!!WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 7/29/2010 18:49' prior: 34996997!exampleSSL: certName	"This example implements a simple https server allowing to view 	and download files (like browsing ftp sites etc):		WebServer exampleSSL: 'Internet Widgits Pty'.		WebServer exampleSSL: '/home/andreas/certs/testcert.pem'.	"	| server port |	port := 8443.	server := WebServer reset default.	server accessLog: Transcript.	server certName: certName.	server listenOn: port.	server addService: '/' action:[:req| self browseRequest: req].! !WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 2/25/2010 03:28'!!WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 2/25/2010 03:28' prior: 34996997!exampleSession		"WebServer exampleSession"	"This example uses a simple session cookie to avoid 	authentication for every request."	| server port realm |	realm := 'Example Realm'.	"authentication realm"	port := 9999.	server := WebServer reset default.	server listenOn: port.	"Add a sample user (note: password is hashed, not stored verbatim)"	server passwordAt: 'squeak' realm: realm put: 'squeak'.	"Register the login service (sets cookie when successful)"	server addService: '/login' action:[:req| 		server  authenticate: req  realm: realm methods: #(digest)  do:[ | id |			"Set the cookie and redirect back to /"			server sessionAt: (id := UUID new hex) put: ''.			req send302Response: (req fields at: 'url' ifAbsent:['/'])				do:[:resp| resp setCookie: 'session' value: id path: '/']]].	"Register the normal browse service"	server addService: '/' action:[:req|		"Check if we have a valid session cookie. If not redirect to login."		(server sessionAt: (req cookieAt: 'session')) notNil			ifTrue:[self browseRequest: req]			ifFalse:[req send302Response: '/login?url=', req url encodeForHTTP]].! !WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 11/1/2010 20:59'!!WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 11/1/2010 20:59' prior: 34996997!forUrl: urlString	"Answer the WebServer registered for a given URL string."	^self forUrl: urlString ifAbsent:[self newForUrl: urlString]! !WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 11/1/2010 20:59'!!WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 11/1/2010 20:59' prior: 34996997!forUrl: urlString ifAbsent: aBlock	"Answer the WebServer registered for a given URL string.	If no WebServer is registered, evaluate aBlock."	^self registry at: urlString ifAbsent: aBlock! !WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 11/1/2010 21:02'!!WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 11/1/2010 21:02' prior: 34996997!newForUrl: urlString	"Create a new WebServer instance registered for a given URL string."	| server |	"Out with the old ...."	server := self removeUrl: urlString.	server ifNotNil:[server destroy].	"... and in with the new."	server := self new.	server siteUrl: urlString.	self registry at: urlString put: server.	^server! !WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 11/1/2010 21:11'!!WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 11/1/2010 21:11' prior: 34996997!registry	"Answer the WebServer site registry"	^Registry ifNil:[Registry := Dictionary new]! !WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 11/1/2010 20:59'!!WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 11/1/2010 20:59' prior: 34996997!removeUrl: urlString	"Remove and answer the WebServer registered for a given URL string.	If no WebServer was registered, return nil."	^self removeUrl: urlString ifAbsent:[nil]! !WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 11/1/2010 20:59'!!WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 11/1/2010 20:59' prior: 34996997!removeUrl: urlString ifAbsent: aBlock	"Remove and answer the WebServer registered for a given URL string."	^self registry removeKey: urlString ifAbsent: aBlock! !WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 5/4/2010 21:27'!!WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 5/4/2010 21:27' prior: 34996997!requestBenchmark: persistent	"Runs a WebClient/WebServer benchmark to measure request handling speed.	Uses a persistent connection if requested."	"		WebServer requestBenchmark: false.		WebServer requestBenchmark: true.		MessageTally spyOn:[WebServer requestBenchmark: true]	"	| port |	port := 8888.	WebServer reset default listenOn: port.	WebServer default addService: '/benchmark' action:[:req|		req send200Response: ''.	].	^[WebClient 		requestBenchmark: 'http://localhost:', port, '/benchmark'		persistent: persistent] ensure:[WebServer reset].! !WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 09:29'!!WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2010 09:29' prior: 34996997!reset		"WebServer reset"	"Reset the default WebServer instance."	Default ifNotNil:[		Default destroy.		Default := nil.	].! !WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 8/22/2010 12:57'!!WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 8/22/2010 12:57' prior: 34996997!serverDate	"Returns the date string to be used in responses"	| date |	^String streamContents:[:s|		date := DateAndTime now asUTC.		s nextPutAll: date dayOfWeekAbbreviation, ', '.		date asDate printOn: s format: #(1 2 3 $  2 1 2 ).		s space; nextPutAll: (Time seconds: date asSeconds) print24.		s nextPutAll: ' GMT'.	].! !WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 2/12/2012 21:03'!!WebServer class methodsFor: 'as yet unclassified' stamp: 'ar 2/12/2012 21:03' prior: 34996997!serverString	"Returns the server string to be used in responses"	^'WebServer/1.5 (', 		WebUtils mcVersion, '; ', 		SystemVersion current version,'-', 		SystemVersion current highestUpdate printString, '; ', 		WebUtils platformName,')'.! !----End fileIn of /Users/craig/Downloads/caffeine/backups/28 (history server)/WebServer.st----!----SNAPSHOT----{6 November 2019 . 1:19:14 pm} pod.image priorSource: 2091811!Exit start!----SNAPSHOT----{6 November 2019 . 1:21:38 pm} pod.image priorSource: 2138447!----STARTUP----{6 November 2019 . 1:23:17 pm} as /Users/craig/Downloads/caffeine/backups/37 (headless)/pod.image!'From Squeak4.6 of 8 July 2015 [latest update: #15102] on 6 November 2019 at 1:22:26 pm'!Delay methodsFor: 'as yet unclassified' stamp: 'jm 9/11/97 14:49'!!Delay methodsFor: 'as yet unclassified' stamp: 'jm 9/11/97 14:49' prior: 34996997!adjustResumptionTimeOldBase: oldBaseTime newBase: newBaseTime	"Private!! Adjust the value of the system's millisecond clock at which this Delay will be awoken. Used to adjust resumption times after a snapshot or clock roll-over."	resumptionTime := newBaseTime + (resumptionTime - oldBaseTime).! !----End fileIn of /Users/craig/Downloads/caffeine/backups/28 (history server)/Delay-adjustResumptionTimeOldBasenewBase.st----!----SNAPSHOT----{6 November 2019 . 1:23:33 pm} pod.image priorSource: 2138447!Exit start!----SNAPSHOT----{6 November 2019 . 1:23:52 pm} pod.image priorSource: 2139408!----QUIT/NOSAVE----{6 November 2019 . 1:24:20 pm} pod.image priorSource: 2139501!----STARTUP----{6 November 2019 . 3:42:21 pm} as /Users/craig/Downloads/caffeine/backups/37 (headless)/pod.image!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 11/6/2019 15:44' prior: 35645417!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS ifHeadless: [				JS ifNode: [^JS postMessage: 'eep!!'].								^[					| tether portal connected |								(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.										portal := WorkerEntrance new.					tether := Tether through: portal.								JS						at: #onmessage						put: [:message |							portal incomingMessage: message data counterpart simplestRepresentation.							tether handleEvent].								tether waitForPeer.					connected := tether peer ping				]					forkAt: Processor timingPriority]].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----SNAPSHOT----{6 November 2019 . 3:44:08 pm} pod.image priorSource: 2139501!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 11/6/2019 15:45' prior: 35694313!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS ifHeadless: [				JS ifNode: [					JS debugger.					^JS postMessage: 'eep!!'].								^[					| tether portal connected |								(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.										portal := WorkerEntrance new.					tether := Tether through: portal.								JS						at: #onmessage						put: [:message |							portal incomingMessage: message data counterpart simplestRepresentation.							tether handleEvent].								tether waitForPeer.					connected := tether peer ping				]					forkAt: Processor timingPriority]].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----SNAPSHOT----{6 November 2019 . 3:45:32 pm} pod.image priorSource: 2140720!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 11/6/2019 15:47' prior: 35695333!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS ifHeadless: [				JS ifNode: [					JS console log: 'hey there'.					JS debugger.					^JS postMessage: 'eep!!'].								^[					| tether portal connected |								(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.										portal := WorkerEntrance new.					tether := Tether through: portal.								JS						at: #onmessage						put: [:message |							portal incomingMessage: message data counterpart simplestRepresentation.							tether handleEvent].								tether waitForPeer.					connected := tether peer ping				]					forkAt: Processor timingPriority]].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----SNAPSHOT----{6 November 2019 . 3:47:18 pm} pod.image priorSource: 2141764!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 11/6/2019 15:51' prior: 35696377!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS ifHeadless: [				JS ifNode: [					JS console log: 'hey there'.					JS debugger.					^JS parentPort postMessage: 'eep!!'].								^[					| tether portal connected |								(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.										portal := WorkerEntrance new.					tether := Tether through: portal.								JS						at: #onmessage						put: [:message |							portal incomingMessage: message data counterpart simplestRepresentation.							tether handleEvent].								tether waitForPeer.					connected := tether peer ping				]					forkAt: Processor timingPriority]].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----SNAPSHOT----{6 November 2019 . 3:52:06 pm} pod.image priorSource: 2142842!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 11/6/2019 16:01' prior: 35697455!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS ifHeadless: [				JS ifNode: [					JS console log: 'hey there'.					^JS parentPort postMessage: 'eep!!'].								^[					| tether portal connected |								(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.										portal := WorkerEntrance new.					tether := Tether through: portal.								JS						at: #onmessage						put: [:message |							portal incomingMessage: message data counterpart simplestRepresentation.							tether handleEvent].								tether waitForPeer.					connected := tether peer ping				]					forkAt: Processor timingPriority]].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----SNAPSHOT----{6 November 2019 . 4:01:12 pm} pod.image priorSource: 2143931!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 11/6/2019 16:18' prior: 35698544!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS ifHeadless: [				JS ifNode: [					JS console log: 'hey there'.					JS debugger.					^JS parentPort postMessage: 'eep!!'].								^[					| tether portal connected |								(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.										portal := WorkerEntrance new.					tether := Tether through: portal.								JS						at: #onmessage						put: [:message |							portal incomingMessage: message data counterpart simplestRepresentation.							tether handleEvent].								tether waitForPeer.					connected := tether peer ping				]					forkAt: Processor timingPriority]].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----SNAPSHOT----{6 November 2019 . 4:18:29 pm} pod.image priorSource: 2145002!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 11/6/2019 16:40' prior: 35699615!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS debugger.			JS ifHeadless: [				JS ifNode: [					JS console log: 'hey there'.					JS debugger.					^JS parentPort postMessage: 'eep!!'].								^[					| tether portal connected |								(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.										portal := WorkerEntrance new.					tether := Tether through: portal.								JS						at: #onmessage						put: [:message |							portal incomingMessage: message data counterpart simplestRepresentation.							tether handleEvent].								tether waitForPeer.					connected := tether peer ping				]					forkAt: Processor timingPriority]].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----SNAPSHOT----{6 November 2019 . 4:40:10 pm} pod.image priorSource: 2146091!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 11/6/2019 17:00' prior: 35700704!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS ifHeadless: [				JS ifNode: [					JS console log: 'hey there'.					^JS parentPort postMessage: 'eep!!'].								^[					| tether portal connected |								(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.										portal := WorkerEntrance new.					tether := Tether through: portal.								JS						at: #onmessage						put: [:message |							portal incomingMessage: message data counterpart simplestRepresentation.							tether handleEvent].								tether waitForPeer.					connected := tether peer ping				]					forkAt: Processor timingPriority]].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----SNAPSHOT----{6 November 2019 . 5:00:59 pm} pod.image priorSource: 2147196!----QUIT----{6 November 2019 . 6:48:29 pm} pod.image priorSource: 2148267!----STARTUP----{6 November 2019 . 6:59:50 pm} as /Users/craig/Downloads/caffeine/backups/37 (headless)/pod.image!!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 11/6/2019 20:48'!isNode	^JS display isNode = true! !!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 11/6/2019 20:52' prior: 35701809!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS ifHeadless: [				^[					| tether portal connected handler |								(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.										portal := WorkerEntrance new.					tether := Tether through: portal.										handler := (						[:message |							portal incomingMessage: message data counterpart simplestRepresentation.							tether handleEvent]).								(JS isNode)						ifTrue: [							(JS parentPort)								on: 'message'								with: handler]						ifFalse: [							JS								at: #onmessage								put: handler].								tether waitForPeer.					connected := tether peer ping				]					forkAt: Processor timingPriority]].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----SNAPSHOT----{6 November 2019 . 8:52:14 pm} pod.image priorSource: 2148347!----SNAPSHOT----{6 November 2019 . 9:02:17 pm} pod.image priorSource: 2149720!Platforms!!JSObjectProxy methodsFor: 'as yet unclassified' stamp: 'crl 11/6/2019 21:14' prior: 35703051!isNode	^((JS at: #display) at: #isNode) = true! !----SNAPSHOT----{6 November 2019 . 9:14:21 pm} pod.image priorSource: 2149800!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 11/6/2019 21:27' prior: 35703188!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS ifHeadless: [				^[					| tether portal connected |								(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.										portal := WorkerEntrance new.					tether := Tether through: portal.										(JS isNode)						ifTrue: [							(JS parentPort)								on: 'message'								with: [:message |									portal incomingMessage: message counterpart simplestRepresentation.									tether handleEvent]]						ifFalse: [							JS								at: #onmessage								put: [:message |									portal incomingMessage: message data counterpart simplestRepresentation.									tether handleEvent]].								tether waitForPeer.					connected := tether peer ping				]					forkAt: Processor timingPriority]].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !----SNAPSHOT----{6 November 2019 . 9:27:56 pm} pod.image priorSource: 2150038!!WorkerEntrance methodsFor: 'as yet unclassified' stamp: 'crl 11/6/2019 21:33' prior: 35620030!send	"Send the contents of the current outgoing message."	JS parentPort postMessage: (JS JSON stringify: {#payload -> self outgoingPayload})! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 11/6/2019 21:34' prior: 35644104!handleEvent	(peer recyclingHash = 0)		ifTrue: [			peer := self next..			portal isExit ifFalse: [self push: self].			peerSet signal]		ifFalse: [			| nextWord handler |						nextWord := portal nextWord.			JS ifConnected: [				(nextWord = 1337) ifTrue: [					"This is a message from a JavaScript system."										| exposureHash parameters |										exposureHash := portal nextWord.					parameters := JS JSON parse: (portal next: portal nextWord) asByteArray asString.										^JS parentPort postMessage: (						JS JSON stringify: {							#result -> (								self									perform: parameters selector asString asSymbol									withArguments: parameters arguments asArray).							#exposureHash -> exposureHash})]].						handler := Classes at: nextWord ifAbsent: [3 halt].			handler				ifNil: [3 halt]				ifNotNil: [handler handleEventFrom: self]]! !!WorkerExit methodsFor: 'as yet unclassified' stamp: 'crl 11/6/2019 21:35' prior: 35308212!send	worker parentPort postMessage: self outgoingPayload! !!WorkerExit methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 15:50' prior: 35707066!send	worker postMessage: self outgoingPayload! !----SNAPSHOT----{6 November 2019 . 9:35:38 pm} pod.image priorSource: 2151251!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 11/8/2019 10:22'!performAsSharedTether: message	^[		self			perform: message selector			withArguments: message arguments	]		on: Error		do: [:exception | 'error']		! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 11/8/2019 10:23' prior: 35707421!performAsSharedTether: messageDetails	^[		self			perform: messageDetails first asSymbol			withArguments: (messageDetails copyFrom: 2)	]		on: Error		do: [:exception | 'error']		! !----SNAPSHOT----{8 November 2019 . 10:27:29 am} pod.image priorSource: 2152836!	#(1 2 3 4) copyFrom: 2!!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'crl 11/8/2019 10:29'!copyFrom: index	^self copyFrom: index to: self size! !	#(1 2 3 4) copyFrom: 2!----SNAPSHOT----{8 November 2019 . 10:30:08 am} pod.image priorSource: 2153421!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 11/8/2019 10:31' prior: 35707666!performAsSharedTether: messageDetails	^[		self			perform: messageDetails first asSymbol			withArguments: (messageDetails copyFrom: 2)	]		on: Error		do: [:exception |			JS debugger.			'error']		! !----SNAPSHOT----{8 November 2019 . 10:31:23 am} pod.image priorSource: 2153698!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 11/8/2019 10:34' prior: 35708300!performAsSharedTether: messageDetails	^[		| details |				details := messageDetails asArray collect: [:element | element counterpart].				self			perform: details first asSymbol			withArguments: (details copyFrom: 2)	]		on: Error		do: [:exception |			JS debugger.			'error']		! !----SNAPSHOT----{8 November 2019 . 10:35 am} pod.image priorSource: 2154074!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 11/8/2019 10:40' prior: 35708676!performAsSharedTether: messageDetails	^[		| details |				details := messageDetails asArray.				self			perform: details first asString asSymbol			withArguments: ((details copyFrom: 2) collect: [:element | element counterpart])	]		on: Error		do: [:exception |			JS debugger.			'error']		! !----SNAPSHOT----{8 November 2019 . 10:40:56 am} pod.image priorSource: 2154535!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 11/8/2019 10:34' prior: 35709134!performAsSharedTether: messageDetails	^[		| details |				details := messageDetails asArray collect: [:element | element counterpart].				self			perform: details first asSymbol			withArguments: (details copyFrom: 2)	]		on: Error		do: [:exception |			JS debugger.			'error']		! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 11/8/2019 13:27' prior: 35706095!handleEvent	(peer recyclingHash = 0)		ifTrue: [			peer := self next..			portal isExit ifFalse: [self push: self].			peerSet signal]		ifFalse: [			| nextWord handler |						nextWord := portal nextWord.			JS ifConnected: [				(nextWord = 1337) ifTrue: [					"This is a message from a JavaScript system."										| exposureHash parameters |										exposureHash := portal nextWord.					parameters := JS JSON parse: (portal next: portal nextWord) asByteArray asString.										^JS parentPort postMessage: (						JS JSON stringify: {							#result -> (								self									perform: parameters selector asString asSymbol									withArguments: (parameters arguments asArray collect: [:element | element counterpart])).							#exposureHash -> exposureHash})]].						handler := Classes at: nextWord ifAbsent: [3 halt].			handler				ifNil: [3 halt]				ifNotNil: [handler handleEventFrom: self]]! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 11/8/2019 13:27' prior: 35709606!performAsSharedTether: messageDetails	^[		self			perform: messageDetails first asSymbol			withArguments: (messageDetails copyFrom: 2)	]		on: Error		do: [:exception |			JS debugger.			'error']		! !----SNAPSHOT----{8 November 2019 . 1:27:31 pm} pod.image priorSource: 2155004!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 11/8/2019 13:37' prior: 35709986!handleEvent	(peer recyclingHash = 0)		ifTrue: [			peer := self next..			portal isExit ifFalse: [self push: self].			peerSet signal]		ifFalse: [			| nextWord handler |						nextWord := portal nextWord.			JS ifConnected: [				(nextWord = 1337) ifTrue: [					"This is a message from a JavaScript system."										| exposureHash parameters |										exposureHash := portal nextWord.					parameters := JS JSON parse: (portal next: portal nextWord) asByteArray asString.										^JS parentPort postMessage: (						JS JSON stringify: {							#result -> (								self									perform: parameters selector asString asSymbol									withArguments: (parameters arguments asArray collect: [:element | element simplestRepresentation])).							#exposureHash -> exposureHash})]].						handler := Classes at: nextWord ifAbsent: [3 halt].			handler				ifNil: [3 halt]				ifNotNil: [handler handleEventFrom: self]]! !----SNAPSHOT----{8 November 2019 . 1:38:14 pm} pod.image priorSource: 2156771!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 11/8/2019 13:47' prior: 35711372!handleEvent	(peer recyclingHash = 0)		ifTrue: [			peer := self next..			portal isExit ifFalse: [self push: self].			peerSet signal]		ifFalse: [			| nextWord handler |						nextWord := portal nextWord.			JS ifConnected: [				(nextWord = 1337) ifTrue: [					"This is a message from a JavaScript system."										| exposureHash parameters |										exposureHash := portal nextWord.					parameters := JS JSON parse: (portal next: portal nextWord) asByteArray asString.					JS debugger.					^JS parentPort postMessage: (						JS JSON stringify: {							#result -> (								self									perform: parameters selector asString asSymbol									withArguments: (parameters arguments asArray collect: [:element | element simplestRepresentation])).							#exposureHash -> exposureHash})]].						handler := Classes at: nextWord ifAbsent: [3 halt].			handler				ifNil: [3 halt]				ifNotNil: [handler handleEventFrom: self]]! !----SNAPSHOT----{8 November 2019 . 1:47:43 pm} pod.image priorSource: 2157873!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 11/8/2019 13:50' prior: 35712474!handleEvent	(peer recyclingHash = 0)		ifTrue: [			peer := self next..			portal isExit ifFalse: [self push: self].			peerSet signal]		ifFalse: [			| nextWord handler |						nextWord := portal nextWord.			JS ifConnected: [				(nextWord = 1337) ifTrue: [					"This is a message from a JavaScript system."										| exposureHash parameters arguments |										exposureHash := portal nextWord.					parameters := JS JSON parse: (portal next: portal nextWord) asByteArray asString.					arguments := parameters arguments asArray collect: [:element | element simplestRepresentation].					JS debugger.					^JS parentPort postMessage: (						JS JSON stringify: {							#result -> (								self									perform: parameters selector asString asSymbol									withArguments: (parameters arguments asArray collect: [:element | element simplestRepresentation])).							#exposureHash -> exposureHash})]].						handler := Classes at: nextWord ifAbsent: [3 halt].			handler				ifNil: [3 halt]				ifNotNil: [handler handleEventFrom: self]]! !----SNAPSHOT----{8 November 2019 . 1:51 pm} pod.image priorSource: 2158987!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 11/8/2019 14:01' prior: 35713588!handleEvent	(peer recyclingHash = 0)		ifTrue: [			peer := self next..			portal isExit ifFalse: [self push: self].			peerSet signal]		ifFalse: [			| nextWord handler |						nextWord := portal nextWord.			JS ifConnected: [				(nextWord = 1337) ifTrue: [					"This is a message from a JavaScript system."										| exposureHash parameters arguments |										exposureHash := portal nextWord.					parameters := JS JSON parse: (portal next: portal nextWord) asByteArray asString.					arguments := parameters arguments asArray collect: [:element | element counterpart simplestRepresentation].					JS debugger.					^JS parentPort postMessage: (						JS JSON stringify: {							#result -> (								self									perform: parameters selector asString asSymbol									withArguments: arguments).							#exposureHash -> exposureHash})]].						handler := Classes at: nextWord ifAbsent: [3 halt].			handler				ifNil: [3 halt]				ifNotNil: [handler handleEventFrom: self]]! !----SNAPSHOT----{8 November 2019 . 2:01:57 pm} pod.image priorSource: 2160212!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 11/8/2019 14:05' prior: 35710997!performAsSharedTether: messageDetails	JS debugger.	^[		self			perform: messageDetails first asSymbol			withArguments: (messageDetails copyFrom: 2)	]		on: Error		do: [:exception |			JS debugger.			'error']		! !----SNAPSHOT----{8 November 2019 . 2:05:21 pm} pod.image priorSource: 2161372!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 11/8/2019 14:33' prior: 35714810!handleEvent	(peer recyclingHash = 0)		ifTrue: [			peer := self next..			portal isExit ifFalse: [self push: self].			peerSet signal]		ifFalse: [			| nextWord handler |						nextWord := portal nextWord.			JS ifConnected: [				(nextWord = 1337) ifTrue: [					"This is a message from a JavaScript system."										| exposureHash parameters arguments |										exposureHash := portal nextWord.					parameters := JS JSON parse: (portal next: portal nextWord) asByteArray asString.					arguments := parameters arguments asArray collect: [:element | element counterpart simplestRepresentation].					self									perform: parameters selector asString asSymbol									withArguments: arguments.					JS debugger.					^JS parentPort postMessage: (						JS JSON stringify: {							#result -> (								self									perform: parameters selector asString asSymbol									withArguments: arguments).							#exposureHash -> exposureHash})]].						handler := Classes at: nextWord ifAbsent: [3 halt].			handler				ifNil: [3 halt]				ifNotNil: [handler handleEventFrom: self]]! !----SNAPSHOT----{8 November 2019 . 2:33:22 pm} pod.image priorSource: 2161761!161 + 75!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 11/8/2019 14:59'!performAsSharedTether: selector withArguments: arguments	^[		self			perform: selector			withArguments: arguments	]		on: Error		do: [:exception |			JS debugger.			'error']		! !Tether removeSelector: #performAsSharedTether:!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 11/8/2019 15:01' prior: 35716362!handleEvent	(peer recyclingHash = 0)		ifTrue: [			peer := self next..			portal isExit ifFalse: [self push: self].			peerSet signal]		ifFalse: [			| nextWord handler |						nextWord := portal nextWord.			JS ifConnected: [				(nextWord = 1337) ifTrue: [					"This is a message from a JavaScript system."										| exposureHash parameters |										exposureHash := portal nextWord.					parameters := JS JSON parse: (portal next: portal nextWord) asByteArray asString.					^JS parentPort postMessage: (						JS JSON stringify: {							#result -> (								self									perform: parameters selector asString asSymbol									withArguments: (parameters arguments asArray collect: [:element | element counterpart simplestRepresentation])).							#exposureHash -> exposureHash})]].						handler := Classes at: nextWord ifAbsent: [3 halt].			handler				ifNil: [3 halt]				ifNotNil: [handler handleEventFrom: self]]! !----SNAPSHOT----{8 November 2019 . 3:01:25 pm} pod.image priorSource: 2163025!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 11/8/2019 15:06' prior: 35717621!performAsSharedTether: selector withArguments: arguments	^[		self			perform: selector asSymbol			withArguments: arguments	]		on: Error		do: [:exception |			JS debugger.			'error']		! !----SNAPSHOT----{8 November 2019 . 3:06:58 pm} pod.image priorSource: 2164452!----SNAPSHOT----{8 November 2019 . 3:29:28 pm} pod.image priorSource: 2164815!!Object methodsFor: 'as yet unclassified' stamp: 'crl 11/8/2019 15:34' prior: 34996997!complexContents	^self! !!IndentingListItemMorph methodsFor: 'as yet unclassified' stamp: 'crl 11/8/2019 15:34' prior: 27289294!complexContents	^complexContents! !----SNAPSHOT----{8 November 2019 . 3:36:53 pm} pod.image priorSource: 2164895!----SNAPSHOT----{8 November 2019 . 4:06:18 pm} pod.image priorSource: 2165232!----SNAPSHOT----{9 November 2019 . 4:16:07 pm} pod.image priorSource: 2165312!----SNAPSHOT----{9 November 2019 . 5:04:02 pm} pod.image priorSource: 2165392!----QUIT----{17 November 2019 . 5:18:12 pm} pod.image priorSource: 2165472!----STARTUP----{19 November 2019 . 1:11:30 pm} as /Users/craig/Downloads/caffeine/backups/37 (headless)/pod.image!Object subclass: #Tether	instanceVariableNames: 'portal peer exposedObjects pendingIncomingExchanges pendingOutgoingExchanges module peerSet collaborationClients'	classVariableNames: 'TetherEntranceToLocalhost'	poolDictionaries: 'TetherConstants'	category: 'Tether'!Object subclass: #Tether	instanceVariableNames: 'portal peer exposedObjects pendingIncomingExchanges pendingOutgoingExchanges module peerSet collaborationClients'	classVariableNames: 'TetherEntranceToLocalhost'	poolDictionaries: 'TetherConstants'	category: 'Tether'!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 11/20/2019 12:44'!registerClientWithIDString: idString named: name	"Register uuid as the ID of a collaboration client. Acknowledge the registration."		| id |		id := UUID fromString: idString.		collaborationClients		at: id		put: (			(MemoryProfile new)				id: id;				addName: name;				yourself)! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 11/20/2019 12:44' prior: 34847434!initialize	exposedObjects := IdentityDictionary new.	pendingIncomingExchanges := IdentitySet new.	pendingOutgoingExchanges := Dictionary new.	peerSet := Semaphore new.	module := ModuleEdition new.	collaborationClients := Dictionary new! !Tether removeSelector: #rawk!'From Squeak4.6 of 8 July 2015 [latest update: #15102] on 20 November 2019 at 12:57:33 pm'!Object subclass: #MemoryProfile	instanceVariableNames: 'names id services memoryFilename processorFilename dialect historyMemoryProfile tether'	classVariableNames: 'Current KnownProfiles KnownServices'	poolDictionaries: 'TetherConstants'	category: 'Tether'!Object subclass: #MemoryProfile	instanceVariableNames: 'names id services memoryFilename processorFilename dialect historyMemoryProfile tether'	classVariableNames: 'Current KnownProfiles KnownServices'	poolDictionaries: 'TetherConstants'	category: 'Tether'!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 12/28/2013 14:59'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 12/28/2013 14:59' prior: 34996997!addName: aString	^(names includes: aString) ifFalse: [names add: aString]! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 17:03'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 17:03' prior: 34996997!allCallsOn: aLiteral	^self peer allCallsOn: aLiteral! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 17:03'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 17:03' prior: 34996997!allClassNames	^self peer allClassNames! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 17:04'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 17:04' prior: 34996997!allImplementorsOf: t1	^self peer allImplementorsOf: t1! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/3/2016 23:55'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/3/2016 23:55' prior: 34996997!bytesAvailable	^Smalltalk garbageCollect! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 17:04'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 17:04' prior: 34996997!classCorrespondingTo: localClass ifNone: aBlockClosure	^self peer classWithBaseID: localClass baseID ifNone: aBlockClosure! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 17:04'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 17:04' prior: 34996997!classNamed: className	^self peer classNamed: className! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 17:04'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 17:04' prior: 34996997!copyClassHierarchyFrom: protoclass	protoclass withAllSubclassesDo: [:class |		{class class. class} do: [:each |			| remoteClass |			remoteClass := each counterpartIn: self.			nil == remoteClass ifFalse: [				| module |				module := ModuleEdition new.				"Transcript cr; print: each; endEntry."				remoteClass					instVarAt: 3 put: each format;					instVarAt: 4 put: each instVarNames.				(each instVarAt: 5) == nil ifTrue: [					| theID |					theID := UUID new.					each instVarAt: 5 put: theID.					remoteClass instVarAt: 5 put: theID].				each remember.				each selectors do: [:selector | module addMethodID: (each compiledMethodAt: selector) id].				module synchronizeWith: self peer module]]]! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 11/24/2014 15:50'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 11/24/2014 15:50' prior: 34996997!createNewHistory	(EditHistory counterpartIn: self)		new;		rememberAllActiveClasses! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 10/19/2016 22:34'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 10/19/2016 22:34' prior: 34996997!dialect	^dialect! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2016 21:36'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2016 21:36' prior: 34996997!dialect: smalltalkDialect	dialect := smalltalkDialect! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 15:59'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 15:59' prior: 34996997!historyMemoryProfile	^historyMemoryProfile! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 15:04'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 15:04' prior: 34996997!historyMemoryProfile: profile	historyMemoryProfile := profile! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 1/1/2014 12:50'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 1/1/2014 12:50' prior: 34789873!id	^id! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2016 20:20'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2016 20:20' prior: 34996997!id: uuid	id := uuid! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2016 21:33'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2016 21:33' prior: 34996997!initialize	names := OrderedCollection new.	services := Set new.	id := UUID new! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 17:04'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 17:04' prior: 34996997!isConnected	^self peer recyclingHash ~~ 0! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/7/2016 11:59'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/7/2016 11:59' prior: 34996997!memoryFilename	^memoryFilename		ifNil: [dialect filenameForMemoryWithID: id]		ifNotNil: [dialect filenameForMemoryWithRelativePath: memoryFilename]! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2016 20:53'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2016 20:53' prior: 34996997!memoryFilename: filename	memoryFilename := filename! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 17:04'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 17:04' prior: 34996997!module	^self peer module! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 1/5/2015 03:41'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 1/5/2015 03:41' prior: 34996997!name	^names first! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 1/6/2015 01:47'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 1/6/2015 01:47' prior: 34996997!names	^names! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 17:07'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 17:07' prior: 34996997!names: anOrderedCollection id: aUUID services: aSet tether: aTether	names := anOrderedCollection.	self id: aUUID.	services := aSet.	self tether: aTether! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 12/31/2013 14:40'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 12/31/2013 14:40' prior: 34996997!namesInclude: memoryName	^names includes: memoryName! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 17:30'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 17:30' prior: 34996997!peer	^tether peer! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 17:06'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 17:06' prior: 34996997!peerAddress	^self peer peerAddress! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/4/2016 18:11'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/4/2016 18:11' prior: 34996997!port	^id asIPPort! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2016 21:41'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2016 21:41' prior: 34996997!printOn: aStream	aStream		nextPutAll: 'a ';		print: dialect class;		space;		nextPutAll: dialect version;		nextPutAll: ' memory named ''';		nextPutAll: names first;		nextPut: $'! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 10/25/2016 17:38'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 10/25/2016 17:38' prior: 34996997!processParameters: parameters	"Lots of possibilities here. It would be good to at least detect the method ID of some class-side method and execute the corresponding method. Various subsystems could arrange to participate in this processing, rather like the traditional startup/shutdown scheme."! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2016 20:53'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2016 20:53' prior: 34996997!processorFilename: filename	processorFilename := filename! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 23:54'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 23:54' prior: 34996997!pushEditHistory	self peer editHistory: EditHistory local! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2016 21:29'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2016 21:29' prior: 34996997!remember	self class rememberProfile: self! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 12/19/2013 14:01'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 12/19/2013 14:01' prior: 34996997!removeName: aString	^names remove: aString ifAbsent: []! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 14:37'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 14:37' prior: 34996997!resume	self resumeWithMemoryParameter: 'squeak:///'! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 19:49'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 19:49' prior: 34996997!resumeHistoryMemory	"historyMemoryProfile		resumeWithProcessorParameter: '-headless'		andMemoryParameter: (			(WebSocketLocator new)
				port: self port;				addSegment: 'history';				printString)"! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/7/2016 14:46'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/7/2016 14:46' prior: 34996997!resumeMemoryNamed: memoryPath withProcessorParameter: processorParameter andMemoryParameter: memoryParameter usingProcessorNamed: processorPath	<primitive: 'forkMemoryWithProcessorParameterAndMemoryParameterUsingProcessor' module: 'Flow'>	self primitiveFailed! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 14:18'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 14:18' prior: 34996997!resumeOnPlatform: aHostPlatform withProcessorParameter: processorParameter andMemoryParameter: memoryParameter	self		resumeMemoryNamed: (aHostPlatform pathFor: self memoryFilename)		withProcessorParameter: processorParameter		andMemoryParameter: memoryParameter		usingProcessorNamed: (			aHostPlatform pathFor: (				processorFilename					ifNil: [dialect processorFilename]					ifNotNil: [processorFilename]))! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 14:36'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 14:36' prior: 34996997!resumeWithMemoryParameter: parameter	self resumeWithProcessorParameter: '-headfull' andMemoryParameter: parameter! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 14:36'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 14:36' prior: 34996997!resumeWithProcessorParameter: parameter	self resumeWithProcessorParameter: parameter andMemoryParameter: 'squeak:///'! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/7/2016 14:55'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/7/2016 14:55' prior: 34996997!resumeWithProcessorParameter: processorParameter andMemoryParameter: memoryParameter	(HostPlatform current)		resumeMemory: self		withProcessorParameter: processorParameter		andMemoryParameter: memoryParameter! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 1/9/2014 09:51'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 1/9/2014 09:51' prior: 34996997!services	^services! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 17:06'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 17:06' prior: 34996997!stop	self peer quit! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 17:06'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 17:06' prior: 34996997!storeOnProxyStream: aStream for: aMessagingSession	aStream nextWordPut: MemoryProfileTag.	{		names.		id.		services.	}		do: [:variable | variable storeOnProxyStream: aStream for: aMessagingSession]! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 15:49'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/20/2016 15:49' prior: 34996997!storeOnTether: tether	tether nextWordPut: MemoryProfileTag.	{		names.		id.		services.	}		do: [:variable | variable storeOnTether: tether]! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 10/6/2016 17:28'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 10/6/2016 17:28' prior: 34996997!tether	^tether! !MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 17:07'!!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 17:07' prior: 34996997!tether: aTether	tether := aTether! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MemoryProfile class	instanceVariableNames: ''!MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 21:30'!!MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 21:30' prior: 34996997!current	^Current! !MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 15:30'!!MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 15:30' prior: 34996997!current: profile	Current := profile! !MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2016 21:38'!!MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/5/2016 21:38' prior: 34996997!forDialect: smalltalkDialect	^self new dialect: smalltalkDialect! !MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 17:05'!!MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 17:05' prior: 34996997!fromTether: tether	^(self new)		names: tether next asOrderedCollection		id: tether next		services: tether next		tether: tether;		memoryFilename: tether next;		processorFilename: tether next;		yourself! !MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 14:25'!!MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 14:25' prior: 34996997!greetings	<primitive: 'greetings' module: 'Flow'>	self primitiveFailed! !MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 19:49'!!MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 19:49' prior: 34996997!initialize	KnownProfiles := Dictionary new.	"(WebServer reset default)		listenOn: Current port;		addService: '/history'		action: (Exit actionWithServiceClass: TetherExit);		addService: '/tether'		action: (Exit actionWithServiceClass: TetherExit)."	Smalltalk		addToStartUpList: self;		addToShutDownList: self! !MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/7/2016 16:29'!!MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/7/2016 16:29' prior: 34996997!installEditionForClass: class inMemoryNamed: memoryName	(self peerInMemoryNamed: memoryName) installEditionForClassWithBaseID: class baseID! !MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/7/2016 16:29'!!MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/7/2016 16:29' prior: 34996997!installEditionsForMethodsOfProtoclass: protoclass inMemoryNamed: memoryName	(protoclass isMeta)		ifTrue: [self error: 'This message is meant for protoclasses.']		ifFalse: [			{				protoclass class.				protoclass			}				do: [:theClass |					theClass selectors do: [:selector |						self							installMethodAt: selector							inClass: theClass							inMemoryNamed: memoryName]]]! !MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 15:21'!!MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 15:21' prior: 34996997!installMethodAt: selector inClass: class inMemoryNamed: memoryName	| remoteClass |	remoteClass := class counterpartIn: (self named: memoryName).	remoteClass ifNotNil: [remoteClass installMethodEdition: (class compiledMethodAt: selector) id impromptuEdition]! !MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 15:21'!!MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 15:21' prior: 34996997!named: memoryName	KnownProfiles do: [:profile |		(profile namesInclude: memoryName) ifTrue: [^profile]].	^nil! !MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 12/19/2013 14:00'!!MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 12/19/2013 14:00' prior: 34789971!new	^super new initialize! !MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 15:22'!!MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 15:22' prior: 34996997!peerInMemoryNamed: memoryName	^(self named: memoryName) peer! !MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 15:22'!!MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 15:22' prior: 34996997!peerInMemoryWithID: aUUID	^(self withID: aUUID) peer! !MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 10/7/2016 01:15'!!MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 10/7/2016 01:15' prior: 34996997!ping	^Current peer ping! !MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 19:49'!!MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 19:49' prior: 34996997!provideHistoryService	"| identifier |							identifier := UniformResourceIdentifier fromString: 'ws://localhost:54067/history'.	Current tether: (		(			[TetherEntrance to: identifier printString]				on: ConnectionRefused				do: [:exception |					'The mainstream WebServer takes six seconds to come up after a system resumption. Replace it.'					(Delay forSeconds: 5) wait.					exception retry]		)			tether).	'Wait a bit for the tether's initial object exposure to happen.'	(Delay forSeconds: 1) wait.	Current pushEditHistory"! !MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/7/2016 16:31'!!MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/7/2016 16:31' prior: 34996997!rememberClassHierarchyFrom: protoclass	protoclass withAllSubclassesDo: [:class | self rememberProtoclass: class]! !MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/7/2016 15:20'!!MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/7/2016 15:20' prior: 34996997!rememberProfile: profile	(KnownProfiles includesKey: profile id)		ifTrue: [(KnownProfiles at: profile id) becomeForward: profile]		ifFalse: [			KnownProfiles				at: profile id				put: profile]! !MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/7/2016 16:31'!!MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/7/2016 16:31' prior: 34996997!rememberProtoclass: protoclass	protoclass baseID ifNil: [protoclass baseID: UUID new].	protoclass class baseID ifNil: [protoclass class baseID: UUID new].	protoclass class remember.	protoclass remember! !MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/7/2016 16:32'!!MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/7/2016 16:32' prior: 34996997!removeProfile: profile	KnownProfiles removeKey: profile id.	"Ensure that any proxies involved with previous use of this memory are gone, so as not to cause confusion during future use."	Smalltalk garbageCollect! !MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 10/25/2016 18:44'!!MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 10/25/2016 18:44' prior: 34996997!shutDown: quitting	(quitting and: [EditHistory local recyclingHash > 0 and: [EditHistory local tether isOpen]]) ifTrue: [EditHistory local tether peer quit]! !MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 19:49'!!MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 3/18/2019 19:49' prior: 34996997!startUp: resuming	"resuming ifTrue: [		'Provide history service to the system which started me, or start another system to provide history service for me.'		| attribute identifier scheme |				attribute := Smalltalk getSystemAttribute: 2.		attribute ifNotNil: [			identifier := UniformResourceIdentifier fromString: attribute.			scheme := identifier scheme].				(attribute isNil or: [scheme = 'squeak'])			ifTrue: [				'I was started manually at a command-line, or by SqueakJS (inside or outside a web browser). Start another system to provide history service for me. If I was started with a squeak URI, process a parameter dictionary from it.'				(scheme = 'squeak') ifTrue: [Current processParameters: identifier parameters].								Current dialect folder: (Filename fromString: ((Smalltalk getSystemAttribute: 0) readStream upToAll: 'Contents')).				[Current resumeHistoryMemory] on: Error do: [:exception | ^self].				[					'The mainstream WebServer takes six seconds to come up after a system resumption. Replace it.'					(Delay forSeconds: 6) wait.					EditHistory local recyclingHash = 0 ifFalse: [Current tether: EditHistory local tether]				]					fork]			ifFalse: [				'Connect to the given locator, to provide history service.'				(scheme = 'ws')					ifTrue: [						Current tether: (							(								[TetherEntrance to: identifier printString]									on: ConnectionRefused									do: [:exception |										'The mainstream WebServer takes six seconds to come up after a system resumption. Replace it.'										(Delay forSeconds: 5) wait.										exception retry]							)								tether).						'Wait a bit for the tether's initial object exposure to happen.'						(Delay forSeconds: 1) wait.						Current pushEditHistory]					ifFalse: [self error: 'unsupported startup URL']]]"! !MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 15:22'!!MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 15:22' prior: 34996997!synchronizeFormatsOfClassHierarchyIncluding: localClass withMemoryNamed: memoryName	"Ensure that the identities, formats and instance variable names of all the classes in the hierarchy including localClass are the same as those of the corresponding classes in the memory named memoryName."	"Use at your own risk..."	| remoteClass |	"Ensure that the local class and its counterpart have the same identity."	remoteClass := (		localClass			counterpartIn: (MemoryProfile named: memoryName)			ifNone: [				"Skip it."				nil]).	remoteClass ifNotNil: [		"Ensure the direct superclasses are synchronized. If they aren't, abandon this synchronization and synchronize from higher in the hierarchy instead."		((localClass superclass format) = (remoteClass superclass format)) ifFalse: [			^self				synchronizeFormatsOfClassHierarchyIncluding: localClass superclass				inMemoryNamed: memoryName].		"Change the format of the class."		remoteClass instVarAt: 3 put: localClass format.		"Set the instance variable names of the class."		remoteClass instVarAt: 4 put: localClass instVarNames.		"Flush the method cache of the remote memory."		remoteClass flushCache.		"Synchronize the subclasses."		localClass subclasses do: [:subclass |			self				synchronizeFormatsOfClassHierarchyIncluding: subclass				withMemoryNamed: memoryName]]! !MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 15:22'!!MemoryProfile class methodsFor: 'as yet unclassified' stamp: 'crl 9/8/2016 15:22' prior: 34996997!withID: aUUID	^KnownProfiles at: aUUID ifAbsent: [nil]! !MemoryProfile initialize!----End fileIn of /Users/craig/Downloads/caffeine/backups/28 (history server)/MemoryProfile.st----!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 11/20/2019 13:04'!collaborationClients	"Answer the currently connected collaboration clients."		^WebUtils jsonEncode: collaborationClients values! !----SNAPSHOT----{20 November 2019 . 1:04:35 pm} pod.image priorSource: 2165552!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 11/20/2019 13:06' prior: 35745909!collaborationClients	"Answer the currently connected collaboration clients."		^collaborationClients values! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 11/20/2019 13:07'!registerClient: profile	"Register the memory profile of a collaboration client. Acknowledge the registration."		collaborationClients		at: profile		put: profile.			^true! !Tether removeSelector: #registerClientWithIDString:named:!----SNAPSHOT----{20 November 2019 . 1:07:57 pm} pod.image priorSource: 2191610!Object subclass: #Team	instanceVariableNames: 'id'	classVariableNames: ''	poolDictionaries: ''	category: 'Naiad'!!Team commentStamp: 'crl 11/21/2019 10:13' prior: 0!'	Each of my instances describes a collection of systems used by teammates, and coordinates communication between them.		Author: Craig Latta <craig@blackpagedigital.com>!!Team methodsFor: 'no messages' stamp: 'crl 11/21/2019 10:13'!initialize	id := UUID new! !----SNAPSHOT----{21 November 2019 . 10:15:03 am} pod.image priorSource: 2192205!!Team class methodsFor: 'no messages' stamp: 'crl 11/21/2019 11:50'!named: string	^self new name: string! !Object subclass: #Team	instanceVariableNames: 'id name'	classVariableNames: ''	poolDictionaries: ''	category: 'Naiad'!Object subclass: #Team	instanceVariableNames: 'id name'	classVariableNames: ''	poolDictionaries: ''	category: 'Naiad'!!Team methodsFor: 'as yet unclassified' stamp: 'crl 11/21/2019 11:50'!name: string	name := string! !Object subclass: #Tether	instanceVariableNames: 'portal peer exposedObjects pendingIncomingExchanges pendingOutgoingExchanges module peerSet collaborationClients'	classVariableNames: 'Teams TetherEntranceToLocalhost'	poolDictionaries: 'TetherConstants'	category: 'Tether'!Object subclass: #Tether	instanceVariableNames: 'portal peer exposedObjects pendingIncomingExchanges pendingOutgoingExchanges module peerSet collaborationClients'	classVariableNames: 'Teams TetherEntranceToLocalhost'	poolDictionaries: 'TetherConstants'	category: 'Tether'!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 11/21/2019 11:51'!createTeamNamed: string	"Create a collaboration team named string."		^Teams add: (Team named: string)! !!Tether class methodsFor: 'as yet unclassified' stamp: 'crl 11/21/2019 11:52' prior: 34862346!initialize	"Smalltalk addToStartUpList: self"	Teams := Dictionary new! !	Teams := Dictionary new!!Object methodsFor: 'as yet unclassified' stamp: 'crl 11/21/2019 12:10' prior: 34996997!instVarNamed: aString	"Return the value of the instance variable in me with that name.  Slow and unclean, but very useful. "	^ self instVarAt: (self class						instVarIndexFor: aString asString						ifAbsent: [self error: 'no such inst var'])! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'crl 11/21/2019 12:10' prior: 27782127!validateMessageSource: sourceString forSelector: aSelector inClass: theClass	"Check whether there is evidence that method source is invalid"	(((theClass compiledMethodAt: aSelector) == Behavior reloadingMethod) not and: [((theClass newParser parseSelector: sourceString asString) = aSelector) not]) ifTrue: [self informPossiblyCorruptSource].! !!Object methodsFor: 'as yet unclassified' stamp: 'crl 11/21/2019 12:11'!jsInstanceSlotNames	^self subclassResponsibility! !!Object methodsFor: 'as yet unclassified' stamp: 'crl 11/21/2019 12:11' prior: 0!asJSArgument	"Answer an array of associations that describe how to create an object equivalent to me, and which are useful as an equivalent JavaScript object."		| associations |		associations := (Array new: 5) writeStream.		associations nextPut: (#class -> (self class printString)).	self jsInstanceSlotNames do: [:slotName | associations nextPut: (slotName -> ((self instVarNamed: slotName) asJSArgument))].	^associations contents! !!Team methodsFor: 'as yet unclassified' stamp: 'crl 11/21/2019 12:12'!jsInstanceSlotNames	^self class instVarNames! !----SNAPSHOT----{21 November 2019 . 12:27:32 pm} pod.image priorSource: 2192726!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 11/21/2019 12:52' prior: 35748331!createTeamNamed: string	"Create a collaboration team named string."		| team |		team := Team named: string.		^Teams		at: team id		put: team! !----SNAPSHOT----{21 November 2019 . 12:52:09 pm} pod.image priorSource: 2195760!!Team methodsFor: 'as yet unclassified' stamp: 'crl 11/21/2019 12:54'!id	^id! !!Team methodsFor: 'as yet unclassified' stamp: 'crl 11/21/2019 12:55'!printOn: stream	super printOn: stream.		stream		nextPutAll: ' named ';		print: name! !!Team methodsFor: 'as yet unclassified' stamp: 'crl 11/21/2019 12:55'!name	^name! !----SNAPSHOT----{21 November 2019 . 12:55:38 pm} pod.image priorSource: 2196082!----SNAPSHOT----{28 November 2019 . 11:10:42 am} pod.image priorSource: 2196495!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 11/28/2019 18:39' prior: 35750364!createTeamNamed: string	"Create a collaboration team named string."		| team |		team := Team named: string.		self postMessage: {		#action -> 'team created'.		#team -> team}.		^Teams		at: team id		put: team! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 11/28/2019 18:40'!postMessage: message	JS parentPort postMessage: (JS JSON stringify: message)! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 11/28/2019 18:41' prior: 35717944!handleEvent	(peer recyclingHash = 0)		ifTrue: [			peer := self next..			portal isExit ifFalse: [self push: self].			peerSet signal]		ifFalse: [			| nextWord handler |						nextWord := portal nextWord.			JS ifConnected: [				(nextWord = 1337) ifTrue: [					"This is a message from a JavaScript system."										| exposureHash parameters |										exposureHash := portal nextWord.					parameters := JS JSON parse: (portal next: portal nextWord) asByteArray asString.					^self postMessage: {						#result -> (							self								perform: parameters selector asString asSymbol								withArguments: (parameters arguments asArray collect: [:element | element counterpart simplestRepresentation])).						#exposureHash -> exposureHash}]].						handler := Classes at: nextWord ifAbsent: [3 halt].			handler				ifNil: [3 halt]				ifNotNil: [handler handleEventFrom: self]]! !----SNAPSHOT----{28 November 2019 . 6:42:25 pm} pod.image priorSource: 2196577!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 11/28/2019 18:55' prior: 35751181!createTeamNamed: string	"Create a collaboration team named string."		| team |		team := Team named: string.		self postMessage: {		#action -> 'team created'.		#arguments -> {			#team -> team}}.		^Teams		at: team id		put: team! !----SNAPSHOT----{28 November 2019 . 6:55:28 pm} pod.image priorSource: 2198111!!Tether class methodsFor: 'as yet unclassified' stamp: 'crl 11/28/2019 19:01' prior: 34862906!startUp: resuming	resuming ifTrue: [		JS			ifConnected: [				WebServer reset.				"Establish localhost Tether service."				TetherEntranceToLocalhost := nil.				"self establishLocalTetherService".				JS parentPort postMessage: (JS JSON stringify: {#action -> 'worker started'})]			ifNotConnected: [				JSObjectProxy stop.				Exit start]]! !----SNAPSHOT----{28 November 2019 . 7:01:08 pm} pod.image priorSource: 2198522!SmalltalkImage classPool at: #StartUpList!	Smalltalk addToStartUpList: self.!!Tether class methodsFor: 'as yet unclassified' stamp: 'crl 11/28/2019 19:18' prior: 35748534!initialize	Smalltalk addToStartUpList: self.	Teams := Dictionary new! !----SNAPSHOT----{28 November 2019 . 7:18:24 pm} pod.image priorSource: 2199049!SmalltalkImage classPool at: #StartUpList!!Tether class methodsFor: 'as yet unclassified' stamp: 'crl 11/28/2019 19:19' prior: 35753131!startUp: resuming	resuming ifTrue: [		JS			ifConnected: [				WebServer reset.				"Establish localhost Tether service."				TetherEntranceToLocalhost := nil.				"self establishLocalTetherService".				JS debugger.				JS parentPort postMessage: (JS JSON stringify: {#action -> 'worker started'})]			ifNotConnected: [				JSObjectProxy stop.				Exit start]]! !----SNAPSHOT----{28 November 2019 . 7:19:50 pm} pod.image priorSource: 2199380!SmalltalkImage classPool at: #StartUpList!!HostPlatform class methodsFor: 'as yet unclassified' stamp: 'crl 11/28/2019 19:24' prior: 35704651!startUp: resuming	"Note the current host platform."	resuming ifTrue: [		JS ifConnected: [			JS ifHeadless: [				^[					| tether portal connected |								(Processor waitingProcessesAt: Processor userSchedulingPriority) do: [:process | process terminate].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.										portal := WorkerEntrance new.					tether := Tether through: portal.										(JS isNode)						ifTrue: [							(JS parentPort)								on: 'message'								with: [:message |									portal incomingMessage: message counterpart simplestRepresentation.									tether handleEvent];								postMessage: (JS JSON stringify: {#action -> 'worker started'})]						ifFalse: [							JS								at: #onmessage								put: [:message |									portal incomingMessage: message data counterpart simplestRepresentation.									tether handleEvent]].								tether waitForPeer.					connected := tether peer ping				]					forkAt: Processor timingPriority]].					Current := (Platforms at: (Smalltalk getSystemAttribute: 1001)) new.		"Filename resume"]! !!Tether class methodsFor: 'as yet unclassified' stamp: 'crl 5/21/2018 03:20' prior: 35754033!startUp: resuming	resuming ifTrue: [		JS			ifConnected: [				WebServer reset.				"Establish localhost Tether service."				TetherEntranceToLocalhost := nil.				"self establishLocalTetherService"]			ifNotConnected: [				JSObjectProxy stop.				Exit start]]! !----SNAPSHOT----{28 November 2019 . 7:25:17 pm} pod.image priorSource: 2199968!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 11/29/2019 16:57' prior: 35752714!createTeamNamed: string	"Create a collaboration team named string."		| team |		team := Team named: string.		self postMessage: {		#action -> 'team created'.		#arguments -> {team}}.		^Teams		at: team id		put: team! !----SNAPSHOT----{29 November 2019 . 4:57:32 pm} pod.image priorSource: 2201662!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 11/29/2019 20:04' prior: 35746399!registerClient: profile	"Register the memory profile of a collaboration client. Acknowledge the registration."		collaborationClients		at: profile id		put: profile.			^true! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 12/1/2019 14:42' prior: 35756265!createTeamNamed: string	"Create a collaboration team named string."		| team |		team := Team named: string.		self postMessage: {		#action -> 'team created'.		#selector -> #noteTeamCreated:.		#arguments -> {team}}.		^Teams		at: team id		put: team! !----SNAPSHOT----{1 December 2019 . 2:43:27 pm} pod.image priorSource: 2202060!Object subclass: #Team	instanceVariableNames: 'id name members'	classVariableNames: ''	poolDictionaries: ''	category: 'Naiad'!!Team methodsFor: 'as yet unclassified' stamp: 'crl 12/2/2019 22:08' prior: 35747129!initialize	id := UUID new.	members := Dictionary new! !!Team methodsFor: 'as yet unclassified' stamp: 'crl 12/2/2019 22:08'!addMember: profile	^members		at: profile id		put: profile! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 12/2/2019 22:13'!addClientWithID: clientID toTeamWithID: teamID	"Add the client with id clientID to the team with id teamID."		| team member |		team := Teams at: teamID.	member := team addMember: (collaborationClients at: clientID).	self postMessage: {		#selector -> #noteMemberAdded:toTeam:.		#arguments -> {member. team}}.		^member! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 12/2/2019 22:26' prior: 35756933!createTeamNamed: string	"Create a collaboration team named string."		| team |		team := Team named: string.		self postMessage: {		#selector -> #noteTeamCreated:.		#arguments -> {team}}.		^Teams		at: team id		put: team! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 12/2/2019 22:28' prior: 35756663!registerClient: profile	"Register the memory profile of a collaboration client. Acknowledge the registration."		collaborationClients		at: profile id		put: profile.			self postMessage: {		#selector -> #noteRegisteredClient:.		#arguments -> {profile}}.	^true! !----QUIT----{4 December 2019 . 1:36:59 pm} pod.image priorSource: 2202762!!Tether class methodsFor: 'as yet unclassified' stamp: 'crl 12/5/2019 09:28' prior: 35755827!startUp: resuming	resuming ifTrue: [		JS			ifConnected: [				WebServer reset.				"Establish localhost Tether service."				TetherEntranceToLocalhost := nil.				"self establishLocalTetherService"]			ifNotConnected: [				"JSObjectProxy stop."				Exit start]]! !----STARTUP----{5 December 2019 . 9:28:59 am} as /Users/craig/Downloads/caffeine/backups/37 (headless)/pod.image!----SNAPSHOT----{5 December 2019 . 9:29:03 am} pod.image priorSource: 2204336!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 12/5/2019 09:32' prior: 35758498!registerClient: profile	"Register the memory profile of a collaboration client. Acknowledge the registration."		collaborationClients		at: profile id		put: profile.			self postMessage: {		#action -> 'broadcast message'.		#selector -> #noteRegisteredClient:.		#arguments -> {profile}}.	^true! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 12/5/2019 09:33' prior: 35757757!addClientWithID: clientID toTeamWithID: teamID	"Add the client with id clientID to the team with id teamID."		| team member |		team := Teams at: teamID.	member := team addMember: (collaborationClients at: clientID).	self postMessage: {		#action -> 'broadcast message'.		#selector -> #noteMemberAdded:toTeam:.		#arguments -> {member. team}}.		^member! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 12/5/2019 09:33' prior: 35758177!createTeamNamed: string	"Create a collaboration team named string."		| team |		team := Team named: string.		self postMessage: {		#action -> 'broadcast message'.		#selector -> #noteTeamCreated:.		#arguments -> {team}}.		^Teams		at: team id		put: team! !----SNAPSHOT----{5 December 2019 . 9:33:47 am} pod.image priorSource: 2204892!'hello' class isBytes!!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 12/7/2019 11:11' prior: 35278334!startUp: resuming	"After a system resumption, if the system is being run by SqueakJS in a web browser, reset constants related to that web browser's JavaScript environment."	| forceToScreen |	resuming ifTrue: [		(self == Webpage)			ifTrue: [				Fullscreen := false.								Top := TopDocument := ContainingDiv := ContainingCanvas := ContainingFrame := Current := Options := nil.				Preferences					setPreference: #fastDragWindowForMorphic					toValue: JS isConnected.				JS ifConnected: [					| url |					JS ifHeadless: [						JS at: #onmessage put: [:message | JS debugger].						^self].					Top := [JS top counterpart magicWindow] on: Error do: [:exception | JS].					url := (						Top							ifNil: [String randomOfLength: 5]							ifNotNil: [								TopDocument := Top document.								Url absoluteFromText: Top location href asString]).					Options := (						(JS SqueakJS options at: #parameters)							ifNil: [nil]							ifNotNil: [JS SqueakJS options parameters counterpart]).												ContainingCanvas := JS document counterpart getElementById: 'squeak'.					[ContainingCanvas						at: #width put: Options width;						at: #height put: Options height] on: Error do: [:e | ].											Top ifNotNil: [ContainingFrame := Top document getElementById: #Caffeine].					ContainingCanvas ifNotNil: [						ContainingDiv := (							ContainingFrame								ifNil: [ContainingCanvas parentNode]								ifNotNil: [									self styleAt: #transition put: 'opacity 500ms'.									ContainingFrame parentNode parentNode]).						ContainingDiv at: #onresize put: [self resize].						ContainingCanvas at: #tabIndex put: 0.						self captureCurrentExtent.						ContainingCanvas onclick: [self focus]].										forceToScreen := [:event | Display forceToScreen].					Top						at: #onresize						put: forceToScreen; 						at: #onscroll						put: forceToScreen;						at: #onorientationchange						put: [:event |							forceToScreen value: event.							self scrollToTop].															ContainingCanvas ifNotNil: [						ContainingCanvas							styleAt: 'user-select'							put: [false]].					Pages						at: url						ifAbsent: [							self								ifOptionAt: 'appID'								then: [:appID |									| appClass |																		appClass := self allSubclasses detect: [:subclass | subclass appID = appID] ifNone: [nil].									appClass										ifNil: [nil]										ifNotNil: [											Pages												at: url												put: (appClass fromURL: url)]]								else: [nil]]]]]! !----SNAPSHOT----{7 December 2019 . 11:11:36 am} pod.image priorSource: 2206174!!Webpage class methodsFor: 'as yet unclassified' stamp: 'crl 9/24/2019 11:55' prior: 35760806!startUp: resuming	"After a system resumption, if the system is being run by SqueakJS in a web browser, reset constants related to that web browser's JavaScript environment."	| forceToScreen |	resuming ifTrue: [		(self == Webpage)			ifTrue: [				Fullscreen := false.								Top := TopDocument := ContainingDiv := ContainingCanvas := ContainingFrame := Current := Options := nil.				Preferences					setPreference: #fastDragWindowForMorphic					toValue: JS isConnected.				JS ifConnected: [					| url |					JS ifHeadless: [^self].					Top := [JS top counterpart magicWindow] on: Error do: [:exception | JS].					url := (						Top							ifNil: [String randomOfLength: 5]							ifNotNil: [								TopDocument := Top document.								Url absoluteFromText: Top location href asString]).					Options := (						(JS SqueakJS options at: #parameters)							ifNil: [nil]							ifNotNil: [JS SqueakJS options parameters counterpart]).												ContainingCanvas := JS document counterpart getElementById: 'squeak'.					[ContainingCanvas						at: #width put: Options width;						at: #height put: Options height] on: Error do: [:e | ].											Top ifNotNil: [ContainingFrame := Top document getElementById: #Caffeine].					ContainingCanvas ifNotNil: [						ContainingDiv := (							ContainingFrame								ifNil: [ContainingCanvas parentNode]								ifNotNil: [									self styleAt: #transition put: 'opacity 500ms'.									ContainingFrame parentNode parentNode]).						ContainingDiv at: #onresize put: [self resize].						ContainingCanvas at: #tabIndex put: 0.						self captureCurrentExtent.						ContainingCanvas onclick: [self focus]].										forceToScreen := [:event | Display forceToScreen].					Top						at: #onresize						put: forceToScreen; 						at: #onscroll						put: forceToScreen;						at: #onorientationchange						put: [:event |							forceToScreen value: event.							self scrollToTop].															ContainingCanvas ifNotNil: [						ContainingCanvas							styleAt: 'user-select'							put: [false]].					Pages						at: url						ifAbsent: [							self								ifOptionAt: 'appID'								then: [:appID |									| appClass |																		appClass := self allSubclasses detect: [:subclass | subclass appID = appID] ifNone: [nil].									appClass										ifNil: [nil]										ifNotNil: [											Pages												at: url												put: (appClass fromURL: url)]]								else: [nil]]]]]! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 12/8/2019 02:10' prior: 35759493!registerClient: profile	"Register the memory profile of a collaboration client. Acknowledge the registration."		self postMessage: {		#action -> 'broadcast message'.		#selector -> #noteRegisteredClient:.		#arguments -> {profile}}.	^true! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 12/8/2019 02:10'!noteRegisteredClient: profile	collaborationClients		at: profile id		put: profile! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 12/8/2019 02:16' prior: 35766423!noteRegisteredClient: profile	JS debugger.	collaborationClients		at: profile id		put: profile! !----SNAPSHOT----{8 December 2019 . 2:17:49 am} pod.image priorSource: 2208921!'From Squeak4.6 of 8 July 2015 [latest update: #15102] on 8 December 2019 at 3:06:23 am'!Object methodsFor: 'as yet unclassified' stamp: 'fbs 1/30/2013 20:02'!!Object methodsFor: 'as yet unclassified' stamp: 'fbs 1/30/2013 20:02' prior: 34996997!subclassResponsibility	"This message sets up a framework for the behavior of the class' subclasses.	Announce that the subclass should have implemented this message."	^ SubclassResponsibility		signal: ('My {1} subclass should have overridden {2}'			format: {self className. thisContext sender selector}).! !----End fileIn of /Users/craig/Downloads/caffeine/backups/28 (history server)/Object-subclassResponsibility.st----!----SNAPSHOT----{8 December 2019 . 3:07:03 am} pod.image priorSource: 2212266!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 12/8/2019 03:11'!jsInstanceSlotNames	^#()! !----SNAPSHOT----{8 December 2019 . 3:12:09 am} pod.image priorSource: 2213026!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 12/8/2019 21:47' prior: 35766598!noteRegisteredClient: profile	collaborationClients		at: profile id		put: profile! !!MemoryProfile methodsFor: 'as yet unclassified' stamp: 'crl 12/8/2019 21:48'!jsInstanceSlotNames	^#(names id services memoryFilename processorFilename dialect)! !----SNAPSHOT----{8 December 2019 . 9:49:16 pm} pod.image priorSource: 2213207!Object subclass: #Tether	instanceVariableNames: 'portal peer exposedObjects pendingIncomingExchanges pendingOutgoingExchanges module peerSet collaborationClients teams'	classVariableNames: 'Teams TetherEntranceToLocalhost'	poolDictionaries: 'TetherConstants'	category: 'Tether'!Object subclass: #Tether	instanceVariableNames: 'portal peer exposedObjects pendingIncomingExchanges pendingOutgoingExchanges module peerSet collaborationClients teams'	classVariableNames: 'Teams TetherEntranceToLocalhost'	poolDictionaries: 'TetherConstants'	category: 'Tether'!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 12/8/2019 22:00'!noteTeamCreated: team	teams		at: team id		put: team! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 12/8/2019 22:00' prior: 35721177!initialize	exposedObjects := IdentityDictionary new.	pendingIncomingExchanges := IdentitySet new.	pendingOutgoingExchanges := Dictionary new.	peerSet := Semaphore new.	module := ModuleEdition new.	collaborationClients := Dictionary new.	teams := Dictionary new! !----SNAPSHOT----{8 December 2019 . 10:00:24 pm} pod.image priorSource: 2213628!!Tether class methodsFor: 'as yet unclassified' stamp: 'crl 12/8/2019 22:07' prior: 35753739!initialize	Smalltalk addToStartUpList: self! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 12/8/2019 22:07' prior: 35759886!addClientWithID: clientID toTeamWithID: teamID	"Add the client with id clientID to the team with id teamID."		| team member |		team := teams at: teamID.	member := team addMember: (collaborationClients at: clientID).	self postMessage: {		#action -> 'broadcast message'.		#selector -> #noteMemberAdded:toTeam:.		#arguments -> {member. team}}.		^member! !!Tether methodsFor: 'as yet unclassified' stamp: 'crl 12/8/2019 22:07' prior: 35760340!createTeamNamed: string	"Create a collaboration team named string."		| team |		team := Team named: string.		self postMessage: {		#action -> 'broadcast message'.		#selector -> #noteTeamCreated:.		#arguments -> {team}}! !Object subclass: #Tether	instanceVariableNames: 'portal peer exposedObjects pendingIncomingExchanges pendingOutgoingExchanges module peerSet collaborationClients teams'	classVariableNames: 'TetherEntranceToLocalhost'	poolDictionaries: 'TetherConstants'	category: 'Tether'!----SNAPSHOT----{8 December 2019 . 10:08:36 pm} pod.image priorSource: 2214765!!Tether methodsFor: 'as yet unclassified' stamp: 'crl 12/8/2019 22:11' prior: 35769963!createTeamNamed: string	"Create a collaboration team named string."		| team |		team := Team named: string.		self postMessage: {		#action -> 'broadcast message'.		#selector -> #noteTeamCreated:.		#arguments -> {team}}.			^team! !----SNAPSHOT----{8 December 2019 . 10:11:30 pm} pod.image priorSource: 2216038!