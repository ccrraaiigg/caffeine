/*! osc.js 2.4.1, Copyright 2020 Colin Clark | github.com/colinbdclark/osc.js */


!function(i, a) {
    "object" == typeof exports ? (i.osc = exports, a(0, require("slip"), require("EventEmitter"), require("long"))) : "function" == typeof define && define.amd ? define([ "exports", "slip", "EventEmitter", "long" ], function(e, t, r, n) {
        return i.osc = e, i.osc, a(0, t, r, n);
    }) : (i.osc = {}, a(i.osc, slip, EventEmitter));
}(this, function(e, i, t, r) {
    var l = l || {};
    !function() {
        "use strict";
        l.SECS_70YRS = 2208988800, l.TWO_32 = 4294967296, l.defaults = {
            metadata: !1,
            unpackSingleArgs: !0
        }, l.isCommonJS = !("undefined" == typeof module || !module.exports), l.isNode = l.isCommonJS && "undefined" == typeof window, 
        l.isElectron = !("undefined" == typeof process || !process.versions || !process.versions.electron), 
        l.isBufferEnv = l.isNode || l.isElectron, l.isArray = function(e) {
            return e && "[object Array]" === Object.prototype.toString.call(e);
        }, l.isTypedArrayView = function(e) {
            return e.buffer && e.buffer instanceof ArrayBuffer;
        }, l.isBuffer = function(e) {
            return l.isBufferEnv && e instanceof Buffer;
        }, l.Long = void 0 !== r ? r : l.isNode ? require("long") : void 0, l.TextDecoder = "undefined" != typeof TextDecoder ? new TextDecoder("utf-8") : "undefined" != typeof util && (util.TextDecoder, 
        1) ? new util.TextDecoder("utf-8") : void 0, l.TextEncoder = "undefined" != typeof TextEncoder ? new TextEncoder("utf-8") : "undefined" != typeof util && (util.TextEncoder, 
        1) ? new util.TextEncoder("utf-8") : void 0, l.dataView = function(e, t, r) {
            return e.buffer ? new DataView(e.buffer, t, r) : e instanceof ArrayBuffer ? new DataView(e, t, r) : new DataView(new Uint8Array(e), t, r);
        }, l.byteArray = function(e) {
            if (e instanceof Uint8Array) return e;
            var t = e.buffer ? e.buffer : e;
            if (!(t instanceof ArrayBuffer || void 0 !== t.length && "string" != typeof t)) throw new Error("Can't wrap a non-array-like object as Uint8Array. Object was: " + JSON.stringify(e, null, 2));
            return new Uint8Array(t);
        }, l.nativeBuffer = function(e) {
            return l.isBufferEnv ? l.isBuffer(e) ? e : Buffer.from(e.buffer ? e : new Uint8Array(e)) : l.isTypedArrayView(e) ? e : new Uint8Array(e);
        }, l.copyByteArray = function(e, t, r) {
            if (l.isTypedArrayView(e) && l.isTypedArrayView(t)) t.set(e, r); else for (var n = void 0 === r ? 0 : r, i = Math.min(t.length - r, e.length), a = 0, o = n; a < i; a++, 
            o++) t[o] = e[a];
            return t;
        }, l.readString = function(e, t) {
            for (var r = [], n = t.idx; n < e.byteLength; n++) {
                var i = e.getUint8(n);
                if (0 === i) {
                    n++;
                    break;
                }
                r.push(i);
            }
            return n = n + 3 & -4, t.idx = n, (l.isBufferEnv ? l.readString.withBuffer : l.TextDecoder ? l.readString.withTextDecoder : l.readString.raw)(r);
        }, l.readString.raw = function(e) {
            for (var t = "", r = 0; r < e.length; r += 1e4) t += String.fromCharCode.apply(null, e.slice(r, r + 1e4));
            return t;
        }, l.readString.withTextDecoder = function(e) {
            var t = new Int8Array(e);
            return l.TextDecoder.decode(t);
        }, l.readString.withBuffer = function(e) {
            return Buffer.from(e).toString("utf-8");
        }, l.writeString = function(e) {
            var t, r = e + "\0", n = r.length, i = new Uint8Array(n + 3 & -4), a = l.isBufferEnv ? l.writeString.withBuffer : l.TextEncoder ? l.writeString.withTextEncoder : null;
            a && (t = a(r));
            for (var o = 0; o < r.length; o++) {
                var s = a ? t[o] : r.charCodeAt(o);
                i[o] = s;
            }
            return i;
        }, l.writeString.withTextEncoder = function(e) {
            return l.TextEncoder.encode(e);
        }, l.writeString.withBuffer = function(e) {
            return Buffer.from(e);
        }, l.readPrimitive = function(e, t, r, n) {
            var i = e[t](n.idx, !1);
            return n.idx += r, i;
        }, l.writePrimitive = function(e, t, r, n, i) {
            var a;
            return i = void 0 === i ? 0 : i, t ? a = new Uint8Array(t.buffer) : (a = new Uint8Array(n), 
            t = new DataView(a.buffer)), t[r](i, e, !1), a;
        }, l.readInt32 = function(e, t) {
            return l.readPrimitive(e, "getInt32", 4, t);
        }, l.writeInt32 = function(e, t, r) {
            return l.writePrimitive(e, t, "setInt32", 4, r);
        }, l.readInt64 = function(e, t) {
            var r = l.readPrimitive(e, "getInt32", 4, t), n = l.readPrimitive(e, "getInt32", 4, t);
            return l.Long ? new l.Long(n, r) : {
                high: r,
                low: n,
                unsigned: !1
            };
        }, l.writeInt64 = function(e, t, r) {
            var n = new Uint8Array(8);
            return n.set(l.writePrimitive(e.high, t, "setInt32", 4, r), 0), n.set(l.writePrimitive(e.low, t, "setInt32", 4, r + 4), 4), 
            n;
        }, l.readFloat32 = function(e, t) {
            return l.readPrimitive(e, "getFloat32", 4, t);
        }, l.writeFloat32 = function(e, t, r) {
            return l.writePrimitive(e, t, "setFloat32", 4, r);
        }, l.readFloat64 = function(e, t) {
            return l.readPrimitive(e, "getFloat64", 8, t);
        }, l.writeFloat64 = function(e, t, r) {
            return l.writePrimitive(e, t, "setFloat64", 8, r);
        }, l.readChar32 = function(e, t) {
            var r = l.readPrimitive(e, "getUint32", 4, t);
            return String.fromCharCode(r);
        }, l.writeChar32 = function(e, t, r) {
            var n = e.charCodeAt(0);
            if (!(void 0 === n || n < -1)) return l.writePrimitive(n, t, "setUint32", 4, r);
        }, l.readBlob = function(e, t) {
            var r = l.readInt32(e, t), n = r + 3 & -4, i = new Uint8Array(e.buffer, t.idx, r);
            return t.idx += n, i;
        }, l.writeBlob = function(e) {
            var t = (e = l.byteArray(e)).byteLength, r = new Uint8Array(4 + (t + 3 & -4)), n = new DataView(r.buffer);
            return l.writeInt32(t, n), r.set(e, 4), r;
        }, l.readMIDIBytes = function(e, t) {
            var r = new Uint8Array(e.buffer, t.idx, 4);
            return t.idx += 4, r;
        }, l.writeMIDIBytes = function(e) {
            e = l.byteArray(e);
            var t = new Uint8Array(4);
            return t.set(e), t;
        }, l.readColor = function(e, t) {
            var r = new Uint8Array(e.buffer, t.idx, 4), n = r[3] / 255;
            return t.idx += 4, {
                r: r[0],
                g: r[1],
                b: r[2],
                a: n
            };
        }, l.writeColor = function(e) {
            var t = Math.round(255 * e.a);
            return new Uint8Array([ e.r, e.g, e.b, t ]);
        }, l.readTrue = function() {
            return !0;
        }, l.readFalse = function() {
            return !1;
        }, l.readNull = function() {
            return null;
        }, l.readImpulse = function() {
            return 1;
        }, l.readTimeTag = function(e, t) {
            var r = l.readPrimitive(e, "getUint32", 4, t), n = l.readPrimitive(e, "getUint32", 4, t);
            return {
                raw: [ r, n ],
                native: 0 === r && 1 === n ? Date.now() : l.ntpToJSTime(r, n)
            };
        }, l.writeTimeTag = function(e) {
            var t = e.raw ? e.raw : l.jsToNTPTime(e.native), r = new Uint8Array(8), n = new DataView(r.buffer);
            return l.writeInt32(t[0], n, 0), l.writeInt32(t[1], n, 4), r;
        }, l.timeTag = function(e, t) {
            e = e || 0;
            var r = (t = t || Date.now()) / 1e3, n = Math.floor(r), i = r - n, a = Math.floor(e), o = i + (e - a);
            if (1 < o) {
                var s = Math.floor(o);
                a += s, o = o - s;
            }
            return {
                raw: [ n + a + l.SECS_70YRS, Math.round(l.TWO_32 * o) ]
            };
        }, l.ntpToJSTime = function(e, t) {
            return 1e3 * (e - l.SECS_70YRS + t / l.TWO_32);
        }, l.jsToNTPTime = function(e) {
            var t = e / 1e3, r = Math.floor(t), n = t - r;
            return [ r + l.SECS_70YRS, Math.round(l.TWO_32 * n) ];
        }, l.readArguments = function(e, t, r) {
            var n = l.readString(e, r);
            if (0 !== n.indexOf(",")) throw new Error("A malformed type tag string was found while reading the arguments of an OSC message. String was: " + n, " at offset: " + r.idx);
            var i = n.substring(1).split(""), a = [];
            return l.readArgumentsIntoArray(a, i, n, e, t, r), a;
        }, l.readArgument = function(e, t, r, n, i) {
            var a = l.argumentTypes[e];
            if (!a) throw new Error("'" + e + "' is not a valid OSC type tag. Type tag string was: " + t);
            var o = a.reader, s = l[o](r, i);
            return n.metadata && (s = {
                type: e,
                value: s
            }), s;
        }, l.readArgumentsIntoArray = function(e, t, r, n, i, a) {
            for (var o = 0; o < t.length; ) {
                var s, u = t[o];
                if ("[" === u) {
                    var d = t.slice(o + 1), c = d.indexOf("]");
                    if (c < 0) throw new Error("Invalid argument type tag: an open array type tag ('[') was found without a matching close array tag ('[]'). Type tag was: " + r);
                    var f = d.slice(0, c);
                    s = l.readArgumentsIntoArray([], f, r, n, i, a), o += c + 2;
                } else s = l.readArgument(u, r, n, i, a), o++;
                e.push(s);
            }
            return e;
        }, l.writeArguments = function(e, t) {
            var r = l.collectArguments(e, t);
            return l.joinParts(r);
        }, l.joinParts = function(e) {
            for (var t = new Uint8Array(e.byteLength), r = e.parts, n = 0, i = 0; i < r.length; i++) {
                var a = r[i];
                l.copyByteArray(a, t, n), n += a.length;
            }
            return t;
        }, l.addDataPart = function(e, t) {
            t.parts.push(e), t.byteLength += e.length;
        }, l.writeArrayArguments = function(e, t) {
            for (var r = "[", n = 0; n < e.length; n++) {
                var i = e[n];
                r += l.writeArgument(i, t);
            }
            return r += "]";
        }, l.writeArgument = function(e, t) {
            if (l.isArray(e)) return l.writeArrayArguments(e, t);
            var r = e.type, n = l.argumentTypes[r].writer;
            if (n) {
                var i = l[n](e.value);
                l.addDataPart(i, t);
            }
            return e.type;
        }, l.collectArguments = function(e, t, r) {
            l.isArray(e) || (e = void 0 === e ? [] : [ e ]), r = r || {
                byteLength: 0,
                parts: []
            }, t.metadata || (e = l.annotateArguments(e));
            for (var n = ",", i = r.parts.length, a = 0; a < e.length; a++) {
                var o = e[a];
                n += l.writeArgument(o, r);
            }
            var s = l.writeString(n);
            return r.byteLength += s.byteLength, r.parts.splice(i, 0, s), r;
        }, l.readMessage = function(e, t, r) {
            t = t || l.defaults;
            var n = l.dataView(e, e.byteOffset, e.byteLength);
            r = r || {
                idx: 0
            };
            var i = l.readString(n, r);
            return l.readMessageContents(i, n, t, r);
        }, l.readMessageContents = function(e, t, r, n) {
            if (0 !== e.indexOf("/")) throw new Error("A malformed OSC address was found while reading an OSC message. String was: " + e);
            var i = l.readArguments(t, r, n);
            return {
                address: e,
                args: 1 === i.length && r.unpackSingleArgs ? i[0] : i
            };
        }, l.collectMessageParts = function(e, t, r) {
            return r = r || {
                byteLength: 0,
                parts: []
            }, l.addDataPart(l.writeString(e.address), r), l.collectArguments(e.args, t, r);
        }, l.writeMessage = function(e, t) {
            if (t = t || l.defaults, !l.isValidMessage(e)) throw new Error("An OSC message must contain a valid address. Message was: " + JSON.stringify(e, null, 2));
            var r = l.collectMessageParts(e, t);
            return l.joinParts(r);
        }, l.isValidMessage = function(e) {
            return e.address && 0 === e.address.indexOf("/");
        }, l.readBundle = function(e, t, r) {
            return l.readPacket(e, t, r);
        }, l.collectBundlePackets = function(e, t, r) {
            r = r || {
                byteLength: 0,
                parts: []
            }, l.addDataPart(l.writeString("#bundle"), r), l.addDataPart(l.writeTimeTag(e.timeTag), r);
            for (var n = 0; n < e.packets.length; n++) {
                var i = e.packets[n], a = (i.address ? l.collectMessageParts : l.collectBundlePackets)(i, t);
                r.byteLength += a.byteLength, l.addDataPart(l.writeInt32(a.byteLength), r), r.parts = r.parts.concat(a.parts);
            }
            return r;
        }, l.writeBundle = function(e, t) {
            if (!l.isValidBundle(e)) throw new Error("An OSC bundle must contain 'timeTag' and 'packets' properties. Bundle was: " + JSON.stringify(e, null, 2));
            t = t || l.defaults;
            var r = l.collectBundlePackets(e, t);
            return l.joinParts(r);
        }, l.isValidBundle = function(e) {
            return void 0 !== e.timeTag && void 0 !== e.packets;
        }, l.readBundleContents = function(e, t, r, n) {
            for (var i = l.readTimeTag(e, r), a = []; r.idx < n; ) {
                var o = l.readInt32(e, r), s = r.idx + o, u = l.readPacket(e, t, r, s);
                a.push(u);
            }
            return {
                timeTag: i,
                packets: a
            };
        }, l.readPacket = function(e, t, r, n) {
            var i = l.dataView(e, e.byteOffset, e.byteLength);
            n = void 0 === n ? i.byteLength : n, r = r || {
                idx: 0
            };
            var a = l.readString(i, r), o = a[0];
            if ("#" === o) return l.readBundleContents(i, t, r, n);
            if ("/" === o) return l.readMessageContents(a, i, t, r);
            throw new Error("The header of an OSC packet didn't contain an OSC address or a #bundle string. Header was: " + a);
        }, l.writePacket = function(e, t) {
            if (l.isValidMessage(e)) return l.writeMessage(e, t);
            if (l.isValidBundle(e)) return l.writeBundle(e, t);
            throw new Error("The specified packet was not recognized as a valid OSC message or bundle. Packet was: " + JSON.stringify(e, null, 2));
        }, l.argumentTypes = {
            i: {
                reader: "readInt32",
                writer: "writeInt32"
            },
            h: {
                reader: "readInt64",
                writer: "writeInt64"
            },
            f: {
                reader: "readFloat32",
                writer: "writeFloat32"
            },
            s: {
                reader: "readString",
                writer: "writeString"
            },
            S: {
                reader: "readString",
                writer: "writeString"
            },
            b: {
                reader: "readBlob",
                writer: "writeBlob"
            },
            t: {
                reader: "readTimeTag",
                writer: "writeTimeTag"
            },
            T: {
                reader: "readTrue"
            },
            F: {
                reader: "readFalse"
            },
            N: {
                reader: "readNull"
            },
            I: {
                reader: "readImpulse"
            },
            d: {
                reader: "readFloat64",
                writer: "writeFloat64"
            },
            c: {
                reader: "readChar32",
                writer: "writeChar32"
            },
            r: {
                reader: "readColor",
                writer: "writeColor"
            },
            m: {
                reader: "readMIDIBytes",
                writer: "writeMIDIBytes"
            }
        }, l.inferTypeForArgument = function(e) {
            switch (typeof e) {
              case "boolean":
                return e ? "T" : "F";

              case "string":
                return "s";

              case "number":
                return "f";

              case "undefined":
                return "N";

              case "object":
                if (null === e) return "N";
                if (e instanceof Uint8Array || e instanceof ArrayBuffer) return "b";
                if ("number" == typeof e.high && "number" == typeof e.low) return "h";
            }
            throw new Error("Can't infer OSC argument type for value: " + JSON.stringify(e, null, 2));
        }, l.annotateArguments = function(e) {
            for (var t = [], r = 0; r < e.length; r++) {
                var n, i = e[r];
                if ("object" == typeof i && i.type && void 0 !== i.value) n = i; else if (l.isArray(i)) n = l.annotateArguments(i); else {
                    n = {
                        type: l.inferTypeForArgument(i),
                        value: i
                    };
                }
                t.push(n);
            }
            return t;
        }, l.isCommonJS && (module.exports = l);
    }();
    l = l || require("./osc.js"), i = i || require("slip"), t = t || require("events").EventEmitter;
    !function() {
        "use strict";
        l.supportsSerial = !1, l.firePacketEvents = function(e, t, r, n) {
            t.address ? e.emit("message", t, r, n) : l.fireBundleEvents(e, t, r, n);
        }, l.fireBundleEvents = function(e, t, r, n) {
            e.emit("bundle", t, r, n);
            for (var i = 0; i < t.packets.length; i++) {
                var a = t.packets[i];
                l.firePacketEvents(e, a, t.timeTag, n);
            }
        }, l.fireClosedPortSendError = function(e, t) {
            t = t || "Can't send packets on a closed osc.Port object. Please open (or reopen) this Port by calling open().", 
            e.emit("error", t);
        }, l.Port = function(e) {
            this.options = e || {}, this.on("data", this.decodeOSC.bind(this));
        };
        var e = l.Port.prototype = Object.create(t.prototype);
        e.constructor = l.Port, e.send = function(e) {
            var t = Array.prototype.slice.call(arguments), r = this.encodeOSC(e), n = l.nativeBuffer(r);
            t[0] = n, this.sendRaw.apply(this, t);
        }, e.encodeOSC = function(e) {
            var t;
            e = e.buffer ? e.buffer : e;
            try {
                t = l.writePacket(e, this.options);
            } catch (e) {
                this.emit("error", e);
            }
            return t;
        }, e.decodeOSC = function(e, t) {
            e = l.byteArray(e), this.emit("raw", e, t);
            try {
                var r = l.readPacket(e, this.options);
                this.emit("osc", r, t), l.firePacketEvents(this, r, void 0, t);
            } catch (e) {
                this.emit("error", e);
            }
        }, l.SLIPPort = function(e) {
            var t = this, r = this.options = e || {};
            r.useSLIP = void 0 === r.useSLIP || r.useSLIP, this.decoder = new i.Decoder({
                onMessage: this.decodeOSC.bind(this),
                onError: function(e) {
                    t.emit("error", e);
                }
            });
            var n = r.useSLIP ? this.decodeSLIPData : this.decodeOSC;
            this.on("data", n.bind(this));
        }, (e = l.SLIPPort.prototype = Object.create(l.Port.prototype)).constructor = l.SLIPPort, 
        e.encodeOSC = function(e) {
            var t;
            e = e.buffer ? e.buffer : e;
            try {
                var r = l.writePacket(e, this.options);
                t = i.encode(r);
            } catch (e) {
                this.emit("error", e);
            }
            return t;
        }, e.decodeSLIPData = function(e, t) {
            this.decoder.decode(e, t);
        }, l.relay = function(e, t, r, n, i, a) {
            r = r || "message", n = n || "send", i = i || function() {}, a = a ? [ null ].concat(a) : [];
            function o(e) {
                a[0] = e, e = i(e), t[n].apply(t, a);
            }
            return e.on(r, o), {
                eventName: r,
                listener: o
            };
        }, l.relayPorts = function(e, t, r) {
            var n = r.raw ? "raw" : "osc", i = r.raw ? "sendRaw" : "send";
            return l.relay(e, t, n, i, r.transform);
        }, l.stopRelaying = function(e, t) {
            e.removeListener(t.eventName, t.listener);
        }, l.Relay = function(e, t, r) {
            (this.options = r || {}).raw = !1, this.port1 = e, this.port2 = t, this.listen();
        }, (e = l.Relay.prototype = Object.create(t.prototype)).constructor = l.Relay, e.open = function() {
            this.port1.open(), this.port2.open();
        }, e.listen = function() {
            this.port1Spec && this.port2Spec && this.close(), this.port1Spec = l.relayPorts(this.port1, this.port2, this.options), 
            this.port2Spec = l.relayPorts(this.port2, this.port1, this.options);
            var e = this.close.bind(this);
            this.port1.on("close", e), this.port2.on("close", e);
        }, e.close = function() {
            l.stopRelaying(this.port1, this.port1Spec), l.stopRelaying(this.port2, this.port2Spec), 
            this.emit("close", this.port1, this.port2);
        }, "undefined" != typeof module && module.exports && (module.exports = l);
    }();
    l = l || require("./osc.js");
    return function() {
        "use strict";
        l.WebSocket = "undefined" != typeof WebSocket ? WebSocket : require("ws"), l.WebSocketPort = function(e) {
            l.Port.call(this, e), this.on("open", this.listen.bind(this)), this.socket = e.socket, 
            this.socket && (1 === this.socket.readyState ? (l.WebSocketPort.setupSocketForBinary(this.socket), 
            this.emit("open", this.socket)) : this.open());
        };
        var e = l.WebSocketPort.prototype = Object.create(l.Port.prototype);
        e.constructor = l.WebSocketPort, e.open = function() {
            (!this.socket || 1 < this.socket.readyState) && (this.socket = new l.WebSocket(this.options.url)), 
            l.WebSocketPort.setupSocketForBinary(this.socket);
            var t = this;
            this.socket.onopen = function() {
                t.emit("open", t.socket);
            }, this.socket.onerror = function(e) {
                t.emit("error", e);
            };
        }, e.listen = function() {
            var t = this;
            this.socket.onmessage = function(e) {
                t.emit("data", e.data, e);
            }, this.socket.onclose = function(e) {
                t.emit("close", e);
            }, t.emit("ready");
        }, e.sendRaw = function(e) {
            this.socket && 1 === this.socket.readyState ? this.socket.send(e) : l.fireClosedPortSendError(this);
        }, e.close = function(e, t) {
            this.socket.close(e, t);
        }, l.WebSocketPort.setupSocketForBinary = function(e) {
            e.binaryType = l.isNode ? "nodebuffer" : "arraybuffer";
        };
    }(), l;
});