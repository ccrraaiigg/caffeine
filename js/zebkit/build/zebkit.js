(function() {
    var zebkitEnvironment = function() {
        var pkg    = {},
            hostRe = /([a-zA-Z]+)\:\/\/([^/:]+)/,
            isFF   = typeof navigator !== 'undefined' &&
                     navigator.userAgent.toLowerCase().indexOf('firefox') >= 0;

        function $sleep() {
            var r = new XMLHttpRequest(),
                t = (new Date()).getTime().toString(),
                i = window.location.toString().lastIndexOf("?");
            r.open('GET', window.location + (i > 0 ? "&" : "?") + t, false);
            r.send(null);
        }

        function $Request() {
            this.responseText = this.statusText = "";
            this.onreadystatechange = this.responseXml = null;
            this.readyState = this.status = 0;
        }

        $Request.prototype.open = function(method, url, async, user, password) {
            var m = url.match(hostRe);
            if (location.scheme.toLowerCase() === "file:" ||
                  (m           !== null &&
                   typeof m[2] !== 'undefined' &&
                   m[2].toLowerCase() === location.host.toLowerCase()))
            {
                this._request = new XMLHttpRequest();
                this._xdomain = false;

                var $this = this;
                this._request.onreadystatechange = function() {
                    $this.readyState = $this._request.readyState;
                    if ($this._request.readyState === 4) {
                        $this.responseText = $this._request.responseText;
                        $this.responseXml  = $this._request.responseXml;
                        $this.status       = $this._request.status;
                        $this.statusText   = $this._request.statusText;
                    }

                    if ($this.onreadystatechange) {
                        $this.onreadystatechange();
                    }
                };

                return this._request.open(method, url, (async !== false), user, password);
            } else {
                this._xdomain = true;
                this._async = (async === true);
                this._request = new XDomainRequest();
                return this._request.open(method, url);
            }
        };

        $Request.prototype.send = function(data) {
            if (this._xdomain) {
                var originalReq = this._request,
                    $this       = this;

                //!!!! handler has to be defined after
                //!!!! open method has been called and all
                //!!!! four handlers have to be defined
                originalReq.ontimeout = originalReq.onprogress = function () {};

                originalReq.onerror = function() {
                    $this.readyState = 4;
                    $this.status = 404;
                    if ($this._async && $this.onreadystatechange) {
                        $this.onreadystatechange();
                    }
                };

                originalReq.onload  = function() {
                    $this.readyState = 4;
                    $this.status = 200;

                    if ($this._async && $this.onreadystatechange) {
                        $this.onreadystatechange(originalReq.responseText, originalReq);
                    }
                };

                //!!! set time out zero to prevent data lost
                originalReq.timeout = 0;

                if (this._async === false) {
                    originalReq.send(data);

                    while (this.status === 0) {
                        pkg.$sleep();
                    }

                    this.readyState = 4;
                    this.responseText = originalReq.responseText;

                } else {
                    //!!!  short timeout to make sure bloody IE is ready
                    setTimeout(function () {
                       originalReq.send(data);
                    }, 10);
                }
            } else  {
                return this._request.send(data);
            }
        };

        $Request.prototype.abort = function(data) {
            return this._request.abort();
        };

        $Request.prototype.setRequestHeader = function(name, value) {
            if (this._xdomain) {
                if (name === "Content-Type") {
                    //!!!
                    // IE8 and IE9 anyway don't take in account the assignment
                    // IE8 throws exception every time a value is assigned to
                    // the property
                    // !!!
                    //this._request.contentType = value;
                    return;
                } else {
                    throw new Error("Method 'setRequestHeader' is not supported for " + name);
                }
            } else {
                this._request.setRequestHeader(name, value);
            }
        };

        $Request.prototype.getResponseHeader = function(name) {
            if (this._xdomain) {
                throw new Error("Method is not supported");
            }
            return this._request.getResponseHeader(name);
        };

        $Request.prototype.getAllResponseHeaders = function() {
            if (this._xdomain) {
                throw new Error("Method is not supported");
            }
            return this._request.getAllResponseHeaders();
        };

        pkg.getHttpRequest = function() {
            if (typeof XMLHttpRequest !== "undefined") {
                var r = new XMLHttpRequest();

                if (isFF) {
                    r.__send = r.send;
                    r.send = function(data) {
                        // !!! FF can throw NS_ERROR_FAILURE exception instead of
                        // !!! returning 404 File Not Found HTTP error code
                        // !!! No request status, statusText are defined in this case
                        try { return this.__send(data); }
                        catch(e) {
                            if (!e.message || e.message.toUpperCase().indexOf("NS_ERROR_FAILURE") < 0) {
                                // exception has to be re-instantiate to be Error class instance
                                throw new Error(e.toString());
                            }
                        }
                    };
                }
                return ("withCredentials" in r) ? r  // CORS is supported out of box
                                                : new $Request(); // IE
            }
            throw new Error("Archaic browser detected");
        };

        pkg.parseXML = function(s) {
            function rmws(node) {
                if (node.childNodes !== null) {
                    for (var i = node.childNodes.length; i-- > 0;) {
                        var child= node.childNodes[i];
                        if (child.nodeType === 3 && child.data.match(/^\s*$/) !== null) {
                            node.removeChild(child);
                        }

                        if (child.nodeType === 1) {
                            rmws(child);
                        }
                    }
                }
                return node;
            }

            if (typeof DOMParser !== "undefined") {
                return rmws((new DOMParser()).parseFromString(s, "text/xml"));
            } else {
                for (var n in { "Microsoft.XMLDOM":0, "MSXML2.DOMDocument":1, "MSXML.DOMDocument":2 }) {
                    var p = null;
                    try {
                        p = new ActiveXObject(n);
                        p.async = false;
                    } catch (e) {
                        continue;
                    }

                    if (p === null) {
                        throw new Error("XML parser is not available");
                    }
                    p.loadXML(s);
                    return p;
                }
            }
            throw new Error("No XML parser is available");
        };

        /**
         * Loads an image by the given URL.
         * @param  {String|HTMLImageElement} img an image URL or image object
         * @param  {Function} ready a call back method to be notified when the image has been completely
         * loaded or failed. The method gets three parameters

            - an URL to the image
            - boolean loading result. true means success
            - an image that has been loaded

        * @example
            // load image
            zebkit.environment.loadImage("test.png", function(image) {
                 // handle loaded image
                 ...
            }, function (img, exception) {
                // handle error
                ...
            });
         * @return {HTMLImageElement}  an image
         * @for  zebkit.web
         * @method  loadImage
         */
        pkg.loadImage = function(ph, success, error) {
            var img = null;
            if (ph instanceof Image) {
                img = ph;
            } else {
                img = new Image();
                img.crossOrigin = '';
                img.crossOrigin ='anonymous';
                img.src = ph;
            }

            if (img.complete === true && img.naturalWidth !== 0) {
                success.call(this, img);
            } else {
                var pErr  = img.onerror,
                    pLoad = img.onload,
                    $this = this;

                img.onerror = function(e) {
                    img.onerror = null;
                    try {
                        if (typeof error !== 'undefined') {
                            error.call($this, img, new Error("Image '" + ph + "' cannot be loaded " + e));
                        }
                    } finally {
                        if (typeof pErr === 'function') {
                            img.onerror = pErr;
                            pErr.call(this, e);
                        }
                    }
                };

                img.onload  = function(e) {
                    img.onload = null;
                    try {
                        success.call($this, img);
                    } finally {
                        if (typeof pLoad === 'function') {
                            img.onload = pLoad;
                            pLoad.call(this, e);
                        }
                    }
                };
            }

            return img;
        };

        pkg.parseJSON = JSON.parse;

        pkg.stringifyJSON = JSON.stringify;

        pkg.setInterval = function (cb, time) {
            return window.setInterval(cb, time);
        };

        pkg.clearInterval = function (id) {
            return window.clearInterval(id);
        };

        if (typeof window !== 'undefined') {
            var $taskMethod = window.requestAnimationFrame       ||
                              window.webkitRequestAnimationFrame ||
                              window.mozRequestAnimationFrame    ||
                              function(callback) { return setTimeout(callback, 35); };

            pkg.decodeURIComponent = window.decodeURIComponent;
            pkg.encodeURIComponent = window.encodeURIComponent;

        } else {
            pkg.decodeURIComponent = function(s) { return s; } ;
            pkg.encodeURIComponent = function(s) { return s; } ;
        }

        /**
         * Request to run a method as an animation task.
         * @param  {Function} f the task body method
         * @method  animate
         * @for  zebkit.web
         */
        pkg.animate = function(f){
            return $taskMethod.call(window, f);
        };

        function buildFontHelpers() {
            //  font metrics API
            var e = document.getElementById("zebkit.fm");
            if (e === null) {
                e = document.createElement("div");
                e.setAttribute("id", "zebkit.fm");  // !!! position fixed below allows to avoid 1px size in HTML layout for "zebkit.fm" element
                e.setAttribute("style", "visibility:hidden;line-height:0;height:1px;vertical-align:baseline;position:fixed;");
                e.innerHTML = "<span id='zebkit.fm.text' style='display:inline;vertical-align:baseline;'>&nbsp;</span>" +
                              "<img id='zebkit.fm.image' style='width:1px;height:1px;display:inline;vertical-align:baseline;' width='1' height='1'/>";
                document.body.appendChild(e);
            }
            var $fmCanvas = document.createElement("canvas").getContext("2d"),
                $fmText   = document.getElementById("zebkit.fm.text"),
                $fmImage  = document.getElementById("zebkit.fm.image");

            $fmImage.onload = function() {
                // TODO: hope the base64 specified image load synchronously and
                // checking it with "join()"
            };

            // set 1x1 transparent picture
            $fmImage.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAApJREFUCNdjYAAAAAIAAeIhvDMAAAAASUVORK5CYII%3D';

            pkg.fontMeasure = $fmCanvas;

            pkg.fontStringWidth = function(font, str) {
                if (str.length === 0) {
                    return 0;
                } else {
                    if ($fmCanvas.font !== font) {
                        $fmCanvas.font = font;
                    }
                    return ($fmCanvas.measureText(str).width + 0.5) | 0;
                }
            };

            pkg.fontMetrics = function(font) {
                if ($fmText.style.font !== font) {
                    $fmText.style.font = font;
                }

                var height = $fmText.offsetHeight;
                //!!!
                // Something weird is going sometimes in IE10 !
                // Sometimes the property offsetHeight is 0 but
                // second attempt to access to the property gives
                // proper result
                if (height === 0) {
                    height = $fmText.offsetHeight;
                }

                return {
                    height : height,
                    ascent : $fmImage.offsetTop - $fmText.offsetTop + 1
                };
            };
        }

        if (typeof document !== 'undefined') {
            document.addEventListener("DOMContentLoaded", buildFontHelpers);
        }

        return pkg;
    };

    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
        module.exports.zebkitEnvironment = zebkitEnvironment;

        // TODO:
        // typeof the only way to make environment visible is makling it global
        // since module cannot be applied in the ase of browser context
        if (typeof global !== 'undefined') {
            global.zebkitEnvironment = zebkitEnvironment;
        }
    } else {
        window.zebkitEnvironment = zebkitEnvironment;
    }
})();
(function() {
/**
 * This is the core package that provides powerful easy OOP concept, packaging
 * and number of utility methods. The package doesn't have any dependencies
 * from others zebkit packages and can be used independently. Briefly the
 * package possibilities are listed below:

   - **easy OOP concept**. Use "zebkit.Class" and "zebkit.Interface" to declare
     classes and interfaces

    ```JavaScript
        // declare class A
        var ClassA = zebkit.Class([
            function() { // class constructor
                ...
            },
            // class method
            function a(p1, p2, p3) { ... }
        ]);

        var ClassB = zebkit.Class(ClassA, [
            function() {  // override constructor
                this.$super(); // call super constructor
            },

            function a(p1, p2, p3) { // override method "a"
                this.$super(p1, p2, p3);  // call super implementation of method "a"
            }
        ]);

        var b = new ClassB(); // instantiate classB
        b.a(1,2,3); // call "a"

        // instantiate anonymous class with new method "b" declared and
        // overridden method "a"
        var bb = new ClassB([
            function a(p1, p2, p3) { // override method "a"
                this.$super(p1, p2, p3);  // call super implementation of method "a"
            },

            function b() { ... } // declare method "b"
        ]);

        b.a();
        b.b();
    ```

   - **Packaging.** Zebkit uses Java-like packaging system where your code is bundled in
      the number of hierarchical packages.

    ```JavaScript
        // declare package "zebkit.test"
        zebkit.package("test", function(pkg) {
            // declare class "Test" in the package
            pkg.Test = zebkit.Class([ ... ]);
        });

        ...
        // Later on use class "Test" from package "zebkit.test"
        zebkit.require("test", function(test) {
            var test = new test.Test();
        });
    ```

    - **Resources loading.** Resources should be loaded with a special method to guarantee
      its proper loading in zebkit sequence and the loading completeness.

    ```JavaScript
        // declare package "zebkit.test"
        zebkit.resources("http://my.com/test.jpg", function(img) {
            // handle completely loaded image here
            ...
        });

        zebkit.package("test", function(pkg, Class) {
            // here we can be sure all resources are loaded and ready
        });
    ```

   - **Declaring number of core API method and classes**
      - **"zebkit.DoIt"** - improves Promise like alternative class
      - **"zebkit.URI"** - URI helper class
      - **"zebkit.Dummy"** - dummy class
      - **instanceOf(...)** method to evaluate zebkit classes and and interfaces inheritance.
        The method has to be used instead of JS "instanceof" operator to provide have valid
        result.
      - **zebkit.newInstance(...)** method
      - **zebkit.clone(...)**  method
      - etc

 * @class zebkit
 * @access package
 */

    // Environment specific stuff
    var zenv = {},
        isInBrowser = typeof navigator !== "undefined",
        $global     = (typeof window !== "undefined" && window !== null) ? window
                                                                         : (typeof global !== 'undefined' ? global
                                                                                                          : this);
    if (typeof zebkitEnvironment === 'function') {
        zenv = zebkitEnvironment();
    } else {
        if (typeof window !== 'undefined') {
            zenv = window;
        }
    }

    // ( (http) :// (host)? (:port)? (/)? )? (path)? (?query_string)?
    //
    //  [1] scheme://host/
    //  [2] scheme
    //  [3] host
    //  [4]  port
    //  [5] /
    //  [6] path
    //  [7] ?query_string
    //
    var $uriRE = /^(([a-zA-Z]+)\:\/\/([^\/:]+)?(\:[0-9]+)?(\/)?)?([^?]+)?(\?.+)?/;

    /**
     * URI class. Pass either a full uri (as a string or zebkit.URI) or number of an URI parts
     * (scheme, host, etc) to constructor it.
     * @param {String} [uri] an URI.
     * @param {String} [scheme] a scheme.
     * @param {String} [host] a host.
     * @param {String|Integer} [port] a port.
     * @param {String} [path] a path.
     * @param {String} [qs] a query string.
     * @constructor
     * @class zebkit.URI
     */
    function URI(uri) {
        if (arguments.length > 1) {
            if (arguments[0] !== null) {
                this.scheme = arguments[0].toLowerCase();
            }

            if (arguments[1] !== null) {
                this.host = arguments[1];
            }

            var ps = false;
            if (arguments.length > 2) {
                if (isNumber(arguments[2])) {
                    this.port = arguments[2];
                } else if (arguments[2] !== null) {
                    this.path = arguments[2];
                    ps = true;
                }
            }

            if (arguments.length > 3) {
                if (ps === true) {
                    this.qs = arguments[3];
                } else {
                    this.path = arguments[3];
                }
            }

            if (arguments.length > 4) {
                this.qs = arguments[4];
            }
        } else if (uri instanceof URI) {
            this.host   = uri.host;
            this.path   = uri.path;
            this.qs     = uri.qs;
            this.port   = uri.port;
            this.scheme = uri.scheme;
        } else {
            var m = uri.match($uriRE);
            if (m === null) {
                throw new Error("Invalid URI '" + uri + "'");
            }

            // fetch scheme
            if (typeof m[1] !== 'undefined') {
                this.scheme = m[2].toLowerCase();

                if (typeof m[3] === 'undefined') {
                    if (this.scheme !== "file") {
                        throw new Error("Invalid host name : '" + url + "'");
                    }
                } else {
                    this.host = m[3];
                }

                if (typeof m[4] !== 'undefined') {
                    this.port = parseInt(m[4].substring(1), 10);
                }
            }

            // fetch path
            if (typeof m[6] !== 'undefined') {
                this.path = m[6];
            } else if (typeof m[1] !== 'undefined') {
                throw new Error("Invalid URL '" + url + "'");
            }

            if (typeof m[7] !== 'undefined' && m[7].length > 1) {
                this.qs = m[7].substring(1).trim();
            }
        }

        if (this.path !== null) {
            this.path = this.path.replace(/\/\/*/g, '/');

            var l = this.path.length;
            if (l > 1 && this.path[l - 1] === '/') {
                this.path = this.path.substring(0, l - 1);
            }

            if ((this.host !== null || this.scheme !== null) && this.path[0] !== '/') {
                this.path = "/" + this.path;
            }
        }

        /**
         * URI path.
         * @attribute path
         * @type {String}
         * @readOnly
         */

        /**
         * URI host.
         * @attribute host
         * @type {String}
         * @readOnly
         */

        /**
         * URI port number.
         * @attribute port
         * @type {Integer}
         * @readOnly
         */

        /**
         * URI query string.
         * @attribute qs
         * @type {String}
         * @readOnly
         */

         /**
          * URI scheme (e.g. 'http', 'ftp', etc).
          * @attribute scheme
          * @type {String}
          * @readOnly
          */
    }

    URI.prototype = {
        scheme   : null,
        host     : null,
        port     : -1,
        path     : null,
        qs       : null,

        /**
         * Serialize URI to its string representation.
         * @method  toString
         * @return {String} an URI as a string.
         */
        toString : function() {
            return (this.scheme !== null ? this.scheme + "://" : '') +
                   (this.host !== null ? this.host : '' ) +
                   (this.port !== -1   ? ":" + this.port : '' ) +
                   (this.path !== null ? this.path : '' ) +
                   (this.qs   !== null ? "?" + this.qs : '' );
        },

        /**
         * Get a parent URI.
         * @method getParent
         * @return {zebkit.URI} a parent URI.
         */
        getParent : function() {
            if (this.path === null) {
                return null;
            } else {
                var i = this.path.lastIndexOf('/');
                return (i < 0 || this.path === '/') ? null
                                                    : new zebkit.URI(this.scheme,
                                                                     this.host,
                                                                     this.port,
                                                                     this.path.substring(0, i),
                                                                     this.qs);
            }
        },

        /**
         * Append the given parameters to a query string of the URI.
         * @param  {Object} obj a dictionary of parameters to be appended to
         * the URL query string
         * @method appendQS
         */
        appendQS : function(obj) {
            if (obj !== null) {
                if (this.qs === null) {
                    this.qs = '';
                }

                if (this.qs.length > 0) {
                    this.qs = this.qs + "&" + URI.toQS(obj);
                } else {
                    this.qs = URI.toQS(obj);
                }
            }
        }
    };

    /**
     * Test if the given string is absolute path or URI.
     * @param  {String|zebkit.URI}  u an URI
     * @return {Boolean} true if the string is absolute path or URI.
     * @method isAbsolute
     * @static
     */
    URI.isAbsolute = function(u) {
        return u[0] === '/' || /^[a-zA-Z]+\:\/\//i.test(u);
    };

    /**
     * Test if the given string is URL.
     * @param  {String}  u a string to be checked.
     * @return {Boolean} true if the string is URL
     * @method isURL
     * @static
     */
    URI.isURL = function(u) {
        return /^[a-zA-Z]+\:\/\//i.test(u);
    };

    /**
     * Parse the specified query string of the given URI.
     * @param  {String} url an URI
     * @param  {Boolean} [decode] pass true if query string has to be decoded.
     * @return {Object} a parsed query string as a dictionary of parameters
     * @method parseQS
     * @static
     */
    URI.parseQS = function(qs, decode) {
        var mqs      = qs.match(/[a-zA-Z0-9_.]+=[^?&=]+/g),
            parsedQS = {};

        if (mqs !== null) {
            for(var i = 0; i < mqs.length; i++) {
                var q = mqs[i].split('=');
                this.parsedQS[q[0].substring(1)] = (decode === true ? zebkit.environment.decodeURIComponent(q[1])
                                                                    : q[1]);
            }
        }

        return parsedQS;
    };

    /**
     * Convert the given dictionary of parameters to a query string.
     * @param  {Object} obj a dictionary of parameters
     * @param  {Boolean} [encode] pass true if the parameters values have to be
     * encoded
     * @return {String} a query string built from parameters list
     * @static
     * @method toQS
     */
    URI.toQS = function(obj, encode) {
        if (zebkit.isString(obj) || zebkit.isBoolean(obj) || zebkit.isNumber(obj)) {
            return "" + obj;
        }

        var p = [];
        for(var k in obj) {
            if (obj.hasOwnProperty(k)) {
                p.push(k + '=' + (encode === true ? zebkit.environment.encodeURIComponent(obj[k].toString())
                                                  : obj[k].toString()));
            }
        }
        return p.join("&");
    };


    /**
     * Join the given  paths
     * @param  {String} p* a relative paths
     * @return {String} an absolute URI
     * @method join
     * @static
     */
    URI.join = function() {
        var pu = new URI(arguments[0]);

        for(var i = 1; i < arguments.length; i++) {
            var p = arguments[i].toString().trim();
            if (p.length === 0 || URI.isAbsolute(p)) {
                throw new Error("Absolute path '" + p + "' cannot be joined");
            }

            p = p.replace(/\/\/*/g, '/');
            if (p[p.length - 1] === '/' ) {
                p = p.substring(0, p.length - 1);
            }

            if (pu.path === null) {
                pu.path = p;
                if ((pu.host !== null || pu.scheme !== null) && pu.path[0] !== '/') {
                    pu.path = "/" + pu.path;
                }
            } else {
                pu.path = pu.path + "/" + p;
            }
        }

        return pu.toString();
    };

    /**
     * Sequential tasks runner (D-then). Allows developers to execute number of steps (async and sync) in the
     * exact order they have been called by runner. The ideas of the runner implementation is making the
     * code more readable and plain nevertheless it includes asynchronous parts:
     * @example

        var r = new zebkit.DoIt();

        // step 1
        r.then(function() {
            // call three asynchronous HTTP GET requests to read three files
            // pass join to every async. method to be notified when the async.
            // part is completed
            asyncHttpCall("http://test.com/a.txt", this.join());
            asyncHttpCall("http://test.com/b.txt", this.join());
            asyncHttpCall("http://test.com/c.txt", this.join());
        })
        .  // step 2
        then(function(r1, r2, r3) {
            // handle completely read on previous step files
            r1.responseText  // "a.txt" file content
            r2.responseText  // "b.txt" file content
            r3.responseText  // "c.txt" file content
        })
        . // handle error
        catch(function(e) {
            // called when an exception has occurred
            ...
        });


     * @class zebkit.DoIt
     * @param {Boolean} [ignore] flag to rule error ignorance
     * @constructor
     */
    function DoIt(body, ignore) {
        this.recover();

        if (arguments.length === 1) {
            if (zebkit.isBoolean(body)) {
                this.$ignoreError = body;
                body = null;
            } else {
                this.then(body);
            }
        } else if (arguments.length === 2) {
            this.$ignoreError = ignore;
            this.then(body);
        }
    }

    DoIt.prototype = {
        // TODO: not stable API
        recover : function(body) {
            if (this.$error !== null) {
                var err = this.$error;
                this.$error = null;
                this.$tasks   = [];
                this.$results = [];
                this.$taskCounter = this.$level = this.$busy = 0;

                if (arguments.length === 1) {
                    body.call(this, err);
                }
            }
        },

        /**
         * Restart the do it object to clear error that has happened and
         * continue tasks that has not been run yet because of the error.
         * @method  restart
         * @chainable
         */
        restart : function() {
            if (this.$error !== null) {
                this.$error = null;
            }
            this.$schedule();
            return this;
        },

        /**
         * Run the given method as one of the sequential step of the doit execution.
         * @method  then
         * @param  {Function} body a method to be executed. The method can get results
         * of previous step execution as its arguments. The method is called in context
         * of instance of a DoIt instance.
         * @chainable
         */
        then : function(body, completed) {
            var level = this.$level;  // store level then was executed for the given task
                                      // to be used to compute correct the level inside the
                                      // method below
            if (body instanceof DoIt) {
                if (body.$error !== null) {
                    this.error(body.$error);
                } else {
                    var $this = this;
                    this.then(function() {
                        var jn = $this.join();
                        body.then(function(res) {
                            if (arguments.length > 0) {
                                // also pass result to body DoIt
                                this.join.apply(this, arguments);
                            }
                        }, function() {
                            if ($this.$error === null) {
                                jn.apply($this, arguments);
                            }
                        }).catch(function(e) {
                            $this.error(e);
                        });
                    });
                }

                return this;
            } else {
                var task = function() {
                    // clean results of execution of a previous task

                    this.$busy = 0;
                    var pc = this.$taskCounter, args = null, r;

                    if (this.$error === null) {
                        if (typeof this.$results[level] !== 'undefined') {
                            args = this.$results[level];
                        }

                        this.$taskCounter    = 0;  // we have to count the tasks on this level
                        this.$level          = level + 1;
                        this.$results[level] = [];

                        // it is supposed the call is embedded with other call, no need to
                        // catch it one more time
                        if (level > 0) {
                            r = body.apply(this, args);
                        } else {
                            try {
                                r = body.apply(this, args);
                            } catch(e) {
                                this.error(e);
                            }
                        }

                        // this.$busy === 0 means we have called synchronous task
                        // and make sure the task has returned a result
                        if (this.$busy === 0 && this.$error === null && typeof r !== "undefined") {
                            this.$results[level] = [ r ];
                        }
                    }

                    if (level === 0) {
                        // zero level is responsible for handling exception
                        try {
                            this.$schedule();
                        } catch(e) {
                            this.error(e);
                        }
                    } else {
                        this.$schedule();
                    }

                    this.$level = level; // restore level
                    this.$taskCounter = pc;  // restore counter

                    // TODO: not a graceful solution. It has been done to let call "join" out
                    // outside of body. Sometimes it is required to provide proper level of
                    // execution since join calls schedule
                    if (typeof completed === 'function') {
                        if (level === 0) {
                            try {
                                if (args === null) completed.call(this);
                                else               completed.apply(this, args);
                            } catch(e) {
                                this.error(e);
                            }
                        } else {
                            if (args === null) completed.call(this);
                            else               completed.apply(this, args);
                        }
                    }
                    if (args !== null) args.length = 0;
                };

                if (this.$error === null) {
                    if (level === 0 && this.$busy === 0) {
                        if (this.$results[level] != null && this.$results[level].length > 0) {
                            task.apply(this, this.$results[level]);
                        } else {
                            task.call(this);
                        }
                    } else {
                        // put task in list
                        if (this.$level > 0) {
                            this.$tasks.splice(this.$taskCounter++, 0, task);
                        } else {
                            this.$tasks.push(task);
                        }
                    }
                }
            }

            if (this.$level === 0) {
                this.$schedule();
            }

            return this;
        },

        $ignored : function(e) {
            zebkit.dumpError(e);
        },

        /**
         * Force to fire error.
         * @param  {Error} e an error to be fired
         * @method error
         * @chainable
         */
        error : function(e, pr) {
            if (arguments.length === 0) {
                if (this.$error !== null) {
                    zebkit.dumpError(e);
                }
            } else {
                if (this.$error === null) {
                    if (this.$ignoreError) {
                        this.$ignored(e);
                    } else {
                        this.$taskCounter = this.$level = this.$busy = 0;
                        this.$error   = e;
                        this.$results = [];
                    }

                    this.$schedule();
                } else {
                    if (arguments.length < 2 || pr === true) {
                        zebkit.dumpError(e);
                    }
                }
            }

            return this;
        },

        /**
         * Wait before the given doit is ready to be called.
         * @param  {zebkit.DoIt} r a runner
         * @example
         *
         *      var async = new DoIt().then(function() {
         *          // imagine we do asynchronous ajax call
         *          ajaxCall("http://test.com/data", this.join());
         *      });
         *
         *      var doit = new DoIt().till(async).then(function(res) {
         *          // handle result that has been fetched
         *          // by "async" do it
         *          ...
         *      });
         *
         * @chainable
         * @method till
         */
        till : function(r) {
            // wait till the given DoIt is executed
            this.then(function() {
                var $this = this,
                    jn    = this.join(), // block execution of the runner
                    res   = arguments.length > 0 ? Array.prototype.slice.call(arguments) : []; // save arguments to restore it later

                // call "doit" we are waiting for
                r.then(function() {
                    if ($this.$error === null) {
                        // unblock the doit that waits for the runner we are in and
                        // restore its arguments
                        if (res.length > 0) jn.apply($this, res);
                        else                jn.call($this);

                        // preserve arguments for the next call
                        if (arguments.length > 0) {
                            this.join.apply(this, arguments);
                        }
                    }
                }).catch(function(e) {
                    // delegate error to a waiting runner
                    $this.error(e);
                });
            });

            return this;
        },

        /**
         * Returns join callback for asynchronous parts of the doit. The callback
         * has to be requested and called by an asynchronous method to inform the
         * doit the given method is completed.
         * @example
         *
         *      var d = new DoIt().then(function() {
         *          // imagine we call ajax HTTP requests
         *          ajaxCall("http://test.com/data1", this.join());
         *          ajaxCall("http://test.com/data2", this.join());
         *      }).then(function(res1, res2) {
         *          // handle results of ajax requests from previous step
         *          ...
         *      });
         *
         * @return {Function} a method to notify doit the given asynchronous part
         * has been completed. The passed to the method arguments will be passed
         * to the next step of the runner.         *
         * @method join
         */
        join : function() {
            // if join is called outside runner than level is set to 0
            var level = this.$level === 0 ? 0 : this.$level - 1;

            if (arguments.length > 0) {
                this.$results[level] = [];
                for(var i = 0; i < arguments.length; i++) {
                    this.$results[level][i] = arguments[i];
                }
            } else {
                // TODO: join uses busy flag to identify the result index the given join will supply
                // what triggers a potential result overwriting  problem (jn2 overwrite jn1  result):
                //    var jn1 = join(); jn1();
                //    var jn2 = join(); jn2();

                var $this = this,
                    index = this.$busy++;

                return function() {
                    if ($this.$results[level] == null) {
                        $this.$results[level] = [];
                    }

                    // since error can occur and times variable
                    // can be reset to 0 we have to check it
                    if ($this.$busy > 0) {
                        var i = 0;

                        if (arguments.length > 0) {
                            $this.$results[level][index] = [];
                            for(i = 0; i < arguments.length; i++) {
                                $this.$results[level][index][i] = arguments[i];
                            }
                        }

                        if (--$this.$busy === 0) {
                            // collect result
                            if ($this.$results[level].length > 0) {
                                var args = $this.$results[level],
                                    res  = [];

                                for(i = 0; i < args.length; i++) {
                                    Array.prototype.push.apply(res, args[i]);
                                }
                                $this.$results[level] = res;
                            }

                            // TODO: this code can bring to unexpected scheduling for a situation when
                            // doit is still in then:
                            //    then(function () {
                            //        var jn1 = join();
                            //        ...
                            //        jn1()  // unexpected scheduling of the next then since busy is zero
                            //        ...
                            //        var jn2 = join(); // not actual
                            //    })

                            $this.$schedule();
                        }
                    }
                };
            }
        },

        /**
         * Method to catch error that has occurred during the doit sequence execution.
         * @param  {Function} [body] a callback to handle the error. The method
         * gets an error that has happened as its argument. If there is no argument
         * the error will be printed in output. If body is null then no error output
         * is expected.
         * @chainable
         * @method catch
         */
        catch : function(body) {
            var level = this.$level;  // store level then was executed for the given task
                                      // to be used to compute correct the level inside the
                                      // method below

            var task = function() {
                // clean results of execution of a previous task

                this.$busy = 0;
                var pc = this.$taskCounter;
                if (this.$error !== null) {
                    this.$taskCounter = 0;  // we have to count the tasks on this level
                    this.$level       = level + 1;

                    try {
                        if (typeof body === 'function') {
                            body.call(this, this.$error);
                        } else if (body === null) {

                        } else {
                            zebkit.dumpError(this.$error);
                        }
                    } catch(e) {
                        this.$level       = level; // restore level
                        this.$taskCounter = pc;    // restore counter
                        throw e;
                    }
                }

                if (level === 0) {
                    try {
                        this.$schedule();
                    } catch(e) {
                        this.error(e);
                    }
                } else {
                    this.$schedule();
                }

                this.$level       = level; // restore level
                this.$taskCounter = pc;    // restore counter
            };

            if (this.$level > 0) {
                this.$tasks.splice(this.$taskCounter++, 0, task);
            } else {
                this.$tasks.push(task);
            }

            if (this.$level === 0) {
                this.$schedule();
            }

            return this;
        },

        /**
         * Throw an exception if an error has happened before the method call,
         * otherwise fo nothing.
         * @method  throw
         * @chainable
         */
        throw : function() {
            return this.catch(function(e) {
                throw e;
            });
        },

        $schedule : function() {
            if (this.$tasks.length > 0 && this.$busy === 0) {
                this.$tasks.shift().call(this);
            }
        },

        end : function() {
            this.recover();
        }
    };

    //  Faster match operation analogues:
    //  Math.floor(f)  =>  ~~(a)
    //  Math.round(f)  =>  (f + 0.5) | 0
    function isString(o)  {
        return typeof o !== "undefined" && o !== null &&
              (typeof o === "string" || o.constructor === String);
    }

    function isNumber(o)  {
        return typeof o !== "undefined" && o !== null &&
              (typeof o === "number" || o.constructor === Number);
    }

    function isBoolean(o) {
        return typeof o !== "undefined" && o !== null &&
              (typeof o === "boolean" || o.constructor === Boolean);
    }

    function lookupObjValue(obj, name) {
        if (arguments.length === 1) {
            name = obj;
            obj  = $global;
        }

        if (typeof name === 'undefined' || name.trim().length === 0) {
            throw new Error("Invalid field name: '" + name + "'");
        }

        var names = name.trim().split('.');
        for(var i = 0; i < names.length; i++) {
            obj = obj[names[i]];

            if (typeof obj === 'undefined' || ((i + 1) === names.length && obj === null)) {
                throw new Error("'" + name + "' value cannot be detected");
            }
        }
        return obj;
    }

    function $ls(callback, all) {
        for (var k in this) {
            var v = this[k];
            if (this.hasOwnProperty(k) && (v instanceof Package) === false)  {
                if ((k[0] !== '$' && k[0] !== '_') || all === true) {
                    if (callback.call(this, k, this[k]) === true) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    function $lsall(fn) {
        return $ls.call(this, function(k, v) {
            if (v !== null && v.clazz === zebkit.Class) {
                if (typeof v.$name === "undefined") {
                    v.$name = fn + k;
                    v.$pkg  = lookupObjValue($global, fn.substring(0, fn.length - 1));
                }
                return $lsall.call(v, v.$name + ".");
            }
        });
    }

    /**
     *  Package is a special class to declare zebkit packages. Global variable "zebkit" is
     *  root package for all other packages. To declare a new package use "zebkit" global
     *  variable:
     *
     *      // declare new "mypkg" package
     *      zebkit.package("mypkg", function(pkg, Class) {
     *          // put the package entities in
     *          pkg.packageVariable = 10;
     *          ...
     *      });
     *      ...
     *
     *      // now we can access package and its entities directly
     *      zebkit.mypkg.packageVariable
     *
     *      // or it is preferable to wrap a package access with "require"
     *      // method
     *      zebkit.require("mypkg", function(mypkg) {
     *          mypkg.packageVariable
     *      });
     *
     *  @class zebkit.Package
     */
    function Package(name, parent) {
        /**
         * URL the package has been loaded
         * @attribute $url
         * @readOnly
         * @type {String}
         */
        this.$url = null;

        /**
         * Name of the package
         * @attribute $name
         * @readOnly
         * @type {String}
         */
        this.$name = name;

        /**
         * Package configuration parameters.
         * @attribute config
         * @readOnly
         * @type {Object}
         */
        this.config = {};

        this.$ready = new DoIt();

        /**
         * Reference to a parent package
         * @attribute $parent
         * @private
         * @type {zebkit.Package}
         */
        this.$parent = arguments.length < 2 ? null : parent;

        if (typeof __dirname !== 'undefined') {
            this.$url = __dirname;
        } else if (typeof document !== "undefined") {
            //
            var s  = document.getElementsByTagName('script'),
                ss = s[s.length - 1].getAttribute('src'),
                i  = ss === null ? -1 : ss.lastIndexOf("/"),
                a = document.createElement('a');

            a.href = (i > 0) ? ss.substring(0, i + 1)
                             : document.location.toString();

            this.$url = a.href.toString();
        }
    }

    /**
     * Get full name of the package. Full name includes not the only the given
     * package name, but also all parent packages separated with "." character.
     * @return {String} a full package name
     * @method fullname
     */
    Package.prototype.fullname = function() {
        var n = [ this.$name ], p = this;
        while (p.$parent !== null) {
            p = p.$parent;
            n.unshift(p.$name);
        }
        return n.join(".");
    };

    /**
     * Find a package with the given file like path relatively to the given package.
     * @param {String} path a file like path
     * @return {String} path a path
     * @example
     *
     *      // declare "zebkit.test" package
     *      zebkit.package("test", function(pkg, Class) {
     *          ...
     *      });
     *      ...
     *
     *      zebkit.require("test", function(test) {
     *          var parent = test.cd(".."); // parent points to zebkit package
     *          ...
     *      });
     *
     * @method cd
     */
    Package.prototype.cd = function(path) {
        if (path[0] === '/') {
            path = path.substring(1);
        }

        var paths = path.split('/'),
            pk    = this;

        for (var i = 0; i < paths.length; i++) {
            var pn = paths[i];
            if (pn === "..") {
                pk = pk.$parent;
            } else {
                pk = pk[pn];
            }

            if (typeof pk === 'undefined' || pk === null) {
                throw new Error("Package path '" + path + "' cannot be resolved");
            }
        }

        return pk;
    };

    /**
     * List the package sub-packages.
     * @param  {Function} callback    callback function that gets a sub-package name and the
     * sub-package itself as its arguments
     * @param  {boolean}  [recursively]  indicates if sub-packages have to be traversed recursively
     * @method packages
     */
    Package.prototype.packages = function(callback, recursively) {
        for (var k in this) {
            var v = this[k];
            if (k !== "$parent" && this.hasOwnProperty(k) && v instanceof Package) {

                if (callback.call(this, k, v) === true || (recursively === true && v.packages(callback, recursively) === true)) {
                    return true;
                }
            }
        }

        return false;
    };

    /**
     * List classes, variables and interfaces defined in the given package.
     * If second parameter "all" passed to the method is false, the method
     * will skip package entities whose name starts from "$" or "_" character.
     * These entities are considered as private ones. Pay attention sub-packages
     * are not listed.
     * @param  {Function} cb a callback method that get the package entity key
     * and the entity value as arguments.
     * @param  {Boolean}  [all] flag that specifies if private entities are
     * should be listed.
     * @method ls
     */
    Package.prototype.ls = function(cb, all) {
        return $ls.call(this, cb, all);
    };

    /**
     * Build import JS code string that can be evaluated in a local space to make visible
     * the given package or packages classes, variables and methods.
     * @example
     *
     *     (function() {
     *         // make visible variables, classes and methods declared in "zebkit.ui"
     *         // package in the method local space
     *         eval(zebkit.import("ui"));
     *
     *         // use imported from "zebkit.ui.Button" class without necessity to specify
     *         // full path to it
     *         var bt = new Button("Ok");
     *     })();
     *
     * @param {String} [pkgname]* names of packages to be imported
     * @return {String} an import string to be evaluated in a local JS space
     * @method  import
     */
    Package.prototype.import = function() {
        var code = [];
        if (arguments.length > 0) {
            for(var i = 0; i < arguments.length; i++) {
                var v = lookupObjValue(this, arguments[i]);
                if ((v instanceof Package) === false) {
                    throw new Error("Package '" + arguments[i] + " ' cannot be found");
                }
                code.push(v.import());
            }

            return code.length > 0 ?  code.join(";") : null;
        } else {
            var fn = this.fullname();
            this.ls(function(k, v) {
                code.push(k + '=' + fn + '.' + k);
            });

            return code.length > 0 ?  "var " + code.join(",") + ";" : null;
        }
    };

    /**
     * Method to request sub-package or sub-packages be ready and visible in
     * passed callback. The method guarantees the callbacks be called the time
     * all zebkit data is loaded and ready.
     * @param {String} [packages]* name or names of sub-packages to make visible
     * in callback method
     * @param {Function} [callback] a method to be called. The method is called
     * in context of the given package and gets requested packages passed as the
     * method arguments in order they have been requested.
     * @method  require
     * @example
     *
     *     zebkit.require("ui", function(ui) {
     *         var b = new ui.Button("Ok");
     *         ...
     *     });
     *
     */
    Package.prototype.require = function() {
        var pkgs  = [],
            $this = this,
            fn    = arguments[arguments.length - 1];

        if (typeof fn !== 'function') {
            throw new Error("Invalid callback function");
        }

        for(var i = 0; isString(arguments[i]) && i < arguments.length; i++) {
            var pkg = lookupObjValue(this, arguments[i]);
            if ((pkg instanceof Package) === false) {
                throw new Error("Package '" + arguments[i] + "' cannot be found");
            }
            pkgs.push(pkg);
        }

        return this.then(function() {
            fn.apply($this, pkgs);
        });
    };

    var $textualFileExtensions = [
        "txt", "json", "htm", "html", "md", "properties", "conf", "xml"
    ];

    /**
     * This method loads resources (images, textual files, etc) and call callback
     * method with completely loaded resources as input arguments.
     * @example
     *
     *     zebkit.resources(
     *         "http://test.com/image1.jpg",
     *         "http://test.com/text.txt",
     *         function(image, text) {
     *             // handle resources here
     *             ...
     *         }
     *     );
     *
     * @param  {String} paths*  paths to resources to be loaded
     * @param  {Function} cb callback method that is executed when all listed
     * resources are loaded and ready to be used.
     * @method resources
     */
    Package.prototype.resources = function() {
        var args  = Array.prototype.slice.call(arguments),
            $this = this,
            fn    = args.pop();

        if (typeof fn !== 'function') {
            throw new Error("Invalid callback function");
        }

        this.then(function() {
            for(var i = 0; i < args.length ; i++) {
                (function(path, jn) {
                    var m    = path.match(/^(\<[a-z]+\>\s*)?(.*)$/),
                        type = "img",
                        p    = m[2].trim();

                    if (typeof m[1] !== 'undefined') {
                        type = m[1].trim().substring(1, m[1].length - 1).trim();
                    } else {
                        var li = p.lastIndexOf('.');
                        if (li > 0) {
                            var ext = p.substring(li + 1).toLowerCase();
                            if ($textualFileExtensions.indexOf(ext) >= 0) {
                                type = "txt";
                            }
                        }
                    }

                    if (type === "img") {
                        zebkit.environment.loadImage(p, function(img) {
                            jn(img);
                        }, function(img, e) {
                            jn(img);
                        });
                    } else if (type === "txt") {
                        // TODO: this part has to be replaced with less low-level code
                        var req  = zebkit.environment.getHttpRequest();
                        req.open("GET", p, true);
                        req.onreadystatechange = function() {
                            if (req.readyState === 4) {
                                if (req.status >= 400 || req.status < 100) {
                                    console.log("HTTP error '" + req.statusText + "', code = " + req.status + " '" + path + "'");
                                    jn(null);
                                } else {
                                    jn(req.responseText);
                                }
                            }
                        };

                        try {
                            req.send(null);
                        } catch(e) {
                            jn(null);
                        }
                    } else {
                        console.log("Invalid path '" + path + "'");
                        jn(null);
                    }

                })(args[i], this.join());
            }
        }).then(function() {
            fn.apply($this, arguments);
        });
    };

    /**
     * This method helps to sync accessing to package entities with the
     * package internal state. For instance package declaration can initiate
     * loading resources that happens asynchronously. In this case to make sure
     * the package completed loading its configuration we should use package
     * "then" method.
     * @param  {Function} f a callback method where we can safely access the
     * package entities
     * @chainable
     * @private
     * @example
     *
     *     zebkit.then(function() {
     *         // here we can make sure all package declarations
     *         // are completed and we can start using it
     *     });
     *
     * @method  then
     */
    Package.prototype.then = function(f) {
        this.$ready.then(f).catch(function(e) {
            zebkit.dumpError(e);
            // re-start other waiting tasks
            this.restart();
        });
        return this;
    };

    Package.prototype.join = function() {
        return this.$ready.join.apply(this.$ready, arguments);
    };

    /**
     * Method that has to be used to declare packages.
     * @param  {String}   name     a name of the package
     * @param  {Function} [callback] a call back method that is called in package
     * context. The method has to be used to populate the given package classes,
     * interfaces and variables.
     * @example
     *     // declare package "zebkit.log"
     *     zebkit.package("log", function(pkg) {
     *         // declare the package class Log
     *         pkg.Log = zebkit.Class([
     *              function error() { ... },
     *              function warn()  { ... },
     *              function info()  { ... }
     *         ]);
     *     });
     *
     *     // later on you can use the declared package stuff as follow
     *     zebkit.require("log", function(log) {
     *         var myLog = new log.Log();
     *         ...
     *         myLog.warn("Warning");
     *     });
     *
     * @return {zebkit.Package} a package
     * @method package
     */
    Package.prototype.package = function(name, callback) {
        // no arguments than return the package itself
        if (arguments.length === 0) {
            return this;
        }

        var target = this;
        if (typeof arguments[0] !== 'function') {
            if (typeof name === 'undefined' || name === null) {
                throw new Error("Null package name");
            }

            name = name.trim();
            if (name.match(/^[a-zA-Z_][a-zA-Z0-9_]+(\.[a-zA-Z_][a-zA-Z0-9_]+)*$/) === null) {
                throw new Error("Invalid package name '" + name + "'");
            }

            var names = name.split('.');
            for(var i = 0, k = names[0]; i < names.length; i++, k = k + '.' + names[i]) {
                var n = names[i], p = target[n];
                if (typeof p === "undefined") {
                    p = new Package(n, target);
                    target[n] = p;
                } else if ((p instanceof Package) === false) {
                    throw new Error("Requested package '" + name +  "' conflicts with variable '" + n + "'");
                }
                target = p;
            }
        }

        if (typeof arguments[arguments.length - 1] === 'function') {
            var f = arguments[arguments.length - 1];

            this.then(function() {
                f.call(target, target, typeof zebkit !== 'undefined' ? zebkit.Class : null);
                $lsall.call(target, target.fullname() + "."); // resolve "clazz.$name" properties of the package classes
            });
        }

        return target;
    };

    // =================================================================================================
    //
    //   Zebkit root package declaration
    //
    // =================================================================================================
    var zebkit = new Package("zebkit");

    /**
     * Reference to zebkit environment. Environment is basic, minimal API
     * zebkit and its components require.
     * @for  zebkit
     * @attribute environment
     * @readOnly
     * @type {Object}
     */
    zebkit.environment = zenv;

    // declaring zebkit as a global variable has to be done before calling "package" method
    // otherwise the method cannot find zebkit to resolve class names
    //
    // nodejs
    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
        module.exports = zebkit;

        // TODO: not a good pattern to touch global space, but zebkit has to be visible
        // globally
        if (typeof global !== 'undefined') {
            global.zebkit = zebkit;
        }
    } else {
        window.zebkit = zebkit;
    }

    zebkit.package(function(pkg) {
        var $$$     = 11,  // hash code counter
            $caller = null; // currently called method reference

        // single method proxy wrapper
        function ProxyMethod(name, f, clazz) {
            if (typeof f.methodBody !== "undefined") {
                throw new Error("Proxy method '" + name + "' cannot be wrapped");
            }

            var a = function() {
                var cm = $caller;
                $caller = a;
                // don't use finally section it is slower than try-catch
                try {
                    var r = f.apply(this, arguments);
                    $caller = cm;
                    return r;
                } catch(e) {
                    $caller = cm;
                    console.log(name + "(" + arguments.length + ") " + (e.stack ? e.stack : e));
                    throw e;
                }
            };

            a.methodBody = f;
            a.methodName = name;
            a.boundTo    = clazz;
            return a;
        }

        // copy methods from source to destination
        function cpMethods(src, dest, clazz) {
            var overriddenAbstractMethods = 0;
            for(var name in src) {
                if (name   !== pkg.CNAME     &&
                    name   !== "clazz"       &&
                    src.hasOwnProperty(name)   )
                {
                    var method = src[name];
                    if (typeof method === "function" && method !== $toString) {
                        if (name === "$prototype") {
                            method.call(dest, clazz);
                        } else {
                            // TODO analyze if we overwrite existent field
                            if (typeof dest[name] !== 'undefined') {
                                // abstract method is overridden, let's skip abstract method
                                // stub implementation
                                if (method.$isAbstract === true) {
                                    overriddenAbstractMethods++;
                                    continue;
                                }

                                if (dest[name].boundTo === clazz) {
                                    throw new Error("Method '" + name + "(...)'' bound to this class already exists");
                                }
                            }

                            if (typeof method.methodBody !== "undefined") {
                                dest[name] = ProxyMethod(name, method.methodBody, clazz);
                            } else {
                                dest[name] = ProxyMethod(name, method, clazz);
                            }

                            // save information about abstract method
                            if (method.$isAbstract === true) {
                                dest[name].$isAbstract = true;
                            }
                        }
                    }
                }
            }

            return overriddenAbstractMethods;
        }

        function $toString() {
            return this.$hash$;
        }

        // return function that is meta class
        //  instanceOf      - parent template function (can be null)
        //  templateConstructor - template function,
        //  inheritanceList     - parent class and interfaces
        function make_template(instanceOf, templateConstructor, inheritanceList) {
            // supply template with unique identifier that is returned with toString() method
            templateConstructor.$hash$   = "$zEk$" + ($$$++);
            templateConstructor.toString = $toString;
            templateConstructor.prototype.clazz = templateConstructor; // instances of the template has to point to the template as a class

            templateConstructor.clazz = templateConstructor.constructor = instanceOf;

            /**
             *  Unique string hash code. The property is not defined if the class was not
             *  maid hashable by calling "hashable()" method.
             *  @attribute $hash$
             *  @private
             *  @type {String}
             *  @for  zebkit.Class
             *  @readOnly
             */

            /**
             * Dictionary of all inherited interfaces where key is unique interface hash code and the value
             * is interface itself.
             * @private
             * @readOnly
             * @for zebkit.Class
             * @type {Object}
             * @attribute $parents
             * @type {Object}
             */
            templateConstructor.$parents = {};

            // instances of the constructor also has to be unique
            // so force toString method population
            templateConstructor.prototype.constructor = templateConstructor; // set constructor of instances to the template

            // setup parent entities
            if (arguments.length > 2 && inheritanceList.length > 0) {
                for(var i = 0; i < inheritanceList.length; i++) {
                    var toInherit = inheritanceList[i];
                    if (typeof toInherit === 'undefined'        ||
                        toInherit === null                      ||
                        typeof toInherit        !== "function"  ||
                        typeof toInherit.$hash$ === "undefined"   )
                    {
                        throw new ReferenceError("Invalid parent class or interface:" + toInherit);
                    }

                    if (typeof templateConstructor.$parents[toInherit.$hash$] !== "undefined") {
                        throw Error("Duplicate toInherit class or interface: " + toInherit);
                    }

                    templateConstructor.$parents[toInherit.$hash$] = toInherit;

                    // if parent has own parents copy the parents references
                    for(var k in toInherit.$parents) {
                        if (typeof templateConstructor.$parents[k] !== "undefined") {
                            throw Error("Duplicate inherited class or interface: " + k);
                        }

                        templateConstructor.$parents[k] = toInherit.$parents[k];
                    }
                }
            }
            return templateConstructor;
        }

        /**
         * Dump the given error to output.
         * @param  {Exception | Object} e an error.
         * @method dumpError
         * @for  zebkit
         */
        pkg.dumpError = function(e) {
            if (typeof console !== "undefined" && typeof console.log !== "undefined") {
                var msg = "zebkit.err [";
                if (typeof Date !== 'undefined') {
                    var date = new Date();
                    msg = msg + date.getDate()   + "/" +
                          (date.getMonth() + 1) + "/" +
                          date.getFullYear() + " " +
                          date.getHours() + ":" + date.getMinutes() + ":" + date.getSeconds();
                }

                console.log(msg + "] : " + e);
                if (e === null || typeof e === 'undefined') {
                    console.log("Unknown error");
                } else {
                    console.log((e.stack ? e.stack : e));
                }
            }
        };

        pkg.URI = URI;

        pkg.CNAME = '$';
        pkg.CDNAME = '';

        pkg.$FN = (isString.name !== "isString") ? (function(f) {  // IE stuff
                                                        if (typeof f.$methodName === 'undefined') { // test if name has been earlier detected
                                                            var mt = f.toString().match(/^function\s+([^\s(]+)/);
                                                            f.$methodName = (mt === null) ? pkg.CDNAME
                                                                                          : (typeof mt[1] === "undefined" ? pkg.CDNAME
                                                                                                                          : mt[1]);
                                                        }
                                                        return f.$methodName;
                                                    })
                                                 : (function(f) { return f.name; });


        pkg.isIE    = isInBrowser && (Object.hasOwnProperty.call(window, "ActiveXObject") || !!window.ActiveXObject || window.navigator.userAgent.indexOf("Edge") > -1);
        pkg.isFF    = isInBrowser && window.mozInnerScreenX !== null;
        pkg.isMacOS = isInBrowser && navigator.platform.toUpperCase().indexOf('MAC') !== -1;

        /**
         * Check if the given value is string
         * @param {Object} v a value.
         * @return {Boolean} true if the given value is string
         * @method isString
         * @for zebkit
         */
        pkg.isString = isString;

        /**
         * Check if the given value is number
         * @param {Object} v a value.
         * @return {Boolean} true if the given value is number
         * @method isNumber
         * @for zebkit
         */
        pkg.isNumber = isNumber;

        /**
         * Check if the given value is boolean
         * @param {Object} v a value.
         * @return {Boolean} true if the given value is boolean
         * @method isBoolean
         * @for zebkit
         */
        pkg.isBoolean = isBoolean;

        /**
         * Reference to global space.
         * @attribute $global
         * @private
         * @readOnly
         * @type {Object}
         * @for zebkit
         */
        pkg.$global = $global;


        pkg.$Map = function() {
            var Map = function() {
                this.keys   = [];
                this.values = [];
                this.size   = 0 ;
            };

            Map.prototype = {
                set : function(key, value) {
                    var i = this.keys.indexOf(key);
                    if (i < 0) {
                        this.keys.push(key);
                        this.values.push(value);
                        this.size++;
                    } else {
                       this.values[i] = value;
                    }
                    return this;
                 },

                delete: function(key) {
                    var i = this.keys.indexOf(key);
                    if (i < 0) {
                       return false;
                    }

                    this.keys.splice(i, 1);
                    this.values.splice(i, 1);
                    this.size--;
                    return true;
                },

                get : function(key) {
                    var i = this.keys.indexOf(key);
                    return i < 0 ? undefined : this.values[i];
                },

                clear : function() {
                    this.keys = [];
                    this.keys.length = 0;
                    this.values = [];
                    this.values.length = 0;
                    this.size = 0;
                },

                has : function(key) {
                    return this.keys.indexOf(key) >= 0;
                },

                forEach: function(callback, context) {
                    var $this = arguments.length < 2 ? this : context;
                    for(var i = 0 ; i < this.size; i++) {
                        callback.call($this, this.values[i], this.keys[i], this);
                    }
                }
            };

            return Map;
        };

        // ES6 Map is class
        if (typeof Map === 'undefined' && (typeof pkg.$global !== 'undefined' || typeof pkg.$global.Map === "undefined")) {
            pkg.$global.Map = pkg.$Map();
        }

        /**
         * Clone the given object. The method tries to perform deep cloning by
         * traversing the given object structure recursively. Any part of an
         * object can be marked as not cloneable by adding  "$notCloneable"
         * field that equals to true. Also at any level of object structure
         * the cloning can be customized with adding "$clone" method. In this
         * case the method will be used to clone the part of object.
         * clonable
         * @param  {Object} obj an object to be cloned
         * @return {Object} a cloned object
         * @method  clone
         * @for  zebkit
         */
        pkg.clone = function (obj, map) {
            // clone atomic type
            // TODO: to speedup cloning we don't use isString, isNumber, isBoolean
            if (obj === null || typeof obj === 'undefined' || obj.$notCloneable === true ||
                                                              (typeof obj === "string"  || obj.constructor === String  ) ||
                                                              (typeof obj === "boolean" || obj.constructor === Boolean ) ||
                                                              (typeof obj === "number"  || obj.constructor === Number  )    )
            {
                return obj;
            }

            map = map || new Map();
            var t = map.get(obj);
            if (typeof t !== "undefined") {
                return t;
            }

            // clone with provided custom "clone" method
            if (typeof obj.$clone !== "undefined") {
                return obj.$clone(map);
            }

            // clone array
            if (Array.isArray(obj)) {
                var naobj = [];

                map.set(obj, naobj);
                map[obj] = naobj;

                for(var i = 0; i < obj.length; i++) {
                    naobj[i] = pkg.clone(obj[i], map);
                }
                return naobj;
            }

            // clone class
            if (obj.clazz === pkg.Class) {
                var clazz = pkg.Class(obj, []);
                clazz.inheritProperties = true;
                return clazz;
            }

            // function cannot be cloned
            if (typeof obj === 'function' || obj.constructor !==  Object) {
                return obj;
            }

            var nobj = {};
            map.set(obj, nobj);

            // clone object fields
            for(var k in obj) {
                if (obj.hasOwnProperty(k) === true) {
                    nobj[k] = pkg.clone(obj[k], map);
                }
            }

            return nobj;
        };

        /**
         * Instantiate a new class instance of the given class with the specified constructor
         * arguments.
         * @param  {Function} clazz a class
         * @param  {Array} [args] an arguments list
         * @return {Object}  a new instance of the given class initialized with the specified arguments
         * @method newInstance
         * @for  zebkit
         */
        pkg.newInstance = function(clazz, args) {
            if (arguments.length > 1 && args.length > 0) {
                var f = function () {};
                f.prototype = clazz.prototype;
                var o = new f();
                clazz.apply(o, args);
                return o;
            }
            return new clazz();
        };

        /**
         * Get a property setter method if it is declared with the class of the specified object for the
         * given property. Setter is a method whose name matches the following pattern: "set<PropertyName>"
         * where the first letter of the property name is in upper case. For instance setter method for
         * property "color" has to have name "setColor".
         * @param  {Object} obj an object instance
         * @param  {String} name a property name
         * @return {Function}  a method that can be used as a setter for the given property
         * @method  getPropertySetter
         * @protected
         * @for  zebkit
         */
        pkg.getPropertySetter = function(obj, name) {
            var pi = obj.constructor.$propertyInfo, m = null;
            if (typeof pi !== 'undefined') {
                if (typeof pi[name] === "undefined") {
                    m = obj[ "set" + name[0].toUpperCase() + name.substring(1) ];
                    pi[name] = (typeof m  === "function") ? m : null;
                }
                return pi[name];
            }

            m = obj[ "set" + name[0].toUpperCase() + name.substring(1) ];
            return (typeof m  === "function") ? m : null;
        };

        /**
         * Populate the given target object with the properties set. The properties set
         * is a dictionary that keeps properties names and its corresponding values.
         * The method detects if a property setter method exits and call it to apply
         * the property value. Otherwise property is initialized as a field. Setter
         * method is a method that matches "set<PropertyName>" pattern.
         * @param  {Object} target a target object
         * @param  {Object} p   a properties set
         * @return {Object} an object with the populated properties set.
         * @method  properties
         * @for  zebkit
         */
        pkg.properties = function(target, p) {
            for(var k in p) {
                // skip private properties( properties that start from "$")
                if (k !== "clazz" && k[0] !== '$' && p.hasOwnProperty(k) && typeof p[k] !== "undefined" && typeof p[k] !== 'function') {
                    if (k[0] === '-') {
                        delete target[k.substring(1)];
                    } else {
                        var v = p[k],
                            m = zebkit.getPropertySetter(target, k);

                        // value factory detected
                        if (v !== null && typeof v.$new !== 'undefined') {
                            v = v.$new();
                        }

                        if (m === null) {
                            target[k] = v;  // setter doesn't exist, setup it as a field
                        } else {
                            // property setter is detected, call setter to
                            // set the property value
                            if (Array.isArray(v)) m.apply(target, v);
                            else                  m.call(target, v);
                        }
                    }
                }
            }
            return target;
        };

        function $make_proto(props, superProto) {
            if (superProto === null) {
                return function $prototype(clazz) {
                    for(var k in props) {
                        if (props.hasOwnProperty(k)) {
                            this[k] = props[k];
                        }
                    }
                };
            } else {
                return function $prototype(clazz) {
                    superProto.call(this, clazz);
                    for(var k in props) {
                        if (props.hasOwnProperty(k)) {
                            this[k] = props[k];
                        }
                    }
                };
            }
        }

        /**
         * Interface is way to share common functionality by avoiding multiple inheritance.
         * It allows developers to mix number of methods to different classes. For instance:

        // declare "I" interface that contains one method a
        var I = zebkit.Interface([
            function a() {

            }
        ]);

        // declare "A" class
        var A = zebkit.Class([]);

        // declare "B" class that inherits class A and mix interface "I"
        var B = zebkit.Class(A, I, []);

        // instantiate "B" class
        var b = new B();
        zebkit.instanceOf(b, I);  // true
        zebkit.instanceOf(b, A);  // true
        zebkit.instanceOf(b, B);  // true

        // call mixed method
        b.a();

         * @return {Function} an interface
         * @param {Array} [methods] list of methods declared in the interface
         * @constructor
         * @class  zebkit.Interface
         */
        pkg.Interface = make_template(null, function() {
            var $Interface = make_template(pkg.Interface, function() {
                // Clone interface  parametrized with the given properties set
                if (typeof this === 'undefined' || this.constructor !== $Interface) {  // means the method execution is not a result of "new" method
                    if (arguments.length !== 1) {
                        throw new Error("Invalid number of arguments. Properties set is expected");
                    }

                    if (arguments[0].constructor !== Object) {
                        throw new Error("Invalid argument type. Properties set is expected");
                    }

                    var clone = $Interface.$clone();
                    clone.prototype.$prototype = $make_proto(arguments[0],
                                                             $Interface.prototype.$prototype);
                    return clone;
                } else {
                    // Create a class that inherits the interface and instantiate it
                    if (arguments.length > 1) {
                        throw new Error("One or zero argument is expected");
                    }
                    return new (pkg.Class($Interface, arguments.length > 0 ? arguments[0] : []))();
                }
            });

            if (arguments.length > 1) {
                throw new Error("Invalid number of arguments. List of methods or properties is expected");
            }

            // abstract method counter, not used now, but can be used in the future
            // to understand if the given class override all abstract methods (should be
            // controlled in the places of "cpMethods" call)
            $Interface.$abstractMethods = 0;

            var arg = arguments.length === 0 ? [] : arguments[0];
            if (arg.constructor === Object) {
                arg = [ $make_proto(arg, null) ];
            } else if (Array.isArray(arg) === false) {
                throw new Error("Invalid argument type. List of methods pr properties is expected");
            }

            if (arg.length > 0) {
                var  proto      = $Interface.prototype,
                     isAbstract = false;

                for(var i = 0; i < arg.length; i++) {
                    var method = arg[i];

                    if (method === "abstract") {
                        isAbstract = true;
                    } else {
                        if (typeof method !== "function") {
                            throw new Error("Method is expected instead of " + method);
                        }

                        var name = pkg.$FN(method);
                        if (name === pkg.CDNAME) {
                            throw new Error("Constructor declaration is not allowed in interface");
                        }

                        if (typeof proto[name] !== 'undefined') {
                            throw new Error("Duplicated interface method '" + name + "(...)'");
                        }

                        if (name === "$clazz") {
                            method.call($Interface, $Interface);
                        } else if (isAbstract === true) {
                            (function(name) {
                                proto[name] = function() {
                                    throw new Error("Abstract method '" + name + "(...)' is not implemented");
                                };

                                // mark method as abstract
                                proto[name].$isAbstract = true;

                                // count abstract methods
                                $Interface.$abstractMethods++;
                            })(name);
                        } else {
                            proto[name] = method;
                        }
                    }
                }
            }

            /**
             * Private implementation of an interface cloning.
             * @return {zebkit.Interface} a clone of the interface
             * @method $clone
             * @private
             */
            $Interface.$clone = function() {
                var clone = pkg.Interface(), k = null; // create interface

                // clone interface level variables
                for(k in this) {
                    if (this.hasOwnProperty(k)) {
                        clone[k] = pkg.clone(this[k]);
                    }
                }

                // copy methods from proto
                var proto = this.prototype;
                for(k in proto) {
                    if (k !== "clazz" && proto.hasOwnProperty(k) === true) {
                        clone.prototype[k] = pkg.clone(proto[k]);
                    }
                }

                return clone;
            };

            $Interface.clazz.$name = "zebkit.Interface"; // assign name
            return $Interface;
        });

        /**
         * Core method method to declare a zebkit class following easy OOP approach. The easy OOP concept
         * supports the following OOP features:
         *
         *
         *  __Single class inheritance.__ Any class can extend an another zebkit class

        // declare class "A" that with one method "a"
        var A = zebkit.Class([
            function a() { ... }
        ]);

        // declare class "B" that inherits class "A"
        var B = zebkit.Class(A, []);

        // instantiate class "B" and call method "a"
        var b = new B();
        b.a();


        * __Class method overriding.__ Override a parent class method implementation

        // declare class "A" that with one method "a"
        var A = zebkit.Class([
            function a() { ... }
        ]);

        // declare class "B" that inherits class "A"
        // and overrides method a with an own implementation
        var B = zebkit.Class(A, [
            function a() { ... }
        ]);


        * __Constructors.__ Constructor is a method with empty name

        // declare class "A" that with one constructor
        var A = zebkit.Class([
            function () { this.variable = 100; }
        ]);

        // instantiate "A"
        var a = new A();
        a.variable // variable is 100

        * __Static methods and variables declaration.__ Static fields and methods can be defined
            by declaring special "$clazz" method whose context is set to declared class

        var A = zebkit.Class([
            // special method where static stuff has to be declared
            function $clazz() {
                // declare static field
                this.staticVar = 100;
                // declare static method
                this.staticMethod = function() {};
            }
        ]);

        // access static field an method
        A.staticVar      // 100
        A.staticMethod() // call static method

        * __Access to super class context.__ You can call method declared in a parent class

        // declare "A" class with one class method "a(p1,p2)"
        var A = zebkit.Class([
            function a(p1, p2) { ... }
        ]);

        // declare "B" class that inherits "A" class and overrides "a(p1,p2)" method
        var B = zebkit.Class(A, [
            function a(p1, p2) {
                // call "a(p1,p2)" method implemented with "A" class
                this.$super(p1,p2);
            }
        ]);

         *
         *  One of the powerful feature of zebkit easy OOP concept is possibility to instantiate
         *  anonymous classes and interfaces. Anonymous class is an instance of an existing
         *  class that can override the original class methods with own implementations, implements
         *  own list of interfaces and methods. In other words the class instance customizes class
         *  definition for the particular instance of the class;

        // declare "A" class
        var A = zebkit.Class([
            function a() { return 1; }
        ]);

        // instantiate anonymous class that add an own implementation of "a" method
        var a = new A([
            function a() { return 2; }
        ]);
        a.a() // return 2

         * @param {zebkit.Class} [inheritedClass] an optional parent class to be inherited
         * @param {zebkit.Interface} [inheritedInterfaces]* an optional list of interfaces for
         * the declared class to be mixed in the class
         * @param {Array} methods list of declared class methods. Can be empty array.
         * @return {Function} a class definition
         * @constructor
         * @class zebkit.Class
         */
        var mixing = pkg.$mixing = function(clazz, methods) {
            if (Array.isArray(methods) === false) {
                throw new Error("Methods array is expected (" + methods + ")");
            }

            var names = {};
            for(var i = 0; i < methods.length; i++) {
                var method     = methods[i],
                    methodName = pkg.$FN(method);

                // detect if the passed method is proxy method
                if (typeof method.methodBody !== 'undefined') {
                    throw new Error("Proxy method '" + methodName + "' cannot be mixed in a class");
                }

                // map user defined constructor to internal constructor name
                if (methodName === pkg.CDNAME) {
                    methodName = pkg.CNAME;
                } else if (methodName[0] === '$') {
                    // populate prototype fields if a special method has been defined
                    if (methodName === "$prototype") {
                        method.call(clazz.prototype, clazz);
                        if (clazz.prototype[pkg.CDNAME]) {
                            clazz.prototype[pkg.CNAME] = clazz.prototype[pkg.CDNAME];
                            delete clazz.prototype[pkg.CDNAME];
                        }
                        continue;
                    }

                    // populate class level fields if a special method has been defined
                    if (methodName === "$clazz") {
                        method.call(clazz);
                        continue;
                    }
                }

                if (names[methodName] === true) {
                    throw new Error("Duplicate declaration of '" + methodName+ "(...)' method");
                }

                var existentMethod = clazz.prototype[methodName];
                if (typeof existentMethod !== 'undefined' && typeof existentMethod !== 'function') {
                    throw new Error("'" + methodName + "(...)' method clash with a field");
                }

                // if constructor doesn't have super definition than let's avoid proxy method
                // overhead
                if (typeof existentMethod === 'undefined' && methodName === pkg.CNAME) {
                    clazz.prototype[methodName] = method;
                } else {
                    // Create and set proxy method that is bound to the given class
                    clazz.prototype[methodName] = ProxyMethod(methodName, method, clazz);
                }

                // save method we have already added to check double declaration error
                names[methodName] = true;
            }
        };

        // create Class template what means we define a function (meta class) that has to be used to define
        // Class. That means we define a function that returns another function that is a Class
        pkg.Class = make_template(null, function() {
            if (arguments.length === 0) {
                throw new Error("No class method list was found");
            }

            if (Array.isArray(arguments[arguments.length - 1]) === false) {
                throw new Error("No class methods have been passed");
            }

            if (arguments.length > 1 && typeof arguments[0] !== "function")  {
                throw new ReferenceError("Invalid parent class or interface '" + arguments[0] + "'");
            }

            var classMethods = arguments[arguments.length - 1],
                parentClass  = null,
                toInherit    = [];

            // detect parent class in inheritance list as the first argument that has "clazz" set to Class
            if (arguments.length > 0 && (arguments[0] === null || arguments[0].clazz === pkg.Class)) {
                parentClass = arguments[0];
            }

            // use instead of slice for performance reason
            for(var i = 0; i < arguments.length - 1; i++) {
                toInherit[i] = arguments[i];

                // let's make sure we inherit interface
                if (parentClass === null || i > 0) {
                    if (typeof toInherit[i] === 'undefined' || toInherit[i] === null) {
                        throw new ReferenceError("Undefined inherited interface [" + i + "] " );
                    } else if (toInherit[i].clazz !== pkg.Interface) {
                        throw new ReferenceError("Inherited interface is not an Interface ( [" + i + "] '" + toInherit[i] + "'')");
                    }
                }
            }

            // define Class (function) that has to be used to instantiate the class instance
            var classTemplate = make_template(pkg.Class, function() {
                if (classTemplate.$uniqueness === true) {
                    this.$hash$ = "$ZkIo" + ($$$++);
                }

                if (arguments.length > 0) {
                    var a = arguments[arguments.length - 1];

                    // anonymous is customized class instance if last arguments is array of functions
                    if (Array.isArray(a) === true && typeof a[0] === 'function') {
                        a = a[0];

                        // prepare arguments list to declare an anonymous class
                        var args = [ classTemplate ],      // first of all the class has to inherit the original class
                            k    = arguments.length - 2;

                        // collect interfaces the anonymous class has to implement
                        for(; k >= 0 && arguments[k].clazz === pkg.Interface; k--) {
                            args.push(arguments[k]);
                        }

                        // add methods list
                        args.push(arguments[arguments.length - 1]);

                        var cl = pkg.Class.apply(null, args),  // declare new anonymous class
                            // create a function to instantiate an object that will be made the
                            // anonymous class instance. The intermediate object is required to
                            // call constructor properly since we have arguments as an array
                            f  = function() {};

                        cl.$name = classTemplate.$name; // the same class name for anonymous
                        f.prototype = cl.prototype; // the same prototypes

                        var o = new f();

                        // call constructor
                        // use array copy instead of cloning with slice for performance reason
                        // (Array.prototype.slice.call(arguments, 0, k + 1))
                        args = [];
                        for (var i = 0; i < k + 1; i++) {
                            args[i] = arguments[i];
                        }
                        cl.apply(o, args);

                        // set constructor field for consistency
                        o.constructor = cl;
                        return o;
                    }
                }

                // call class constructor
                if (typeof this.$ !== 'undefined') { // TODO: hard-coded constructor name to speed up
                    return this.$.apply(this, arguments);
                }
            }, toInherit);


            /**
             *  Internal attribute that caches properties setter references.
             *  @attribute $propertyInfo
             *  @type {Object}
             *  @private
             *  @for zebkit.Class
             *  @readOnly
             */
            // prepare fields that caches the class properties. existence of the property
            // force getPropertySetter method to cache the method
            classTemplate.$propertyInfo = {};

            /**
             *  Reference to a parent class
             *  @attribute $parent
             *  @type {zebkit.Class}
             *  @protected
             *  @readOnly
             */

            // copy parents prototype methods and fields into
            // new class template
            classTemplate.$parent = parentClass;
            if (parentClass !== null) {
                for(var k in parentClass.prototype) {
                    if (parentClass.prototype.hasOwnProperty(k)) {
                        var f = parentClass.prototype[k];
                        classTemplate.prototype[k] = (typeof f !== 'undefined' &&
                                                      f !== null &&
                                                      f.hasOwnProperty("methodBody")) ? ProxyMethod(f.methodName, f.methodBody, f.boundTo)
                                                                                      : f;
                    }
                }
            }

            /**
             * Extend existent class instance with the given methods and interfaces
             * For example:

                var A = zebkit.Class([ // declare class A that defines one "a" method
                    function a() {
                        console.log("A:a()");
                    }
                ]);

                var a = new A();
                a.a();  // show "A:a()" message

                A.a.extend([
                    function b() {
                        console.log("EA:b()");
                    },

                    function a() {   // redefine "a" method
                        console.log("EA:a()");
                    }
                ]);

                a.b(); // show "EA:b()" message
                a.a(); // show "EA:a()" message

             * @param {zebkit.Interface} [interfaces]* interfaces to be implemented with the
             * class instance
             * @param {Array} methods list of methods the class instance has to be extended
             * with
             * @method extend
             * @for zebkit.Class.zObject
             */
            classTemplate.prototype.extend = function() {
                var clazz = this.clazz,
                    l = arguments.length,
                    f = arguments[l - 1],
                    hasArray = Array.isArray(f),
                    i = 0;

                // replace the instance class with a new intermediate class
                // that inherits the replaced class. it is done to support
                // $super method calls.
                if (this.$isExtended !== true) {
                    clazz = pkg.Class(clazz, []);
                    this.$isExtended = true;         // mark the instance as extended to avoid double extending.
                    clazz.$name = this.clazz.$name;
                    this.clazz = clazz;
                }

                if (hasArray) {
                    var init = null;
                    for(i = 0; i < f.length; i++) {
                        var n = pkg.$FN(f[i]);
                        if (n === pkg.CDNAME) {
                            init = f[i];  // postpone calling initializer before all methods will be defined
                        } else {
                            if (typeof this[n] !== 'undefined' && typeof this[n] !== 'function') {
                                throw new Error("Method '" + n + "' clash with a property");
                            }
                            this[n] = ProxyMethod(n, f[i], clazz);
                        }
                    }

                    if (init !== null) {
                        init.call(this);
                    }
                    l--;
                }

                // add new interfaces if they has been passed
                for (i = 0; i < arguments.length - (hasArray ? 1 : 0); i++) {
                    if (arguments[i].clazz !== pkg.Interface) {
                        throw new Error("Invalid argument " + arguments[i] + " Interface is expected.");
                    }

                    var I = arguments[i];
                    if (typeof clazz.$parents[I.$hash$] !== 'undefined') {
                        throw new Error("Interface has been already inherited");
                    }

                    cpMethods(I.prototype, this, clazz);
                    clazz.$parents[I.$hash$] = I;
                }
                return this;
            };

            /**
             * Call super method implementation.
             * @param {Function} [superMethod]? optional parameter that should be a method of the class instance
             * that has to be called
             * @param {Object} [args]* arguments list to pass the executed method
             * @return {Object} return what super method returns
             * @method $super
             * @example
             *
             *    var A = zebkit.Class([
             *        function a(p) { return 10 + p; }
             *    ]);
             *
             *    var B = zebkit.Class(A, [
             *        function a(p) {
             *            return this.$super(p) * 10;
             *        }
             *    ]);
             *
             *    var b = new B();
             *    b.a(10) // return 200
             *
             * @for zebkit.Class.zObject
             */
            classTemplate.prototype.$super = function() {
               if ($caller !== null) {
                    for (var $s = $caller.boundTo.$parent; $s !== null; $s = $s.$parent) {
                        var m = $s.prototype[$caller.methodName];
                        if (typeof m !== 'undefined') {
                            return m.apply(this, arguments);
                        }
                    }

                    // handle method not found error
                    var cln = this.clazz && this.clazz.$name ? this.clazz.$name + "." : "";
                    throw new ReferenceError("Method '" +
                                             cln +
                                             ($caller.methodName === pkg.CNAME ? "constructor"
                                                                               : $caller.methodName) + "(" + arguments.length + ")" + "' not found");
                } else {
                    throw new Error("$super is called outside of class context");
                }
            };

            // TODO: not stable API
            classTemplate.prototype.$supera = function(args) {
               if ($caller !== null) {
                    for (var $s = $caller.boundTo.$parent; $s !== null; $s = $s.$parent) {
                        var m = $s.prototype[$caller.methodName];
                        if (typeof m !== 'undefined') {
                            return m.apply(this, args);
                        }
                    }

                    // handle method not found error
                    var cln = this.clazz && this.clazz.$name ? this.clazz.$name + "." : "";
                    throw new ReferenceError("Method '" +
                                             cln +
                                             ($caller.methodName === pkg.CNAME ? "constructor"
                                                                               : $caller.methodName) + "(" + arguments.length + ")" + "' not found");
                } else {
                    throw new Error("$super is called outside of class context");
                }
            };

            // TODO: not stable API, $super that doesn't throw exception is there is no super implementation
            classTemplate.prototype.$$super = function() {
               if ($caller !== null) {
                    for(var $s = $caller.boundTo.$parent; $s !== null; $s = $s.$parent) {
                        var m = $s.prototype[$caller.methodName];
                        if (typeof m !== 'undefined') {
                            return m.apply(this, arguments);
                        }
                    }
                } else {
                    throw new Error("$super is called outside of class context");
                }
            };

            /**
             * Get a first super implementation of the given method in a parent classes hierarchy.
             * @param  {String} name a name of the method
             * @return {Function} a super method implementation
             * @method  $getSuper
             * @for  zebkit.Class.zObject
             */
            classTemplate.prototype.$getSuper = function(name) {
               if ($caller !== null) {
                    for(var $s = $caller.boundTo.$parent; $s !== null; $s = $s.$parent) {
                        var m = $s.prototype[name];
                        if (typeof m === 'function') {
                            return m;
                        }
                    }
                    return null;
                }
                throw new Error("$super is called outside of class context");
            };

            classTemplate.prototype.$genHash = function() {
                if (typeof this.$hash$ === 'undefined') {
                    this.$hash$ = "$ZeInGen" + ($$$++);
                }
                return this.$hash$;
            };

            classTemplate.prototype.$clone = function(map) {
                map = map || new Map();

                var f = function() {};
                f.prototype = this.constructor.prototype;
                var nobj = new f();
                map.set(this, nobj);

                for(var k in this) {
                    if (this.hasOwnProperty(k)) {
                        // obj's layout is obj itself
                        var t = map.get(this[k]);
                        if (t !== undefined) {
                            nobj[k] = t;
                        } else {
                            nobj[k] = zebkit.clone(this[k], map);
                        }
                    }
                }

                // speed up clearing resources
                map.clear();

                nobj.constructor = this.constructor;

                if (typeof nobj.$hash$ !== 'undefined') {
                    nobj.$hash$ = "$zObj_" + ($$$++);
                }

                nobj.clazz = this.clazz;
                return nobj;
            };

            /**
             * The instance class.
             * @attribute clazz
             * @type {zebkit.Class}
             */
            classTemplate.prototype.clazz = classTemplate;

            // check if the method has been already defined in the class
            if (typeof classTemplate.prototype.properties === 'undefined') {
                classTemplate.prototype.properties = function(p) {
                    return pkg.properties(this, p);
                };
            }

            // copy methods from interfaces before mixing class methods
            if (toInherit.length > 0) {
                for(var i = toInherit[0].clazz === pkg.Interface ? 0 : 1; i < toInherit.length; i++) {
                    var  ic = toInherit[i];
                    cpMethods(ic.prototype, classTemplate.prototype, classTemplate);

                    // copy static fields from interface to the class
                    for(var sk in ic) {
                        if (sk[0] !== '$' &&
                            ic.hasOwnProperty(sk) === true &&
                            classTemplate.hasOwnProperty(sk) === false)
                        {
                            classTemplate[sk] = pkg.clone(ic[sk]);
                        }
                    }
                }
            }

            // add class declared methods
            mixing(classTemplate, classMethods);

            // populate static fields
            // TODO: exclude the basic static methods and static constant
            // static inheritance

            classTemplate.$uniqueness = false;
            if (parentClass !== null) {
                for (var key in parentClass) {
                    if (key[0] !== '$' &&
                        parentClass.hasOwnProperty(key) &&
                        classTemplate.hasOwnProperty(key) === false)
                    {
                        classTemplate[key] = pkg.clone(parentClass[key]);
                    }
                }

                if (parentClass.$uniqueness === true) {
                    classTemplate.hashable();
                }
            }

            /**
             * Make the class hashable. Hashable class instances are automatically
             * gets unique hash code that is returned with its overridden "toString()"
             * method. The hash code is stored in special "$hash$" field. The feature
             * can be useful when you want to store class instances in "{}" object
             * where key is the hash and the value is the instance itself.
             * @method hashable
             * @chainable
             * @for zebkit.Class
             */
            classTemplate.hashable = function() {
                if (this.$uniqueness !== true) {
                    this.$uniqueness = true;
                    this.prototype.toString = $toString;
                }
                return this;
            };

            /**
             * Make the class hashless. Prevents generation of hash code for
             * instances of the classes.
             * @method hashless
             * @chainable
             * @for zebkit.Class
             */
            classTemplate.hashless = function() {
                if (this.$uniqueness === true) {
                    this.$uniqueness = false;
                    this.prototype.toString = Object.prototype.toString;
                }
                return this;
            };

            /**
             * Extend the class with new method and implemented interfaces.
             * @param {zebkit.Interface} [varname]*  number of interfaces the class has to implement.
             * @param {Array} methods set of methods the given class has to be extended.
             * @method extend
             * @for  zebkit.Class
             */

            // add extend method later to avoid the method be inherited as a class static field
            classTemplate.extend = function() {
                var methods    = arguments[arguments.length - 1],
                    hasMethod  = Array.isArray(methods);

                // inject class
                if (hasMethod && this.$isExtended !== true) {
                    // create intermediate class
                    var A = this.$parent !== null ? pkg.Class(this.$parent, [])
                                                  : pkg.Class([]);

                    // copy this class prototypes methods to intermediate class A and re-define
                    // boundTo to the intermediate class A if they were bound to source class
                    // methods that have been  moved from source class to class have to be re-bound
                    // to A class
                    for(var name in this.prototype) {
                        if (name !== "clazz" && this.prototype.hasOwnProperty(name) ) {
                            var f = this.prototype[name];
                            if (typeof f === 'function') {
                                A.prototype[name] = typeof f.methodBody !== 'undefined' ? ProxyMethod(name, f.methodBody, f.boundTo)
                                                                                        : f;

                                if (A.prototype[name].boundTo === this) {
                                    A.prototype[name].boundTo = A;
                                    if (f.boundTo === this) {
                                        f.boundTo = A;
                                    }
                                }
                            }
                        }
                    }

                    this.$parent = A;
                    this.$isExtended = true;
                }

                if (hasMethod) {
                    mixing(this, methods);
                }

                // add passed interfaces
                for(var i = 0; i < arguments.length - (hasMethod ? 1 : 0); i++) {
                    var I = arguments[i];
                    if (I === null || typeof I === 'undefined' || I.clazz !== zebkit.Interface) {
                        throw new Error("Interface is expected");
                    }

                    if (typeof this.$parents[I.$hash$] !== 'undefined') {
                        throw new Error("Interface has been already inherited");
                    }

                    cpMethods(I.prototype, this.prototype, this);
                    this.$parents[I.$hash$] = I;
                }
            };

            /**
             * Tests if the given class inherits the given class or interface.
             * @param  {clazz}  clazz a class or interface.
             * @return {Boolean} true if the class or interface is inherited with
             * the class.
             * @method  isInherit
             * @for  zebkit.Class
             */
            classTemplate.isInherit = function(clazz) {
                if (this !== clazz) {
                    // detect class
                    if (clazz.clazz === this.clazz) {
                        for (var p = this.$parent; p !== null; p = p.$parent) {
                            if (p === clazz) {
                                return true;
                            }
                        }
                    } else { // detect interface
                        if (this.$parents[clazz.$hash$] === clazz) {
                            return true;
                        }
                    }
                }
                return false;
            };

            // assign proper name to class
            classTemplate.clazz.$name = "zebkit.Class";

            // copy methods from interfaces
            if (toInherit.length > 0) {
                // notify inherited class and interfaces that they have been inherited with the given class
                for(var i = 0; i < toInherit.length; i++) {
                    if (typeof toInherit[i].inheritedWidth === 'function') {
                        toInherit[i].inheritedWidth(classTemplate);
                    }
                }
            }

            return classTemplate;
        });

        var $cachedO = pkg.$cachedO = {},
            $cachedE = pkg.$cachedE = [];

        /**
         * maximal cache size (cache is primary used to keep references to class).
         * @attribute $cacheSize
         * @private
         * @default 7777
         * @type {Number}
         * @for  zebkit
         */
        pkg.$cacheSize = 7777;

        /**
         * Get an object by the given key from cache (and cached it if necessary)
         * @param  {String} key a key to an object. The key is hierarchical reference starting with the global
         * name space as root. For instance "test.a" key will fetch $global.test.a object.
         * @return {Object}  an object
         * @for  zebkit
         * @private
         * @method  $cache
         */
        pkg.$cache = function(key) {
            // don't cache global objects
            if (pkg.$global.hasOwnProperty(key)) {
                return pkg.$global[key];
            }

            if ($cachedO.hasOwnProperty(key) === true) {
                // read cached entry
                var e = $cachedO[key];
                if (e.i < ($cachedE.length-1)) { // cached entry is not last one

                    // move accessed entry to the list tail to increase its access weight
                    var pn = $cachedE[e.i + 1];
                    $cachedE[e.i]   = pn;
                    $cachedE[++e.i] = key;
                    $cachedO[pn].i--;
                }
                return e.o;
            }

            var ctx = pkg.$global, i = 0, j = 0;
            for( ;ctx != null; ) {
                i = key.indexOf('.', j);

                if (i < 0) {
                    ctx = ctx[key.substring(j, key.length)];
                    break;
                }

                ctx = ctx[key.substring(j, i)];
                j = i + 1;
            }

            if (ctx != null) {
                if ($cachedE.length >= pkg.$cacheSize) {
                    // cache is full, replace first element with the new one
                    var n = $cachedE[0];
                    $cachedE[0]   = key;
                    $cachedO[key] = { o: ctx, i: 0 };
                    delete $cachedO[n];
                } else {
                    $cachedO[key] = { o: ctx, i: $cachedE.length };
                    $cachedE[$cachedE.length] = key;
                }
                return ctx;
            }

            throw new Error("Reference '" + key + "' not found");
        };

        /**
         * Get class by the given class name
         * @param  {String} name a class name
         * @return {Function} a class. Throws exception if the class cannot be
         * resolved by the given class name
         * @method forName
         * @throws Error
         * @for  zebkit.Class
         */
        pkg.Class.forName = function(name) {
            return pkg.$cache(name);
        };

        /**
         * Create an instance of the class
         * @param  {String} [name]* arguments to be passed to the class constructor
         * @return {Object} an instance of the class.
         * @method newInstance
         * @for  zebkit.Class
         */
        pkg.Class.newInstance = function() {
            return pkg.newInstance(this, arguments);
        };

        /**
         * Test if the given object is instance of the specified class or interface. It is preferable
         * to use this method instead of JavaScript "instanceof" operator whenever you are dealing with
         * zebkit classes and interfaces.
         * @param  {Object} obj an object to be evaluated
         * @param  {Function} clazz a class or interface
         * @return {Boolean} true if a passed object is instance of the given class or interface
         * @method instanceOf
         * @for  zebkit
         */
        pkg.instanceOf = function(obj, clazz) {
            if (clazz !== null && typeof clazz !== 'undefined') {
                if (obj === null || typeof obj === 'undefined')  {
                    return false;
                } else if (typeof obj.clazz === 'undefined') {
                    return (obj instanceof clazz);
                } else {
                    return typeof obj.clazz !== 'undefined' && obj.clazz !== null &&
                           (obj.clazz === clazz ||
                            obj.clazz.$parents.hasOwnProperty(clazz.$hash$));
                }
            }

            throw new Error("instanceOf(): null class");
        };

        /**
         * Dummy class that implements nothing but can be useful to instantiate
         * anonymous classes with some on "the fly" functionality:

            // instantiate and use zebkit class with method "a()" implemented
            var ac = new zebkit.Dummy([
                 function a() {
                    ...
                 }
            ]);

            // use it
            ac.a();

         * @constructor
         * @class zebkit.Dummy
         */
        pkg.Dummy = pkg.Class([]);

        pkg.DoIt = DoIt;

        /**
         * Event producer interface. This interface provides number of methods
         * to register, un-register, fire events. It follows on/off notion like
         * JQuery does it. It is expected an event producer class implementation
         * has a special field  "_" that keeps listeners.
         *
         *     var MyClass = zebkit.Class(zebkit.EventProducer, [
         *         function() {
         *             // "fired" events listeners container
         *             this._ = new zebkit.util.Listeners();
         *         }
         *     ]);
         *
         *     var a = new MyClass();
         *     a.on("fired", function(arg) {
         *         // handle "fired" events
         *     });
         *
         *     a.fire(10);
         *
         * @class zebkit.EventProducer
         * @interface zebkit.EventProducer
         */
        pkg.EventProducer = pkg.Interface([
            function $prototype() {
                // on(event, path, cb)  handle the given event for all elements identified with the path
                // on(cb)               handle all events
                // on(path | event, cb) handle the given event or all events for elements matched with the path


                /**
                 * Register listener for the given events types or/and the given nodes in tree-like
                 * structure or listen all events types.
                 * @param {String} [eventName] an event type name to listen. If the event name is not passed
                 * then listen all events types.
                 * @param {String} [path] a xpath-like path to traversing elements in tree and register event
                 * handlers for the found elements. The parameter can be used if the interface is implemented
                 * with tree-like structure (for instance zebkit UI components).
                 * @param {Function|Object} cb a listener method or an object that contains number of methods
                 * to listen the specified events types.
                 * @example
                 *     var comp = new zebkit.ui.Panel();
                 *     comp.add(new zebkit.ui.Button("Test 1").setId("c1"));
                 *     comp.add(new zebkit.ui.Button("Test 2").setId("c2"));
                 *     ...
                 *     // register event handler for children components of "comp"
                 *     comp.on("/*", function() {
                 *         // handle button fired event
                 *         ...
                 *     });
                 *
                 *     // register event handler for button component with id equals "c1"
                 *     comp.on("#c1", function() {
                 *         // handle button fired event
                 *         ...
                 *     });
                 *
                 * @method on
                 */
                this.on = function() {
                    var cb = arguments[arguments.length - 1],  // callback or object
                        pt = null,                             // path
                        nm = null;                             // event name

                    if (cb === null || isString(cb)) {
                        throw new Error("Invalid event handler");
                    }

                    if (arguments.length === 1) {
                        return this._.add(cb);
                    } else if (arguments.length === 2) {
                        if (arguments[0] === null) {
                            throw new Error("Invalid event or path");
                        } else if (arguments[0][0] === '.' || arguments[0][0] === '/' || arguments[0][0] === '#') { // detect path
                            pt = arguments[0];
                        } else {
                            return this._.add(arguments[0], cb);
                        }
                    } else if (arguments.length === 3) {
                        pt = arguments[1];
                        nm = arguments[0];
                        if (pt === null) {
                            return this._.add(nm, cb);
                        }
                    }

                    this.byPath(pt, function(node) {
                        if (typeof node._ !== 'undefined') {
                            if (nm !== null) {
                                if (typeof node._[nm] !== 'undefined') {
                                    node._.add(nm, cb);
                                }
                            } else {
                                node._.add(cb);
                            }
                        }
                        return false;
                    });

                    return cb;
                };

                // off()            remove all events handler
                // off(event)       remove the event handler
                // off(event, path)  remove the event handler for all nodes detected with the path
                // off(path)
                // off(cb)
                // off(path, cb)
                //
                /**
                 * Stop listening the given event type.
                 * @param {String} [eventName] an event type name to stop listening. If the event name is not passed
                 * then stop listening all events types.
                 * @param {String} [path] a xpath-like path to traversing elements in tree and stop listening
                 * the event type for the found in the tree elements. The parameter can be used if the interface
                 * is implemented with tree-like structure (for instance zebkit UI components).
                 * @param [cb] remove the given event handler.
                 * @method off
                 */
                this.off = function() {
                    var pt = null,  // path
                        fn = null,  // handler
                        nm = null;  // event name or listener

                    if (arguments.length === 0) {
                        return this._.remove();
                    } else if (arguments.length === 1) {
                        if (isString(arguments[0]) && (arguments[0][0] === '.' || arguments[0][0] === '/' || arguments[0][0] === '#')) {
                            pt = arguments[0];
                        } else {
                            return this._.remove(arguments[0]);
                        }
                    } else if (arguments.length === 2) {
                        if (isString(arguments[1])) { // detect path
                            pt = arguments[1];
                            nm = arguments[0];
                        } else {
                            if (isString(arguments[1])) {
                                nm = arguments[1];
                            } else {
                                fn = arguments[1];
                            }

                            if (arguments[0][0] === '.' || arguments[0][0] === '/' || arguments[0][0] === '#') {
                                pt = arguments[0];
                            } else {
                                throw new Error("Path is expected");
                            }
                        }
                    }

                    this.byPath(pt, function(node) {
                        if (typeof node._ !== 'undefined') {
                            if (fn !== null) {
                                node._.remove(fn);
                            } else if (nm !== null) {
                                if (typeof node._[nm] !== 'undefined') {
                                    node._.remove(nm);
                                }
                            } else {
                                node._.remove();
                            }
                        }
                        return false;
                    });
                };

                // fire(event, [ a1, a2, ...])
                // fire(event, e)
                // fire(event, path, e)
                // fire(event, path, [a1, a2 ...])
                this.fire = function() {
                    var pt   = null,  // path
                        args = null,
                        nm   = arguments[0];  // event name or listener

                    if (arguments.length >= 0 && arguments.length < 3) {
                        if (arguments.length === 0) {
                            nm = "fired";
                        }

                        if (this._.hasEvent(nm) === false) {
                            throw new Error("Listener doesn't '" + nm + "' support the event");
                        }

                        var fn = this._[nm];
                        args = (arguments.length === 2 ? arguments[1] : this);

                        return arguments.length === 2 && Array.isArray(args) ? fn.apply(this._, args)
                                                                             : fn.call(this._, args);

                    } else if (arguments.length === 3) {
                        pt   = arguments[1];
                        args = arguments[2];
                    } else {
                        throw new Error("Invalid number of arguments");
                    }

                    this.byPath(pt, function(n) {
                        var ec = n._;
                        if (typeof ec !== 'undefined' && n._.hasEvent(nm)) {
                            if (args !== null && Array.isArray(args)) {
                                ec[nm].apply(ec, args);
                            } else {
                                ec[nm].call(ec, args);
                            }
                        }
                        return false;
                    });
                };
            }
        ]);
    });

    if (isInBrowser) {
        zebkit.then(function() {
            var jn        = this.join(),
                $interval = zenv.setInterval(function () {
                if (document.readyState === "complete") {
                    zenv.clearInterval($interval);
                    jn(zebkit);
                }
            }, 100);
        });
    }

    return zebkit;
})();

zebkit.package("util", function(pkg, Class) {
    /**
     * Number of different utilities methods and classes. The package has alternative to JS promise approach
     * that helps to make your code more linear looking nevertheless it can contain asynchronous calling.
     * One more useful class is zebkit Zson that allows developer to describe number of objects
     * and its properties value in JSON format.
     * @class zebkit.util
     * @access package
     */

    /**
     * Validate the specified value to be equal one of the given values
     * @param  {value} value a value to be validated
     * @param  {Object} [value]* a number of valid values to test against
     * @throws Error if the value doesn't match any valid value
     * @for  zebkit.util
     * @method  $validateValue
     * @example
     *      // test if the alignment is equal one of the possible values
     *      // throws error otherwise
     *      zebkit.util.$validateValue(alignment, "top", "left", "right", "bottom");
     * @protected
     */
    pkg.$validateValue = function(value) {
        if (arguments.length < 2) {
            throw new Error("Invalid arguments list. List of valid values is expected");
        }

        for(var i = 1; i < arguments.length; i++) {
            if (arguments[i] === value) {
                return value;
            }
        }

        var values = Array.prototype.slice.call(arguments).slice(1);
        throw new Error("Invalid value '" + value + "',the following values are expected: " + values.join(','));
    };

    pkg.format = function(s, obj, ph) {
        if (arguments.length < 3) ph = '';

        var rg = /\$\{([0-9]+\s*,)?(.?,)?([a-zA-Z_][a-zA-Z0-9_]*)\}/g,
            r  = [],
            i  = 0,
            j  = 0,
            m  = null;

        while ((m = rg.exec(s)) !== null) {
            r[i++] = s.substring(j, m.index);

            j = m.index + m[0].length;

            var v  = obj[m[3]],
                mn = "get" + m[3][0].toUpperCase() + m[3].substring(1),
                f  = obj[mn];

            if (typeof f === "function") {
                v = f.call(obj);
            }

            if (typeof m[1] !== 'undefined') {
                var ml  = parseInt(m[1].substring(0, m[1].length - 1).trim()),
                    ph2 = typeof m[2] !== 'undefined' ? m[2].substring(0, m[2].length - 1) : ph;

                if (v === null || typeof v === 'undefined') {
                    ph2 = ph;
                    v = "";
                } else {
                    v = "" + v;
                }

                for(var k = v.length; k < ml; k++) {
                    v = ph2 + v;
                }
            }

            if (v === null || typeof v === 'undefined') v = ph;

            r[i++] = v;
        }

        if (i > 0) {
            if (j < s.length) {
                r[i++] = s.substring(j);
            }

            return pkg.format(r.join(''), obj, ph);
        }

        return s;
    };

    /**
     * Load image or complete the given image loading.
     * @param  {String|Image} ph path or image to complete loading.
     * @param  {Boolean} [fireErr] flag to force or preserve error firing.
     * @return {zebkit.DoIt}
     * @method image
     * @for  zebkit.util
     */
    pkg.image = function(ph, fireErr) {
        if (arguments.length < 2) {
            fireErr = false;
        }

        var d  = new zebkit.DoIt(),
            jn = d.join();

        zebkit.environment.loadImage(ph,
            function(img) {
                jn(img);
            },
            function(img, e) {
                if (fireErr === true) {
                    d.error(e);
                } else {
                    jn(img);
                }
            }
        );

        return d;
    };

    /**
     * Abstract event class.
     * @class zebkit.util.Event
     * @constructor
     */
    pkg.Event = Class([
        function $prototype() {
            /**
             * Source of an event
             * @attribute source
             * @type {Object}
             * @default null
             * @readOnly
             */
            this.source = null;
        }
    ]);

    /**
     *  Finds an item by xpath-like simplified expression applied to a tree-like structure.
     *  Passed tree-like structure doesn't have a special requirements except every item of
     *  the structure have to define its kids by exposing "kids" field. The field is array
     *  of children elements:
     *
     *      // example of tree-like structure
     *      var treeLikeRoot = {
     *          value : "Root",
     *          kids : [
     *              { value: "Item 1" },
     *              { value: "Item 2" }
     *          ]
     *      };
     *
     *      zebkit.util.findInTree(treeLikeRoot,
     *          "/item1",
     *          function(foundElement) {
     *             ...
     *             // returning true means stop lookup
     *             return true;
     *          },
     *          function(item, fragment) {
     *              return item.value === fragment;
     *          });
     *
     *
     * The find method traverse the tree-like structure according to the xpath-like
     * expression. To understand if the given tree item confronts with the currently
     * traversing path fragment a special equality method has to be passed. The method
     * gets the traversing tree item and a string path fragment. The method has to
     * decide if the given tree item complies the specified path fragment.
     *
     * @param  {Object} root a tree root element. If the element has a children elements
     * the children have to be stored in "kids" field as an array.
     * @param  {String}  path a path-like expression. The path has to satisfy number of requirements:

        - has to start with "." or "/" or "//" character
        - has to define path part after "/" or "//"
        - path part can be either "*" or a name
        - optionally an attribute or/and its value can be defined as "[@<attr_name>=<attr_value>]"
        - attribute value is optional and can be boolean (true or false), integer, null or string value
        - string attribute value has to be wrapped with single quotes

     *
     * For examples:

        - "//*" traverse all tree elements
        - "//*[@a=10]" traverse all tree elements that has an attribute "a" that equals 10
        - "//*[@a]" traverse all tree elements that has an attribute "a" defined
        - "/Item1/Item2" find an element by exact path
        - ".//" traverse all tree elements including the root element

     * @param  {Function} cb callback function that is called every time a new tree element
     * matches the given path fragment. The function has to return true if the tree look up
     * has to be interrupted
     * @param  {Function}  [eq]  an equality function. The function gets current evaluated tree element
     * and a path fragment against which the tree element has to be evaluated. It is expected the method
     * returns boolean value to say if the given passed tree element matches the path fragment. If the
     * parameter is not passed or null then default equality method is used. The default method expects
     * a tree item has "path" field that is matched with  given path fragment.
     * @method findInTree
     * @for  zebkit.util
     */

    var PATH_RE = /^[.]?(\/[\/]?)([^\[\/]+)\s*(\[\s*\@([a-zA-Z_][a-zA-Z0-9_\.]*)\s*(\=\s*[0-9]+|\=\s*true|\=\s*false|\=\s*null|\=\s*\'[^']*\')?\s*\])?/;
    pkg.findInTree = function(root, path, cb, eq, m) {
        if (root === null || typeof root === 'undefined') {
            throw new Error("Null tree root");
        }

        // if the method called first time
        if (arguments.length < 5) {
            path = path.trim();
            if (path[0] === '#') {
                path = "//*[@id='" + path.substring(1).trim() + "']";
            } else if (path === '.') {
                return cb(root);
            } else if (path[0] === '.' && path[1] === '/') { // means we have to include root in search
                root = { kids: [ root ] };
                path = path.substring(1);
            }
            m = null;
        }

        if (eq === null || arguments.length < 4) {
            eq = function(n, fragment) { return n.path === fragment; };
        }

        if (typeof root.kids !== 'undefined' &&   // a node has children
            root.kids        !== null        &&
            root.kids.length > 0                )
        {
            //
            // m == null                      : means this is the first call of the method
            // m[0].length !== m.input.length : means this is terminal part of the path
            //
            if (m === null ||  m[0].length !== m.input.length) {
                m = path.match(PATH_RE);

                if (m === null) {
                    throw new Error("Cannot resolve path '" + path + "'");
                }

                // check if the matched path is not terminal
                if (m[0].length !== path.length) {
                    path = path.substring(m[0].length);  // cut found fragment from the path
                }

                // normalize attribute value
                if (typeof m[3] !== 'undefined' && typeof m[5] !== 'undefined') {
                    m[5] = m[5].substring(1).trim();

                    if (m[5][0] === "'") {
                        m[5] = m[5].substring(1, m[5].length - 1);
                    } else if (m[5] === "true") {
                        m[5] = true;
                    } else if (m[5] === "false") {
                        m[5] = false;
                    } else if (m[5] === "null") {
                        m[5] = null;
                    } else {
                        var vv = parseInt(m[5], 10);
                        if (isNaN(vv) === false) m[5] = vv;
                    }
                }
            }

            var isTerminal = m[0].length === m.input.length,
                pathDelim  = m[1],
                pathValue  = m[2];

            for (var i = 0; i < root.kids.length ; i++) {
                var kid     = root.kids[i],
                    isMatch = false;
                                            // XOR
                if (pathValue === "*" || (eq(kid, pathValue) ? pathValue[0] !== '!' : pathValue[0] === '!')) {
                    if (typeof m[3] !== 'undefined') { // has attributes
                        var attrName = m[4].trim();

                        // leave if attribute doesn't match
                        if (typeof kid[attrName] !== 'undefined' && (typeof m[5] === 'undefined' || kid[attrName] === m[5])) {
                            isMatch = true;
                        }
                    } else {
                        isMatch = true;
                    }
                }

                // if the kid match the path fragment and this is a terminal node
                // let callback know we found a node
                if (isMatch === true && isTerminal === true && cb(kid) === true) {
                    return true;
                }

                // if path delimiter indicates it is recursive children search or
                // we matched not a terminal node let dig deeper in tree
                if ((isMatch === true && isTerminal === false) || pathDelim === "//") {
                    if (pkg.findInTree(kid, path, cb, eq, m) === true) {
                        return true;
                    }
                }
            }
        }
        return false;
    };

    /**
     * Interface that provides path search functionality for a tree-like structure.
     * @class  zebkit.util.PathSearch
     * @interface zebkit.util.PathSearch
     */
    pkg.PathSearch = zebkit.Interface([
        function $prototype() {
            /**
             * Find all children items with the passed path expression.
             * @param  {String} path path expression. Path expression is simplified form
             * of XPath-like expression. See  {{#crossLink "zebkit"}}sdsd{{/crossLink}} method to
             * get more details.
             *
             * @param {Function} [cb] function that is called every time a new children
             * component has been found. If callback has not been passed then the method
             * return first found item or null.
             * @method byPath
             * @return {Object} found children item or null if no children items were found
             */
            this.byPath = function(path, cb) {
                if (typeof this.$normalizePath !== 'undefined') {
                    path = this.$normalizePath(path);
                }

                if (arguments.length === 2) {
                    if (arguments[1] === null) {
                        var r = [];
                        pkg.findInTree(this, path, function(n) {
                            r.push(n);
                            return false;
                        }, typeof this.$matchPath !== 'undefined' ? this.$matchPath
                                                                  : null);
                        return r;
                    } else {
                        pkg.findInTree(this, path, cb, typeof this.$matchPath !== 'undefined' ? this.$matchPath
                                                                                              : null);
                    }
                } else {
                    var res = null;
                    pkg.findInTree(this, path, function(n) {
                        res = n;
                        return true;
                    }, typeof this.$matchPath !== 'undefined' ? this.$matchPath : null);
                    return res;
                }
            };
        }
    ]);

    /**
     * RGB color class. This class represents a rgb color as JavaScript structure:

           // rgb color
           var rgb1 = new zebkit.util.rgb(100,200,100);

           // rgb with transparency
           var rgb2 = new zebkit.util.rgb(100,200,100, 0.6);

           // encoded as a string rgb color
           var rgb3 = new zebkit.util.rgb("rgb(100,100,200)");

           // hex rgb color
           var rgb3 = new zebkit.util.rgb("#CCDDFF");

     * @param  {Integer|String} r  the meaning of the argument depends on number of arguments the
     * constructor gets:
     *
     *   - If constructor gets only this argument the argument is considered as encoded rgb color:
     *      - **String**  means its hex encoded ("#CCFFDD") or rgb ("rgb(100,10,122)", "rgba(100,33,33,0.6)") encoded color
     *      - **Integer** means this is number encoded rgb color
     *   - Otherwise the argument is an integer value that depicts a red intensity of rgb color
     *
     * encoded in string rgb color
     * @param  {Integer} [g]  green color intensity
     * @param  {Integer} [b] blue color intensity
     * @param  {Float}   [a] alpha color intensity
     * @constructor
     * @class zebkit.util.rgb
     */
    pkg.rgb = Class([
        function (r, g, b, a) {
            /**
             * Red color intensity
             * @attribute r
             * @type {Integer}
             * @readOnly
             */

            /**
             * Green color intensity
             * @attribute g
             * @type {Integer}
             * @readOnly
             */

            /**
             * Blue color intensity
             * @attribute b
             * @type {Integer}
             * @readOnly
             */

            /**
             * Alpha
             * @attribute a
             * @type {Float}
             * @readOnly
             */
            if (arguments.length === 1) {
                if (zebkit.isString(r)) {
                    this.s = r;
                    if (r[0] === '#') {
                        r = parseInt(r.substring(1), 16);
                    } else {
                        if (r[0] === 'r' && r[1] === 'g' && r[2] === 'b') {
                            var i = r.indexOf('(', 3), p = r.substring(i + 1, r.indexOf(')', i + 1)).split(",");
                            this.r = parseInt(p[0].trim(), 10);
                            this.g = parseInt(p[1].trim(), 10);
                            this.b = parseInt(p[2].trim(), 10);
                            if (p.length > 3) {
                                this.a = parseInt(p[3].trim(), 10);
                                this.isOpaque = (this.a === 1);
                            }
                            return;
                        }
                    }
                }
                this.r =  r >> 16;
                this.g = (r >> 8) & 0xFF;
                this.b = (r & 0xFF);
            } else {
                this.r = r;
                this.g = g;
                this.b = b;
                if (arguments.length > 3) this.a = a;
            }

            if (this.s === null) {
                this.s = (typeof this.a !== "undefined") ? 'rgba(' + this.r + "," + this.g +  "," +
                                                                     this.b + "," + this.a + ")"
                                                         : '#' +
                                                           ((this.r < 16) ? "0" + this.r.toString(16) : this.r.toString(16)) +
                                                           ((this.g < 16) ? "0" + this.g.toString(16) : this.g.toString(16)) +
                                                           ((this.b < 16) ? "0" + this.b.toString(16) : this.b.toString(16));
            }
        },

        function $prototype() {
            this.s = null;

            /**
             * Indicates if the color is opaque
             * @attribute isOpaque
             * @readOnly
             * @type {Boolean}
             */
            this.isOpaque = true;

            this.toString = function() {
                return this.s;
            };
        },

        function $clazz() {
            /**
             * Black color constant
             * @attribute black
             * @type {zebkit.util.rgb}
             * @static
             */

            this.black       = new this(0);
            this.white       = new this(0xFFFFFF);
            this.red         = new this(255,0,0);
            this.blue        = new this(0,0,255);
            this.green       = new this(0,255,0);
            this.gray        = new this(128,128,128);
            this.lightGray   = new this(211,211,211);
            this.darkGray    = new this(169,169,169);
            this.orange      = new this(255,165,0);
            this.yellow      = new this(255,255,0);
            this.pink        = new this(255,192,203);
            this.cyan        = new this(0,255,255);
            this.magenta     = new this(255,0,255);
            this.darkBlue    = new this(0, 0, 140);
            this.transparent = new this(0, 0, 0, 0.0);

            this.mergeable = false;
        }
    ]);

    /**
     * Compute intersection of the two given rectangular areas
     * @param  {Integer} x1 a x coordinate of the first rectangular area
     * @param  {Integer} y1 a y coordinate of the first rectangular area
     * @param  {Integer} w1 a width of the first rectangular area
     * @param  {Integer} h1 a height of the first rectangular area
     * @param  {Integer} x2 a x coordinate of the first rectangular area
     * @param  {Integer} y2 a y coordinate of the first rectangular area
     * @param  {Integer} w2 a width of the first rectangular area
     * @param  {Integer} h2 a height of the first rectangular area
     * @param  {Object}  r  an object to store result
     *
     *      { x: {Integer}, y:{Integer}, width:{Integer}, height:{Integer} }
     *
     * @method intersection
     * @for zebkit.util
     */
    pkg.intersection = function(x1,y1,w1,h1,x2,y2,w2,h2,r){
        r.x = x1 > x2 ? x1 : x2;
        r.width = Math.min(x1 + w1, x2 + w2) - r.x;
        r.y = y1 > y2 ? y1 : y2;
        r.height = Math.min(y1 + h1, y2 + h2) - r.y;
    };

    /**
     * Test if two rectangular areas have intersection
     * @param  {Integer} x1 a x coordinate of the first rectangular area
     * @param  {Integer} y1 a y coordinate of the first rectangular area
     * @param  {Integer} w1 a width of the first rectangular area
     * @param  {Integer} h1 a height of the first rectangular area
     * @param  {Integer} x2 a x coordinate of the first rectangular area
     * @param  {Integer} y2 a y coordinate of the first rectangular area
     * @param  {Integer} w2 a width of the first rectangular area
     * @param  {Integer} h2 a height of the first rectangular area
     * @return {Boolean} true if the given two rectangular areas intersect
     *
     * @method isIntersect
     * @for zebkit.util
     */
    pkg.isIntersect = function(x1,y1,w1,h1,x2,y2,w2,h2){
        return (Math.min(x1 + w1, x2 + w2) - (x1 > x2 ? x1 : x2)) > 0 &&
               (Math.min(y1 + h1, y2 + h2) - (y1 > y2 ? y1 : y2)) > 0;
    };

    /**
     * Unite two rectangular areas to one rectangular area.
     * @param  {Integer} x1 a x coordinate of the first rectangular area
     * @param  {Integer} y1 a y coordinate of the first rectangular area
     * @param  {Integer} w1 a width of the first rectangular area
     * @param  {Integer} h1 a height of the first rectangular area
     * @param  {Integer} x2 a x coordinate of the first rectangular area
     * @param  {Integer} y2 a y coordinate of the first rectangular area
     * @param  {Integer} w2 a width of the first rectangular area
     * @param  {Integer} h2 a height of the first rectangular area
     * @param  {Object}  r  an object to store result
     *
     *      { x: {Integer}, y:{Integer}, width:{Integer}, height:{Integer} }
     *
     * @method unite
     * @for zebkit.util
     */
    pkg.unite = function(x1,y1,w1,h1,x2,y2,w2,h2,r){
        r.x = x1 < x2 ? x1 : x2;
        r.y = y1 < y2 ? y1 : y2;
        r.width  = Math.max(x1 + w1, x2 + w2) - r.x;
        r.height = Math.max(y1 + h1, y2 + h2) - r.y;
    };

    var letterRE = /[A-Za-z]/;
    pkg.isLetter = function (ch) {
        if (ch.length !== 1) throw new Error("Incorrect character");
        return letterRE.test(ch);
    };

    /**
     * This method allows to declare a listeners container class for the given
     * dedicated event types.

        // create listener container to keep three different events
        // handlers
        var MyListenerContainerClass = zebkit.util.ListenersClass("event1",
                                                                  "event2",
                                                                  "event3");

        // instantiate listener class container
        var listeners = new MyListenerContainerClass();

        // add "event1" listener
        listeners.add(function event1() {
            ...
        });

        // add "event2" listener
        listeners.add(function event2() {
           ...
        });

        // add listener for both event1 and event2 events
        listeners.add(function() {
           ...
        });

        // and firing event1 to registered handlers
        listeners.event1(...);

        // and firing event2 to registered handlers
        listeners.event2(...);

     * @for zebkit.util
     * @method ListenersClass
     * @param {String} [events]* events types the listeners container has to support
     * @return {zebkit.util.Listener} a listener container class
     */
    var $NewListener = function() {
        var clazz = function() {};
        clazz.eventNames = arguments.length === 0 ? [ "fired" ]
                                                  : Array.prototype.slice.call(arguments);

        clazz.ListenersClass = function() {
            var args = this.eventNames.slice(); // clone
            for(var i = 0; i < arguments.length; i++) args.push(arguments[i]);
            return $NewListener.apply(this, args);
        };

        if (clazz.eventNames.length === 1) {
            var $ename = clazz.eventNames[0];

            clazz.prototype.v = null;

            clazz.prototype.add = function() {
                var ctx = this,
                    l   = arguments[arguments.length - 1]; // last arguments are handler(s)

                if (typeof l !== 'function') {
                    ctx = l;
                    l   = l[$ename];

                    if (typeof l !== "function") {
                        return null;
                    }
                }

                if (arguments.length > 1 && arguments[0] !== $ename) {
                    throw new Error("Unknown event type :" + $ename);
                }

                if (this.v === null) {
                    this.v = [];
                }

                this.v.push(ctx, l);
                return l;
            };

            clazz.prototype.remove = function(l) {
                if (this.v !== null) {
                    if (arguments.length === 0) {
                        // remove all
                        this.v.length = 0;
                    } else {
                        var name = arguments.length > 1 || zebkit.isString(arguments[0]) ? arguments[0]
                                                                                         : null,
                            fn   = arguments.length > 1 ? arguments[1]
                                                        : (name === null ? arguments[0] : null),
                            i    = 0;

                        if (name !== null && name !== $ename) {
                            throw new Error("Unknown event type :" + name);
                        }

                        if (fn === null) {
                            this.v.length = 0;
                        } else {
                            while ((i = this.v.indexOf(fn)) >= 0) {
                                if (i % 2 > 0) i--;
                                this.v.splice(i, 2);
                            }
                        }
                    }
                }
            };

            clazz.prototype.hasHandler = function(l) {
                if (zebkit.isString(l)) {
                    return this.v !== null && l === $ename && this.v.length > 0;
                } else {
                    return this.v.length > 0 && this.v.indexOf(l) >= 0;
                }
            };

            clazz.prototype[$ename] = function() {
                if (this.v !== null) {
                    for(var i = 0; i < this.v.length; i +=2 ) {
                        if (this.v[i + 1].apply(this.v[i], arguments) === true) {
                            return true;
                        }
                    }
                }
                return false;
            };

            clazz.prototype.hasEvent = function(nm) {
                return nm === $ename;
            };
        } else {
            var names = {};
            for(var i = 0; i < clazz.eventNames.length; i++) {
                names[clazz.eventNames[i]] = true;
            }

            clazz.prototype.$methods = null;

            clazz.prototype.add = function(l) {
                if (this.$methods === null) {
                    this.$methods = {};
                }

                var n   = null,
                    k   = null,
                    nms = typeof this.$names !== 'undefined' ? this.$names : names;

                if (arguments.length > 1) {
                    n = arguments[0];
                    l = arguments[arguments.length - 1]; // last arguments are handler(s)
                }

                if (typeof l === 'function') {
                    if (n !== null && nms.hasOwnProperty(n) === false) {
                        throw new Error("Unknown event type " + n);
                    }

                    if (n === null) {
                        for(k in nms) {
                            if (this.$methods.hasOwnProperty(k) === false) {
                                this.$methods[k] = [];
                            }
                            this.$methods[k].push(this, l);
                        }
                    } else {
                        if (this.$methods.hasOwnProperty(n) === false) {
                            this.$methods[n] = [];
                        }
                        this.$methods[n].push(this, l);
                    }
                } else {
                    var b = false;
                    for (k in nms) {
                        if (typeof l[k] === "function") {
                            b = true;
                            if (this.$methods.hasOwnProperty(k) === false) {
                                this.$methods[k] = [];
                            }
                            this.$methods[k].push(l, l[k]);
                        }
                    }

                    if (b === false) {
                        return null;
                    }
                }
                return l;
            };

            clazz.prototype.hasHandler = function(l) {
                if (zebkit.isString(l)) {
                    return this.$methods !== null &&
                           this.$methods.hasOwnProperty(l) &&
                           this.$methods[l].length > 0;
                } else {
                    for(var k in this.$methods) {
                        var v = this.$methods[k];
                        if (v.indexOf(l) >= 0) {
                            return true;
                        }
                    }
                    return false;
                }
            };

            clazz.prototype.addEvents = function() {
                if (typeof this.$names === 'undefined') {
                    this.$names = {};
                    for (var k in names) {
                        this.$names[k] = names[k];
                    }
                }

                for(var i = 0; i < arguments.length; i++) {
                    var name = arguments[i];

                    if (name === null || typeof name === 'undefined' || typeof this[name] !== 'undefined') {
                        throw new Error("Invalid " + name + " (event name)");
                    }

                    this[name] = (function(name) {
                        return function() {
                            if (this.$methods !== null) {
                                if (this.$methods.hasOwnProperty(name)) {
                                    var c = this.$methods[name];
                                    for(var i = 0; i < c.length; i += 2) {
                                        if (c[i + 1].apply(c[i], arguments) === true) {
                                            return true;
                                        }
                                    }
                                }
                            }
                            return false;
                        };
                    })(name);

                    this.$names[name] = true;
                }
            };

            // populate methods that has to be called to send appropriate events to
            // registered listeners
            clazz.prototype.addEvents.apply(clazz.prototype, clazz.eventNames);

            clazz.prototype.remove = function() {
                if (this.$methods !== null) {
                    var k = null;
                    if (arguments.length === 0) {
                        for(k in this.$methods) {
                            if (this.$methods.hasOwnProperty(k)) this.$methods[k].length = 0;
                        }
                        this.$methods = {};
                    } else {
                        var name = arguments.length > 1 || zebkit.isString(arguments[0]) ? arguments[0]
                                                                                         : null,
                            fn   = arguments.length > 1 ? arguments[1]
                                                        : (name === null ? arguments[0] : null),
                            i    = 0,
                            v    = null;

                        if (name !== null) {
                            if (this.$methods.hasOwnProperty(name)) {
                                if (fn === null) {
                                    this.$methods[name].length = 0;
                                    delete this.$methods[name];
                                } else {
                                    v = this.$methods[name];
                                    while ((i = v.indexOf(fn)) >= 0) {
                                        if (i % 2 > 0) i--;
                                        v.splice(i, 2);
                                    }

                                    if (v.length === 0) {
                                        delete this.$methods[name];
                                    }
                                }
                            }
                        } else {
                            for (k in this.$methods) {
                                v = this.$methods[k];
                                while ((i = v.indexOf(fn)) >= 0) {
                                    if (i % 2 > 0) i--;
                                    v.splice(i, 2);
                                }

                                if (v.length === 0) {
                                    delete this.$methods[k];
                                }
                            }
                        }
                    }
                }
            };

            clazz.prototype.hasEvent = function(nm) {
                if (typeof this.$names !== 'undefined') {
                    return this.$names.hasOwnProperty(nm);
                } else {
                    return names.hasOwnProperty(nm);
                }
            };
        }


        return clazz;
    };

    /**
     * Listeners container class that can be handy to store number of listeners
     * for one type of event.
     * @param {String} [eventName] an event name the listeners container has been
     * created. By default "fired" is default event name. Event name is used to fire
     * the given event to a listener container.
     * @constructor
     * @class zebkit.util.Listeners
     * @example
     *
     *      // create container with a default event name
     *      var  container = new Listeners();
     *
     *      // register a listener
     *      var  listener = container.add(function(param1, param2) {
     *          // handle fired event
     *      });
     *
     *      ...
     *      // fire event
     *      container.fired(1, 2, 3);
     *
     *      // remove listener
     *      container.remove(listener);
     *
     * @extends {zebkit.util.Listener}
     */


    /**
     * Add listener
     * @param {Function|Object} l a listener method or object.
     * @return {Function} a listener that has been registered in the container. The result should
     * be used to un-register the listener
     * @method  add
     */


    /**
     * Remove listener or all registered listeners from the container
     * @param {Function} [l] a listener to be removed. If the argument has not been specified
     * all registered in the container listeners will be removed
     * @method  remove
     */
    pkg.Listeners = $NewListener();


    pkg.ListenersClass = $NewListener;


    /**
     * Useful class to track a virtual cursor position in a structure that has dedicated number of lines
     * where every line has a number of elements. The structure metric has to be described by providing
     * an instance of zebkit.util.Position.Metric interface that discovers how many lines the structure
     * has and how many elements every line includes.
     * @param {zebkit.util.Position.Metric} m a position metric
     * @constructor
     * @class zebkit.util.Position
     */

    /**
     * Fire when a virtual cursor position has been updated
     *
     *      position.on(function(src, prevOffset, prevLine, prevCol) {
     *          ...
     *      });
     *
     * @event posChanged
     * @param {zebkit.util.Position} src an object that triggers the event
     * @param {Integer} prevOffest a previous virtual cursor offset
     * @param {Integer} prevLine a previous virtual cursor line
     * @param {Integer} prevCol a previous virtual cursor column in the previous line
     */
    pkg.Position = Class(zebkit.EventProducer, [
        function(pi){
            this._ = new this.clazz.Listeners();

            /**
             * Shows if the position object is in valid state.
             * @private
             * @type {Boolean}
             * @attribute isValid
             */
            this.isValid = false;

            /**
             * Current virtual cursor line position
             * @attribute currentLine
             * @type {Integer}
             * @readOnly
             */

            /**
             * Current virtual cursor column position
             * @attribute currentCol
             * @type {Integer}
             * @readOnly
             */

            /**
             * Current virtual cursor offset
             * @attribute offset
             * @type {Integer}
             * @readOnly
             */

            this.currentLine = this.currentCol = this.offset = 0;
            this.setMetric(pi);
        },

        function $clazz() {
            this.Listeners = pkg.ListenersClass("posChanged");

            /**
             * Position metric interface. This interface is designed for describing
             * a navigational structure that consists on number of lines where
             * every line consists of number of elements
             * @class zebkit.util.Position.Metric
             * @interface zebkit.util.Position.Metric
             */

            /**
             * Get number of lines to navigate through
             * @return {Integer} a number of lines
             * @method  getLines
             */

             /**
              * Get a number of elements in the given line
              * @param {Integer} l a line index
              * @return {Integer} a number of elements in a line
              * @method  getLineSize
              */

             /**
              * Get a maximal element index (a last element of a last line)
              * @return {Integer} a maximal element index
              * @method  getMaxOffset
              */

            this.Metric = zebkit.Interface([
                "abstract",
                    function getLines()     {

                    },

                    function getLineSize()  {

                    },

                    function getMaxOffset() {

                    }
            ]);
        },

        /**
         *  @for zebkit.util.Position
         */
        function $prototype() {
            /**
             * Set the specified virtual cursor offsest
             * @param {Integer} o an offset, pass null to set position to indefinite state.
             *
             *   - if offset is null than offset will set to -1 (undefined state)
             *   - if offset is less than zero than offset will be set to zero
             *   - if offset is greater or equal to maximal possible offset it will be set to maximal possible offset
             *
             *  @return {Integer} an offset that has been set
             * @method setOffset
             */
            this.setOffset = function(o){
                if (o < 0) o = 0;
                else {
                    if (o === null) o = -1;
                    else {
                        var max = this.metrics.getMaxOffset();
                        if (o >= max) o = max;
                    }
                }

                if (o !== this.offset){
                    var prevOffset = this.offset,
                        prevLine   = this.currentLine,
                        prevCol    = this.currentCol,
                        p          = this.getPointByOffset(o);

                    this.offset = o;
                    if (p !== null){
                        this.currentLine = p[0];
                        this.currentCol  = p[1];
                    } else {
                        this.currentLine = this.currentCol = -1;
                    }
                    this.isValid = true;
                    this._.posChanged(this, prevOffset, prevLine, prevCol);
                }

                return o;
            };

            /**
             * Seek virtual cursor offset with the given shift
             * @param {Integer} off a shift
             * @return {Integer} an offset that has been set
             * @method seek
             */
            this.seek = function(off) {
                return this.setOffset(this.offset + off);
            };

            /**
             * Set the virtual cursor line and the given column in the line
             * @param {Integer} r a line
             * @param {Integer} c a column in the line
             * @method setRowCol
             */
            this.setRowCol = function(r, c) {
                if (r !== this.currentLine || c !== this.currentCol){
                    var prevOffset = this.offset,
                        prevLine = this.currentLine,
                        prevCol = this.currentCol;

                    this.offset = this.getOffsetByPoint(r, c);
                    this.currentLine = r;
                    this.currentCol = c;
                    this._.posChanged(this, prevOffset, prevLine, prevCol);
                }
            };

            /**
             * Special method to inform the position object that its state has to be adjusted
             * because of the given portion of data had been inserted .
             * @param  {Integer} off  an offset the insertion has happened
             * @param  {Integer} size a length of the inserted portion
             * @protected
             * @method  removed
             */
            this.inserted = function(off, size) {
                if (this.offset >= 0 && off <= this.offset){
                    this.isValid = false;
                    this.setOffset(this.offset + size);
                }
            };

            /**
             * Special method to inform the position object that its state has to be adjusted
             * because of the given portion of data had been removed.
             * @param  {Integer} off  an offset the removal has happened
             * @param  {Integer} size a length of the removed portion
             * @protected
             * @method  removed
             */
            this.removed = function (off, size){
                if (this.offset >= 0 && this.offset >= off){
                    this.isValid = false;
                    this.setOffset(this.offset >= (off + size) ? this.offset - size
                                                               : off);
                }
            };

            /**
             * Calculate a line and line column by the given offset.
             * @param  {Integer} off an offset
             * @return {Array} an array that contains a line as the first
             * element and a column in the line as the second element.
             * @method getPointByOffset
             */
            this.getPointByOffset = function(off){
                if (off >= 0) {
                    var m = this.metrics, max = m.getMaxOffset();
                    if (off > max) {
                        throw new Error("Out of bounds:" + off);
                    }

                    if (max === 0) return [(m.getLines() > 0 ? 0 : -1), 0];
                    if (off === 0) return [0, 0];

                    var d = 0, sl = 0, so = 0;
                    if (this.isValid === true && this.offset !== -1) {
                        sl = this.currentLine;
                        so = this.offset - this.currentCol;
                        if (off > this.offset) d = 1;
                        else {
                            if (off < this.offset) d = -1;
                            else return [sl, this.currentCol];
                        }
                    } else {
                        d = (~~(max / off) === 0) ? -1 : 1;
                        if (d < 0) {
                            sl = m.getLines() - 1;
                            so = max - m.getLineSize(sl);
                        }
                    }

                    for(; sl < m.getLines() && sl >= 0; sl += d){
                        var ls = m.getLineSize(sl);
                        if (off >= so && off < so + ls) {
                            return [sl, off - so];
                        }
                        so += d > 0 ? ls : -m.getLineSize(sl - 1);
                    }
                }
                return null;
            };

            /**
             * Calculate an offset by the given line and column in the line
             * @param  {Integer} row a line
             * @param  {Integer} col a column in the line
             * @return {Integer} an offset
             * @method getOffsetByPoint
             */
            this.getOffsetByPoint = function (row, col){
                var startOffset = 0, startLine = 0, m = this.metrics, i = 0;

                if (row >= m.getLines()) {
                    throw new RangeError(row);
                }

                if (col >= m.getLineSize(row)) {
                    throw new RangeError(col);
                }

                if (this.isValid === true && this.offset !==  -1) {
                    startOffset = this.offset - this.currentCol;
                    startLine = this.currentLine;
                }

                if (startLine <= row) {
                    for(i = startLine;i < row; i++) {
                        startOffset += m.getLineSize(i);
                    }
                } else {
                    for(i = startLine - 1;i >= row; i--) {
                        startOffset -= m.getLineSize(i);
                    }
                }
                return startOffset + col;
            };

            /**
             * Seek virtual cursor to the next position. How the method has to seek to the next position
             * has to be denoted by one of the following constants:

        - **"begin"** seek cursor to the begin of the current line
        - **"end"** seek cursor to the end of the current line
        - **"up"** seek cursor one line up
        - **"down"** seek cursor one line down

             * If the current virtual position is not known (-1) the method always sets
             * it to the first line, the first column in the line (offset is zero).
             * @param  {Integer} t   an action the seek has to be done
             * @param  {Integer} num number of seek actions
             * @method seekLineTo
             */
            this.seekLineTo = function(t,num){
                if (this.offset < 0){
                    this.setOffset(0);
                } else {
                    if (arguments.length === 1) num = 1;

                    var prevOffset = this.offset,
                        prevLine   = this.currentLine,
                        prevCol    = this.currentCol,
                        maxCol     = 0,
                        i          = 0;

                    switch(t) {
                        case "begin":
                            if (this.currentCol > 0){
                                this.offset -= this.currentCol;
                                this.currentCol = 0;
                            } break;
                        case "end":
                            maxCol = this.metrics.getLineSize(this.currentLine);
                            if (this.currentCol < (maxCol - 1)) {
                                this.offset += (maxCol - this.currentCol - 1);
                                this.currentCol = maxCol - 1;
                            } break;
                        case "up":
                            if (this.currentLine > 0) {
                                this.offset -= (this.currentCol + 1);
                                this.currentLine--;
                                for(i = 0; this.currentLine > 0 && i < (num - 1); i++, this.currentLine--) {
                                    this.offset -= this.metrics.getLineSize(this.currentLine);
                                }

                                maxCol = this.metrics.getLineSize(this.currentLine);
                                if (this.currentCol < maxCol) {
                                    this.offset -= (maxCol - this.currentCol - 1);
                                } else {
                                    this.currentCol = maxCol - 1;
                                }
                            } break;
                        case "down":
                            if (this.currentLine < (this.metrics.getLines() - 1)) {
                                this.offset += (this.metrics.getLineSize(this.currentLine) - this.currentCol);
                                this.currentLine++;
                                var size = this.metrics.getLines() - 1;
                                for (i = 0; this.currentLine < size && i < (num - 1); i++ ,this.currentLine++ ) {
                                    this.offset += this.metrics.getLineSize(this.currentLine);
                                }

                                maxCol = this.metrics.getLineSize(this.currentLine);
                                if (this.currentCol < maxCol) {
                                    this.offset += this.currentCol;
                                } else {
                                    this.currentCol = maxCol - 1;
                                    this.offset += this.currentCol;
                                }
                            } break;
                        default: throw new Error("" + t);
                    }

                    this._.posChanged(this, prevOffset, prevLine, prevCol);
                }
            };

            /**
             * Set position metric. Metric describes how many lines
             * and elements in these line the virtual cursor can be navigated
             * @param {zebkit.util.Position.Metric} p a position metric
             * @method setMetric
             */
            this.setMetric = function (p){
                if (p === null || typeof p === 'undefined') {
                    throw new Error("Null metric");
                }

                if (p !== this.metrics){
                    this.metrics = p;
                    this.setOffset(null);
                }
            };
        }
    ]);

    /**
     * Single column position implementation. More simple and more fast implementation of
     * position class for the cases when only one column is possible.
     * @param {zebkit.util.Position.Metric} m a position metric
     * @constructor
     * @class zebkit.util.SingleColPosition
     * @extends {zebkit.util.Position}
     */
    pkg.SingleColPosition = Class(pkg.Position, [
        function $prototype() {
            this.setRowCol = function(r,c) {
                this.setOffset(r);
            };

            this.setOffset = function(o){
                if (o < 0) o = 0;
                else {
                    if (o === null) o = -1;
                    else {
                        var max = this.metrics.getMaxOffset();
                        if (o >= max) o = max;
                    }
                }

                if (o !== this.offset) {
                    var prevOffset = this.offset,
                        prevLine   = this.currentLine,
                        prevCol    = this.currentCol;

                    this.currentLine = this.offset = o;
                    this.isValid = true;
                    this._.posChanged(this, prevOffset, prevLine, prevCol);
                }

                return o;
            };

            this.seekLineTo = function(t, num){
                if (this.offset < 0){
                    this.setOffset(0);
                } else {
                    if (arguments.length === 1) {
                        num = 1;
                    }

                    switch(t) {
                        case "begin":
                        case "end": break;
                        case "up":
                            if (this.offset > 0) {
                                this.setOffset(this.offset - n);
                            } break;
                        case "down":
                            if (this.offset < (this.metrics.getLines() - 1)){
                                this.setOffset(this.offset + n);
                            } break;
                        default: throw new Error("" + t);
                    }
                }
            };
        }
    ]);

    /**
     * Task set is light-weight class to host number of callbacks methods that are called within a context of one JS interval
     * method execution. The class manages special tasks queue to run it one by one as soon as a dedicated interval for the
     * given task is elapsed

        var tasks = zebkit.util.TasksSet();

        tasks.run(function(t) {
            // task1 body
            ...
            if (condition) {
                t.shutdown();
            }
        }, 1000, 200);

        tasks.run(function(t) {
            // task2 body
            ...
            if (condition) {
                t.shutdown();
            }
        }, 2000, 300);

     * @constructor
     * @param  {Integer} [maxTasks] maximal possible number of active tasks in queue.
     * @class zebkit.util.TasksSet
     */
    pkg.TasksSet = Class([
        function(c) {
            this.tasks = Array(arguments.length > 0 ? c : 5);

            // pre-fill tasks pool
            for(var i = 0; i < this.tasks.length; i++) {
                this.tasks[i] = new this.clazz.Task(this);
            }
        },

        function $clazz() {
            /**
             * Task class
             * @class zebkit.util.TasksSet.Task
             * @for zebkit.util.TasksSet.Task
             * @param {zebkit.util.TasksSet} tasksSet a reference to tasks set that manages the task
             * @constructor
             */
            this.Task = Class([
                function(set) {
                    /**
                     * Reference to a tasks set that owns the task
                     * @type {zebkit.util.TasksSet}
                     * @attribute taskSet
                     * @private
                     * @readOnly
                     */
                    this.taskSet = set;

                    /**
                     * Indicates if the task is executed (active)
                     * @type {Boolean}
                     * @attribute isStarted
                     * @readOnly
                     */
                    this.isStarted = false;
                },

                function $prototype() {
                    this.task = null;
                    this.ri = this.si  = 0;

                    /**
                     * Shutdown the given task.
                     * @return {Boolean} true if the task has been stopped
                     * @method shutdown
                     */
                    this.shutdown = function() {
                        return this.taskSet.shutdown(this);
                    };

                    /**
                     * Pause the given task.
                     * @return {Boolean} true if the task has been paused
                     * @method pause
                     */
                    this.pause = function() {
                        if (this.task === null) {
                            throw new Error("Stopped task cannot be paused");
                        }

                        if (this.isStarted === true) {
                            this.isStarted = false;
                            return true;
                        }
                        return false;
                    };

                    /**
                     * Resume the given task
                     * @param {Integer} [startIn] a time in milliseconds to resume the task
                     * @return {Boolean} true if the task has been resumed
                     * @method resume
                     */
                    this.resume = function(t) {
                        if (this.task === null) {
                            throw new Error("Stopped task cannot be paused");
                        }

                        this.si = arguments.length > 0 ? t : 0;
                        if (this.isStarted === true) {
                            return false;
                        }
                        this.isStarted = true;
                        return true;
                    };
                }
            ]);
        },

        /**
         *  @for  zebkit.util.TasksSet
         */
        function $prototype() {
            /**
             * Interval
             * @attribute quantum
             * @private
             * @type {Number}
             * @default 40
             */
            this.quantum = 40;

            /**
             * pid of executed JS interval method callback
             * @attribute pid
             * @private
             * @type {Number}
             * @default -1
             */
            this.pid = -1;

            /**
             * Number of run in the set tasks
             * @attribute count
             * @private
             * @type {Number}
             * @default 0
             */
            this.count = 0;

            /**
             * Shut down all active at the given moment tasks
             * body and the given context.
             * @method shutdownAll
             */
            this.shutdownAll = function() {
                for(var i = 0; i < this.tasks.length; i++) {
                    this.shutdown(this.tasks[i]);
                }
            };

            /**
             * Shutdown the given task
             * @param  {zebkit.util.TasksSet.Task} t a task
             * @return {Boolean}  true if the task has been stopped, false if the task has not been started
             * to be stopped
             * @protected
             * @method shutdown
             */
            this.shutdown = function(t) {
                if (t.task !== null) {
                    this.count--;
                    t.task = null;
                    t.isStarted = false;
                    t.ri = t.si = 0;
                    return true;
                }

                if (this.count === 0 && this.pid  >= 0) {
                    zebkit.environment.clearInterval(this.pid);
                    this.pid = -1;
                }

                return false;
            };

            /**
             * Take a free task from tasks pool and run it once in the specified period of time.
             * @param  {Function|Object} f a task function that has to be executed. The task method gets the task
             * context as its argument. You can pass an object as the argument if the object has "run" method
             * implemented. In this cases "run" method will be used as the task body.
             * @param  {Integer} [startIn]  time in milliseconds the task has to be executed in
             * @method runOnce
             */
            this.runOnce = function(f, startIn) {
                this.run(f, startIn, -1);
            };

            /**
             * Take a free task from pool and run it with the specified body and the given context.
             * @param  {Function|Object} f a task function that has to be executed. The task method gets the task
             * context as its argument. You can pass an object as the argument if the object has "run" method
             * implemented. In this cases "run" method will be used as the task body.
             * @param {Integer} [si]  time in milliseconds the task has to be executed
             * @param {Integer} [ri]  the time in milliseconds the task has to be periodically repeated
             * @return {zebkit.util.Task} an allocated task
             * @example

        var tasks = new zebkit.util.TasksSet();

        // execute task
        var task = tasks.run(function (t) {
            // do something
            ...
            // complete task if necessary
            t.shutdown();
        }, 100, 300);

        // pause task
        task.pause(1000, 2000);

        ...
        // resume task in a second
        task.resume(1000);

             * @example

        var tasks = new zebkit.util.TasksSet();

        var a = new zebkit.Dummy([
            function run() {
                // task body
                ...
            }
        ]);

        // execute task
        var task = tasks.runOnce(a);

             * @method run
             */
            this.run = function(f, si, ri){
                if (f === null || typeof f === 'undefined') {
                    throw new Error("" + f);
                }

                var $this = this;
                function dispatcher() {
                    var c = 0;
                    for(var i = 0; i < $this.tasks.length; i++) {
                        var t = $this.tasks[i];

                        // count paused or run tasks
                        if (t.task !== null) {  // means task has been shutdown
                            c++;
                        }

                        if (t.isStarted === true) {
                            if (t.si <= 0) {
                                try {
                                    if (typeof t.task.run !== 'undefined') {
                                        t.task.run(t);
                                    } else {
                                        t.task(t);
                                    }

                                    if (t.ri < 0) {
                                        t.shutdown();
                                    }
                                } catch(e) {
                                    zebkit.dumpError(e);
                                }

                                t.si += t.ri;
                            } else {
                                t.si -= $this.quantum;
                            }
                        }
                    }

                    if (c === 0 && $this.pid >= 0) {
                        zebkit.environment.clearInterval($this.pid);
                        $this.pid = -1;
                    }
                }

                // find free and return free task
                for(var i = 0; i < this.tasks.length; i++) {
                    var j = (i + this.count) % this.tasks.length,
                        t = this.tasks[j];

                    if (t.task === null) {
                        // initialize internal variables start in and repeat in
                        // arguments
                        t.si = (arguments.length > 1) ? si : 0;
                        t.ri = (arguments.length > 2) ? ri : -1;
                        t.isStarted = true;
                        t.task = f;
                        this.count++;

                        if (this.count > 0 && this.pid < 0) {
                            this.pid = zebkit.environment.setInterval(dispatcher, this.quantum);
                        }

                        return t;
                    }
                }

                throw new Error("Out of active tasks limit (" +  this.tasks.length + ")");
            };
        }
    ]);

    /**
     * Predefined default tasks set.
     * @attribute tasksSet
     * @type {zebkit.util.TasksSet}
     * @for zebkit.util
     */
    pkg.tasksSet = new pkg.TasksSet(7);


    pkg.Fireable = zebkit.Interface();

    /**
     * JSON object loader class is a handy way to load hierarchy of objects encoded with
     * JSON format. The class supports standard JSON types plus it extends JSON with a number of
     * features that helps to make object creation more flexible. Zson allows developers
     * to describe creation of any type of object. For instance if you have a class "ABC" with
     * properties "prop1", "prop2", "prop3" you can use instance of the class as a value of
     * a JSON property as follow:
     *
     *      { "instanceOfABC": {
     *              "@ABC"  : [],
     *              "prop1" : "property 1 value",
     *              "prop2" : true,
     *              "prop3" : 200
     *          }
     *      }
     *
     *  And than:
     *
     *       // load JSON mentioned above
     *       zebkit.util.Zson.then("abc.json", function(zson) {
     *           zson.get("instanceOfABC");
     *       });
     *
     *  Features the JSON zson supports are listed below:
     *
     *    - **Access to hierarchical properties** You can use dot notation to get a property value. For
     *    instance:
     *
     *     { "a" : {
     *            "b" : {
     *                "c" : 100
     *            }
     *         }
     *     }
     *
     *     zebkit.util.Zson.then("abc.json", function(zson) {
     *         zson.get("a.b.c"); // 100
     *     });
     *
     *
     *    - **Property reference** Every string JSON value that starts from "@" considers as reference to
     *    another property value in the given JSON.
     *
     *     {  "a" : 100,
     *        "b" : {
     *            "c" : "%{a.b}"
     *        }
     *     }
     *
     *    here property "b.c" equals to 100 since it refers to  property "a.b"
     *
     *    - **Inheritance** By using special property name "inherit" it is possible to embed set of properties
     *    from a JSON object:
     *
     *     {
     *        // base component
     *        "BaseComponent": {
     *            "background": "red",
     *            "border": "plain",
     *            "size": [300, 300]
     *        },
     *
     *        // component that inherits properties from BaseComponent,
     *        // but override background property with own value
     *        "ExtenderComp": {
     *            "inherit": "@{BaseComponent}",
     *            "background": "green"
     *        }
     *     }
     *
     *    - **Class instantiation**  Property can be easily initialized with an instantiation of required class. JSON
     *    zson considers all properties whose name starts from "@" character as a class name that has to be instantiated:
     *
     *     {  "date": {
     *           { "@Date" : [] }
     *         }
     *     }
     *
     *   Here property "date" is set to instance of JS Date class.
     *
     *   - **Factory classes** JSON zson follows special pattern to describe special type of property whose value
     *   is re-instantiated every time the property is requested. Definition of the property value is the same
     *   to class instantiation, but the name of class has to prefixed with "*" character:
     *
     *
     *     {  "date" : {
     *           "@ *Date" : []
     *        }
     *     }
     *
     *
     *   Here, every time you call get("date") method a new instance of JS date object will be returned. So
     *   every time will have current time.
     *
     *   - **JS Object initialization** If you have an object in your code you can easily fulfill properties of the
     *   object with JSON zson. For instance you can create zebkit UI panel and adjust its background, border and so on
     *   with what is stored in JSON:
     *
     *
     *     {
     *       "background": "red",
     *       "layout"    : { "@zebkit.layout.BorderLayout": [] },
     *       "border"    : { "@zebkit.ui.RoundBorder": [ "black", 2 ] }
     *     }
     *
     *     var pan = new zebkit.ui.Panel();
     *     new zebkit.util.Zson(pan).then("pan.json", function(zson) {
     *         // loaded and fullil panel
     *         ...
     *     });
     *
     *
     *   - **Expression** You can evaluate expression as a property value:
     *
     *
     *     {
     *         "a": { ".expr":  "100*10" }
     *     }
     *
     *
     *   Here property "a" equals 1000
     *
     * @class zebkit.util.Zson
     * @constructor
     * @param {Object} [obj] a root object to be loaded with
     * the given JSON configuration
     */
    pkg.Zson = zebkit.Class([
        function (root) {
            if (arguments.length > 0) {
                this.root = root;
            }

            /**
             * Map of aliases and appropriate classes
             * @attribute classAliases
             * @protected
             * @type {Object}
             * @default {}
             */
            this.classAliases = {};
        },

        function $prototype() {
            this.url = null;


            /**
             * Object that keeps loaded and resolved content of a JSON
             * @readOnly
             * @attribute root
             * @type {Object}
             * @default {}
             */
            this.root = null;

            /**
             * Original JSON as a JS object
             * @attribute content
             * @protected
             * @type {Object}
             * @default null
             */
            this.content = null;

            /**
             * The property says if the object introspection is required to try find a setter
             * method for the given key. For instance if an object is loaded with the
             * following JSON:

             {
                "color": "red"
             }

             * the introspection will cause zson class to try finding "setColor(c)" method in
             * the loaded with the JSON object and call it to set "red" property value.
             * @attribute usePropertySetters
             * @default true
             * @type {Boolean}
             */
            this.usePropertySetters = true;

            /**
             * Get a property value by the given key. The property name can point to embedded fields:
             *
             *      new zebkit.util.Zson().then("my.json", function(zson) {
             *          zson.get("a.b.c");
             *      });
             *
             *
             * @param  {String} key a property key.
             * @return {Object} a property value
             * @throws Error if property cannot be found and it  doesn't start with "?"
             * @method  get
             */
            this.get = function(key) {
                if (key === null || typeof key === 'undefined') {
                    throw new Error("Null key");
                }

                var ignore = false;
                if (key[0] === '?') {
                    key = key.substring(1).trim();
                    ignore = true;
                }

                var v = this.$get(key.split('.'), this.root);
                if (ignore === false && typeof v === 'undefined') {
                    throw new Error("Property '" + key + "' not found");
                }

                return v;
            };

            /**
             * Internal implementation of fetching a property value.
             * @param  {Array} keys array of a key path parts
             * @param  {Object} root an object to start resolving a property value
             * @method  $get
             * @protected
             * @return {Object} a property value or undefined if the property  cannot be fetched from the
             * object
             */
            this.$get = function(keys, root) {
                if (keys.length === 0) {
                    throw new Error("No keys were found");
                }

                var v = root;
                for(var i = 0; i < keys.length; i++) {
                    v = v[keys[i]];
                    if (typeof v === "undefined") {
                        return undefined;
                    }
                }
                return v !== null && v.$new ? v.$new() : v;
            };

            /**
             * Test if the given value has atomic type (String, Number or Boolean).
             * @param  {Object}  v a value
             * @return {Boolean} true if the value has atomic type
             * @protected
             * @method  $isAtomic
             */
            this.$isAtomic = function(v) {
                return v === null || typeof v === 'undefined' ||
                       (typeof v === "string"  || v.constructor === String)  ||
                       (typeof v === "number"  || v.constructor === Number)  ||
                       (typeof v === "boolean" || v.constructor === Boolean)  ;
            };

            /**
             * Call method.
             * @param  {String} name a method name
             * @param  {Object} d arguments
             * @return {Object} a method execution result
             * @method callMethod
             */
            this.callMethod = function(name, d) {
                var m  = this[name.substring(1).trim()],
                    ts = this.$runner.$tasks.length,
                    bs = this.$runner.$busy;

                if (typeof m !== 'function') {
                    throw new Error("Method '" + name + "' cannot be found");
                }

                var args = this.buildValue(Array.isArray(d) ? d
                                                            : [ d ]),
                    $this = this;

                if (this.$runner.$tasks.length === ts &&
                    this.$runner.$busy === bs           )
                {
                    var res = m.apply(this, args);
                    if (res instanceof zebkit.DoIt) {
                        return new zebkit.DoIt().till(this.$runner).then(function() {
                            var jn = this.join();
                            res.then(function(res) {
                                jn(res);
                                return res;
                            }).then(function(res) {
                                return res;
                            });
                        }).catch(function(e) {
                            $this.$runner.error(e);
                        });
                    } else {
                        return res;
                    }
                } else {
                    return new zebkit.DoIt().till(this.$runner).then(function() {
                        if (args instanceof zebkit.DoIt) {
                            var jn = this.join();
                            args.then(function(res) {
                                jn(res);
                                return res;
                            });
                        } else {
                            return args;
                        }
                    }).then(function(args) {
                        var res = m.apply($this, args);
                        if (res instanceof zebkit.DoIt) {
                            var jn = this.join();
                            res.then(function(res) {
                                jn(res);
                                return res;
                            });
                        } else {
                            return res;
                        }
                    }).then(function(res) {
                        return res;
                    }).catch(function(e) {
                        $this.$runner.error(e);
                    });
                }
            };

            this.$resolveRef = function(target, names) {
                var fn = function(ref, rn) {
                    rn.then(function(target) {
                        if (target != null && target.hasOwnProperty(ref) === true) {
                            var v = target[ref];
                            if (v instanceof zebkit.DoIt) {
                                var jn = this.join();
                                v.then(function(res) {
                                    jn.call(rn, res);
                                    return res;
                                });
                            } else {
                                return v;
                            }
                        } else {
                            return undefined;
                        }
                    });
                };

                for (var j = 0; j < names.length; j++) {
                    var ref = names[j];

                    if (target.hasOwnProperty(ref)) {
                        var v = target[ref];

                        if (v instanceof zebkit.DoIt) {
                            var rn      = new zebkit.DoIt(),
                                trigger = rn.join();

                            for(var k = j; k < names.length; k++) {
                                fn(names[k], rn);
                            }

                            trigger.call(rn, target);
                            return rn;
                        } else {
                            target = target[ref];
                        }

                    } else {
                        return undefined;
                    }
                }

                return target;
            };

            this.$buildArray = function(d) {
                var hasAsync = false;
                for (var i = 0; i < d.length; i++) {
                    var v = this.buildValue(d[i]);
                    if (v instanceof zebkit.DoIt) {
                        hasAsync = true;
                        this.$assignValue(d, i, v);
                    } else {
                        d[i] = v;
                    }
                }

                if (hasAsync) {
                    return new zebkit.DoIt().till(this.$runner).then(function() {
                        return d;
                    });
                } else {
                    return d;
                }
            };

            this.$buildClass = function(k, d) {
                var classname = k.substring(1).trim(),
                    args      = d[k],
                    clz       = null,
                    busy      = this.$runner.$busy,
                    tasks     = this.$runner.$tasks.length;

                delete d[k]; // delete class name

                // '?' means optional class instance.
                if (classname[0] === '?') {
                    classname = classname.substring(1).trim();
                    try {
                        clz = this.resolveClass(classname[0] === '*' ? classname.substring(1).trim()
                                                                     : classname);
                    } catch (e) {
                        return null;
                    }
                } else {
                    clz = this.resolveClass(classname[0] === '*' ? classname.substring(1).trim()
                                                                 : classname);
                }

                args = this.buildValue(Array.isArray(args) ? args
                                                           : [ args ]);

                if (classname[0] === '*') {
                    return (function(clazz, args) {
                        return {
                            $new : function() {
                                return zebkit.newInstance(clazz, args);
                            }
                        };
                    })(clz, args);
                }

                var props = this.buildValue(d);

                // let's do optimization to avoid unnecessary overhead
                // equality means nor arguments neither properties has got async call
                if (this.$runner.$busy === busy && this.$runner.$tasks.length === tasks) {
                    var inst = zebkit.newInstance(clz, args);
                    this.merge(inst, props, true);
                    return inst;
                } else {
                    var $this = this;
                    return new zebkit.DoIt().till(this.$runner).then(function() {
                        var jn1 = this.join(),  // create all join here to avoid result overwriting
                            jn2 = this.join();

                        if (args instanceof zebkit.DoIt) {
                            args.then(function(res) {
                                jn1(res);
                                return res;
                            });
                        } else {
                            jn1(args);
                        }

                        if (props instanceof zebkit.DoIt) {
                            props.then(function(res) {
                                jn2(res);
                                return res;
                            });
                        } else {
                            jn2(props);
                        }
                    }).then(function(args, props) {
                        var inst = zebkit.newInstance(clz, args);
                        $this.merge(inst, props, true);
                        return inst;
                    });
                }
            };

            this.$buildRef = function(d) {
                var idx = -1;

                if (d[2] === "<" || d[2] === '.' || d[2] === '/') { //TODO: not complete solution that cannot detect URLs
                    var path  = null,
                        type  = null,
                        $this = this;

                    if (d[2] === '<') {
                        // if the referenced path is not absolute path and the zson has been also
                        // loaded by an URL than build the full URL as a relative path from
                        // BAG URL
                        idx = d.indexOf('>');
                        if (idx <= 4) {
                            throw new Error("Invalid content type in URL '" + d + "'");
                        }

                        path = d.substring(idx + 1, d.length - 1).trim();
                        type = d.substring(3, idx).trim();
                    } else {
                        path = d.substring(2, d.length - 1).trim();
                        type = "json";
                    }

                    if (type === 'js') {
                        return this.expr(path);
                    }

                    if (this.url !== null && zebkit.URI.isAbsolute(path) === false) {
                        var pURL = new zebkit.URI(this.url).getParent();
                        if (pURL !== null) {
                            path = zebkit.URI.join(pURL, path);
                        }
                    }

                    if (type === "json") {
                        var bag = new this.clazz();
                        bag.usePropertySetters = this.usePropertySetters;

                        var bg = bag.then(path).catch();
                        this.$runner.then(bg.then(function(res) {
                            return res.root;
                        }));
                        return bg;
                    } else if (type === 'img') {
                        if (this.url !== null && zebkit.URI.isAbsolute(path) === false) {
                            path = zebkit.URI.join(new zebkit.URI(this.url).getParent(),
                                                   path);
                        }
                        return pkg.image(path, false);
                    } else if (type === 'txt') {
                        return new zebkit.io.GET(path).then(function(r) {
                            return r.responseText;
                        }).catch(function(e) {
                            $this.$runner.error(e);
                        });
                    } else {
                        throw new Error("Invalid content type " + type);
                    }

                } else {
                    // ? means don't throw exception if reference cannot be resolved
                    idx = 2;
                    if (d[2] === '?') {
                        idx ++;
                    }

                    var name    = d.substring(idx, d.length - 1).trim(),
                        names   = name.split('.'),
                        targets = [ this.content, this.root,  zebkit.$global ];

                    for(var i = 0; i < targets.length; i++) {
                        var target = targets[i];
                        if (target !== null) {
                            var value = this.$resolveRef(target, names);
                            if (typeof value !== 'undefined') {
                                return value;
                            }
                        }
                    }

                    if (idx === 2) {
                        throw new Error("Reference '" + name + "' cannot be resolved");
                    } else {
                        return d;
                    }
                }
            };

            /**
             * Build a value by the given JSON description
             * @param  {Object} d a JSON description
             * @return {Object} a value
             * @protected
             * @method buildValue
             */
            this.buildValue = function(d) {
                if (typeof d === 'undefined' || d === null || d instanceof zebkit.DoIt ||
                    (typeof d === "number"   || d.constructor === Number)              ||
                    (typeof d === "boolean"  || d.constructor === Boolean)                )
                {
                    return d;
                }

                if (Array.isArray(d)) {
                    return this.$buildArray(d);
                }

                if (typeof d === "string" || d.constructor === String) {
                    if (d[0] === '%' && d[1] === '{' && d[d.length - 1] === '}') {
                        return this.$buildRef(d);
                    } else {
                        return d;
                    }
                }

                var k = null;

                // test whether we have a class definition
                for (k in d) {
                    // handle class definition
                    if (k[0] === '@' && d.hasOwnProperty(k) === true) {
                        return this.$buildClass(k, d);
                    }

                    //!!!!  trust the name of class occurs first what in general
                    //      cannot be guaranteed by JSON spec but we can trust
                    //      since many other third party applications stands
                    //      on it too :)
                    break;
                }

                for (k in d) {
                    if (d.hasOwnProperty(k)) {
                        var v = d[k];

                        // special field name that says to call method to create a
                        // value by the given description
                        if (k[0] === "." || k[0] === '#') {
                            delete d[k];
                            if (k[0] === '#') {
                                this.callMethod(k, v, d);
                            } else {
                                return this.callMethod(k, v, d);
                            }
                        } else if (k[0] === '%') {
                            delete d[k];
                            this.mixin(d, this.$buildRef(k));
                        } else {
                            this.$assignValue(d, k, this.buildValue(v));
                        }
                    }
                }

                return d;
            };

            this.$assignValue = function(o, k, v) {
                o[k] = v;
                if (v instanceof zebkit.DoIt) {
                    var $this = this;
                    this.$runner.then(v.then(function(res) {
                        o[k] = res;
                        return res;
                    }));
                }
            };

            this.$assignProperty = function(o, m, v) {
                // setter has to be placed in queue to let
                // value resolves its DoIts
                this.$runner.then(function(res) {
                    if (Array.isArray(v)) {
                        m.apply(o, v);
                    } else {
                        m.call (o, v);
                    }
                    return res;
                });
            };

            this.merge = function(dest, src, recursively) {
                if (arguments.length < 3) {
                    recursively = true;
                }

                for (var k in src) {
                    if (src.hasOwnProperty(k)) {
                        var sv = src [k],
                            dv = dest[k];

                        if (this.usePropertySetters === true) {
                            var m = zebkit.getPropertySetter(dest, k);
                            if (m !== null) {
                                this.$assignProperty(dest, m, sv);
                                continue;
                            }
                        }


                        if (this.$isAtomic(dv) || Array.isArray(dv) ||
                            this.$isAtomic(sv) || Array.isArray(sv) ||
                            typeof sv.clazz !== 'undefined'            )
                        {
                            this.$assignValue(dest, k, sv);
                        } else if (recursively === true) {
                            if (dv != null && typeof dv.clazz !== 'undefined' && dv.clazz.mergeable === false) {
                                this.$assignValue(dest, k, sv);
                            } else {
                                this.merge(dv, sv);
                            }
                        }
                    }
                }
                return dest;
            };

            this.mixin = function(dest, src) {
                if (src instanceof zebkit.DoIt) {
                    var $this = this;
                    this.$runner.then(src.then(function(src) {
                        for (var k in src) {
                            if (src.hasOwnProperty(k) && (typeof dest[k] === 'undefined' || dest[k] === null)) {
                                $this.$assignValue(dest, k, src[k]);
                            }
                        }
                    }));
                } else {
                    for (var k in src) {
                        if (src.hasOwnProperty(k) && (typeof dest[k] === 'undefined' || dest[k] === null)) {
                            this.$assignValue(dest, k, src[k]);
                        }
                    }
                }
            };

            /**
             * Called every time the given class name has to be transformed into
             * the class object (constructor) reference. The method checks if the given class name
             * is alias that is mapped with the zson to a class.
             * @param  {String} className a class name
             * @return {Function} a class reference
             * @method resolveClass
             * @protected
             */
            this.resolveClass = function(className) {
                return this.classAliases.hasOwnProperty(className) ? this.classAliases[className]
                                                                   : zebkit.Class.forName(className);
            };

            /**
             * Adds class aliases
             * @param {Object} aliases dictionary where key is a class alias that can be referenced from
             * JSON and the value is class itself (constructor)
             * @method  addClassAliases
             */
            this.addClassAliases = function(aliases) {
                for(var k in aliases) {
                    this.classAliases[k] = Class.forName(aliases[k].trim());
                }
            };

            this.expr = function(expr) {
                if (expr.length > 200) {
                    throw new Error("Out of evaluated script limit");
                }

                return eval("'use strict';" + expr);
            };

            /**
             * Load and parse the given JSON content.
             * @param  {String|Object} json a JSON content. It can be:
             *    - **String**
             *       - JSON string
             *       - URL to a JSON
             *    - **Object** JavaScript object
             * @return {zebkit.DoIt} a reference to the runner
             * @method then
             * @example
             *
             *     // load JSON in zson from a remote site asynchronously
             *     new zebkit.util.Zson().then("http://test.com/test.json", function(zson) {
             *             // zson is loaded and ready for use
             *             zson.get("a.c");
             *         }
             *     ).catch(function(error) {
             *         // handle error
             *         ...
             *     });
             */
            this.then = function(json, fn) {
                if (json === null || typeof json === 'undefined' || (zebkit.isString(json) && json.trim().length === 0)) {
                    throw new Error("Null content");
                }

                this.$runner = new zebkit.DoIt();

                var $this = this;
                this.$runner.then(function() {
                    if (zebkit.isString(json)) {
                        json = json.trim();

                        // detect if the passed string is not a JSON, but URL
                        if ((json[0] !== '[' || json[json.length - 1] !== ']') &&
                            (json[0] !== '{' || json[json.length - 1] !== '}')   )
                        {
                            $this.url = json + (json.lastIndexOf("?") > 0 ? "&" : "?") + (new Date()).getTime().toString();

                            var join = this.join();
                            zebkit.io.GET($this.url).then(function(r) {
                                join.call($this, r.responseText);
                            }).catch(function(e) {
                                $this.$runner.error(e);
                            });
                        } else {
                            return json;
                        }
                    } else {
                        return json;
                    }
                }).then(function(json) { // populate JSON content
                    if (zebkit.isString(json)) {
                        try {
                            $this.content = JSON.parse(json);
                        } catch(e) {
                            throw new Error("JSON format error: " + e);
                        }
                    } else {
                        $this.content = json;
                    }

                    $this.$assignValue($this, "content", $this.buildValue($this.content));
                }).then(function() {
                    if ($this.root !== null) {
                        $this.merge($this.root, $this.content);
                    } else {
                        $this.root = $this.content;
                    }
                    return $this;
                });

                if (arguments.length > 1) {
                    this.$runner.then(fn);
                }

                return this.$runner;
            };
        }
    ]);
});
zebkit.package("io", function(pkg, Class) {
    /**
     * The module provides number of classes to help to communicate with remote services and servers by HTTP,
     * JSON-RPC, XML-RPC protocols.
     *
     *       // shortcut method to perform HTTP GET request
     *       zebkit.io.GET("http://test.com").then(function(req) {
     *           // handle request
     *           req.responseText
     *           ...
     *       }).catch(function(exception) {
     *           // handle error
     *       });
     *
     * @class zebkit.io
     * @access package
     */

    // TODO: Web dependencies:
    //    -- Uint8Array
    //    -- ArrayBuffer

    // !!!
    // b64 is supposed to be used with binary stuff, applying it to utf-8 encoded data can bring to error
    // !!!

    var HEX    = "0123456789ABCDEF",
        b64str = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

    /**
     * Generate UUID of the given length
     * @param {Integer} [size] the generated UUID length. The default size is 16 characters.
     * @return {String} an UUID
     * @method  UID
     * @for  zebkit.io
     */
    pkg.UID = function(size) {
        if (arguments.length === 0) size = 16;
        var id = "";
        for (var i = 0; i < size; i++) id = id + HEX[~~(Math.random() * 16)];
        return id;
    };

    /**
     * Encode the given string into base64
     * @param  {String} input a string to be encoded
     * @method  b64encode
     * @for zebkit.io
     */
    pkg.b64encode = function(input) {
        var out = [], i = 0, len = input.length, c1, c2, c3;
        if (typeof ArrayBuffer !== "undefined") {
            if (input instanceof ArrayBuffer) {
                input = new Uint8Array(input);
            }
            input.charCodeAt = function(i) { return this[i]; };
        }

        if (Array.isArray(input)) {
            input.charCodeAt = function(i) { return this[i]; };
        }

        while(i < len) {
            c1 = input.charCodeAt(i++) & 0xff;
            out.push(b64str.charAt(c1 >> 2));
            if (i === len) {
                out.push(b64str.charAt((c1 & 0x3) << 4), "==");
                break;
            }

            c2 = input.charCodeAt(i++);
            out.push(b64str.charAt(((c1 & 0x3) << 4) | ((c2 & 0xF0) >> 4)));
            if (i === len) {
                out.push(b64str.charAt((c2 & 0xF) << 2), "=");
                break;
            }

            c3 = input.charCodeAt(i++);
            out.push(b64str.charAt(((c2 & 0xF) << 2) | ((c3 & 0xC0) >> 6)), b64str.charAt(c3 & 0x3F));
        }

        return out.join('');
    };

    /**
     * Decode the base64 encoded string
     * @param {String} input base64 encoded string
     * @return {String} a string
     * @for zebkit.io
     * @method b64decode
     */
    pkg.b64decode = function(input) {
        var output = [], chr1, chr2, chr3, enc1, enc2, enc3, enc4;
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

        while ((input.length % 4) !== 0) input += "=";

        for(var i=0; i < input.length;) {
            enc1 = b64str.indexOf(input.charAt(i++));
            enc2 = b64str.indexOf(input.charAt(i++));
            enc3 = b64str.indexOf(input.charAt(i++));
            enc4 = b64str.indexOf(input.charAt(i++));

            chr1 = (enc1 << 2) | (enc2 >> 4);
            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            chr3 = ((enc3 & 3) << 6) | enc4;
            output.push(String.fromCharCode(chr1));
            if (enc3 !== 64) output.push(String.fromCharCode(chr2));
            if (enc4 !== 64) output.push(String.fromCharCode(chr3));
        }
        return output.join('');
    };

    pkg.dateToISO8601 = function(d) {
        function pad(n) { return n < 10 ? '0'+ n : n; }
        return [ d.getUTCFullYear(), '-', pad(d.getUTCMonth()+1), '-', pad(d.getUTCDate()), 'T', pad(d.getUTCHours()), ':',
                 pad(d.getUTCMinutes()), ':', pad(d.getUTCSeconds()), 'Z'].join('');
    };

    // http://webcloud.se/log/JavaScript-and-ISO-8601/
    pkg.ISO8601toDate = function(v) {
        var regexp = ["([0-9]{4})(-([0-9]{2})(-([0-9]{2})", "(T([0-9]{2}):([0-9]{2})(:([0-9]{2})(\.([0-9]+))?)?",
                      "(Z|(([-+])([0-9]{2}):([0-9]{2})))?)?)?)?"].join(''), d = v.match(new RegExp(regexp)),
                      offset = 0, date = new Date(d[1], 0, 1);

        if (d[3])  date.setMonth(d[3] - 1);
        if (d[5])  date.setDate(d[5]);
        if (d[7])  date.setHours(d[7]);
        if (d[8])  date.setMinutes(d[8]);
        if (d[10]) date.setSeconds(d[10]);
        if (d[12]) date.setMilliseconds(Number("0." + d[12]) * 1000);
        if (d[14]) {
            offset = (Number(d[16]) * 60) + Number(d[17]);
            offset *= ((d[15] === '-') ? 1 : -1);
        }

        offset -= date.getTimezoneOffset();
        date.setTime(Number(date) + (offset * 60 * 1000));
        return date;
    };

    /**
     * HTTP request class. This class provides API to generate different
     * (GET, POST, etc) HTTP requests
     * @class zebkit.io.HTTP
     * @constructor
     * @param {String} url an URL to a HTTP resource
     */
    pkg.HTTP = Class([
        function(url) {
            this.url = url;
            this.header = {};
        },

        function $prototype() {
            /**
             * Perform HTTP GET request with the given query parameters.
             * @param {Object} [q] a dictionary of query parameters
             * @return {zebkit.DoIt} an object to get response
             * @example

        // GET request with the number of query parameters
        var result = zebkit.io.HTTP("google.com").GET({
            param1: "var1",
            param3: "var2",
            param3: "var3"
        }).then(function(req) {
            // handle response
            req.responseText;
        }).catch(function(e)  {
            // handle error
            ...
        });

             * @method GET
             */
            this.GET = function(q) {
                var u = this.url + ((arguments.length === 0 || q === null) ? ''
                                                                           : ((this.url.indexOf("?") > 0) ? '&'
                                                                                                          : '?') + zebkit.URI.toQS(q, true));
                return this.SEND("GET", u);
            };

            /**
             * Perform HTTP POST request with the give data to be sent.
             * @param {String|Object} d a data to be sent by HTTP POST request.  It can be
             * either a parameters set or a string.
             * @return {zebkit.DoIt} an object to get response
             * @example

       // asynchronously send POST
       zebkit.io.HTTP("google.com").POST("Hello").then(function(req) {
           // handle HTTP GET response ...
       }).catch(function(e) {
           // handle error ...
       });

            * Or you can pass a number of parameters to be sent:

       // send parameters synchronously by HTTP POST request
       zebkit.io.HTTP("google.com").POST({
           param1: "val1",
           param2: "val3",
           param3: "val3"
       }).then(function(req) {
            // handle HTTP GET response ...
       }).catch(function(e) {
            // handle error ...
       });

             * @method POST
             */
            this.POST = function(d) {
                // if the passed data is simple dictionary object encode it as POST
                // parameters
                //
                // TODO: think also about changing content type
                // "application/x-www-form-urlencoded; charset=UTF-8"
                if (d !== null && zebkit.isString(d) === false && d.constructor === Object) {
                    d = zebkit.URI.toQS(d, false);
                }

                return this.SEND("POST", this.url, d);
            };

            /**
             * Universal HTTP request method that can be used to generate a HTTP request with
             * any HTTP method to the given URL with the given data to be sent asynchronously.
             * @param {String}   method   an HTTP method (GET, POST, DELETE, PUT, etc)
             * @param {String}   url      an URL
             * @param {String}   [data]   a data to be sent to the given URL
             * @return {zebkit.DoIt} an object to handle result
             * @method SEND
             */
            this.SEND = function(method, url, data) {
                var req = zebkit.environment.getHttpRequest();

                req.open(method, url, true);
                for (var k in this.header) {
                    req.setRequestHeader(k, this.header[k]);
                }

                return new zebkit.DoIt(function() {
                    var jn    = this.join(),
                        $this = this;

                    req.onreadystatechange = function() {
                        if (req.readyState === 4) {
                            // evaluate http response
                            if (req.status >= 400 || req.status < 100) {
                                var e = new Error("HTTP error '" + req.statusText + "', code = " + req.status + " '" + url + "'");
                                e.status     = req.status;
                                e.statusText = req.statusText;
                                e.readyState = req.readyState;
                                $this.error(e);
                            } else {
                                jn(req);
                            }
                        }
                    };

                    try {
                        req.send(arguments.length > 2 ? data : null);
                    } catch(e) {
                        this.error(e);
                    }
                });
            };
        }
    ]);

    /**
     * Shortcut method to perform HTTP GET requests.

        zebkit.io.GET("http://test.com").then(function(request) {
            // handle result ...
        }).catch(function(e) {
            // handle error ...
        });

        var res = zebkit.io.GET("http://test.com", {
            param1 : "var1",
            param1 : "var2",
            param1 : "var3"
        }).then(function(req) {
            // handle result ...
        });

     * @param {String|Object} url an URL
     * @param {Object} [parameters] a dictionary of query parameters
     * @return  {zebkit.DoIt} an object to handle result
     * @method GET
     * @for zebkit.io
     */
    pkg.GET = function(url) {
        var http = new pkg.HTTP(url);
        return http.GET.apply(http, Array.prototype.slice.call(arguments, 1));
    };

    /**
     * Shortcut method to perform HTTP POST requests.

        zebkit.io.POST("http://test.com", null).then(function(request) {
            // handle result
            ...
        }).catch(function(e) {
            // handle error ...
        });

        var res = zebkit.io.POST("http://test.com", {
            param1 : "var1",
            param1 : "var2",
            param1 : "var3"
        }).then(function(request) {
            // handle result
            ...
        });

        zebkit.io.POST("http://test.com", "request").then(function(request) {
            // handle error
            ...
        });

     * @param {String} url an URL
     * @param {Object} [data] a data or form data parameters
     * @return  {zebkit.DoIt} an object to handle result
     * @method  POST
     * @for zebkit.io
     */
    pkg.POST = function(url) {
        var http = new pkg.HTTP(url);
        return http.POST.apply(http, Array.prototype.slice.call(arguments, 1));
    };

    /**
     * A remote service connector class. It is supposed the class has to be extended with
     * different protocols like RPC, JSON etc. The typical pattern of connecting to
     * a remote service is shown below:

        // create service connector that has two methods "a()" and "b(param1)"
        var service = new zebkit.io.Service("http://myservice.com", [
            "a", "b"
        ]);

        // call the methods of the remote service
        service.a();
        service.b(10);

     * Also the methods of a remote service can be called asynchronously. In this case
     * a callback method has to be passed as the last argument of called remote methods:

        // create service connector that has two methods "a()" and "b(param1)"
        var service = new zebkit.io.Service("http://myservice.com", [
            "a", "b"
        ]);

        // call "b" method from the remote service asynchronously
        service.b(10, function(res) {
            // handle a result of the remote method execution here
            ...
        });
     *
     * Ideally any specific remote service extension of "zebkit.io.Service"
     * class has to implement two methods:

        - **encode** to say how the given remote method with passed parameters have
        to be transformed into a concrete service side protocol (JSON, XML, etc)
        - **decode** to say how the specific service response has to be converted into
        JavaScript object

     * @class zebkit.io.Service
     * @constructor
     * @param {String} url an URL of remote service
     * @param {Array} methods a list of methods names the remote service provides
     */
    pkg.Service = Class([
        function(url, methods) {
            var $this = this;
            /**
             * Remote service url
             * @attribute url
             * @readOnly
             * @type {String}
             */
            this.url = url;

            /**
             * Remote service methods names
             * @attribute methods
             * @readOnly
             * @type {Array}
             */
            if (Array.isArray(methods) === false) {
                methods = [ methods ];
            }

            for(var i = 0; i < methods.length; i++) {
                (function() {
                    var name = methods[i];
                    $this[name] = function() {
                        var args = Array.prototype.slice.call(arguments);
                        return this.send(url, this.encode(name, args)).then(function(req) {
                            if (req.status === 200) {
                                return $this.decode(req.responseText);
                            } else {
                                this.error(new Error("Status: " + req.status + ", '" + req.statusText + "'"));
                            }
                        });
                    };
                })();
            }
        },

        function $prototype() {
            this.contentType = null;

             /**
              * Send the given data to the given url and return a response. Callback
              * function can be passed for asynchronous result handling.
              * @protected
              * @param  {String}   url an URL
              * @param  {String}   data  a data to be send
              * @return {zebkit.util.}  a result
              * @method  send
              */
            this.send = function(url, data) {
                var http = new pkg.HTTP(url);
                if (this.contentType !== null) {
                    http.header['Content-Type'] = this.contentType;
                }
                return http.POST(data);
            };
        }

        /**
         * Transforms the given remote method execution with the specified parameters
         * to service specific protocol.
         * @param {String} name a remote method name
         * @param {Array} args an passed to the remote method arguments
         * @return {String} a remote service specific encoded string
         * @protected
         * @method encode
         */

        /**
         * Transforms the given remote method response to a JavaScript
         * object.
         * @param {String} name a remote method name
         * @return {Object} a result of the remote method calling as a JavaScript
         * object
         * @protected
         * @method decode
         */
    ]);

    /**
     * Build invoke method that calls a service method.
     * @param  {zebkit.Class} clazz a class
     * @param  {String} url an URL
     * @param  {String} a service method name
     * @return {Function} a wrapped method to call RPC method with
     * @private
     * @method  invoke
     * @static
     */
    pkg.Service.invoke = function(clazz, url, method) {
        var rpc = new clazz(url, method);
        return function() {
            return rpc[method].apply(rpc, arguments);
        };
    };

    /**
     * The class is implementation of JSON-RPC remote service connector.

        // create JSON-RPC connector to a remote service that
        // has three remote methods
        var service = new zebkit.io.JRPC("json-rpc.com", [
            "method1", "method2", "method3"
        ]);

        // synchronously call remote method "method1"
        service.method1();

        // asynchronously call remote method "method1"
        service.method1(function(res) {
            ...
        });

     * @class zebkit.io.JRPC
     * @constructor
     * @param {String} url an URL of remote service
     * @param {Array} methods a list of methods names the remote service provides
     * @extends {zebkit.io.Service}
     */
    pkg.JRPC = Class(pkg.Service, [
        function $prototype() {
            this.version     = "2.0";
            this.contentType = "application/json; charset=ISO-8859-1;";

            this.encode = function(name, args) {
                return zebkit.environment.stringifyJSON({
                    jsonrpc : this.version,
                    method  : name,
                    params  : args,
                    id      : pkg.UID() });
            };

            this.decode = function(r) {
                if (r === null || r.length === 0) {
                    throw new Error("Empty JSON result string");
                }

                r = zebkit.environment.parseJSON(r);
                if (typeof(r.error) !== "undefined") {
                    throw new Error(r.error.message);
                }

                if (typeof r.result === "undefined" || typeof r.id === "undefined") {
                    throw new Error("Wrong JSON response format");
                }
                return r.result;
            };
        }
    ]);

    /**
     * Shortcut to call the specified method of a JSON-RPC service.
     * @param  {String} url an URL
     * @param  {String} method a method name
     * @for zebkit.io.JRPC
     * @static
     * @method invoke
     */
    pkg.JRPC.invoke = function(url, method) {
        return pkg.Service.invoke(pkg.JRPC, url, method);
    };

    pkg.Base64 = function(s) { if (arguments.length > 0) this.encoded = pkg.b64encode(s); };
    pkg.Base64.prototype.toString = function() { return this.encoded; };
    pkg.Base64.prototype.decode   = function() { return pkg.b64decode(this.encoded); };

    /**
     * The class is implementation of XML-RPC remote service connector.

        // create XML-RPC connector to a remote service that
        // has three remote methods
        var service = new zebkit.io.XRPC("xmlrpc.com", [
            "method1", "method2", "method3"
        ]);

        // synchronously call remote method "method1"
        service.method1();

        // asynchronously call remote method "method1"
        service.method1(function(res) {
            ...
        });

     * @class zebkit.io.XRPC
     * @constructor
     * @extends {zebkit.io.Service}
     * @param {String} url an URL of remote service
     * @param {Array} methods a list of methods names the remote service provides
     */
    pkg.XRPC = Class(pkg.Service, [
        function $prototype() {
            this.contentType = "text/xml";

            this.encode = function(name, args) {
                var p = ["<?xml version=\"1.0\"?>\n<methodCall><methodName>", name, "</methodName><params>"];
                for(var i=0; i < args.length;i++) {
                    p.push("<param>");
                    this.encodeValue(args[i], p);
                    p.push("</param>");
                }
                p.push("</params></methodCall>");
                return p.join('');
            };

            this.encodeValue = function(v, p)  {
                if (v === null) {
                    throw new Error("Null is not allowed");
                }

                if (zebkit.isString(v)) {
                    v = v.replace("<", "&lt;");
                    v = v.replace("&", "&amp;");
                    p.push("<string>", v, "</string>");
                } else {
                    if (zebkit.isNumber(v)) {
                        if (Math.round(v) === v) {
                            p.push("<i4>", v.toString(), "</i4>");
                        } else {
                            p.push("<double>", v.toString(), "</double>");
                        }
                    } else {
                        if (zebkit.isBoolean(v)) {
                            p.push("<boolean>", v?"1":"0", "</boolean>");
                        } else {
                            if (v instanceof Date)  {
                                p.push("<dateTime.iso8601>", pkg.dateToISO8601(v), "</dateTime.iso8601>");
                            } else {
                                if (Array.isArray(v))  {
                                    p.push("<array><data>");
                                    for(var i=0;i<v.length;i++) {
                                        p.push("<value>");
                                        this.encodeValue(v[i], p);
                                        p.push("</value>");
                                    }
                                    p.push("</data></array>");
                                } else {
                                    if (v instanceof pkg.Base64) {
                                        p.push("<base64>", v.toString(), "</base64>");
                                    } else {
                                        p.push("<struct>");
                                        for (var k in v) {
                                            if (v.hasOwnProperty(k)) {
                                                p.push("<member><name>", k, "</name><value>");
                                                this.encodeValue(v[k], p);
                                                p.push("</value></member>");
                                            }
                                        }
                                        p.push("</struct>");
                                    }
                                }
                            }
                        }
                    }
                }
            };

            this.decodeValue = function (node) {
                var tag = node.tagName.toLowerCase(), i = 0;

                if (tag === "struct") {
                     var p = {};
                     for(i = 0; i < node.childNodes.length; i++) {
                        var member = node.childNodes[i],  // <member>
                            key    = member.childNodes[0].childNodes[0].nodeValue.trim(); // <name>/text()
                        p[key] = this.decodeValue(member.childNodes[1].childNodes[0]);   // <value>/<xxx>
                    }
                    return p;
                }

                if (tag === "array") {
                    var a = [];
                    node = node.childNodes[0]; // <data>
                    for(i = 0; i < node.childNodes.length; i++) {
                        a[i] = this.decodeValue(node.childNodes[i].childNodes[0]); // <value>
                    }
                    return a;
                }

                var v = node.childNodes[0].nodeValue.trim();
                switch (tag) {
                    case "datetime.iso8601": return pkg.ISO8601toDate(v);
                    case "boolean": return v === "1";
                    case "int":
                    case "i4":     return parseInt(v, 10);
                    case "double": return Number(v);
                    case "base64":
                        var b64 = new pkg.Base64();
                        b64.encoded = v;
                        return b64;
                    case "string": return v;
                }
                throw new Error("Unknown tag " + tag);
            };

            this.decode = function(r) {
                var p = zebkit.environment.parseXML(r),
                    c = p.getElementsByTagName("fault");

                if (c.length > 0) {
                    var err = this.decodeValue(c[0].getElementsByTagName("struct")[0]);
                    throw new Error(err.faultString);
                }

                c = p.getElementsByTagName("methodResponse")[0];
                c = c.childNodes[0].childNodes[0]; // <params>/<param>
                if (c.tagName.toLowerCase() === "param") {
                    return this.decodeValue(c.childNodes[0].childNodes[0]); // <value>/<xxx>
                }
                throw new Error("Incorrect XML-RPC response");
            };
        }
    ]);

    /**
     * Shortcut to call the specified method of a XML-RPC service.
     * @param  {String} url an URL
     * @param  {String} method a method name
     * @for zebkit.io.XRPC
     * @method invoke
     * @static
     */
    pkg.XRPC.invoke = function(url, method) {
        return pkg.Service.invoke(pkg.XRPC, url, method);
    };
});

zebkit.package("data", function(pkg, Class) {
    /**
     * Collection of various data models. The models are widely used by zebkit UI
     * components as part of model-view-controller approach, but the package doesn't depend on
     * zebkit UI and can be used independently.
     *
     *      var model = new zebkit.data.TreeModel();
     *      model.on("itemInserted", function(model, item) {
     *          // handle item inserted tree model event
     *          ...
     *      });
     *
     *      model.add(model.root, new zebkit.data.Item("Child 1"));
     *      model.add(model.root, new zebkit.data.Item("Child 2"));
     *
     * @class zebkit.data
     * @access package
     */

    pkg.descent = function descent(a, b) {
        if (typeof a === 'undefined' || a === null) return 1;
        return zebkit.isString(a) ? a.localeCompare(b) : a - b;
    };

    pkg.ascent = function ascent(a, b) {
        if (b === null || typeof b === 'undefined') return 1;
        return zebkit.isString(b) ? b.localeCompare(a) : b - a;
    };

    /**
     * Data model marker interface. It has no methods implemented.
     * @class zebkit.data.DataModel
     * @interface zebkit.data.DataModel
     */
    pkg.DataModel = zebkit.Interface();

    /**
     * Abstract text model class
     * @class zebkit.data.TextModel
     * @uses {zebkit.data.DataModel}
     */

    /**
     * Get the given string line stored in the model
     * @method getLine
     * @param  {Integer} line a line number
     * @return {String}  a string line
     */

    /**
     * Get wrapped by the text model original text string
     * @method getValue
     * @return {String} an original text
     */

    /**
     * Get number of lines stored in the text model
     * @method getLines
     * @return {Integer} a number of lines
     */

    /**
     * Get number of characters stored in the model
     * @method getTextLength
     * @return {Integer} a number of characters
     */

    /**
     * Write the given string in the text model starting from the specified offset
     * @method write
     * @param  {String} s a string to be written into the text model
     * @param  {Integer} offset an offset starting from that the passed
     * string has to be written into the text model
     */

    /**
     * Remove substring from the text model.
     * @method remove
     * @param  {Integer} offset an offset starting from that a substring
     * will be removed
     * @param  {Integer} size a size of a substring to be removed
     */

    /**
     * Fill the text model with the given text
     * @method  setValue
     * @param  {String} text a new text to be set for the text model
     */

    /**
     * Fired when the text model has been updated: a string has been
     * inserted or removed

        text.on(function(src, b, off, len, startLine, lines) {
            ...
        });

     *
     * @event textUpdated
     * @param {zebkit.data.Text} src a text model that triggers the event
     * @param {Boolean}  b a flag that is true if a string has been written
     * in the text model, false if the model substring has been removed
     * @param {Integer}  off an offset starting form that the text update
     * took place
     * @param {Integer}  len a length of text that has been affected by
     * the text model update
     * @param {Integer}  startLine a first line that has been affected
     * by the text model update
     * @param {Integer}  lines a number of lines that has been affected
     * by the text model update
     */
    pkg.TextModel = Class(pkg.DataModel, [
        function $clazz() {
            this.Listeners = zebkit.util.ListenersClass("textUpdated");
        }
    ]);

    /**
     * Multi-lines text model implementation
     * @class zebkit.data.Text
     * @param  {String}  [s] the specified text the model has to be filled
     * @constructor
     * @extends zebkit.data.TextModel
     * @uses {zebkit.EventProducer}
     */
    pkg.Text = Class(pkg.TextModel, zebkit.EventProducer, [
        function(s) {
            /**
             * Array of lines
             * @attribute lines
             * @type {zebkit.data.Text.Line[]}
             * @private
             * @readOnly
             */
            this.$lines = [ new this.clazz.Line("") ];
            this._ = new this.clazz.Listeners();
            this.setValue(arguments.length === 0 || s === null ? "" : s);
        },

        function $clazz() {
            this.Line = function(s) {
                this.$s = s;
            };

            //  toString for array.join method
            this.Line.prototype.toString = function() {
                return this.$s;
            };
        },

        function $prototype() {
            /**
             * Text length
             * @attribute textLength
             * @private
             * @readOnly
             * @type {Integer}
             */
            this.textLength = 0;

            /**
             * Detect line by offset starting from the given line and offset.
             * @param  {Integer} [start]       start line
             * @param  {Integer} [startOffset] start offset of the start line
             * @param  {Integer} o             offset to detect line
             * @private
             * @method calcLineByOffset
             * @return {Array}  an array that consists of two elements: detected line index and its offset
             */
            this.calcLineByOffset = function(start, startOffset, o) {
                if (arguments.length === 1) {
                    startOffset = start = 0;
                }

                for(; start < this.$lines.length; start++){
                    var line = this.$lines[start].$s;
                    if (o >= startOffset && o <= startOffset + line.length){
                        return [start, startOffset];
                    }
                    startOffset += (line.length + 1);
                }
                return [];
            };

            /**
             * Calculate an offset in the text the first character of the specified line.
             * @param  {Integer} line a line index
             * @return {Integer} an offset
             * @protected
             * @method  calcLineOffset
             */
            this.calcLineOffset = function(line) {
                var off = 0;
                for(var i = 0; i < line; i++){
                    off += (this.$lines[i].$s.length + 1);
                }
                return off;
            };

            this.$lineTags = function(i) {
                return this.$lines[i];
            };

            this.getLine = function(line) {
                if (line < 0 || line >= this.$lines.length) throw RangeError(line);
                return this.$lines[line].$s;
            };

            this.getValue = function() {
                return this.$lines.join("\n");
            };

            this.getLines = function () {
                return this.$lines.length;
            };

            this.getTextLength = function() {
                return this.textLength;
            };

            /**
             * Remove number of text lines starting form the specified line
             * @param  {Integer} start a starting line to remove text lines
             * @param  {Integer} [size]  a number of lines to be removed. If the
             * argument is not passed number equals 1
             * @method removeLines
             */
            this.removeLines = function(start, size) {
                if (start < 0 || start >= this.$lines.length) {
                    throw new RangeError(start);
                }

                if (arguments.length === 1) {
                    size = 1;
                } else if (size <= 0) {
                    throw new Error("Invalid number of lines : " + size);
                }

                // normalize number required lines to be removed
                if ((start + size) > this.$lines.length) {
                    size = this.$lines.length - start;
                }

                var end  = start + size - 1,            // last line to be removed
                    off  = this.calcLineOffset(start),  // offset of the first line to be removed
                    olen = start !== end ? this.calcLineOffset(end) + this.$lines[end].$s.length + 1 - off
                                         : this.$lines[start].$s.length + 1;


                // if this is the last line we have to correct offset to point to "\n" character in text
                if (start === this.$lines.length - 1) {
                    off--;
                }

                this.$lines.splice(start, size);
                this._.textUpdated(this, false, off, olen, start, size);
            };

            /**
             * Insert number of lines starting from the given starting line
             * @param  {Integer} startLine a starting line to insert lines
             * @param  {String}  [lines]*  string lines to inserted
             * @method  insertLines
             */
            this.insertLines = function(startLine) {
                if (startLine < 0 || startLine > this.$lines.length) {
                    throw new RangeError(startLine);
                }

                var off = this.calcLineOffset(startLine), offlen = 0;
                if (startLine === this.$lines.length) {
                    off--;
                }

                for(var i = 1; i < arguments.length; i++) {
                    offlen += arguments[i].length + 1;
                    this.$lines.splice(startLine + i - 1, 0, new this.clazz.Line(arguments[i]));
                }
                this._.textUpdated(this, true, off, offlen, startLine, arguments.length - 1);
            };

            this.write = function (s, offset) {
                if (s.length > 0) {
                    var slen    = s.length,
                        info    = this.calcLineByOffset(0,0,offset),
                        line    = this.$lines[info[0]].$s,
                        j       = 0,
                        lineOff = offset - info[1],
                        tmp     = line.substring(0, lineOff) + s + line.substring(lineOff);

                    for(; j < slen && s[j] !== '\n'; j++);

                    if (j >= slen) {
                        this.$lines[info[0]].$s = tmp;
                        j = 1;
                    } else {
                        this.$lines.splice(info[0], 1);
                        j = this.parse(info[0], tmp, this.$lines);
                    }

                    if (slen > 0) {
                        this.textLength += slen;
                        this._.textUpdated(this, true, offset, slen, info[0], j);
                        return true;
                    }
                }
                return false;
            };

            this.remove = function(offset, size) {
                if (size > 0) {
                    var i1   = this.calcLineByOffset(0, 0, offset),
                        i2   = this.calcLineByOffset(i1[0], i1[1], offset + size),
                        l1   = this.$lines[i1[0]].$s,
                        l2   = this.$lines[i2[0]].$s,
                        off1 = offset - i1[1], off2 = offset + size - i2[1],
                        buf  = l1.substring(0, off1) + l2.substring(off2);

                    if (i2[0] === i1[0]) {
                        this.$lines.splice(i1[0], 1, new this.clazz.Line(buf));
                    } else {
                        this.$lines.splice(i1[0], i2[0] - i1[0] + 1);
                        this.$lines.splice(i1[0], 0, new this.clazz.Line(buf));
                    }

                    if (size > 0) {
                        this.textLength -= size;
                        this._.textUpdated(this, false, offset, size, i1[0], i2[0] - i1[0] + 1);
                        return true;
                    }
                }
                return false;
            };

            this.parse = function (startLine, text, lines){
                var size = text.length, prevIndex = 0, prevStartLine = startLine;
                for(var index = 0; index <= size; prevIndex = index, startLine++){
                    var fi = text.indexOf("\n", index);
                    index = (fi < 0 ? size : fi);
                    this.$lines.splice(startLine, 0, new this.clazz.Line(text.substring(prevIndex, index)));
                    index++;
                }
                return startLine - prevStartLine;
            };

            this.setValue = function(text) {
                var old = this.getValue();
                if (old !== text) {
                    if (old.length > 0) {
                        var numLines = this.getLines(), txtLen = this.getTextLength();
                        this.$lines.length = 0;
                        this.$lines = [ new this.clazz.Line("") ];
                        this._.textUpdated(this, false, 0, txtLen, 0, numLines);
                    }

                    this.$lines = [];
                    this.parse(0, text, this.$lines);
                    this.textLength = text.length;
                    this._.textUpdated(this, true, 0, this.textLength, 0, this.getLines());
                    return true;
                }
                return false;
            };
        }
    ]);

    /**
     * Single line text model implementation
     * @param  {String}  [s] the specified text the model has to be filled
     * @param  {Integer} [max] the specified maximal text length
     * @constructor
     * @class zebkit.data.SingleLineTxt
     * @extends zebkit.data.TextModel
     * @uses {zebkit.EventProducer}
     */
    pkg.SingleLineTxt = Class(pkg.TextModel, zebkit.EventProducer,[
        function (s, max) {
            if (arguments.length > 1) {
                this.maxLen = max;
            }

            this._ = new this.clazz.Listeners();
            this.setValue(arguments.length === 0 || s === null ? "" : s);
        },

        function $prototype() {
            this.buf    = "";
            this.extra  =  0;
            this.maxLen = -1;

            /**
             * Maximal text length. -1 means the text is not restricted
             * regarding its length.
             * @attribute maxLen
             * @type {Integer}
             * @default -1
             * @readOnly
             */
            this.$lineTags = function(i) {
                return this;
            };

            this.getValue = function(){
                return this.buf;
            };

            /**
             * Get number of lines stored in the text model. The model
             * can have only one line
             * @method getLines
             * @return {Integer} a number of lines
             */
            this.getLines = function(){
                return 1;
            };

            this.getTextLength = function(){
                return this.buf.length;
            };

            this.getLine = function(line){
                if (line !== 0) {
                    throw new RangeError(line);
                }
                return this.buf;
            };

            this.write = function(s,offset) {
                // cut to the first new line character
                var j = s.indexOf("\n");
                if (j >= 0) {
                    s = s.substring(0, j);
                }

                var l = (this.maxLen > 0 && (this.buf.length + s.length) >= this.maxLen) ? this.maxLen - this.buf.length
                                                                                         : s.length;
                if (l !== 0) {
                    var nl = this.buf.substring(0, offset) + s.substring(0, l) + this.buf.substring(offset);
                    if (typeof this.validate !== 'function' || this.validate(nl)) {
                        this.buf = nl;
                        if (l > 0) {
                            this._.textUpdated(this, true, offset, l, 0, 1);
                            return true;
                        }
                    }
                }
                return false;
            };

            this.remove = function(offset,size){
                if (size > 0) {
                    var nl = this.buf.substring(0, offset) +
                             this.buf.substring(offset + size);

                    if (nl.length !== this.buf.length && (typeof this.validate !== 'function' || this.validate(nl))) {
                        this.buf = nl;
                        this._.textUpdated(this, false, offset, size, 0, 1);
                        return true;
                    }
                }
                return false;
            };

            this.setValue = function(text){
                if (typeof this.validate === 'function' && this.validate(text) === false) {
                    return false;
                }

                // cut to next line
                var i = text.indexOf('\n');
                if (i >= 0) {
                    text = text.substring(0, i);
                }

                if ((this.buf === null || this.buf !== text) && (typeof this.validate !== 'function'  || this.validate(text))) {
                    if (this.buf !== null && this.buf.length > 0) {
                        this._.textUpdated(this, false, 0, this.buf.length, 0, 1);
                    }

                    if (this.maxLen > 0 && text.length > this.maxLen) {
                        text = text.substring(0, this.maxLen);
                    }

                    this.buf = text;
                    this._.textUpdated(this, true, 0, text.length, 0, 1);
                    return true;
                }

                return false;
            };

            /**
             * Set the given maximal length the text can have
             * @method setMaxLength
             * @param  {Integer} max a maximal length of text
             */
            this.setMaxLength = function (max){
                if (max !== this.maxLen){
                    this.maxLen = max;
                    this.setValue("");
                }
            };

            /**
             *  Validate the given text. This method can be implemented to prevent
             *  inserting text in text model that doesn't satisfy the given condition.
             *  For instance text can allow only numeric.
             *  @method validate
             *  @param {String} text a text
             *  @return {Boolean} return true if the text is valid otherwise return false
             */
        }
    ]);

    /**
     * List model class
     * @param  {Array} [a] an array the list model has to be initialized with
     * @example

          // create list model that contains three integer elements
          var l = new zebkit.data.ListModel([1,2,3]);
          l.on("elementInserted", function(list, element, index) {
              // handle list item inserted event
              ...
          })
          ...
          l.add(10)

     * @constructor
     * @class zebkit.data.ListModel
     * @uses {zebkit.EventProducer}
     */

     /**
      * Fired when a new element has been added to the list model

         list.on("elementInserted", function(src, o, i) {
             ...
         });

      * @event elementInserted
      * @param {zebkit.data.ListModel} src a list model that triggers the event
      * @param {Object}  o an element that has been added
      * @param {Integer} i an index at that the new element has been added
      */

     /**
      * Fired when an element has been removed from the list model

         list.on("elementRemoved", function(src, o, i) {
             ...
         });

      * @event elementRemoved
      * @param {zebkit.data.ListModel} src a list model that triggers the event
      * @param {Object}  o an element that has been removed
      * @param {Integer} i an index at that the element has been removed
      */

     /**
      * Fired when an element has been re-set

         list.on("elementSet", function(src, o, p, i) {
             ...
         });

      * @event elementSet
      * @param {zebkit.data.ListModel} src a list model that triggers the event
      * @param {Object}  o an element that has been set
      * @param {Object}  p a previous element
      * @param {Integer} i an index at that the element has been re-set
      */

    pkg.ListModel = Class(pkg.DataModel, zebkit.EventProducer,[
        function() {
            this._ = new this.clazz.Listeners();
            this.$data = (arguments.length === 0) ? [] : arguments[0];
        },

        function $clazz () {
            this.Listeners = zebkit.util.ListenersClass("elementInserted", "elementRemoved", "elementSet");
        },

        function $prototype() {
            /**
             * Get an item stored at the given location in the list
             * @method get
             * @param  {Integer} i an item location
             * @return {object}  a list item
             */
            this.get = function(i) {
                if (i < 0 || i >= this.$data.length) {
                    throw new RangeError(i);
                }
                return this.$data[i];
            };

            /**
             * Add the given item to the end of the list
             * @method add
             * @param  {Object} o an item to be added
             */
            this.add = function(o) {
                this.$data.push(o);
                this._.elementInserted(this, o, this.$data.length - 1);
            };

            /**
             * Remove all elements from the list model
             * @method removeAll
             */
            this.removeAll = function() {
                var size = this.$data.length;
                for(var i = size - 1; i >= 0; i--) this.removeAt(i);
            };

            /**
             * Remove an element at the given location of the list model
             * @method removeAt
             * @param {Integer} i a location of an element to be removed from the list
             */
            this.removeAt = function(i) {
                var re = this.$data[i];
                this.$data.splice(i, 1);
                this._.elementRemoved(this, re, i);
            };

            /**
             * Remove the given element from the list
             * @method remove
             * @param {Object} o an element to be removed from the list
             */
            this.remove = function(o) {
                for(var i = 0;i < this.$data.length; i++ ){
                    if (this.$data[i] === o) this.removeAt(i);
                }
            };

            /**
             * Insert the given element into the given position of the list
             * @method insert
             * @param {Integer} i a position at which the element has to be inserted into the list
             * @param {Object} o an element to be inserted into the list
             */
            this.insert = function(i, o){
                if (i < 0 || i > this.$data.length) {
                    throw new RangeError(i);
                }
                this.$data.splice(i, 0, o);
                this._.elementInserted(this, o, i);
            };

            /**
             * Get number of elements stored in the list
             * @method count
             * @return {Integer} a number of element in the list
             */
            this.count = function () {
                return this.$data.length;
            };

            /**
             * Set the new element at the given position
             * @method setAt
             * @param  {Integer} i a position
             * @param  {Object} o a new element to be set as the list element at the given position
             * @return {Object}  previous element that was stored at the given position
             */
            this.setAt = function(i, o) {
                if (i < 0 || i >= this.$data.length) {
                    throw new RangeError(i);
                }
                var pe = this.$data[i];
                this.$data[i] = o;
                this._.elementSet(this, o, pe, i);
                return pe;
            };

            /**
             * Check if the element is in the list
             * @method contains
             * @param  {Object} o an element to be checked
             * @return {Boolean} true if the element is in the list
             */
            this.contains = function (o){
                return this.indexOf(o) >= 0;
            };

            /**
             * Get position the given element is stored in the list
             * @method indexOf
             * @param  {Object} o an element
             * @return {Integer} the element position. -1 if the element cannot be found in the list
             */
            this.indexOf = function(o){
                return this.$data.indexOf(o);
            };
        }
    ]);

    /**
     * Tree model item class. The structure is used by tree model to store
     * tree items values, parent and children item references.
     * @class zebkit.data.Item
     * @param  {Object} [v] the item value
     * @constructor
     */
    pkg.Item = Class([
        function(v) {
            /**
             * Array of children items of the item element
             * @attribute kids
             * @type {Array}
             * @default []
             * @readOnly
             */
            this.kids = [];

            /**
             * Value stored with this item
             * @attribute value
             * @type {Object}
             * @default null
             * @readOnly
             */
            if (arguments.length > 0) {
                this.value = v;
            }
        },

        function $prototype() {
            /**
             * Reference to a parent item
             * @attribute parent
             * @type {zebkit.data.Item}
             * @default null
             * @readOnly
             */
             this.parent = null;

             /**
              * The tree model item value. It is supposed the value should be updated
              * via execution of "setValue(...)" method of a tree model the item
              * belongs to.
              * @attribute value
              * @default null
              * @type {Object}
              * @readOnly
              */
             this.value = null;
        }
    ]).hashable();


    /**
     * Tree model class. The class is simple and handy way to keep hierarchical structure.
     *
     * @param  {zebkit.data.Item|Object} [r] a root item. As the argument you can pass "zebkit.data.Item" or
     * a JavaScript object. In the second case you can describe the tree as it is shown in example below:
     * @example

         // create tree model initialized with tree structure passed as
         // special formated JavaScript object. The tree will look as follow:
         //  "Root"
         //    |
         //    +--- "Root kid 1"
         //    +--- "Root kid 2"
         //            |
         //            +--- "Kid of kid 2"
         var tree = new zebkit.data.TreeModel({
            value:"Root",
            kids: [
                "Root kid 1",
                {
                    value: "Root kid 2",
                    kids:  [ "Kid of kid 2"]
                }
            ]
         });
         ...
         // reg item modified events handler
         tree.on("itemModified", function(tree, item, prevValue) {
             // catch item value modification
             ...
         });

         // item value has to be updated via tree model API
         tree.setValue(tree.root.kids[0], "new value");

     * @class zebkit.data.TreeModel
     * @uses {zebkit.data.DataModel}
     * @uses {zebkit.EventProducer}
     * @constructor
     */

    /**
     * Fired when the tree model item value has been updated.

     tree.on("itemModified", function(src, item, prevValue) {
         ...
     });

     * @event itemModified
     * @param {zebkit.data.TreeModel} src a tree model that triggers the event
     * @param {zebkit.data.Item}  item an item whose value has been updated
     * @param {Object} prevValue a previous value the item has had
     */

    /**
     * Fired when the tree model item has been removed

     tree.on("itemRemoved", function(src, item) {
        ...
     });

     * @event itemRemoved
     * @param {zebkit.data.TreeModel} src a tree model that triggers the event
     * @param {zebkit.data.Item}  item an item that has been removed from the tree model
     */

    /**
     * Fired when the tree model item has been inserted into the model

     tree.on("itemInserted", function(src, item) {{
        ...
     });

     * @event itemInserted
     * @param {zebkit.data.TreeModel} src a tree model that triggers the event
     * @param {zebkit.data.Item}  item an item that has been inserted into the tree model
     */
    pkg.TreeModel = Class(pkg.DataModel, zebkit.EventProducer, [
        function(r) {
            if (arguments.length === 0) {
                this.root = new pkg.Item();
            } else {
                this.root = zebkit.instanceOf(r, pkg.Item) ? r : this.clazz.create(r);
            }

            this._ = new this.clazz.Listeners();
        },

        function $clazz() {
            this.Listeners = zebkit.util.ListenersClass("itemModified", "itemRemoved", "itemInserted");

            /**
             * Create tree model item hierarchy by the given JavaScript object.
             * @param  {Object} r
             * @return {zebkit.data.Item} a built items hierarchy
             * @example
             *
             *      // create the following items hierarchy:
             *      //  "Root"
             *      //    +--- "Kid 1"
             *      //    |      +--- "Kid 1.1"
             *      //    |      |       +--- "Kid 1.1.1"
             *      //    |      +--- "Kid 2.2"
             *      //    +--- "Kid 2"
             *      //    |        +--- "Kid 2.1"
             *      //    |        +--- "Kid 2.2"
             *      //    |        +--- "Kid 2.3"
             *      //    +--- "Kid 3"
             *      //
             *      var rootItem = zebkit.data.TreeModel.create({
             *          value : "Root",
             *          kids  : [
             *              {   value : "Kid 1"
             *                  kids  : [
             *                      {  value: "Kid 1.1",
             *                         kids : "Kid 1.1.1"
             *                      },
             *                      "Kid 2.2"
             *                  ]
             *              },
             *              {   value: "Kid 2",
             *                  kids : ["Kid 2.1", "Kid 2.2", "Kid 2.3"]
             *              },
             *              "Kid 3"
             *          ]
             *      });
             *
             * @static
             * @method create
             */
            this.create = function(r, p) {
                var item = new pkg.Item(r.hasOwnProperty("value")? r.value : r);
                item.parent = arguments.length < 2 ? null : p;
                if (typeof r.kids !== 'undefined' && r.kids !== null) {
                    for(var i = 0; i < r.kids.length; i++) {
                        item.kids[i] = this.create(r.kids[i], item);
                    }
                }
                return item;
            };

            /**
             * Find the first tree item (starting from the specified root item) whose value equals the given value.
             * @param  {zebkit.data.Item} root a root item of the tree
             * @param  {Object} value a value to evaluate
             * @return {zebkit.data.Item} a found tree item
             * @static
             * @method findOne
             */
            this.findOne = function(root, value) {
                var res = null;
                this.find(root, value, function(item) {
                    res = item;
                    return true;
                });
                return res;
            };

            /**
             * Find all items (starting from the specified root item) whose value equals the given value.
             * @param  {zebkit.data.Item} root a root item of the tree
             * @param  {Object} value a value to evaluate
             * @param  {Function} [cb] a callback method that is called for every tree item whose value matches
             * the specified one. The method gets the found item as its argument. The method can return true
             * if the tree traversing has to be interrupted.
             * @return {Array} a list of all found item whose value matches the specified one. The array is returned
             * only if no callback method has been passed to the method.
             * @example
             *
             *      // create tree items
             *      var rootItem = zebkit.data.TreeModel.create({
             *          value: "Root",
             *          kids : [ "Kid 1", "Kid 2", "Kid 1", "Kid 3", "Kid 1" ]
             *      });
             *
             *      // find all items that have its value set to "Kid 1" and return
             *      // it as array
             *      var items = zebkit.data.TreeModel.find(rootItem, "Kid 1");
             *
             *      // find the first two "Kid 1" item in the tree using callback
             *      var items = [];
             *      zebkit.data.TreeModel.find(rootItem, "Kid 1", function(item) {
             *          items.push(item);
             *
             *          // stop the tree traversing as soon as we found two items
             *          return items.length > 1;
             *      });
             *
             * @static
             * @method find
             */
            this.find = function(root, value, cb) {
                if (arguments.length < 3) {
                    var res = [];
                    this.find(root, value, function(item) {
                        res.push(item);
                        return false;
                    });
                    return res;
                }

                if (root.value === value) {
                    if (cb.call(this, root) === true) {
                        return true;
                    }
                }

                if (typeof root.kids !== 'undefined' && root.kids !== null) {
                    for (var i = 0; i < root.kids.length; i++) {
                        if (this.find(root.kids[i], value, cb)) {
                            return true;
                        }
                    }
                }
                return false;
            };

            this.print = function(root, render, shift) {
                if (zebkit.instanceOf(root, pkg.TreeModel)) {
                    root = root.root;
                }

                if (arguments.length < 2) {
                    shift  = "";
                    render = null;
                } else if (arguments.length === 2) {
                    if (zebkit.isString(render)) {
                        shift  = render;
                        render = null;
                    } else {
                        shift = "";
                    }
                }

                var b = typeof root.kids !== 'undefined' && root.kids !== null,
                    v = render !== null ? render(root)
                                        : (root.value === null ? "<null>" : root.value) + " {" + (b?root.kids.length:0) + "}";
                if (b) {
                    shift = shift + "    ";
                    for (var i = 0; i < root.kids.length; i++) {
                        this.print(root.kids[i], render, shift);
                    }
                }
            };
        },

        function $prototype() {
            /**
             * Reference to the tree model root item
             * @attribute root
             * @type {zebkit.data.Item}
             * @readOnly
             */
            this.root = null;

            /**
             * Iterate over tree hierarchy starting from its root element
             * @param  {zebkit.data.Item} r a root element to start traversing the tree model
             * @param  {Function} f a callback function that is called for every tree item traversed item.
             * The callback gets tree model and the item as its arguments
             * @method iterate
             */
            this.iterate = function(r, f) {
                var res = f.call(this, r);
                if (res === 1 || res === 2) { //TODO: make it clear what is a mening of the res ?
                    return r;
                }

                for (var i = 0; i < r.kids.length; i++) {
                    res = this.iterate(r.kids[i], f);
                    if (res === 2) return res;
                }
            };

            /**
             * Update a value of the given tree model item with the new one
             * @method setValue
             * @param  {zebkit.data.Item} item an item whose value has to be updated
             * @param  {Object} v   a new item value
             */
            this.setValue = function(item, v){
                var prev = item.value;
                item.value = v;
                this._.itemModified(this, item, prev);
            };

            /**
             * Add the new item to the tree model as a children element of the given parent item
             * @method add
             * @param  {zebkit.data.Item} [to] a parent item to which the new item has to be added.
             * If it has not been passed the node will be added to root.
             * @param  {Object|zebkit.data.Item} an item or value of the item to be
             * added to the parent item of the tree model
             */
            this.add = function(to,item) {
                if (arguments.length < 2) {
                    to = this.root;
                }

                this.insert(to, item, to.kids.length);
            };

            /**
             * Insert the new item to the tree model as a children element at the
             * given position of the parent element
             * @method insert
             * @param  {zebkit.data.Item} to a parent item to which the new item
             * has to be inserted
             * @param  {Object|zebkit.data.Item} an item or value of the item to be
             * inserted to the parent item
             * @param  {Integer} i a position the new item has to be inserted into
             * the parent item
             */
            this.insert = function(to, item, i) {
                if (i < 0 || to.kids.length < i) throw new RangeError(i);
                if (zebkit.isString(item)) {
                    item = new pkg.Item(item);
                }
                to.kids.splice(i, 0, item);
                item.parent = to;
                this._.itemInserted(this, item);

                // !!!
                // it is necessary to analyze if the inserted item has kids and
                // generate inserted event for all kids recursively
            };

            /**
             * Remove the given item from the tree model
             * @method remove
             * @param  {zebkit.data.Item} item an item to be removed from the tree model
             */
            this.remove = function(item){
                if (item === this.root) {
                    this.root = null;
                } else {
                    if (typeof item.kids !== 'undefined') {
                        for(var i = item.kids.length - 1; i >= 0; i--) {
                            this.remove(item.kids[i]);
                        }
                    }
                    item.parent.kids.splice(item.parent.kids.indexOf(item), 1);
                }

                // preserve reference to parent when we call a listener
                try {
                    this._.itemRemoved(this, item);
                } catch(e) {
                    item.parent = null;
                    throw e;
                }
                item.parent = null;
            };

            /**
             * Remove all children items from the given item of the tree model
             * @method removeKids
             * @param  {zebkit.data.Item} item an item from that all children items have to be removed
             */
            this.removeKids = function(item) {
                for(var i = item.kids.length - 1; i >= 0; i--) {
                    this.remove(item.kids[i]);
                }
            };
        }
    ]);

    /**
     *  Matrix model class.
     *  @constructor
     *  @param  {Array} [data] the given data as two dimensional array
     *  @param  {Integer} [rows] a number of rows
     *  @param  {Integer} [cols] a number of columns
     *  @class zebkit.data.Matrix
     *  @uses {zebkit.EventProducer}
     *  @uses {zebkit.data.DataModel}
     *  @example
     *
     *      // create matrix with 10 rows and 5 columns
     *      var matrix = zebkit.data.Matrix(10, 5);
     *
     *      matrix.get(0,0);
     *      matrix.put(0,0, "Cell [0,0]");
     *
     *  @example
     *
     *      // create matrix with 3 rows and 5 columns
     *      var matrix = zebkit.data.Matrix([
     *          [ 0, 1, 2, 3, 4 ],  // row 0
     *          [ 0, 1, 2, 3, 4 ],  // row 1
     *          [ 0, 1, 2, 3, 4 ],  // row 2
     *          [ 0, 1, 2, 3, 4 ],  // row 3
     *          [ 0, 1, 2, 3, 4 ]   // row 4
     *      ]);
     *
     *  @example
     *
     *      // create matrix with 0 rows and 0 columns
     *      var matrix = zebkit.data.Matrix();
     *
     *      // setting value for cell (2, 4) will change
     *      // matrix size to 2 rows and 3 columns
     *      matrix.put(2, 4, "Cell [row = 2, col = 4]");
     */

    /**
     * Fired when the matrix model size (number of rows or columns) is changed.

      matrix.on("matrixResized", function(src, pr, pc) {
          ...
      });

     * @event matrixResized
     * @param {zebkit.data.Matrix} src a matrix that triggers the event
     * @param {Integer}  pr a previous number of rows
     * @param {Integer}  pc a previous number of columns
     */

    /**
     * Fired when the matrix model cell has been updated.

      matrix.on("cellModified", function(src, row, col, old) {
         ...
      });

     * @event cellModified
     * @param {zebkit.data.Matrix} src a matrix that triggers the event
     * @param {Integer}  row an updated row
     * @param {Integer}  col an updated column
     * @param {Object}  old a previous cell value
     */

    /**
     * Fired when the matrix data has been re-ordered.

      matrix.on("matrixSorted", function(src, sortInfo) {
         ...
      });

     * @event matrixSorted
     * @param {zebkit.data.Matrix} src a matrix that triggers the event
     * @param {Object}  sortInfo a new data order info. The information
     * contains:
     *
     *      {
     *         func: sortFunction,
     *         name: sortFunctionName,
     *         col : sortColumn
     *      }
     *
     */

    /**
     * Fired when a row has been inserted into the matrix.

      matrix.on("matrixRowInserted", function(src, rowIndex) {
         ...
      });

     * @event matrixColInserted
     * @param {zebkit.data.Matrix} src a matrix that triggers the event
     * @param {Integer}  rowIndex a row that has been inserted
     * contains:
     */

    /**
     * Fired when a column has been inserted into the matrix.

      matrix.on("matrixColInserted", function(src, colIndex) {
         ...
      });

     * @event matrixColInserted
     * @param {zebkit.data.Matrix} src a matrix that triggers the event
     * @param {Integer}  colIndex a column that has been inserted
     * contains:
     */
    pkg.Matrix = Class(pkg.DataModel, zebkit.EventProducer, [
        function() {
            /**
             * Number of rows in the matrix model
             * @attribute rows
             * @type {Integer}
             * @readOnly
             */

            /**
             * Number of columns in the matrix model
             * @attribute cols
             * @type {Integer}
             * @readOnly
             */

            /**
             * The multi-dimensional embedded arrays to host matrix data
             * @attribute $objs
             * @type {Array}
             * @readOnly
             * @private
             */

            this._ = new this.clazz.Listeners();
            if (arguments.length === 1) {
                this.$objs = arguments[0];
                this.cols = (this.$objs.length > 0) ? this.$objs[0].length : 0;
                this.rows = this.$objs.length;
            } else {
                this.$objs = [];
                this.rows = this.cols = 0;
                if (arguments.length > 1) {
                    this.setRowsCols(arguments[0], arguments[1]);
                }
            }
        },

        function $clazz() {
            this.Listeners = zebkit.util.ListenersClass("matrixResized", "cellModified",
                                                        "matrixSorted",  "matrixRowInserted",
                                                        "matrixColInserted");
        },

        function $prototype() {
            /**
             * Get a matrix model cell value at the specified row and column
             * @method get
             * @param  {Integer} row a cell row
             * @param  {Integer} col a cell column
             * @return {Object}  matrix model cell value
             */
            this.get = function (row,col){
                if (row < 0 || row >= this.rows) {
                    throw new RangeError(row);
                }

                if (col < 0 || col >= this.cols) {
                    throw new RangeError(col);
                }

                return this.$objs[row] == null ? undefined : this.$objs[row][col];
            };

            /**
             * Get a matrix model cell value by the specified index
             * @method geti
             * @param  {Integer} index a cell index
             * @return {Object}  matrix model cell value
             */
            this.geti = function(i) {
                return this.get(~~(i / this.cols), i % this.cols);
            };

            /**
             * Set the specified by row and column cell value. If the specified row or column
             * is greater than the matrix model has the model size will be adjusted to new one.
             * @method put
             * @param  {Integer} row a cell row
             * @param  {Integer} col a cell column
             * @param  {Object} obj a new cell value
             */
            this.put = function(row,col,obj){
                var nr = this.rows,
                    nc = this.cols;

                if (row >= nr) nr += (row - nr + 1);
                if (col >= nc) nc += (col - nc + 1);

                this.setRowsCols(nr, nc);
                var old = this.$objs[row] != null ? this.$objs[row][col] : undefined;
                if (obj !== old) {
                    // allocate array if no data for the given row exists
                    if (typeof this.$objs[row] === 'undefined') this.$objs[row] = [];
                    this.$objs[row][col] = obj;
                    this._.cellModified(this, row, col, old);
                }
            };

            /**
             * Set the specified by index cell value. The index identifies cell starting from [0,0]
             * cell till [rows,columns]. If the index is greater than size of model the model size
             * will be adjusted to new one.
             * @method puti
             * @param  {Integer} i a cell row
             * @param  {Object} obj a new cell value
             */
            this.puti = function(i, obj){
                this.put( ~~(i / this.cols),
                             i % this.cols, obj);
            };

            /**
             * Set the given number of rows and columns the model has to have.
             * @method setRowsCols
             * @param  {Integer} rows a new number of rows
             * @param  {Integer} cols a new number of columns
             */
            this.setRowsCols = function(rows, cols){
                if (rows !== this.rows || cols !== this.cols){
                    var pc = this.cols,
                        pr = this.rows;

                    this.cols = cols;
                    this.rows = rows;

                    // re-locate matrix space
                    if (this.$objs.length > rows) {
                        this.$objs.length = rows;   // shrink number of rows
                    }

                    // shrink columns
                    if (pc > cols) {
                        for(var i = 0; i < this.$objs.length; i++) {
                            // check if data for columns has been allocated and the size
                            // is greater than set number of columns
                            if (typeof this.$objs[i] !== 'undefined' && this.$objs[i].length > cols) {
                                this.$objs[i].length = cols;
                            }
                        }
                    }

                    this._.matrixResized(this, pr, pc);
                }
            };

             /**
             * Set the given number of rows the model has to have.
             * @method setRows
             * @param  {Integer} rows a new number of rows
             */
            this.setRows = function(rows) {
                this.setRowsCols(rows, this.cols);
            };

            /**
             * Set the given number of columns the model has to have.
             * @method setCols
             * @param  {Integer} cols a new number of columns
             */
            this.setCols = function(cols) {
                this.setRowsCols(this.rows, cols);
            };

            /**
             * Remove specified number of rows from the model starting
             * from the given row.
             * @method removeRows
             * @param  {Integer} begrow a start row
             * @param  {Integer} count  a number of rows to be removed
             */
            this.removeRows = function(begrow,count) {
                if (arguments.length === 1) {
                    count = 1;
                }

                if (begrow < 0 || begrow + count > this.rows) {
                    throw new RangeError(begrow);
                }

                this.$objs.splice(begrow, count);
                this.rows -= count;
                this._.matrixResized(this, this.rows + count, this.cols);
            };

            /**
             * Remove specified number of columns from the model starting
             * from the given column.
             * @method removeCols
             * @param  {Integer}  begcol a start column
             * @param  {Integer} count  a number of columns to be removed
             */
            this.removeCols = function (begcol,count){
                if (arguments.length === 1) {
                    count = 1;
                }

                if (begcol < 0 || begcol + count > this.cols) {
                    throw new RangeError(begcol);
                }

                for(var i = 0; i < this.$objs.length; i++) {
                    if (this.$objs[i] != null && this.$objs[i].length > 0) {
                        this.$objs[i].splice(begcol, count);
                    }
                }

                this.cols -= count;
                this._.matrixResized(this, this.rows, this.cols + count);
            };

            /**
             * Insert the given number of rows at the specified row
             * @param  {Integer} row   a starting row to insert
             * @param  {Integer} count a number of rows to be added
             * @method insertRows
             */
            this.insertRows = function(row, count) {
                if (arguments.length === 1) {
                    count = 1;
                }

                var i = 0;
                if (row <= this.$objs.length - 1) {
                    for(i = 0; i < count; i++) {
                        this.$objs.splice(row, 0, undefined);
                        this._.matrixRowInserted(this, row + i);
                    }
                } else {
                    for(i = 0; i < count; i++) {
                        this._.matrixRowInserted(this, row + i);
                    }
                }

                this.rows += count;
                this._.matrixResized(this, this.rows - count, this.cols);
            };

            /**
             * Insert the given number of columns at the specified column
             * @param  {Integer} col   a starting column to insert
             * @param  {Integer} count a number of columns to be added
             * @method insertCols
             */
            this.insertCols = function(col, count) {
                if (arguments.length === 1) {
                    count = 1;
                }

                if (this.$objs.length  > 0) {
                    for(var j = 0; j < count; j++) {
                        for(var i = 0; i < this.rows; i++) {
                            if (this.$objs[i] != null && j <= this.$objs[i].length) {
                                this.$objs[i].splice(col, 0, undefined);
                            }
                        }
                        this._.matrixColInserted(this, col + j);
                    }
                }

                this.cols += count;
                this._.matrixResized(this, this.rows, this.cols - count);
            };

            /**
             * Sort the given column of the matrix model.
             * @param  {Integer} col a column to be re-ordered
             * @param  {Function} [f] an optional sort function. The name of the function
             * is grabbed to indicate type of the sorting the method does. For instance:
             * "descent", "ascent".
             * @method sortCol
             */
            this.sortCol = function(col, f) {
                if (arguments.length < 2) {
                    f = pkg.descent;
                }

                this.$objs.sort(function(a, b) {
                    return f(a[col], b[col]);
                });

                this._.matrixSorted(this, { col : col,
                                            func: f,
                                            name: zebkit.$FN(f).toLowerCase() });
            };
        }
    ]);
});
zebkit.package("layout", function(pkg, Class) {
    /**
     * Layout package provides number of classes, interfaces, methods and variables that allows
     * developers easily implement rules based layouting of hierarchy of rectangular elements.
     * The package has no relation to any concrete UI, but it can be applied to a required UI
     * framework very easily. In general layout manager requires an UI component to provide:
     *    - **setLocation(x,y)** method
     *    - **setSize(w,h)** method
     *    - **setBounds()** method
     *    - **getPreferredSize(x,y)** method
     *    - **getTop(), getBottom(), getRight(), getLeft()** methods
     *    - **constraints** read only property
     *    - **width, height, x, y** read only metrics properties
     *    - **kids** read only property that keep all children components
     *
     * @access package
     * @class zebkit.layout
     */

     /**
      * Find a direct children element for the given children component
      * and the specified parent component
      * @param  {zebkit.layout.Layoutable} parent  a parent component
      * @param  {zebkit.layout.Layoutable} child  a children component
      * @return {zebkit.layout.Layoutable}  a direct children component
      * @method getDirectChild
      * @for  zebkit.layout
      */
    pkg.getDirectChild = function(parent, child) {
        for(; child !== null && child.parent !== parent; child = child.parent) {}
        return child;
    };

    /**
     * Layout manager interface is simple interface that all layout managers have to
     * implement. One method has to calculate preferred size of the given component and
     * another one method has to perform layouting of children components of the given
     * target component.
     * @class zebkit.layout.Layout
     * @interface zebkit.layout.Layout
     */

    /**
     * Calculate preferred size of the given component
     * @param {zebkit.layout.Layoutable} t a target layoutable component
     * @method calcPreferredSize
     */

    /**
     * Layout children components of the specified layoutable target component
     * @param {zebkit.layout.Layoutable} t a target layoutable component
     * @method doLayout
     */
    pkg.Layout = new zebkit.Interface([
        "abstract",
            function doLayout(target) {},
            function calcPreferredSize(target) {}
    ]);

    /**
     * Find a direct component located at the given location of the specified parent component
     * and the specified parent component
     * @param  {Integer} x a x coordinate relatively to the parent component
     * @param  {Integer} y a y coordinate relatively to the parent component
     * @param  {zebkit.layout.Layoutable} parent  a parent component
     * @return {zebkit.layout.Layoutable} an index of direct children component
     * or -1 if no a children component can be found
     * @method getDirectAt
     * @for  zebkit.layout
     */
    pkg.getDirectAt = function(x, y, p){
        for(var i = 0;i < p.kids.length; i++){
            var c = p.kids[i];
            if (c.isVisible === true && c.x <= x && c.y <= y && c.x + c.width > x && c.y + c.height > y) {
                return i;
            }
        }
        return -1;
    };

    /**
     * Get a top (the highest in component hierarchy) parent component
     * of the given component
     * @param  {zebkit.layout.Layoutable} c a component
     * @return {zebkit.layout.Layoutable}  a top parent component
     * @method getTopParent
     * @for  zebkit.layout
     */
    pkg.getTopParent = function(c){
        for(; c !== null && c.parent !== null; c = c.parent);
        return c;
    };

    /**
     * Translate the given relative location into the parent relative location.
     * @param  {Integer} [x] a x coordinate relatively  to the given component
     * @param  {Integer} [y] a y coordinate relatively  to the given component
     * @param  {zebkit.layout.Layoutable} c a component
     * @param  {zebkit.layout.Layoutable} [p] a parent component
     * @return {Object} a relative to the given parent UI component location:

            { x:{Integer}, y:{Integer} }

     * @method toParentOrigin
     * @for  zebkit.layout
     */
    pkg.toParentOrigin = function(x,y,c,p){
        if (arguments.length === 1) {
            c = x;
            x = y = 0;
            p = null;
        } else {
            if (arguments.length < 4) p = null;
        }

        while (c !== null && c !== p) {
            x += c.x;
            y += c.y;
            c = c.parent;
        }

        if (c === null) {
            //throw new Error("Invalid params");
        }

        return { x:x, y:y };
    };

    /**
     * Convert the given component location into relative
     * location of the specified children component successor.
     * @param  {Integer} x a x coordinate relatively to the given
     * component
     * @param  {Integer} y a y coordinate relatively to the given
     * component
     * @param  {zebkit.layout.Layoutable} p a component
     * @param  {zebkit.layout.Layoutable} c a children successor component
     * @return {Object} a relative location
     *
     *      { x:{Integer}, y:{Integer} }
     *
     * @method toChildOrigin
     * @for  zebkit.layout
     */
    pkg.toChildOrigin = function(x, y, p, c){
        while(c !== p){
            x -= c.x;
            y -= c.y;
            c = c.parent;
        }
        return { x:x, y:y };
    };

    /**
     * Calculate maximal preferred width and height of
     * children component of the given target component.
     * @param  {zebkit.layout.Layoutable} target a target component
     * @return {Object} a maximal preferred width and height

            { width:{Integer}, height:{Integer} }

     * @method getMaxPreferredSize
     * @for zebkit.layout
     */
    pkg.getMaxPreferredSize = function(target) {
        var maxWidth = 0, maxHeight = 0;
        for(var i = 0;i < target.kids.length; i++){
            var l = target.kids[i];
            if (l.isVisible === true){
                var ps = l.getPreferredSize();
                if (ps.width > maxWidth) maxWidth = ps.width;
                if (ps.height > maxHeight) maxHeight = ps.height;
            }
        }
        return { width:maxWidth, height:maxHeight };
    };


    /**
     * Test if the given parent component is ancestor of the specified component.
     * @param  {zebkit.layout.Layoutable}  p a parent component
     * @param  {zebkit.layout.Layoutable}  c a component
     * @return {Boolean} true if the given parent is ancestor of the specified component
     * @for  zebkit.layout
     * @method  isAncestorOf
     */
    pkg.isAncestorOf = function(p, c){
        for(; c !== null && c !== p; c = c.parent);
        return c !== null;
    };

    /**
     * Layoutable class defines rectangular component that has elementary metrical properties like width,
     * height and location and can be a participant of layout management process. Layoutable component is
     * container that can contains other layoutable component as its children. The children components are
     * ordered by applying a layout manager of its parent component.
     * @class zebkit.layout.Layoutable
     * @constructor
     * @extends {zebkit.layout.Layout}
     * @uses {zebkit.EventProducer}
     * @uses {zebkit.util.PathSearch}
     */
    pkg.Layoutable = Class(pkg.Layout, zebkit.EventProducer, zebkit.util.PathSearch, [
        function() {
            /**
             *  Reference to children components
             *  @attribute kids
             *  @type {Array}
             *  @default empty array
             *  @readOnly
             */
            this.kids = [];

            /**
            * Layout manager that is used to order children layoutable components
            * @attribute layout
            * @default itself
            * @readOnly
            * @type {zebkit.layout.Layout}
            */
            this.layout = this;
        },

        function $prototype() {
            /**
             * x coordinate
             * @attribute x
             * @default 0
             * @readOnly
             * @type {Integer}
             */

            /**
            * y coordinate
            * @attribute y
            * @default 0
            * @readOnly
            * @type {Integer}
            */

            /**
            * Width of rectangular area
            * @attribute width
            * @default 0
            * @readOnly
            * @type {Integer}
            */

            /**
            * Height of rectangular area
            * @attribute height
            * @default 0
            * @readOnly
            * @type {Integer}
            */

            /**
            * Indicate a layoutable component visibility
            * @attribute isVisible
            * @default true
            * @readOnly
            * @type {Boolean}
            */

            /**
            * Indicate a layoutable component validity
            * @attribute isValid
            * @default false
            * @readOnly
            * @type {Boolean}
            */

            /**
            * Reference to a parent layoutable component
            * @attribute parent
            * @default null
            * @readOnly
            * @type {zebkit.layout.Layoutable}
            */

            this.x = this.y = this.height = this.width = this.cachedHeight = 0;

            this.psWidth = this.psHeight = this.cachedWidth = -1;
            this.isLayoutValid = this.isValid = false;

            this.layout = null;

            /**
             * The component layout constraints. The constraints is specific to
             * the parent component layout manager value that customizes the
             * children component layouting on the parent component.
             * @attribute constraints
             * @default null
             * @type {Object}
             */
            this.constraints = this.parent = null;
            this.isVisible = true;

            this.$matchPath = function(node, name) {
                if (name[0] === '~') {
                    return typeof node.clazz !== 'undefined' &&
                           node.clazz !== null &&
                           zebkit.instanceOf(node, zebkit.Class.forName(name.substring(1)));
                } else {
                    return typeof node.clazz.$name !== "undefined" &&
                           node.clazz.$name === name;
                }
            };

            /**
             * Set the given id for the component
             * @param {String} id an ID to be set
             * @method setId
             * @chainable
             */
            this.setId = function(id) {
                this.id = id;
                return this;
            };

            /**
             * Apply the given set of properties to the given component or a number of children
             * its components.
             * @example
             *
             *     var c = new zebkit.layout.Layoutable();
             *     c.properties({
             *         width: [100, 100],
             *         location: [10,10],
             *         layout: new zebkit.layout.BorderLayout()
             *     })
             *
             *     c.add(new zebkit.layout.Layoutable()).add(zebkit.layout.Layoutable())
             *                                          .add(zebkit.layout.Layoutable());
             *     c.properties("//*", {
             *         size: [100, 200]
             *     });
             *
             * @param  {String} [path]  a path to find children components
             * @param  {Object} props a dictionary of properties to be applied
             * @return {zebkit.ui.Layoutable} a component itself
             * @chainable
             * @method properties
             */
            this.properties = function(path, props) {
                if (arguments.length === 1) {
                    return zebkit.properties(this, path);
                }

                this.byPath(path, function(kid) {
                    zebkit.properties(kid, props);
                });
                return this;
            };

            /**
             * Set the given property to the component or children component
             * specified by the given path (optionally).
             * @param  {String} [path]  a path to find children components
             * @param  {String} name a property name
             * @param  {object} value a property value
             * @chainable
             * @method property
             */
            this.property = function() {
                var p = {};
                if (arguments.length > 2) {
                    p[arguments[1]] = arguments[2];
                    return this.properties(arguments[0], p);
                } else {
                    p[arguments[0]] = arguments[1];
                    return this.properties(p);
                }
            };

            /**
             * Validate the component metrics. The method is called as a one step of the component validation
             * procedure. The method causes "recalc" method execution if the method has been implemented and
             * the component is in invalid state. It is supposed the "recalc" method has to be implemented by
             * a component as safe place where the component metrics can be calculated. Component metrics is
             * individual for the given component properties that has influence to the component preferred
             * size value. In many cases the properties calculation has to be minimized what can be done by
             * moving the calculation in "recalc" method
             * @method validateMetric
             * @protected
             */
            this.validateMetric = function(){
                if (this.isValid === false) {
                    if (typeof this.recalc === 'function') this.recalc();
                    this.isValid = true;
                }
            };

            /**
             * By default there is no any implementation of "recalc" method in the layoutable component. In other
             * words the method doesn't exist. Developer should implement the method if the need a proper and
             * efficient place  to calculate component properties that have influence to the component preferred
             * size. The "recalc" method is called only when it is really necessary to compute the component metrics.
             * @method recalc
             * @protected
             */

            /**
             * Invalidate the component layout. Layout invalidation means the component children components have to
             * be placed with the component layout manager. Layout invalidation causes a parent component layout is
             * also invalidated.
             * @method invalidateLayout
             * @protected
             */
            this.invalidateLayout = function(){
                this.isLayoutValid = false;
                if (this.parent !== null) this.parent.invalidateLayout();
            };

            /**
             * Invalidate component layout and metrics.
             * @method invalidate
             */
            this.invalidate = function(){
                this.isValid = this.isLayoutValid = false;
                this.cachedWidth =  -1;
                if (this.parent !== null) {
                    this.parent.invalidate();
                }
            };

            /**
             * Force validation of the component metrics and layout if it is not valid
             * @method validate
             */
            this.validate = function() {
                if (this.isValid === false) {
                    this.validateMetric();
                }

                if (this.width > 0 && this.height > 0 &&
                    this.isLayoutValid === false &&
                    this.isVisible === true)
                {
                    this.layout.doLayout(this);
                    for (var i = 0; i < this.kids.length; i++) {
                        this.kids[i].validate();
                    }
                    this.isLayoutValid = true;
                    if (typeof this.laidout !== 'undefined') this.laidout();
                }
            };

            /**
             * The method can be implemented to be informed every time the component has completed to layout
             * its children components
             * @method laidout
             */

            /**
             * Get preferred size. The preferred size includes  top, left, bottom and right paddings and
             * the size the component wants to have
             * @method getPreferredSize
             * @return {Object} return size object the component wants to
             * have as the following structure:

             {width:{Integer}, height:{Integer}} object

             */
            this.getPreferredSize = function(){
                this.validateMetric();

                if (this.cachedWidth < 0) {
                    var ps = (this.psWidth < 0 || this.psHeight < 0) ? this.layout.calcPreferredSize(this)
                                                                     : { width:0, height:0 };

                    ps.width  = this.psWidth  >= 0 ? this.psWidth
                                                   : ps.width  + this.getLeft() + this.getRight();
                    ps.height = this.psHeight >= 0 ? this.psHeight
                                                   : ps.height + this.getTop()  + this.getBottom();
                    this.cachedWidth  = ps.width;
                    this.cachedHeight = ps.height;
                    return ps;
                }
                return { width:this.cachedWidth,
                         height:this.cachedHeight };
            };

            /**
             * Get top padding.
             * @method getTop
             * @return {Integer} top padding in pixel
             */
            this.getTop = function ()  { return 0; };

            /**
             * Get left padding.
             * @method getLeft
             * @return {Integer} left padding in pixel
             */
            this.getLeft = function ()  { return 0; };

            /**
             * Get bottom padding.
             * @method getBottom
             * @return {Integer} bottom padding in pixel
             */
            this.getBottom = function ()  { return 0; };

            /**
             * Get right padding.
             * @method getRight
             * @return {Integer} right padding in pixel
             */
            this.getRight = function ()  { return 0; };

            /**
             * Set the parent component.
             * @protected
             * @param {zebkit.layout.Layoutable} o a parent component
             * @method setParent
             * @protected
             */
            this.setParent = function(o) {
                if (o !== this.parent){
                    this.parent = o;
                    this.invalidate();
                }
            };

            /**
             * Set the given layout manager that is used to place
             * children component. Layout manager is simple class
             * that defines number of rules concerning the way
             * children components have to be ordered on its parent
             * surface.
             * @method setLayout
             * @param {zebkit.ui.Layout} m a layout manager
             * @chainable
             */
            this.setLayout = function (m){
                if (m === null || typeof m === 'undefined') {
                    throw new Error("Null layout");
                }

                if (this.layout !== m){
                    var pl = this.layout;
                    this.layout = m;
                    this.invalidate();
                }

                return this;
            };

            /**
             * Internal implementation of the component preferred size calculation.
             * @param  {zebkit.layout.Layoutable} target a component for that the metric has to be calculated
             * @return {Object} a preferred size. The method always
             * returns { width:10, height:10 } as the component preferred
             * size
             * @private
             * @method calcPreferredSize
             */
            this.calcPreferredSize = function (target){
                return { width:10, height:10 };
            };

            /**
             * By default layoutbable component itself implements layout manager to order its children
             * components. This method implementation does nothing, so children component will placed
             * according locations and sizes they have set.
             * @method doLayout
             * @private
             */
            this.doLayout = function (target) {};

            /**
             * Detect index of a children component.
             * @param  {zebkit.ui.Layoutbale} c a children component
             * @method indexOf
             * @return {Integer}
             */
            this.indexOf = function (c){
                return this.kids.indexOf(c);
            };

            /**
             * Insert the new children component at the given index with the specified layout constraints.
             * The passed constraints can be set via a layoutable component that is inserted. Just
             * set "constraints" property of in inserted component.
             * @param  {Integer} i an index at that the new children component has to be inserted
             * @param  {Object} constr layout constraints of the new children component
             * @param  {zebkit.layout.Layoutbale} d a new children layoutable component to be added
             * @return {zebkit.layout.Layoutable} an inserted children layoutable component
             * @method insert
             */
            this.insert = function(i, constr, d){
                if (d.constraints !== null) constr = d.constraints;
                else                        d.constraints = constr;

                if (i === this.kids.length) this.kids.push(d);
                else this.kids.splice(i, 0, d);

                d.setParent(this);

                if (typeof this.kidAdded !== 'undefined') {
                    this.kidAdded(i, constr, d);
                }
                this.invalidate();
                return d;
            };

            /**
             * The method can be implemented to be informed every time a new component
             * has been inserted into the component
             * @param  {Integer} i an index at that the new children component has been inserted
             * @param  {Object} constr layout constraints of the new children component
             * @param  {zebkit.layout.Layoutbale} d a new children layoutable component that has
             * been added
             * @method kidAdded
             */

            /**
             * Set the layoutable component location. Location is x, y coordinates relatively to
             * a parent component
             * @param  {Integer} xx x coordinate relatively to the layoutable component parent
             * @param  {Integer} yy y coordinate relatively to the layoutable component parent
             * @method setLocation
             * @chainable
             */
            this.setLocation = function (xx,yy){
                if (xx !== this.x || this.y !== yy){
                    var px = this.x, py = this.y;
                    this.x = xx;
                    this.y = yy;
                    if (typeof this.relocated !== 'undefined') {
                        this.relocated(px, py);
                    }
                }
                return this;
            };

            /**
             * The method can be implemented to be informed every time the component
             * has been moved
             * @param  {Integer} px x previous coordinate of moved children component
             * @param  {Integer} py y previous coordinate of moved children component
             * @method relocated
             */


            /**
             * Set the layoutable component bounds. Bounds defines the component location and size.
             * @param  {Integer} x x coordinate relatively to the layoutable component parent
             * @param  {Integer} y y coordinate relatively to the layoutable component parent
             * @param  {Integer} w a width of the component
             * @param  {Integer} h a height of the component
             * @method setBounds
             * @chainable
             */
            this.setBounds = function (x, y, w, h){
                this.setLocation(x, y);
                this.setSize(w, h);
                return this;
            };

            /**
             * Set the layoutable component size.
             * @param  {Integer} w a width of the component
             * @param  {Integer} h a height of the component
             * @method setSize
             * @chainable
             */
            this.setSize = function (w,h){
                if (w !== this.width || h !== this.height){
                    var pw = this.width, ph = this.height;
                    this.width = w;
                    this.height = h;
                    this.isLayoutValid = false;
                    if (typeof this.resized !== 'undefined') {
                        this.resized(pw, ph);
                    }
                }
                return this;
            };

            /**
             * The method can be implemented to be informed every time the component
             * has been resized
             * @param  {Integer} w a previous width of the component
             * @param  {Integer} h a previous height of the component
             * @method resized
             */

            /**
             * Get a children layoutable component by the given path (optionally)
             * and the specified constraints.
             * @param  {String} [p] a path.
             * @param  {zebkit.layout.Layoutable} c a constraints
             * @return {zebkit.layout.Layoutable} a children component
             * @method byConstraints
             */
            this.byConstraints = function(constr) {
                if (arguments.length === 2) {
                    var res = null;
                    constr = arguments[1];
                    this.byPath(arguments[0], function(kid) {
                        if (kid.constraints === constr) {
                            res = kid;
                            return true;
                        } else {
                            return false;
                        }
                    });
                    return res;
                } else {
                    if (this.kids.length > 0){
                        for(var i = 0; i < this.kids.length; i++ ){
                            var l = this.kids[i];
                            if (constr === l.constraints) {
                                return l;
                            }
                        }
                    }
                    return null;
                }
            };

            /**
             * Set the component constraints without invalidating the component and its parents components
             * layouts and metrics. It is supposed to be used for internal use
             * @protected
             * @param {Object} c a constraints
             * @chainable
             * @method $setConstraints
             */
            this.$setConstraints = function(c) {
                this.constraints = c;
                return this;
            };

            /**
             * Remove the given children component.
             * @param {zebkit.layout.Layoutable} c a children component to be removed
             * @method remove
             * @return {zebkit.layout.Layoutable} a removed children component
             */
            this.remove = function(c) {
                return this.removeAt(this.kids.indexOf(c));
            };

            /**
             * Remove a children component at the specified position.
             * @param {Integer} i a children component index at which it has to be removed
             * @method removeAt
             * @return {zebkit.layout.Layoutable} a removed children component
             */
            this.removeAt = function (i){
                var obj = this.kids[i];
                obj.setParent(null);
                if (obj.constraints !== null) obj.constraints = null;
                this.kids.splice(i, 1);

                if (typeof this.kidRemoved !== 'undefined') {
                    this.kidRemoved(i, obj);
                }

                this.invalidate();
                return obj;
            };

            /**
             * Remove the component from its parent if it has a parent
             * @method removeMe
             */
            this.removeMe = function() {
                var i = -1;
                if (this.parent !== null && (i = this.parent.indexOf(this)) >= 0) {
                    this.parent.removeAt(i);
                }
            };

            /**
             * The method can be implemented to be informed every time a children component
             * has been removed
             * @param {Integer} i a children component index at which it has been removed
             * @param  {zebkit.layout.Layoutable} c a children component that has been removed
             * @method kidRemoved
             */

            /**
             * Set the specified preferred size the component has to have. Component preferred size is
             * important thing that is widely used to layout the component. Usually the preferred
             * size is calculated by a concrete component basing on its metrics. For instance, label
             * component calculates its preferred size basing on text size. But if it is required
             * the component preferred size can be fixed with the desired value.
             * @param  {Integer} w a preferred width. Pass "-1" as the
             * argument value to not set preferred width
             * @param  {Integer} h a preferred height. Pass "-1" as the
             * argument value to not set preferred height
             * @chainable
             * @method setPreferredSize
             */
            this.setPreferredSize = function(w, h) {
                // if (arguments.length === 1) {
                //     h = w;
                // }

                if (w !== this.psWidth || h !== this.psHeight){
                    this.psWidth  = w;
                    this.psHeight = h;
                    this.invalidate();
                }
                return this;
            };

            /**
             * Replace a children component at the specified index
             * with the given new children component
             * @param  {Integer} i an index of a children component to be replaced
             * @param  {zebkit.layout.Layoutable} d a new children
             * @return {zebkit.layout.Layoutable} a previous component that has
             * been re-set with the new one
             * @method setAt
             */
            this.setAt = function(i, d) {
                var constr = this.kids[i].constraints,
                    pd     = this.removeAt(i);
                if (d !== null) this.insert(i, constr, d);
                return pd;
            };

            /**
             * Add the new children component with the given constraints
             * @param  {Object} constr a constraints of a new children component
             * @param  {zebkit.layout.Layoutable} d a new children component to
             * be added
             * @method add
             * @return {zebkit.layout.Layoutable} added layoutable component
             */
            this.add = function(constr,d) {
                return (arguments.length === 1) ? this.insert(this.kids.length, null, constr)
                                                : this.insert(this.kids.length, constr, d);
            };
        }
    ]);

    /**
     *  Layout manager implementation that places layoutbale components on top of
     *  each other stretching its to fill all available parent component space.
     *  Components that want to have be sized according to its preferred sizes
     *  have to have its constraints set to "usePsSize".
     *  @example
     *
     *      var pan = new zebkit.ui.Panel();
     *      pan.setLayout(new zebkit.ui.StackLayout());
     *
     *      // label component will be stretched over all available pan area
     *      pan.add(new zebkit.ui.Label("A"));
     *
     *      // button component will be sized according to its preferred size
     *      // and aligned to have centered vertical and horizontal alignments
     *      pan.add(new zebkit.ui.Button("Ok").setConstraints("usePsSize"));
     *
     *
     *  @class zebkit.layout.StackLayout
     *  @constructor
     */
    pkg.StackLayout = Class(pkg.Layout, [
        function $prototype() {
            this.calcPreferredSize = function (target){
                return pkg.getMaxPreferredSize(target);
            };

            this.doLayout = function(t){
                var top  = t.getTop(),
                    hh   = t.height - t.getBottom() - top,
                    left = t.getLeft(),
                    ww   = t.width - t.getRight() - left;

                for(var i = 0;i < t.kids.length; i++){
                    var l = t.kids[i];
                    if (l.isVisible === true) {
                        var ctr = l.constraints === null ? null : l.constraints;

                        if (ctr === "usePsSize") {
                            var ps = l.getPreferredSize();
                            l.setBounds(left + Math.floor((ww - ps.width )/2),
                                        top  + Math.floor((hh - ps.height)/2),
                                        ps.width, ps.height);
                        } else {
                            l.setBounds(left, top, ww, hh);
                        }
                    }
                }
            };
        }
    ]);

    /**
     *  Layout manager implementation that logically splits component area into five areas: top, bottom,
     *  left, right and center. Top and bottom components are stretched to fill all available space
     *  horizontally and are sized to have preferred height horizontally. Left and right components are
     *  stretched to fill all available space vertically and are sized to have preferred width vertically.
     *  Center component is stretched to occupy all available space taking in account top, left, right
     *  and bottom components.
     *
     *      // create panel with border layout
     *      var p = new zebkit.ui.Panel(new zebkit.layout.BorderLayout());
     *
     *      // add children UI components with top, center and left constraints
     *      p.add("top",    new zebkit.ui.Label("Top"));
     *      p.add("center", new zebkit.ui.Label("Center"));
     *      p.add("left",   new zebkit.ui.Label("Left"));
     *
     *
     * Construct the layout with the given vertical and horizontal gaps.
     * @param  {Integer} [hgap] horizontal gap. The gap is a horizontal distance between laid out components
     * @param  {Integer} [vgap] vertical gap. The gap is a vertical distance between laid out components
     * @constructor
     * @class zebkit.layout.BorderLayout
     * @extends {zebkit.layout.Layout}
     */
    pkg.BorderLayout = Class(pkg.Layout, [
        function(hgap,vgap){
            if (arguments.length > 0) {
                this.hgap = this.vgap = hgap;
                if (arguments.length > 1) {
                    this.vgap = vgap;
                }
            }
        },

        function $prototype() {
            /**
             * Horizontal gap (space between components)
             * @attribute hgap
             * @default 0
             * @readOnly
             * @type {Integer}
             */

            /**
             * Vertical gap (space between components)
             * @attribute vgap
             * @default 0
             * @readOnly
             * @type {Integer}
             */
            this.hgap = this.vgap = 0;

            this.calcPreferredSize = function (target){
                var center = null, left = null,  right = null, top = null, bottom = null, topRight = null, d = null;
                for(var i = 0; i < target.kids.length; i++){
                    var l = target.kids[i];
                    if (l.isVisible === true){
                        switch(l.constraints) {
                           case null:
                           case undefined:
                           case "center"    : center = l; break;
                           case "top"       : top    = l; break;
                           case "bottom"    : bottom = l; break;
                           case "left"      : left   = l; break;
                           case "right"     : right  = l; break;
                           default: throw new Error("Invalid constraints: " + l.constraints);
                        }
                    }
                }

                var dim = { width:0, height:0 };
                if (right !== null) {
                    d = right.getPreferredSize();
                    dim.width  = d.width + this.hgap;
                    dim.height = (d.height > dim.height ? d.height: dim.height );
                }

                if (left !== null) {
                    d = left.getPreferredSize();
                    dim.width += d.width + this.hgap;
                    dim.height = d.height > dim.height ? d.height : dim.height;
                }

                if (center !== null) {
                    d = center.getPreferredSize();
                    dim.width += d.width;
                    dim.height = d.height > dim.height ? d.height : dim.height;
                }

                if (top !== null) {
                    d = top.getPreferredSize();
                    dim.width = d.width > dim.width ? d.width : dim.width;
                    dim.height += d.height + this.vgap;
                }

                if (bottom !== null) {
                    d = bottom.getPreferredSize();
                    dim.width = d.width > dim.width ? d.width : dim.width;
                    dim.height += d.height + this.vgap;
                }
                return dim;
            };

            this.doLayout = function(target){
                var t      = target.getTop(),
                    b      = target.height - target.getBottom(),
                    l      = target.getLeft(),
                    r      = target.width - target.getRight(),
                    center = null,
                    left   = null,
                    top    = null,
                    bottom = null,
                    right  = null;

                for(var i = 0;i < target.kids.length; i++){
                    var kid = target.kids[i];
                    if (kid.isVisible === true) {
                        switch(kid.constraints) {
                            case null:
                            case undefined:
                            case "center":
                                if (center !== null) {
                                    throw new Error("Component with center constraints is already defined");
                                }
                                center = kid;
                                break;
                            case "top" :
                                if (top !== null) {
                                    throw new Error("Component with top constraints is already defined");
                                }
                                kid.setBounds(l, t, r - l, kid.getPreferredSize().height);
                                t += kid.height + this.vgap;
                                top = kid;
                                break;
                            case "bottom":
                                if (bottom !== null) {
                                    throw new Error("Component with bottom constraints is already defined");
                                }
                                var bh = kid.getPreferredSize().height;
                                kid.setBounds(l, b - bh, r - l, bh);
                                b -= bh + this.vgap;
                                bottom = kid;
                                break;
                            case "left":
                                if (left !== null) {
                                    throw new Error("Component with left constraints is already defined");
                                }
                                left = kid;
                                break;
                            case "right":
                                if (right !== null) {
                                    throw new Error("Component with right constraints is already defined");
                                }
                                right = kid;
                                break;
                            default: throw new Error("Invalid constraints: '" + kid.constraints + "'");
                        }
                    }
                }

                if (right !== null) {
                    var rw = right.getPreferredSize().width;
                    right.setBounds(r - rw, t, rw, b - t);
                    r -= rw + this.hgap;
                }

                if (left !== null) {
                    left.setBounds(l, t, left.getPreferredSize().width, b - t);
                    l += left.width + this.hgap;
                }

                if (center !== null) {
                    center.setBounds(l, t, r - l, b - t);
                }
            };
        }
    ]);

    /**
     * Rester layout manager can be used to use absolute position of layoutable components. That means
     * all components will be laid out according coordinates and size they have. Raster layout manager
     * provides extra possibilities to control children components placing. It is possible to align
     * components by specifying layout constraints, size component to its preferred size and so on.
     * Constraints that can be set for components are the following
     *    - "top"
     *    - "topRight"
     *    - "topLeft"
     *    - "bottom"
     *    - "bottomLeft"
     *    - "bottomRight"
     *    - "right"
     *    - "center"
     *    - "left"
     * @example
     *     // instantiate component to be ordered
     *     var topLeftLab = zebkit.ui.Label("topLeft");
     *     var leftLab    = zebkit.ui.Label("left");
     *     var centerLab  = zebkit.ui.Label("center");
     *
     *     // instantiate a container with raster layoyt manager set
     *     // the manager is adjusted to size added child component to
     *     // its preferred sizes
     *     var container = new zebkit.ui.Panel(new zebkit.layout.RasterLayout(true));
     *
     *     // add child components with appropriate constraints
     *     container.add("topLeft", topLeftLab);
     *     container.add("left", leftLab);
     *     container.add("center", centerLab);
     *
     * @param {Boolean} [usePsSize] flag to add extra rule to set components size to its preferred
     * sizes.
     * @class  zebkit.layout.RasterLayout
     * @constructor
     * @extends {zebkit.layout.Layout}
     */
    pkg.RasterLayout = Class(pkg.Layout, [
        function(usePsSize) {
            if (arguments.length > 0) {
                this.usePsSize = usePsSize;
            }
        },

        function $prototype() {
            /**
             * Define if managed with layout manager components have to be sized according to its
             * preferred size
             * @attribute usePsSize
             * @type {Boolean}
             * @default false
             */
            this.usePsSize = false;

            this.calcPreferredSize = function(c){
                var m = { width:0, height:0 };

                for(var i = 0;i < c.kids.length; i++ ){
                    var kid = c.kids[i];
                    if (kid.isVisible === true) {
                        var ps = this.usePsSize ? kid.getPreferredSize()
                                                : { width:kid.width, height:kid.height },
                            px = kid.x + ps.width,
                            py = kid.y + ps.height;

                        if (px > m.width)  m.width  = px;
                        if (py > m.height) m.height = py;
                    }
                }
                return m;
            };

            this.doLayout = function(c) {
                var r = c.getRight(),
                    b = c.getBottom(),
                    t = c.getTop(),
                    l = c.getLeft();

                for(var i = 0;i < c.kids.length; i++){
                    var kid = c.kids[i], ww = 0, hh = 0;

                    if (kid.isVisible === true){
                        if (this.usePsSize) {
                            var ps = kid.toPreferredSize();
                            ww = ps.width;
                            hh = ps.height;
                        } else {
                            ww = kid.width;
                            hh = kid.height;
                        }

                        var ctr = kid.constraints === null ? null : kid.constraints;
                        if (ctr !== null) {
                            var x = kid.x, y = kid.y, size = null;

                            if (ctr === "top" || ctr === "topRight" || ctr === "topLeft") {
                                y = t;
                            } else if (ctr === "bottom" || ctr === "bottomLeft" || ctr === "bottomRight") {
                                y = c.height - hh - b;
                            } else if (ctr === "center" || ctr === "left" || ctr === "right") {
                                y = Math.floor((c.height - hh) / 2);
                            }

                            if (ctr === "left" || ctr === "topLeft" || ctr === "bottomLeft") {
                                x = l;
                            } else if (ctr === "right" || ctr === "topRight" || ctr === "bottomRight") {
                                x = c.width - ww - r;
                            } else if (ctr === "center" || ctr === "top" || ctr === "bottom") {
                                x = Math.floor((c.width  - ww) / 2);
                            }

                            kid.setLocation(x, y);
                        }
                    }
                }
            };
        }
    ]);

    /**
     * Flow layout manager group and places components ordered with different vertical and horizontal
     * alignments
     *
     *     // create panel and set flow layout for it
     *     // components added to the panel will be placed
     *     // horizontally aligned at the center of the panel
     *     var p = new zebkit.ui.Panel();
     *     p.setLayout(new zebkit.layout.FlowLayout("center", "center"));
     *
     *     // add three buttons into the panel with flow layout
     *     p.add(new zebkit.ui.Button("Button 1"));
     *     p.add(new zebkit.ui.Button("Button 2"));
     *     p.add(new zebkit.ui.Button("Button 3"));
     *
     * @param {String} [ax] ("left" by default) horizontal alignment:

         "left"
         "center"
         "right"

     * @param {String} [ay] ("top" by default) vertical alignment:

         "top"
         "center"
         "bottom"

     * @param {String} [dir] ("horizontal" by default) a direction the component has to be placed
     * in the layout

         "vertical"
         "horizontal"

     * @param {Integer} [gap] a space in pixels between laid out components
     * @class  zebkit.layout.FlowLayout
     * @constructor
     * @extends {zebkit.layout.Layout}
     */
    pkg.FlowLayout = Class(pkg.Layout, [
        function (ax, ay, dir, g){
            if (arguments.length === 1) {
                this.gap = ax;
            } else {
                if (arguments.length > 1) {
                    this.ax = ax;
                    this.ay = ay;
                }

                if (arguments.length > 2)  {
                    this.direction = zebkit.util.$validateValue(dir, "horizontal", "vertical");
                }

                if (arguments.length > 3) this.gap = g;
            }
        },

        function $prototype() {
            /**
             * Gap between laid out components
             * @attribute gap
             * @readOnly
             * @type {Integer}
             * @default 0
             */
            this.gap = 0;

            /**
             * Horizontal laid out components alignment
             * @attribute ax
             * @readOnly
             * @type {String}
             * @default "left"
             */
            this.ax = "left";

            /**
             * Vertical laid out components alignment
             * @attribute ay
             * @readOnly
             * @type {String}
             * @default "center"
             */
            this.ay = "center";

            /**
             * Laid out components direction
             * @attribute direction
             * @readOnly
             * @type {String}
             * @default "horizontal"
             */
            this.direction = "horizontal";

            /**
             * Define if the last added component has to be stretched to occupy
             * the rest of horizontal or vertical space of a parent component.
             * @attribute stretchLast
             * @type {Boolean}
             * @default false
             */
            this.stretchLast = false;

            this.calcPreferredSize = function (c){
                var m = { width:0, height:0 }, cc = 0;
                for(var i = 0;i < c.kids.length; i++){
                    var a = c.kids[i];
                    if (a.isVisible === true){
                        var d = a.getPreferredSize();
                        if (this.direction === "horizontal"){
                            m.width += d.width;
                            m.height = d.height > m.height ? d.height : m.height;
                        }
                        else {
                            m.width = d.width > m.width ? d.width : m.width;
                            m.height += d.height;
                        }
                        cc++;
                    }
                }

                var add = this.gap * (cc > 0 ? cc - 1 : 0);
                if (this.direction === "horizontal") m.width += add;
                else m.height += add;
                return m;
            };

            this.doLayout = function(c){
                var psSize  = this.calcPreferredSize(c),
                    t       = c.getTop(),
                    l       = c.getLeft(),
                    lastOne = null,
                    ew      = c.width  - l - c.getRight(),
                    eh      = c.height - t - c.getBottom(),
                    px      = ((this.ax === "right") ? ew - psSize.width
                                                     : ((this.ax === "center") ? Math.floor((ew - psSize.width) / 2) : 0)) + l,
                    py      = ((this.ay === "bottom") ? eh - psSize.height
                                                      : ((this.ay === "center") ? Math.floor((eh - psSize.height) / 2): 0)) + t;

                for(var i = 0;i < c.kids.length; i++){
                    var a = c.kids[i];
                    if (a.isVisible === true) {

                        var d = a.getPreferredSize(),
                            ctr = a.constraints === null ? null : a.constraints;

                        if (this.direction === "horizontal") {
                            ctr = ctr || this.ay;

                            if (ctr === "stretch") {
                                d.height = c.height - t - c.getBottom();
                            }

                            a.setLocation(px, ctr === "stretch" ? t :
                                              (ctr === "top"    ? py :
                                              (ctr === "bottom" ? Math.floor(psSize.height - d.height) + py :
                                                                  Math.floor((psSize.height - d.height) / 2) + py)));
                            px += (d.width + this.gap);
                        }
                        else {
                            ctr = ctr || this.ax;

                            if (ctr === "stretch") {
                                d.width = c.width - l - c.getRight();
                            }

                            a.setLocation(ctr === "stretch"  ? l  :
                                          (ctr === "left"    ? px :
                                          (ctr === "right"   ? px + Math.floor(psSize.width - d.width) :
                                                               px + Math.floor((psSize.width - d.width) / 2))), py);

                            py += d.height + this.gap;
                        }

                        a.setSize(d.width, d.height);
                        lastOne = a;
                    }
                }

                if (lastOne !== null && this.stretchLast === true){
                    if (this.direction === "horizontal") {
                        lastOne.setSize(c.width - lastOne.x - c.getRight(), lastOne.height);
                    }
                    else {
                        lastOne.setSize(lastOne.width, c.height - lastOne.y - c.getBottom());
                    }
                }
            };
        }
    ]);

    /**
     * List layout places components vertically one by one
     *
     *     // create panel and set list layout for it
     *     var p = new zebkit.ui.Panel();
     *     p.setLayout(new zebkit.layout.ListLayout());
     *
     *     // add three buttons into the panel with list layout
     *     p.add(new zebkit.ui.Button("Item 1"));
     *     p.add(new zebkit.ui.Button("Item 2"));
     *     p.add(new zebkit.ui.Button("Item 3"));
     *
     * @param {String} [ax] horizontal list item alignment:

         "left"
         "right"
         "center"
         "stretch"

     * @param {Integer} [gap] a space in pixels between laid out components
     * @class  zebkit.layout.ListLayout
     * @constructor
     * @extends {zebkit.layout.Layout}
     */
    pkg.ListLayout = Class(pkg.Layout,[
        function (ax, gap) {
            if (arguments.length === 1) {
                this.gap = ax;
            } else if (arguments.length > 1) {
                this.ax  = zebkit.util.$validateValue(ax, "stretch", "left", "right", "center");
                this.gap = gap;
            }
        },

        function $prototype() {
            /**
             * Horizontal list items alignment
             * @attribute ax
             * @type {String}
             * @readOnly
             */
            this.ax = "stretch";

            /**
             * Pixel gap between list items
             * @attribute gap
             * @type {Integer}
             * @readOnly
             */
            this.gap = 0;

            this.calcPreferredSize = function (lw){
                var w = 0, h = 0, c = 0;
                for(var i = 0; i < lw.kids.length; i++){
                    var kid = lw.kids[i];
                    if (kid.isVisible === true){
                        var d = kid.getPreferredSize();
                        h += (d.height + (c > 0 ? this.gap : 0));
                        c++;
                        if (w < d.width) w = d.width;
                    }
                }
                return { width:w, height:h };
            };

            this.doLayout = function (lw){
                var x   = lw.getLeft(),
                    y   = lw.getTop(),
                    psw = lw.width - x - lw.getRight();

                for(var i = 0;i < lw.kids.length; i++){
                    var cc = lw.kids[i];

                    if (cc.isVisible === true){
                        var d      = cc.getPreferredSize(),
                            constr = cc.constraints === null ? this.ax
                                                            : cc.constraints;

                        cc.setSize    ((constr === "stretch") ? psw
                                                                : d.width, d.height);
                        cc.setLocation((constr === "stretch") ? x
                                                                : x + ((constr === "right") ? psw - cc.width
                                                                                            : ((constr === "center") ? Math.floor((psw - cc.width) / 2)
                                                                                                                     : 0)), y);
                        y += (d.height + this.gap);
                    }
                }
            };
        }
    ]);

    /**
     * Percent layout places components vertically or horizontally and sizes its according to its
     * percentage constraints.
     *
     *     // create panel and set percent layout for it
     *     var p = new zebkit.ui.Panel();
     *     p.setLayout(new zebkit.layout.PercentLayout());
     *
     *     // add three buttons to the panel that are laid out horizontally with
     *     // percent layout according to its constraints: 20, 30 and 50 percents
     *     p.add(20, new zebkit.ui.Button("20%"));
     *     p.add(30, new zebkit.ui.Button("30%"));
     *     p.add(50, new zebkit.ui.Button("50%"));
     *
     * @param {String} [dir] a direction of placing components. The
     * value can be "horizontal" or "vertical"
     * @param {Integer} [gap] a space in pixels between laid out components
     * @param {Boolean} [stretch] true if the component should be stretched
     * vertically or horizontally
     * @class  zebkit.layout.PercentLayout
     * @constructor
     * @extends {zebkit.layout.Layout}
     */
    pkg.PercentLayout = Class(pkg.Layout, [
        function(dir, gap, stretch) {
            if (arguments.length > 0) {
                this.direction = zebkit.util.$validateValue(dir, "horizontal", "vertical");
                if (arguments.length > 1) this.gap = gap;
                if (arguments.length > 2) this.stretch = stretch;
            }
        },

        function $prototype() {
             /**
              * Direction the components have to be placed (vertically or horizontally)
              * @attribute direction
              * @readOnly
              * @type {String}
              * @default "horizontal"
              */
            this.direction = "horizontal";

            /**
             * Pixel gap between components
             * @attribute gap
             * @readOnly
             * @type {Integer}
             * @default 2
             */
            this.gap = 2;

            /**
             * Boolean flag that say if the laid out components have
             * to be stretched vertically (if direction is set to "vertical")
             * or horizontally (if direction is set to "horizontal")
             * @attribute stretch
             * @readOnly
             * @type {Boolean}
             * @default true
             */
            this.stretch = true;

            this.doLayout = function(target){
                var right  = target.getRight(),
                    top    = target.getTop(),
                    bottom = target.getBottom(),
                    left   = target.getLeft(),
                    size   = target.kids.length,
                    rs     = -this.gap * (size === 0 ? 0 : size - 1),
                    loc    = 0,
                    ns     = 0;

                if (this.direction === "horizontal"){
                    rs += target.width - left - right;
                    loc = left;
                }
                else{
                    rs += target.height - top - bottom;
                    loc = top;
                }

                for(var i = 0; i < size; i ++ ){
                    var l = target.kids[i], c = l.constraints, useps = (c === "usePsSize");
                    if (this.direction === "horizontal"){
                        ns = ((size - 1) === i) ? target.width - right - loc
                                                : (useps ? l.getPreferredSize().width
                                                         : ~~((rs * c) / 100));
                        var yy = top, hh = target.height - top - bottom;
                        if (this.stretch === false) {
                            var ph = hh;
                            hh = l.getPreferredSize().height;
                            yy = top + Math.floor((ph - hh) / 2);
                        }

                        l.setBounds(loc, yy, ns, hh);
                    }
                    else {
                        ns = ((size - 1) === i) ? target.height - bottom - loc
                                                : (useps ? l.getPreferredSize().height
                                                         : Math.floor((rs * c) / 100));
                        var xx = left, ww = target.width - left - right;
                        if (this.stretch === false) {
                            var pw = ww;
                            ww = l.getPreferredSize().width;
                            xx = left + Math.floor((pw - ww) / 2);
                        }

                        l.setBounds(xx, loc, ww, ns);
                    }
                    loc += (ns + this.gap);
                }
            };

            this.calcPreferredSize = function (target){
                var max  = 0,
                    size = target.kids.length,
                    as   = this.gap * (size === 0 ? 0 : size - 1);

                for(var i = 0; i < size; i++){
                    var d = target.kids[i].getPreferredSize();
                    if (this.direction === "horizontal"){
                        if (d.height > max) max = d.height;
                        as += d.width;
                    }
                    else {
                        if (d.width > max) max = d.width;
                        as += d.height;
                    }
                }
                return (this.direction === "horizontal") ? { width:as, height:max }
                                                         : { width:max, height:as };
            };
        }
    ]);

    /**
     * Grid layout manager constraints. Constraints says how a  component has to be placed in
     * grid layout virtual cell. The constraints specifies vertical and horizontal alignments,
     * a virtual cell paddings, etc.
     * @param {Integer} [ax] a horizontal alignment
     * @param {Integer} [ay] a vertical alignment
     * @param {Integer} [p]  a cell padding
     * @constructor
     * @class zebkit.layout.Constraints
     */
    pkg.Constraints = Class([
        function(ax, ay, p) {
            if (arguments.length > 0) {
                this.ax = ax;
                if (arguments.length > 1) this.ay = ay;
                if (arguments.length > 2) this.setPadding(p);

                zebkit.util.$validateValue(this.ax, "stretch", "left", "center", "right");
                zebkit.util.$validateValue(this.ay, "stretch", "top", "center", "bottom");
            }
        },

        function $prototype() {
            /**
             * Top cell padding
             * @attribute top
             * @type {Integer}
             * @default 0
             */

            /**
             * Left cell padding
             * @attribute left
             * @type {Integer}
             * @default 0
             */

            /**
             * Right cell padding
             * @attribute right
             * @type {Integer}
             * @default 0
             */

            /**
             * Bottom cell padding
             * @attribute bottom
             * @type {Integer}
             * @default 0
             */

            /**
             * Horizontal alignment
             * @attribute ax
             * @type {String}
             * @default "stretch"
             */

            /**
             * Vertical alignment
             * @attribute ay
             * @type {String}
             * @default "stretch"
             */

            this.top = this.bottom = this.left = this.right = 0;
            this.ay = this.ax = "stretch";
            this.rowSpan = this.colSpan = 1;

            /**
             * Set all four paddings (top, left, bottom, right) to the given value
             * @param  {Integer} p a padding
             * @chainable
             * @method setPadding
             */

            /**
             * Set top, left, bottom, right paddings
             * @param  {Integer} t a top padding
             * @param  {Integer} l a left padding
             * @param  {Integer} b a bottom padding
             * @param  {Integer} r a right padding
             * @chainable
             * @method setPadding
             */
            this.setPadding = function(t,l,b,r) {
                if (arguments.length === 1) {
                    this.top = this.bottom = this.left = this.right = t;
                } else {
                    this.top    = t;
                    this.bottom = b;
                    this.left   = l;
                    this.right  = r;
                }
                return this;
            };
        }
    ]);

    /**
     * Grid layout manager. can be used to split a component area to number of virtual cells where
     * children components can be placed. The way how the children components have to be laid out
     * in the cells can be customized by using "zebkit.layout.Constraints" class:
     *
     *     // create constraints
     *     var ctr = new zebkit.layout.Constraints();
     *
     *     // specify cell top, left, right, bottom paddings
     *     ctr.setPadding(8);
     *     // say the component has to be left aligned in a
     *     // virtual cell of grid layout
     *     ctr.ax = "left";
     *
     *     // create panel and set grid layout manager with two
     *     // virtual rows and columns
     *     var p = new zebkit.ui.Panel();
     *     p.setLayout(new zebkit.layout.GridLayout(2, 2));
     *
     *     // add children component
     *     p.add(ctr, new zebkit.ui.Label("Cell 1, 1"));
     *     p.add(ctr, new zebkit.ui.Label("Cell 1, 2"));
     *     p.add(ctr, new zebkit.ui.Label("Cell 2, 1"));
     *     p.add(ctr, new zebkit.ui.Label("Cell 2, 2"));
     *
     * @param {Integer} rows a number of virtual rows to layout children components
     * @param {Integer} cols a number of virtual columns to layout children components
     * @param {Boolean} [stretchRows] true if virtual cell height has to be stretched to occupy the
     * whole vertical container component space
     * @param {Boolean} [stretchCols] true if virtual cell width has to be stretched to occupy the
     * whole horizontal container component space
     * @constructor
     * @class  zebkit.layout.GridLayout
     * @extends {zebkit.layout.Layout}
     */
    pkg.GridLayout = Class(pkg.Layout, [
        function(r, c, stretchRows, stretchCols) {
            /**
             * Number of virtual rows to place children components
             * @attribute rows
             * @readOnly
             * @type {Integer}
             */
            this.rows = r;

            /**
             * Number of virtual columns to place children components
             * @attribute cols
             * @readOnly
             * @type {Integer}
             */
            this.cols = c;

            /**
             * Computed columns sizes.
             * @attribute colSizes
             * @type {Array}
             * @private
             */
            this.colSizes = Array(c + 1);

            /**
             * Computed rows sizes.
             * @attribute rowSizes
             * @type {Array}
             * @private
             */
            this.rowSizes = Array(r + 1);

            /**
             * Default constraints that is applied for children components
             * that doesn't define own constraints
             * @type {zebkit.layout.Constraints}
             * @attribute constraints
             */
            this.constraints = new pkg.Constraints();

            if (arguments.length > 2) {
                this.stretchRows = (stretchRows === true);
            }

            if (arguments.length > 3) {
                this.stretchCols = (stretchCols === true);
            }
        },

        function $prototype() {
            /**
             * Attributes that indicates if component has to be stretched
             * horizontally to occupy the whole space of a virtual cell.
             * @attribute stretchCols
             * @readOnly
             * @type {Boolean}
             * @default false
             */
            this.stretchCols = false;

            /**
             * Attributes that indicates if component has to be stretched
             * vertically to occupy the whole space of a virtual cell.
             * @attribute stretchRows
             * @readOnly
             * @type {Boolean}
             * @default false
             */
            this.stretchRows = false;

            /**
             * Set default grid layout cell paddings (top, left, bottom, right) to the given value
             * @param  {Integer} p a padding
             * @chainable
             * @method setPadding
             */

            /**
             * Set default grid layout cell paddings: top, left, bottom, right
             * @param  {Integer} t a top padding
             * @param  {Integer} l a left padding
             * @param  {Integer} b a bottom padding
             * @param  {Integer} r a right padding
             * @chainable
             * @method setPadding
             */
            this.setPadding = function() {
                this.constraints.setPadding.apply(this.constraints, arguments);
                return this;
            };

            /**
             * Set default constraints.
             * @method setDefaultConstraints
             * @chainable
             * @param {zebkit.layout.Constraints} c a constraints
             */
            this.setDefaultConstraints = function(c) {
                this.constraints = c;
                return this;
            };

            /**
             * Calculate columns metrics
             * @param  {zebkit.layout.Layoutable} c the target container
             * @return {Array} a columns widths
             * @method calcCols
             * @protected
             */
            this.calcCols = function(c){
                this.colSizes[this.cols] = 0;
                for(var i = 0;i < this.cols; i++) {
                    this.colSizes[i] = this.calcCol(i, c);
                    this.colSizes[this.cols] += this.colSizes[i];
                }
                return this.colSizes;
            };

            /**
             * Calculate rows metrics
             * @param  {zebkit.layout.Layoutable} c the target container
             * @return {Array} a rows heights
             * @method calcRows
             * @protected
             */
            this.calcRows = function(c){
                this.rowSizes[this.rows] = 0;
                for(var i = 0;i < this.rows; i++) {
                    this.rowSizes[i] = this.calcRow(i, c);
                    this.rowSizes[this.rows] += this.rowSizes[i];
                }
                return this.rowSizes;
            };

            /**
             * Calculate the given row height
             * @param  {Integer} row a row
             * @param  {zebkit.layout.Layoutable} c the target container
             * @return {Integer} a size of the row
             * @method calcRow
             * @protected
             */
            this.calcRow = function(row, c){
                var max = 0, s = row * this.cols;
                for (var i = s; i < c.kids.length && i < s + this.cols; i++) {
                    var a = c.kids[i];
                    if (a.isVisible === true) {
                        var arg = a.constraints || this.constraints,
                            d   = a.getPreferredSize().height;

                        d += (arg.top + arg.bottom);
                        if (d > max) max = d;
                    }
                }
                return max;
            };

            /**
             * Calculate the given column width
             * @param  {Integer} col a column
             * @param  {zebkit.layout.Layoutable} c the target container
             * @return {Integer} a size of the column
             * @method calcCol
             * @protected
             */
            this.calcCol = function(col, c){
                var max = 0;

                for(var i = col; i < c.kids.length; i += this.cols) {
                    var a = c.kids[i];
                    if (a.isVisible === true) {
                        var arg = a.constraints || this.constraints,
                            d   = a.getPreferredSize().width + arg.left + arg.right;

                        if (d > max) max = d;
                    }
                }
                return max;
            };

            this.calcPreferredSize = function(c){
                return { width : this.calcCols(c)[this.cols],
                         height: this.calcRows(c)[this.rows] };
            };

            this.doLayout = function(c){
                var rows     = this.rows,
                    cols     = this.cols,
                    colSizes = this.calcCols(c),
                    rowSizes = this.calcRows(c),
                    top      = c.getTop(),
                    left     = c.getLeft(),
                    cc       = 0,
                    i        = 0;

                if (this.stretchCols) {
                    var dw = c.width - left - c.getRight() - colSizes[cols];
                    for(i = 0; i < cols; i ++ ) {
                        colSizes[i] = colSizes[i] + (colSizes[i] !== 0 ? Math.floor((dw * colSizes[i]) / colSizes[cols]) : 0);
                    }
                }

                if (this.stretchRows) {
                    var dh = c.height - top - c.getBottom() - rowSizes[rows];
                    for(i = 0; i < rows; i++) {
                        rowSizes[i] = rowSizes[i] + (rowSizes[i] !== 0 ? Math.floor((dh * rowSizes[i]) / rowSizes[rows]) : 0);
                    }
                }

                for (i = 0; i < rows && cc < c.kids.length; i++) {
                    var xx = left;
                    for(var j = 0;j < cols && cc < c.kids.length; j++, cc++){
                        var l = c.kids[cc];
                        if (l.isVisible === true){
                            var arg   = l.constraints || this.constraints,
                                d     = l.getPreferredSize(),
                                cellW = colSizes[j],
                                cellH = rowSizes[i];

                            cellW -= (arg.left + arg.right);
                            cellH -= (arg.top  + arg.bottom);

                            if ("stretch" === arg.ax) d.width  = cellW;
                            if ("stretch" === arg.ay) d.height = cellH;

                            l.setSize(d.width, d.height);
                            l.setLocation(
                                xx  + arg.left + ("stretch" === arg.ax ? 0
                                                                       : ((arg.ax === "right") ? cellW - d.width
                                                                                               : ((arg.ax === "center") ? Math.floor((cellW - d.width) / 2)
                                                                                                                        : 0))),
                                top + arg.top  + ("stretch" === arg.ay ? 0
                                                                       : ((arg.ay === "bottom" ) ? cellH - d.height
                                                                                                 : ((arg.ay === "center") ? Math.floor((cellH - d.height) / 2)
                                                                                                                          : 0)))
                            );

                            xx += colSizes[j];
                        }
                    }
                    top += rowSizes[i];
                }
            };
        }
    ]);
});
zebkit.package("ui", function(pkg, Class) {
    'use strict';
    /**
     *  UI manager class. The class is widely used as base for building various UI managers
     *  like focus, event managers etc. Manager is automatically registered as global events listener
     *  for events it implements handlers
     *  @class zebkit.ui.Manager
     *  @constructor
     */
    pkg.Manager = Class([
        function() {
            if (pkg.events !== null && typeof pkg.events !== 'undefined') {
                pkg.events.on(this);
            }
        }
    ]);

    /**
     * Component event class. Component event is fired when:
     *
     *   - the component is re-located ("compMoved" event)
     *   - the component is re-sized ("compResized" event)
     *   - the component visibility is updated ("compShown" event)
     *   - the component is enabled ("compEnabled" event)
     *   - a component has been inserted into the given component ("compAdded" event)
     *   - a component has been removed from the given component ("compRemoved" event)
     *
     * Appropriate event type is set in the event id property.
     * @constructor
     * @class   zebkit.ui.CompEvent
     * @extends zebkit.util.Event
     */
    pkg.CompEvent = Class(zebkit.util.Event, [
        function $prototype() {
            /**
             * A kid component that has been added or removed (depending on event type).
             * @attribute kid
             * @readOnly
             * @default null
             * @type {zebkit.ui.Panel}
             */
            this.kid = this.constraints = null;

            /**
             * A constraints with that a kid component has been added or removed (depending on event type).
             * @attribute constraints
             * @readOnly
             * @default null
             * @type {Object}
             */

            /**
             * A previous x location the component has had.
             * @readOnly
             * @attribute prevX
             * @type {Integer}
             * @default -1
             */

            /**
             * A previous y location the component has had.
             * @readOnly
             * @attribute prevY
             * @type {Integer}
             * @default -1
             */

            /**
             * An index at which a component has been added or removed.
             * @readOnly
             * @attribute index
             * @type {Integer}
             * @default -1
             */

            /**
             * A previous width the component has had.
             * @readOnly
             * @attribute prevWidth
             * @type {Integer}
             * @default -1
             */

            /**
             * A previous height the component has had.
             * @readOnly
             * @attribute height
             * @type {Integer}
             * @default -1
             */
            this.prevX = this.prevY = this.index = -1;
            this.prevWidth = this.prevHeight = -1;
        }
    ]);

    /**
     * Input key event class.
     * @class  zebkit.ui.KeyEvent
     * @extends zebkit.util.Event
     * @constructor
     */
    pkg.KeyEvent = Class(zebkit.util.Event, [
        function $prototype() {
            /**
             * A code of a pressed key
             * @attribute code
             * @readOnly
             * @type {Strung}
             */
            this.code = null;

            /**
             * A pressed key
             * @attribute key
             * @readOnly
             * @type {String}
             */
            this.key = null;

            /**
             * Input device type. Can be for instance "keyboard", vkeyboard" (virtual keyboard)
             * @attribute device
             * @default "keyboard"
             * @type {String}
             */
            this.device = "keyboard";

            /**
             * Boolean that shows state of ALT key.
             * @attribute altKey
             * @type {Boolean}
             * @readOnly
             */
            this.altKey = false;

            /**
             * Boolean that shows state of SHIFT key.
             * @attribute shiftKey
             * @type {Boolean}
             * @readOnly
             */
            this.shiftKey = false;

            /**
             * Boolean that shows state of CTRL key.
             * @attribute ctrlKey
             * @type {Boolean}
             * @readOnly
             */
            this.ctrlKey = false;

            /**
             * Boolean that shows state of META key.
             * @attribute metaKey
             * @type {Boolean}
             * @readOnly
             */
            this.metaKey = false;

            /**
             * Repeat counter
             * @attribute repeat
             * @type {Number}
             */
            this.repeat = 0;

            /**
             * Time stamp
             * @attribute  timeStamp
             * @type {Number}
             */
            this.timeStamp = 0;

            /**
             * Get the given modifier key state. The following modifier key codes are supported:
             * "Meta", "Control", "Shift", "Alt".
             * @param  {String} m a modifier key code
             * @return {Boolean} true if the modifier key state is pressed.
             * @method getModifierState
             */
            this.getModifierState = function(m) {
                if (m === "Meta") {
                    return this.metaKey;
                }

                if (m === "Control") {
                    return this.ctrlKey;
                }

                if (m === "Shift") {
                    return this.shiftKey;
                }

                if (m === "Alt") {
                    return this.altKey;
                }

                throw new Error("Unknown modifier key '" + m + "'");
            };
        }
    ]);

    /**
     * Mouse and touch screen input event class. The input event is triggered by a mouse or
     * touch screen.
     * @class  zebkit.ui.PointerEvent
     * @constructor
     */
    pkg.PointerEvent = Class(zebkit.util.Event, [
        function $prototype() {
            /**
             * Pointer type. Can be "mouse", "touch", "pen"
             * @attribute  poiterType
             * @type {String}
             */
            this.pointerType = "mouse";

            /**
             * Touch counter
             * @attribute touchCounter
             * @type {Integer}
             * @default 0
             */
            this.touchCounter = 0;

            /**
             * Page x
             * @attribute pageX
             * @type {Integer}
             * @default -1
             */
            this.pageX = -1;

            /**
             * Page y
             * @attribute pageY
             * @type {Integer}
             * @default -1
             */
            this.pageY = -1;

            /**
             * Target DOM element
             * @attribute target
             * @type {DOMElement}
             * @default null
             */
            this.target = null;

            /**
             * Pointer identifier.
             * @attribute identifier
             * @type {Object}
             * @default null
             */
            this.identifier = null;

            this.shiftKey = this.altKey = this.metaKey = this.ctrlKey = false;

            this.pressure = 0.5;

            /**
             * Absolute mouse pointer x coordinate
             * @attribute absX
             * @readOnly
             * @type {Integer}
             */
            this.absX = 0;

            /**
             * Absolute mouse pointer y coordinate
             * @attribute absY
             * @readOnly
             * @type {Integer}
             */
             this.absY = 0;

            /**
             * Mouse pointer x coordinate (relatively to source UI component)
             * @attribute x
             * @readOnly
             * @type {Integer}
             */
            this.x = 0;

            /**
             * Mouse pointer y coordinate (relatively to source UI component)
             * @attribute y
             * @readOnly
             * @type {Integer}
             */
            this.y = 0;

            /**
             * Recompute the event relative location for the new source component and it
             * absolute location
             * @private
             * @param  {zebkit.ui.Panel} source  a source component that triggers the event
             * @param  {Integer} ax an absolute (relatively to a canvas where the source
             * component is hosted) x mouse cursor coordinate
             * @param  {Integer} ay an absolute (relatively to a canvas where the source
             * component is hosted) y mouse cursor coordinate
             * @method  updateCoordinates
             */
            this.update = function(source, ax, ay){
                // this can speed up calculation significantly check if source zebkit component
                // has not been changed, his location and parent component also has not been
                // changed than we can skip calculation of absolute location by traversing
                // parent hierarchy
                if (this.source        === source        &&
                    this.source.parent === source.parent &&
                    source.x           === this.$px      &&
                    source.y           === this.$py         )
                {
                    this.x += (ax - this.absX);
                    this.y += (ay - this.absY);
                    this.absX = ax;
                    this.absY = ay;
                    this.source = source;
                } else {
                    this.source = source;
                    this.absX = ax;
                    this.absY = ay;

                    // convert absolute location to relative location
                    while (source.parent !== null) {
                        ax -= source.x;
                        ay -= source.y;
                        source = source.parent;
                    }
                    this.x = ax;
                    this.y = ay;
                }

                this.$px = source.x;
                this.$py = source.y;
                return this;
            };

            this.isAction = function() {
                // TODO: actually this is abstract method
                throw new Error("Not implemented");
            };

            this.getTouches = function() {
                // TODO: actually this is abstract method
                throw new Error("Not implemented");
            };
        }
    ]);

    /**
     * Event manager class. One of the key zebkit manager that is responsible for distributing various
     * events in zebkit UI. The manager provides possibility to catch and handle UI events globally. Below
     * is list event types that can be caught with the event manager:
     *
     *   - Key events:
     *     - "keyTyped"
     *     - "keyReleased"
     *     - "keyPressed"
     *
     *   - Pointer events:
     *     - "pointerDragged"
     *     - "pointerDragStarted"
     *     - "pointerDragEnded"
     *     - "pointerMoved"
     *     - "pointerClicked"
     *     - "pointerDoubleClicked"
     *     - "pointerPressed"
     *     - "pointerReleased"
     *     - "pointerEntered"
     *     - "pointerExited"
     *
     *   - Focus event:
     *     - "focusLost"
     *     - "focusGained"
     *
     *   - Component events:
     *     - "compSized"
     *     - "compMoved"
     *     - "compEnabled"
     *     - "compShown"
     *     - "compAdded"
     *     - "compRemoved"
     *
     *   - Window events:
     *     - "winOpened"
     *     - "winActivated"
     *
     *   - Menu events:
     *     - "menuItemSelected'
     *
     *   - Shortcut events:
     *     - "shortcutFired"
     *
     * Current events manager is available with "zebkit.ui.events"
     *
     * @class zebkit.ui.EventManager
     * @constructor
     * @extends {zebkit.ui.Manager}
     * @example
     *
     *     // catch all pointer pressed events that are triggered by zebkit UI
     *     zebkit.ui.events.on("pointerPressed", function(e) {
     *         // handle event
     *         ...
     *     });
     */
    pkg.EventManager = Class(pkg.Manager, zebkit.EventProducer, [
        function() {
            this._ = new this.clazz.Listerners();
            this.$super();
        },

        function $clazz(argument) {
            var eventNames = [
                'keyTyped',
                'keyReleased',
                'keyPressed',
                'pointerDragged',
                'pointerDragStarted',
                'pointerDragEnded',
                'pointerMoved',
                'pointerClicked',
                'pointerDoubleClicked',
                'pointerPressed',
                'pointerReleased',
                'pointerEntered',
                'pointerExited',

                'focusLost',
                'focusGained',

                'compSized',
                'compMoved',
                'compEnabled',
                'compShown',
                'compAdded',
                'compRemoved'
            ];

            this.$CHILD_EVENTS_MAP = {};

            // add child<eventName> events names mapping
            for(var i = 0; i < eventNames.length; i++) {
                var eventName = eventNames[i];
                this.$CHILD_EVENTS_MAP[eventName] = "child" + eventName[0].toUpperCase() + eventName.substring(1);
            }

            this.Listerners = zebkit.util.ListenersClass.apply(this, eventNames);
        },

        function $prototype(clazz) {
            var $CEM = clazz.$CHILD_EVENTS_MAP;

            this.regEvents = function() {
                this._.addEvents.apply(this._, arguments);

                // add child<eventName> events names mapping
                for(var i = 0; i < arguments.length; i++) {
                    var eventName = arguments[i];
                    $CEM[eventName] = "child" + eventName[0].toUpperCase() + eventName.substring(1);
                }
            };

            /**
             * Fire event with the given id
             * @param  {String} id an event id type
             * @param  {zebkit.util.Event} e different sort of event
             * @return {Boolean} boolean flag that indicates if a event handling has been interrupted on one of a stage:
             *
             *    - Suppressed by a target component
             *    - By a global listener
             *    - By a target component event listener
             *
             * @method  fire
             * @protected
             */
            this.fire = function(id, e) {
                var childEvent = $CEM[id];

                // assign id that matches method to be called
                e.id = id;

                // TODO: not stable concept. the idea to suppress event distribution to global
                // listeners (managers) and child components
                if (typeof e.source.suppressEvent !== 'undefined' && e.source.suppressEvent(e) === true) {
                    return true;
                }

                // call global listeners
                if (this._[id](e) === false) {
                    // call target component listener
                    if (typeof e.source[id] !== 'undefined' && e.source[id].call(e.source, e) === true) {
                        return true;
                    }

                    // call parent listeners
                    for(var t = e.source.parent; t !== null; t = t.parent){
                        if (typeof t[childEvent] !== 'undefined') {
                            t[childEvent].call(t, e);
                        }
                    }

                    return false;
                } else {
                    return true;
                }
            };
        }
    ]);

    /**
     * Event manager reference. The reference can be used to register listeners that can
     * get all events of the given type that are fired by zebkit UI. For instance you can
     * catch all pointer pressed events as follow:
     * @example
     *
     *     zebkit.ui.events.on("pointerPressed", function(e) {
     *         // handle pointer pressed event here
     *         ...
     *     });
     *
     * @attribute events
     * @type {zebkit.ui.EventManager}
     * @readOnly
     */
     this.events = new pkg.EventManager();

     pkg.Clipboard = Class(pkg.Manager, [
         function $prototype() {
             this.getDestination = function() {
                 return pkg.focusManager.focusOwner;
             };
         }
     ]);

     pkg.CursorManager = Class(pkg.Manager, [
        function $prototype() {
            /**
             * Current cursor type
             * @attribute cursorType
             * @type {String}
             * @readOnly
             * @default "default"
             */
            this.cursorType = "default";
        }
     ]);


    // Panel WEB specific dependencies:
    //   -  getCanvas() -> zCanvas
    //      -  $da (dirty area)
    //      -  $isRootCanvas
    //      -  $waitingForPaint (created and controlled by Panel painting !)
    //      -  $context
    //          - restore(...)
    //          - restoreAll(...)
    //          - save()
    //          - clipRect(...)
    //          - clip()
    //          - clearRect(...)
    //          - translate(...)
    //          - $states[g.$curState] ?
    //
    // Panel zebkit classes dependencies
    //   - ui.CompEvent
    //   - ui.events EventManager
    //   - util.*


    /**
     *  Zebkit UI package contains a lot of various components. Zebkit UI idea is rendering
     *  hierarchy of UI components on a canvas (HTML5 Canvas). Typical zebkit application
     *  looks as following:
     *
     *       zebkit.require("ui", "layout", function(ui) {
     *           // create canvas and save reference to root layer
     *           // where zebkit UI components should live.
     *           var root = new ui.zCanvas(400, 400).root;
     *
     *           // build UI layout
     *           root.properties({
     *               layout : new layout.BorderLayout(4),
     *               padding: 8,
     *               kids   : {
     *                   "center" : new ui.TextArea("A text"),
     *                   "top"    : new ui.ToolbarPan().properties({
     *                       kids : [
     *                           new ui.ImagePan("icon1.png"),
     *                           new ui.ImagePan("icon2.png"),
     *                           new ui.ImagePan("icon3.png")
     *                      ]
     *                   }),
     *                   "bottom" : new ui.Button("Apply")
     *               }
     *           });
     *       });
     *
     *  UI components are ordered with help of layout managers. You should not use absolute
     *  location or size your component. It is up to layout manager to decide which size and
     *  location the given  component has to have. In the example above we add number of UI
     *  components to "root" (UI Panel). The root panel uses "BorderLayout" [to order the
     *  added components. The layout manager split root area to number of areas: "center",
     *  "top", "left", "right", "bottom" where children components can be placed.
     *
     *  @class zebkit.ui
     *  @access package
     */


    // TODO: not stable API
    pkg.$configWith = function(pkg, path) {
        if (arguments.length < 2) {
            var fn = pkg.fullname();
            path = fn.substring(fn.indexOf('.') + 1) + ".json";
        }

        if (path[0] !== '/') {
            var root = zebkit.config['ui.theme.path'];
            if (typeof root === "undefined") {
                root =  typeof zebkit.config['ui.theme.name'] === 'undefined' ? "rs/themes/dark"
                                                                              : "rs/themes/" + zebkit.config['ui.theme.name'];
            }

            if (root[0] !== '/') {
                path = zebkit.URI.join(zebkit.ui.$url, root, path);
            } else {
                path = zebkit.URI.join(root, path);
            }
        }

        // it guarantees that loading if JSONs will be done sequentially in
        // the order the JSON appeared
        zebkit.then(function() { // calling the guarantees it will be called when previous actions are completed
            this.till(new zebkit.util.Zson(pkg).then(path)); // now we can trigger other loading action
        });
    };

    // TODO: prototype of zClass, too simple to say something
    pkg.zCanvas = Class([]);

    /**
     * Get preferred size shortcut. Null can be passed as the method argument
     * @private
     * @param  {zebkit.ui.Layoutable} l a layoutable component
     * @return {Object}  a preferred size:
     *      { width : {Integer}, height: {Integer} }
     * @method $getPS
     * @for zebkit.ui
     */
    pkg.$getPS = function(l) {
        return l !== null && l.isVisible === true ? l.getPreferredSize()
                                                  : { width:0, height:0 };
    };

    /**
     * Calculate visible area of the given components taking in account
     * intersections with parent hierarchy.
     * @private
     * @param  {zebkit.ui.Panel} c  a component
     * @param  {Object} r a variable to store visible area

            { x: {Integer}, y: {Integer}, width: {integer}, height: {Integer} }

     * @method $cvp
     * @for zebkit.ui
     */
    pkg.$cvp = function(c, r) {
        if (c.width > 0 && c.height > 0 && c.isVisible === true){
            var p  = c.parent,
                px = -c.x,
                py = -c.y;

            if (arguments.length < 2) {
                r = { x:0, y:0, width : c.width, height : c.height };
            } else {
                r.x = r.y = 0;
                r.width  = c.width;
                r.height = c.height;
            }

            while (p !== null && r.width > 0 && r.height > 0) {
                var xx = r.x > px ? r.x : px,
                    yy = r.y > py ? r.y : py,
                    w1 = r.x + r.width,
                    w2 = px  + p.width,
                    h1 = r.y + r.height,
                    h2 = py  + p.height;

                r.width  = (w1 < w2 ? w1 : w2) - xx;
                r.height = (h1 < h2 ? h1 : h2) - yy;
                r.x = xx;
                r.y = yy;

                px -= p.x;
                py -= p.y;
                p = p.parent;
            }

            return r.width > 0 && r.height > 0 ? r : null;
        }
        return null;
    };

    /**
     * Relocate the given component to make them fully visible.
     * @param  {zebkit.ui.Panel} [d] a parent component where the given component has to be re-located
     * @param  {zebkit.ui.Panel} c  a component to re-locate to make it fully visible in the parent
     * component
     * @method makeFullyVisible
     * @for  zebkit.ui
     */
    pkg.makeFullyVisible = function(d, c){
        if (arguments.length === 1) {
            c = d;
            d = c.parent;
        }

        var right  = d.getRight(),
            top    = d.getTop(),
            bottom = d.getBottom(),
            left   = d.getLeft(),
            xx     = c.x,
            yy     = c.y;

        if (xx < left) xx = left;
        if (yy < top)  yy = top;
        if (xx + c.width > d.width - right) xx = d.width + right - c.width;
        if (yy + c.height > d.height - bottom) yy = d.height + bottom - c.height;
        c.setLocation(xx, yy);
    };

    pkg.calcOrigin = function(x,y,w,h,px,py,t,tt,ll,bb,rr){
        if (arguments.length < 8) {
            tt = t.getTop();
            ll = t.getLeft();
            bb = t.getBottom();
            rr = t.getRight();
        }

        var dw = t.width, dh = t.height;
        if (dw > 0 && dh > 0){
            if (dw - ll - rr > w){
                var xx = x + px;
                if (xx < ll) px += (ll - xx);
                else {
                    xx += w;
                    if (xx > dw - rr) px -= (xx - dw + rr);
                }
            }
            if (dh - tt - bb > h){
                var yy = y + py;
                if (yy < tt) py += (tt - yy);
                else {
                    yy += h;
                    if (yy > dh - bb) py -= (yy - dh + bb);
                }
            }
            return [px, py];
        }
        return [0, 0];
    };

    /**
     * This class represents a font and provides basic font metrics like height, ascent. Using
     * the class developers can compute string width.

     // plain font
     var f = new zebkit.ui.Font("Arial", 14);

     // bold font
     var f = new zebkit.ui.Font("Arial", "bold", 14);

     // defining font with CSS font name
     var f = new zebkit.ui.Font("100px Futura, Helvetica, sans-serif");

     * @constructor
     * @param {String} name a name of the font. If size and style parameters has not been passed
     * the name is considered as CSS font name that includes size and style
     * @param {String} [style] a style of the font: "bold", "italic", etc
     * @param {Integer} [size] a size of the font
     * @class zebkit.ui.Font
     */
    pkg.Font = Class([
        function(family, style, size) {
            if (arguments.length === 1) {
                this.size = this.clazz.decodeSize(family);
                if (this.size === null) {
                    // trim
                    family = family.trim();

                    // check if a predefined style has been used
                    if (family === "bold" || family === "italic") {
                        this.style = family;
                    } else {  // otherwise handle it as CSS-like font style
                        // try to parse font if possible
                        var re = /([a-zA-Z_\- ]+)?(([0-9]+px|[0-9]+em)\s+([,\"'a-zA-Z_ \-]+))?/,
                            m  = family.match(re);

                        if (typeof m[4] !== 'undefined') {
                            this.family = m[4].trim();
                        }

                        if (typeof m[3] !== 'undefined') {
                            this.size = m[3].trim();
                        }

                        if (typeof m[1] !== 'undefined') {
                            this.style = m[1].trim();
                        }

                        this.s = family;
                    }
                }
            } else if (arguments.length === 2) {
                this.family = family;
                this.size   = this.clazz.decodeSize(style);
                this.style  = this.size === null ? style : null;
            } else if (arguments.length === 3) {
                this.family = family;
                this.style  = style;
                this.size   = this.clazz.decodeSize(size);
            }

            if (this.size === null) {
                this.size = this.clazz.size + "px";
            }

            if (this.s === null) {
                this.s = ((this.style !== null) ? this.style + " ": "") +
                         this.size + " " +
                         this.family;
            }

            var mt = zebkit.environment.fontMetrics(this.s);

            /**
             * Height of the font
             * @attribute height
             * @readOnly
             * @type {Integer}
             */
            this.height = mt.height;

            /**
             * Ascent of the font
             * @attribute ascent
             * @readOnly
             * @type {Integer}
             */
            this.ascent = mt.ascent;
        },

        function $clazz() {

            // default values
            this.family = "Arial, Helvetica";
            this.style  =  null;
            this.size   =  14;

            this.mergeable = false;

            this.decodeSize = function(s, defaultSize) {
                if (arguments.length < 2) {
                    defaultSize = this.size;
                }

                if (zebkit.isString(s)) {
                    var size = Number(s);
                    if (isNaN(size)) {
                        var m = s.match(/^([0-9]+)(%)$/);
                        if (m !== null && typeof m[1] !== 'undefined' && m[2] !== 'undefined') {
                            size = Math.floor((defaultSize * parseInt(m[1], 10)) / 100);
                            return size + "px";
                        } else {
                            return /^([0-9]+)(em|px)$/.test(s) === true ? s : null;
                        }
                    } else {
                        if (s[0] === '+') {
                            size = defaultSize + size;
                        } else if (s[0] === '-') {
                            size = defaultSize - size;
                        }
                        return size + "px";
                    }
                }
                return s === null ? null : s + "px";
            };
        },

        function $prototype(clazz) {
            this.s = null;

            this.family = clazz.family;
            this.style  = clazz.style;
            this.size   = clazz.size;

            /**
             * Returns CSS font representation
             * @return {String} a CSS representation of the given Font
             * @method toString
             * @for zebkit.ui.Font
             */
            this.toString = function() {
                return this.s;
            };

            this.stringWidth = function(s) {
                if (s.length === 0) {
                    return 0;
                } else {
                    var fm = zebkit.environment.fontMeasure;
                    if (fm.font !== this.s) {
                        fm.font = this.s;
                    }

                    return (fm.measureText(s).width + 0.5) | 0;
                }
            };

            /**
             * Calculate the specified substring width
             * @param  {String} s a string
             * @param  {Integer} off fist character index
             * @param  {Integer} len length of substring
             * @return {Integer} a substring size in pixels
             * @method charsWidth
             * @for zebkit.ui.Font
             */
            this.charsWidth = function(s, off, len) {
                var fm = zebkit.environment.fontMeasure;
                if (fm.font !== this.s) {
                    fm.font = this.s;
                }
                return (fm.measureText(len === 1 ? s[off]
                                                 : s.substring(off, off + len)).width + 0.5) | 0;
            };

            /**
             * Resize font and return new instance of font class with new size.
             * @param  {Integer | String} size can be specified in pixels as integer value or as
             * a percentage from the given font:
             * @return {zebkit.ui.Font} a font
             * @for zebkit.ui.Font
             * @method resize
             * @example
             *
             * ```javascript
             * var font = new zebkit.ui.Font(10); // font 10 pixels
             * font = font.resize("200%"); // two times higher font
             * ```
             */
            this.resize = function(size) {
                var nsize = this.clazz.decodeSize(size, this.height);
                if (nsize === null) {
                    throw new Error("Invalid font size : " + size);
                }
                return new this.clazz(this.family, this.style, nsize);
            };

            this.restyle = function(style) {
                return new this.clazz(this.family, style, this.height + "px");
            };
        }
    ]);

    var $paintTask = null,
        $paintTasks = [],
        temporary = { x:0, y:0, width:0, height:0 },
        COMP_EVENT = new pkg.CompEvent();

    /**
     * Trigger painting for all collected paint tasks
     * @protected
     * @method $doPaint
     * @for zebkit.ui
     */
    pkg.$doPaint = function() {
        for (var i = $paintTasks.length - 1; i >= 0; i--) {
            var canvas = $paintTasks.shift();
            try {
                // do validation before timer will be set to null to avoid
                // unnecessary timer initiating what can be caused by validation
                // procedure by calling repaint method
                if (canvas.isValid === false || canvas.isLayoutValid === false) {
                    canvas.validate();
                }

                if (canvas.$da.width > 0) {
                    canvas.$context.save();

                    // check if the given canvas has transparent background
                    // if it is true call clearRect method to clear dirty area
                    // with transparent background, otherwise it will be cleaned
                    // by filling the canvas with background later
                    if (canvas.bg === null || canvas.bg.isOpaque !== true) {
                        canvas.$context.clearRect(canvas.$da.x, canvas.$da.y,
                                                  canvas.$da.width, canvas.$da.height);
                    }
                    // !!!
                    // call clipping area later than possible
                    // clearRect since it can bring to error in IE
                    canvas.$context.clipRect(canvas.$da.x,
                                             canvas.$da.y,
                                             canvas.$da.width,
                                             canvas.$da.height);

                    // no dirty area anymore. put it hear to prevent calling
                    // animation  task from repaint() method that can be called
                    // inside paintComponent method.
                    canvas.$da.width = -1;

                    // clear flag that says the canvas is waiting for repaint, that allows to call
                    // repaint from paint method
                    canvas.$waitingForPaint = false;

                    canvas.paintComponent(canvas.$context);
                    canvas.$context.restore();
                } else {
                    canvas.$waitingForPaint = false;
                }
            } catch(ex) {
                // catch error and clean task list if any to avoid memory leaks
                try {
                    if (canvas !== null) {
                        canvas.$waitingForPaint = false;
                        canvas.$da.width = -1;
                        if (canvas.$context !== null) {
                            canvas.$context.restoreAll();
                        }
                    }
                } catch(exx) {
                    $paintTask = null;
                    $paintTasks.length = 0;
                    throw exx;
                }

                zebkit.dumpError(ex);
            }
        }

        // paint task is done
        $paintTask = null;

        // test if new dirty canvases have appeared and start
        // animation again
        if ($paintTasks.length !== 0) {
            $paintTask = zebkit.environment.animate(pkg.$doPaint);
        }
    };

    /**
     *  This the core UI component class. All other UI components has to be successor of panel class.

          // instantiate panel with no arguments
          var p = new zebkit.ui.Panel();

          // instantiate panel with border layout set as its layout manager
          var p = new zebkit.ui.Panel(new zebkit.layout.BorderLayout());

          // instantiate panel with the given properties (border
          // layout manager, blue background and plain border)
          var p = new zebkit.ui.Panel({
             layout: new zebkit.ui.BorderLayout(),
             background : "blue",
             border     : "plain"
          });

     *  **Container**
     * Panel can contains number of other UI components as its children where the children components
     * are placed with a defined by the panel layout manager:

          // add few children component to panel top, center and bottom parts
          // with help of border layout manager
          var p = new zebkit.ui.Panel();
          p.setLayout(new zebkit.layout.BorderLayout(4)); // set layout manager to
                                                         // order children components

          p.add("top", new zebkit.ui.Label("Top label"));
          p.add("center", new zebkit.ui.TextArea("Text area"));
          p.add("bottom", new zebkit.ui.Button("Button"));

     * **Input and component events**
     * The class provides possibility to catch various component and input events by declaring an
     * appropriate event method handler. The most simple case you just define a method:

          var p = new zebkit.ui.Panel();
          p.pointerPressed = function(e) {
              // handle event here
          };

    * If you prefer to create an anonymous class instance you can do it as follow:

          var p = new zebkit.ui.Panel([
              function pointerPressed(e) {
                  // handle event here
              }
          ]);

    * One more way to add the event handler is dynamic extending of an instance class demonstrated
    * below:

          var p = new zebkit.ui.Panel("Test");
          p.extend([
              function pointerPressed(e) {
                  // handle event here
              }
          ]);

     * Pay attention Zebkit UI components often declare own event handlers and in this case you can
     * overwrite the default event handler with a new one. Preventing the basic event handler execution
     * can cause the component will work improperly. You should care about the base event handler
     * execution as follow:

          // button component declares own pointer pressed event handler
          // we have to call the original handler to keep the button component
          // properly working
          var p = new zebkit.ui.Button("Test");
          p.extend([
              function pointerPressed(e) {
                  this.$super(e); // call parent class event handler implementation
                  // handle event here
              }
          ]);

     *  @class zebkit.ui.Panel
     *  @param {Object|zebkit.layout.Layout} [l] pass a layout manager or number of properties that have
     *  to be applied to the instance of the panel class.
     *  @constructor
     *  @extends zebkit.layout.Layoutable
     */

    /**
     * Implement the event handler method to catch pointer pressed event. The event is triggered every time
     * a pointer button has been pressed or a finger has touched a touch screen.

         var p = new zebkit.ui.Panel();
         p.pointerPressed = function(e) { ... }; // add event handler

     * @event pointerPressed
     * @param {zebkit.ui.PointerEvent} e a pointer event
    */

    /**
     * Implement the event handler method to catch pointer released event. The event is triggered every time
     * a pointer button has been released or a finger has untouched a touch screen.

         var p = new zebkit.ui.Panel();
         p.pointerReleased = function(e) { ... }; // add event handler

     * @event pointerReleased
     * @param {zebkit.ui.PointerEvent} e a pointer event
     */

    /**
     * Implement the event handler method  to catch pointer moved event. The event is triggered every time
     * a pointer cursor has been moved with no a pointer button pressed.

         var p = new zebkit.ui.Panel();
         p.pointerMoved = function(e) { ... }; // add event handler

     * @param {zebkit.ui.PointerEvent} e a pointer event
     * @event  pointerMoved
     */

    /**
     * Implement the event handler method to catch pointer entered event. The event is triggered every
     * time a pointer cursor entered the given component.

         var p = new zebkit.ui.Panel();
         p.pointerEntered = function(e) { ... }; // add event handler

     * @param {zebkit.ui.PointerEvent} e a pointer event
     * @event  pointerEntered
     */

    /**
     * Implement the event handler method to catch pointer exited event. The event is triggered every
     * time a pointer cursor exited the given component.

         var p = new zebkit.ui.Panel();
         p.pointerExited = function(e) { ... }; // add event handler

     * @param {zebkit.ui.PointerEvent} e a pointer event
     * @event  pointerExited
     */

    /**
     * Implement the event handler method to catch pointer clicked event. The event is triggered every
     * time a pointer button has been clicked. Click events are generated only if no one pointer moved
     * or drag events has been generated in between pointer pressed -> pointer released events sequence.

         var p = new zebkit.ui.Panel();
         p.pointerClicked = function(e) { ... }; // add event handler

     * @param {zebkit.ui.PointerEvent} e a pointer event
     * @event  pointerClicked
     */

    /**
     * Implement the event handler method to catch pointer dragged event. The event is triggered every
     * time a pointer cursor has been moved when a pointer button has been pressed. Or when a finger
     * has been moved over a touch screen.

         var p = new zebkit.ui.Panel();
         p.pointerDragged = function(e) { ... }; // add event handler

     * @param {zebkit.ui.PointerEvent} e a pointer event
     * @event  pointerDragged
     */

    /**
     * Implement the event handler method to catch pointer drag started event. The event is triggered
     * every time a pointer cursor has been moved first time when a pointer button has been pressed.
     * Or when a finger has been moved first time over a touch screen.

         var p = new zebkit.ui.Panel();
         p.pointerDragStarted = function(e) { ... }; // add event handler

     * @param {zebkit.ui.PointerEvent} e a pointer event
     * @event  pointerDragStarted
    */

    /**
     * Implement the event handler method to catch pointer drag ended event. The event is triggered
     * every time a pointer cursor has been moved last time when a pointer button has been pressed.
     * Or when a finger has been moved last time over a touch screen.

         var p = new zebkit.ui.Panel();
         p.pointerDragEnded = function(e) { ... }; // add event handler

     * @param {zebkit.ui.PointerEvent} e a pointer event
     * @event  pointerDragEnded
    */

    /**
     * Implement the event handler method to catch key pressed event The event is triggered every
     * time a key has been pressed.

         var p = new zebkit.ui.Panel();
         p.keyPressed = function(e) { ... }; // add event handler

     * @param {zebkit.ui.KeyEvent} e a key event
     * @event  keyPressed
     */

    /**
     * Implement the event handler method to catch key types event The event is triggered every
     *     time a key has been typed.

         var p = new zebkit.ui.Panel();
         p.keyTyped = function(e) { ... }; // add event handler

     * @param {zebkit.ui.KeyEvent} e a key event
     * @event  keyTyped
     */

    /**
     * Implement the event handler method to catch key released event
     * The event is triggered every time a key has been released.

         var p = new zebkit.ui.Panel();
         p.keyReleased = function(e) { ... }; // add event handler

     * @param {zebkit.ui.KeyEvent} e a key event
     * @event  keyReleased
     */

    /**
     * Implement the event handler method to catch the component sized event
     * The event is triggered every time the component has been re-sized.

         var p = new zebkit.ui.Panel();
         p.compSized = function(e) { ... }; // add event handler

     * @param {zebkit.ui.CompEvent} e a component event. Source of the event
     * is a component that has been sized, "prevWidth" and "prevHeight" fields
     * keep a previous size the component had.
     * @event compSized
     */

    /**
     * Implement the event handler method to catch component moved event
     * The event is triggered every time the component location has been
     * updated.

         var p = new zebkit.ui.Panel();
         p.compMoved = function(e) { ... }; // add event handler

     * @param {zebkit.ui.Panel} c a component that has been moved
     * @param {Integer} px a previous x coordinate the moved component had
     * @param {Integer} py a previous y coordinate the moved component had
     * @param {zebkit.ui.CompEvent} e a component event. Source of the event
     * is a component that has been moved. "prevX" and "prevY" fields hold
     * a previous location the component had.
     * @event compMoved
     */

    /**
     * Implement the event handler method to catch component enabled event
     * The event is triggered every time a component enabled state has been
     * updated.

         var p = new zebkit.ui.Panel();
         p.compEnabled = function(e) { ... }; // add event handler

     * @param {zebkit.ui.CompEvent} e a component event.
     * @event compEnabled
     */

    /**
     * Implement the event handler method to catch component shown event
     * The event is triggered every time a component visibility state has
     * been updated.

         var p = new zebkit.ui.Panel();
         p.compShown = function(e) { ... }; // add event handler

     * @param {zebkit.ui.CompEvent} e a component event.
     * @event compShown
     */

    /**
     * Implement the event handler method to catch component added event
     * The event is triggered every time the component has been inserted into
     * another one.

         var p = new zebkit.ui.Panel();
         p.compAdded = function(e) { ... }; // add event handler

     * @param {zebkit.ui.CompEvent} e a component event. The source of the passed event
     * is set to a container component, "kid" field is set to a component that has been
     * added to the container, "constraints" holds a constraints the child component has been
     * added.
     * @event compAdded
     */

    /**
     * Implement the event handler method to catch component removed event
     * The event is triggered every time the component has been removed from
     * its parent UI component.

         var p = new zebkit.ui.Panel();
         p.compRemoved = function(e) { ... }; // add event handler

     * @param {zebkit.ui.CompEvent} e a component event. The source of the passed event
     * is set to the container component. "kid" field is set to a child component that has
     * been removed from the container and "index" field is set to the index the kid component
     * was added before it had been removed from the container.
     * @event compRemoved
     */

    /**
     * Implement the event handler method to catch component focus gained event
     * The event is triggered every time a component has gained focus.

         var p = new zebkit.ui.Panel();
         p.focusGained = function(e) { ... }; // add event handler

     * @param {zebkit.ui.FocusEvent} e an input event
     * @event  focusGained
     */

    /**
     * Implement the event handler method to catch component focus lost event
     * The event is triggered every time a component has lost focus

         var p = new zebkit.ui.Panel();
         p.focusLost = function(e) { ... }; // add event handler

     * @param {zebkit.ui.FocusEvent} e an input event
     * @event  focusLost
     */

    /**
     * It is also possible to listen all the listed above event for children component. To handle
     * the event register listener method following the pattern below:
     *
         var p = new zebkit.ui.Panel();
         p.child<EventName> = function(e) { ... }; // add event handler

     * @param {Integer} id a component event ID. The id can have one of the following value:


     * @param {zebkit.ui.Panel} src a component that triggers the event
     * @param {zebkit.ui.KeyEvent | zebkit.ui.PointerEvent | zebkit.ui.CompEvent| zebkit.ui.FocusEvent} e an UI event fired by a child component.
     * @event  child<EventName>
     */

     /**
      * The method is called for focusable UI components (components that can hold input focus) to ask
      * a string to be saved in native clipboard
      *
      * @return {String} a string to be copied in native clipboard
      *
      * @event clipCopy
      */

     /**
      * The method is called to pass string from clipboard to a focusable (a component that can hold
      * input focus) UI component
      *
      * @param {String} s a string from native clipboard
      *
      * @event clipPaste
      */
    pkg.Panel = Class(zebkit.layout.Layoutable, [
        function $prototype() {
            this.bg = this.border = null;

            /**
             * Request the whole UI component or part of the UI component to be repainted
             * @param  {Integer} [x] x coordinate of the component area to be repainted
             * @param  {Integer} [y] y coordinate of the component area to be repainted
             * @param  {Integer} [w] width of the component area to be repainted
             * @param  {Integer} [h] height of the component area to be repainted
             * @method repaint
             */
            this.repaint = function(x, y, w ,h) {
                // step I: skip invisible components and components that are not in hierarchy
                //         don't initiate repainting thread for such sort of the components,
                //         but don't forget for zCanvas whose parent field is null, but it has $context
                if (this.isVisible === true && (this.parent !== null || typeof this.$context !== 'undefined')) {
                    //!!! find context buffer that holds the given component

                    var canvas = this;
                    for(; typeof canvas.$context === 'undefined'; canvas = canvas.parent) {
                        // component either is not in visible state or is not in hierarchy
                        // than stop repaint procedure
                        if (canvas.isVisible === false || canvas.parent === null) {
                            return;
                        }
                    }

                    // no arguments means the whole component has top be repainted
                    if (arguments.length === 0) {
                        x = y = 0;
                        w = this.width;
                        h = this.height;
                    }

                    // step II: calculate new actual dirty area
                    if (w > 0 && h > 0) {
                        var r = pkg.$cvp(this, temporary);
                        if (r !== null) {
                            zebkit.util.intersection(r.x, r.y, r.width, r.height, x, y, w, h, r);

                            if (r.width > 0 && r.height > 0) {
                                x = r.x;
                                y = r.y;
                                w = r.width;
                                h = r.height;

                                // calculate repainted component absolute location
                                var cc = this;
                                while (cc !== canvas) {
                                    x += cc.x;
                                    y += cc.y;
                                    cc = cc.parent;
                                }

                                // normalize repaint area coordinates
                                if (x < 0) {
                                    w += x;
                                    x = 0;
                                }

                                if (y < 0) {
                                    h += y;
                                    y = 0;
                                }

                                if (w + x > canvas.width ) w = canvas.width - x;
                                if (h + y > canvas.height) h = canvas.height - y;

                                // still have what to repaint than calculate new
                                // dirty area of target canvas element
                                if (w > 0 && h > 0) {
                                    var da = canvas.$da;

                                    // if the target canvas already has a dirty area set than
                                    // unite it with requested
                                    if (da.width > 0) {
                                        // check if the requested repainted area is not in
                                        // exiting dirty area
                                        if (x < da.x                ||
                                            y < da.y                ||
                                            x + w > da.x + da.width ||
                                            y + h > da.y + da.height  )
                                        {
                                            // !!!
                                            // speed up to comment method call
                                            //MB.unite(da.x, da.y, da.width, da.height, x, y, w, h, da);
                                            var dax = da.x, day = da.y;
                                            if (da.x > x) da.x = x;
                                            if (da.y > y) da.y = y;
                                            da.width  = Math.max(dax + da.width,  x + w) - da.x;
                                            da.height = Math.max(day + da.height, y + h) - da.y;
                                        }
                                    } else {
                                        // if the target canvas doesn't have a dirty area set than
                                        // cut (if necessary) the requested repainting area by the
                                        // canvas size

                                        // !!!
                                        // not necessary to call the method since we have already normalized
                                        // repaint coordinates and sizes
                                        //!!! MB.intersection(0, 0, canvas.width, canvas.height, x, y, w, h, da);

                                        da.x      = x;
                                        da.width  = w;
                                        da.y      = y;
                                        da.height = h;
                                    }
                                }
                            }
                        }
                    }

                    if (canvas.$waitingForPaint !== true && (canvas.isValid === false ||
                                                             canvas.$da.width > 0     ||
                                                             canvas.isLayoutValid === false))
                    {
                        $paintTasks[$paintTasks.length] = canvas;
                        canvas.$waitingForPaint = true;
                        if ($paintTask === null) {
                            $paintTask = zebkit.environment.animate(pkg.$doPaint);
                        }
                    }
                }
            };

            // destination is component itself or one of his composite parent.
            // composite component is a component that grab control from his
            // children component. to make a component composite
            // it has to implement catchInput field or method. If composite component
            // has catchInput method it will be called
            // to detect if the composite component takes control for the given kid.
            // composite components can be embedded (parent composite can take
            // control on its child composite component)
            this.getEventDestination = function() {
                var c = this, p = this;
                while ((p = p.parent) !== null) {
                    if (typeof p.catchInput !== 'undefined' &&
                        (p.catchInput === true || (p.catchInput    !== false &&
                                                   p.catchInput(c) === true     )))
                    {
                        c = p;
                    }
                }
                return c;
            };

            /**
             * Paint the component and all its child components using the
             * given 2D HTML Canvas context
             * @param  {CanvasRenderingContext2D} g a canvas 2D context
             * @method paintComponent
             */
            this.paintComponent = function(g) {
                var ts = g.$states[g.$curState];
                if (ts.width  > 0  &&
                    ts.height > 0  &&
                    this.isVisible === true)
                {
                    // !!!
                    // calling setSize in the case of raster layout doesn't
                    // cause hierarchy layout invalidation
                    if (this.isLayoutValid === false) {
                        this.validate();
                    }

                    var b = this.bg !== null && (this.parent === null || this.bg !== this.parent.bg);

                    // if component defines shape and has update, [paint?] or background that
                    // differs from parent background try to apply the shape and than build
                    // clip from the applied shape
                    if ( (this.border !== null && typeof this.border.outline !== 'undefined') &&
                         (b === true || typeof this.update !== 'undefined')                   &&
                         this.border.outline(g, 0, 0, this.width, this.height, this) === true)
                    {
                        g.save();
                        g.clip();

                        if (b) {
                            this.bg.paint(g, 0, 0, this.width, this.height, this);
                        }

                        if (typeof this.update !== 'undefined') {
                            this.update(g);
                        }

                        g.restore();
                    } else {
                        if (b === true) {
                            this.bg.paint(g, 0, 0, this.width, this.height, this);
                        }

                        if (typeof this.update !== 'undefined') {
                            this.update(g);
                        }
                    }

                    if (this.border !== null) {
                        this.border.paint(g, 0, 0, this.width, this.height, this);
                    }

                    if (typeof this.paint !== 'undefined') {
                        var left   = this.getLeft(),
                            top    = this.getTop(),
                            bottom = this.getBottom(),
                            right  = this.getRight();

                        if (left > 0 || right > 0 || top > 0 || bottom > 0) {
                            if (ts.width > 0 && ts.height > 0) {
                                var x1   = (ts.x > left ? ts.x : left),
                                    y1   = (ts.y > top  ? ts.y : top),
                                    cxcw = ts.x + ts.width,
                                    cych = ts.y + ts.height,
                                    cright = this.width - right,
                                    cbottom = this.height - bottom;

                                g.save();
                                g.clipRect(x1, y1, (cxcw < cright  ? cxcw : cright)  - x1,
                                                   (cych < cbottom ? cych : cbottom) - y1);

                                this.paint(g);
                                g.restore();
                            }
                        } else {
                            this.paint(g);
                        }
                    }

                    var count = this.kids.length;
                    for(var i = 0; i < count; i++) {
                        var kid = this.kids[i];
                        if (kid.isVisible === true && typeof kid.$context === 'undefined') {
                            // calculate if the given component area has intersection
                            // with current clipping area
                            var kidXW = kid.x + kid.width,
                                c_xw  = ts.x + ts.width,
                                kidYH = kid.y + kid.height,
                                c_yh  = ts.y + ts.height,
                                iw = (kidXW < c_xw ? kidXW : c_xw) - (kid.x > ts.x ? kid.x : ts.x),
                                ih = (kidYH < c_yh ? kidYH : c_yh) - (kid.y > ts.y ? kid.y : ts.y);

                            if (iw > 0 && ih > 0) {
                                g.save();
                                g.translate(kid.x, kid.y);
                                g.clipRect(0, 0, kid.width, kid.height);
                                kid.paintComponent(g);
                                g.restore();
                            }
                        }
                    }

                    if (typeof this.paintOnTop !== 'undefined') {
                        this.paintOnTop(g);
                    }
                }
            };

            /**
             * UI component border view
             * @attribute border
             * @default null
             * @readOnly
             * @type {zebkit.ui.View}
             */

            /**
             * UI component background view
             * @attribute bg
             * @default null
             * @readOnly
             * @type {zebkit.ui.View}
            */

            /**
             * Define and set the property to true if the component has to catch focus
             * @attribute canHaveFocus
             * @type {Boolean}
             * @default undefined
             */

            this.top = this.left = this.right = this.bottom = 0;

            /**
             * UI component enabled state
             * @attribute isEnabled
             * @default true
             * @readOnly
             * @type {Boolean}
             */
            this.isEnabled = true;

            /**
             * Find a zebkit.ui.zCanvas where the given UI component is hosted
             * @return {zebkit.ui.zCanvas} a zebkit canvas
             * @method getCanvas
             */
            this.getCanvas = function() {
                var c = this;
                for(; c !== null && c.$isRootCanvas !== true; c = c.parent);
                return c;
            };

            this.notifyRender = function(o, n){
                if (o !== null && typeof o.ownerChanged !== 'undefined') o.ownerChanged(null);
                if (n !== null && typeof n.ownerChanged !== 'undefined') n.ownerChanged(this);
            };

            /**
             * Shortcut method to register the specific to the concrete component
             * events listener. For instance "zebkit.ui.Button" component fires event
             * when it is pressed:

            var b = new zebkit.ui.Button("Test");
            b.on(function() {
                // button has been pressed
            });


             * @param {Function|Object} a listener function or an object that
             * declares events handler methods
             * @return {Function|Object} a registered listener
             * @method bind
             */

            /**
             * Shortcut method to remove the register component specific events listener
             * @param {Function|Object} a listener function to be removed
             * @method unbind
             */


            /**
             * Load content of the panel UI components from the specified JSON file.
             * @param  {String|Object} JSON URL, JSON string or JS object tthat describes UI
             * to be loaded into the panel
             * @return {zebkit.DoIt} a runner to track JSON loading
             * @method load
             */
            this.load = function(jsonPath) {
                return new zebkit.util.Zson(this).then(jsonPath);
            };

            /**
             * Get a children UI component that embeds the given point. The method
             * calculates the component visible area first and than looks for a
             * children component only in this calculated visible area. If no one
             * children component has been found than component return itself as
             * a holder of the given point if one of the following condition is true:
             *
             *   - The component doesn't implement custom "contains(x, y)" method
             *   - The component implements "contains(x, y)" method and for the given point the method return true
             *
             * @param  {Integer} x x coordinate
             * @param  {Integer} y y coordinate
             * @return {zebkit.ui.Panel} a children UI component
             * @method getComponentAt
             */
            this.getComponentAt = function(x, y){
                var r = pkg.$cvp(this, temporary);

                if (r === null ||
                    (x < r.x || y < r.y || x >= r.x + r.width || y >= r.y + r.height))
                {
                    return null;
                }

                if (this.kids.length > 0){
                    for(var i = this.kids.length; --i >= 0; ){
                        var kid = this.kids[i];
                        kid = kid.getComponentAt(x - kid.x,
                                                 y - kid.y);
                        if (kid !== null) return kid;
                    }
                }
                return typeof this.contains === 'undefined' || this.contains(x, y) === true ? this : null;
            };

            /**
             * Shortcut method to invalidating the component and initiating the component repainting
             * @method vrp
             */
            this.vrp = function(){
                this.invalidate();

                // extra condition to save few millisecond on repaint() call
                if (this.isVisible === true && this.parent !== null) {
                    this.repaint();
                }
            };

            this.getTop = function() {
                return this.border !== null ? this.top + this.border.getTop()
                                            : this.top;
            };

            this.getLeft = function() {
                return this.border !== null ? this.left + this.border.getLeft()
                                            : this.left;
            };

            this.getBottom = function() {
                return this.border !== null ? this.bottom + this.border.getBottom()
                                            : this.bottom;
            };

            this.getRight  = function() {
                return this.border !== null ? this.right  + this.border.getRight()
                                            : this.right;
            };

            //TODO: the method is not used yet
            this.isInvalidatedByChild = function(c) {
                return true;
            };

            /**
             * The method is implemented to be aware about a children component insertion.
             * @param  {Integer} index an index at that a new children component
             * has been added
             * @param  {Object} constr a layout constraints of an inserted component
             * @param  {zebkit.ui.Panel} l a children component that has been inserted
             * @method kidAdded
             */
            this.kidAdded = function(index, constr, l) {
                COMP_EVENT.source = this;
                COMP_EVENT.constraints = constr;
                COMP_EVENT.kid = l;

                pkg.events.fire("compAdded", COMP_EVENT);

                if (l.width > 0 && l.height > 0) {
                    l.repaint();
                } else {
                    this.repaint(l.x, l.y, 1, 1);
                }
            };

            /**
             * Set the component layout constraints.
             * @param {Object} ctr a constraints whose value depends on layout manager that has been set
             * @method setConstraints
             * @chainable
             */
            this.setConstraints = function(ctr) {
                if (this.constraints !== ctr) {
                    this.constraints = ctr;
                    if (this.parent !== null) {
                        this.vrp();
                    }
                }
                return this;
            };

            /**
             * The method is implemented to be aware about a children component removal.
             * @param  {Integer} i an index of a removed component
             * @param  {zebkit.ui.Panel} l a removed children component
             * @method kidRemoved
             */
            this.kidRemoved = function(i,l){
                COMP_EVENT.source = this;
                COMP_EVENT.index  = i;
                COMP_EVENT.kid    = l;
                pkg.events.fire("compRemoved", COMP_EVENT);
                if (l.isVisible === true) {
                    this.repaint(l.x, l.y, l.width, l.height);
                }
            };

            /**
             * The method is implemented to be aware the component location updating
             * @param  {Integer} px a previous x coordinate of the component
             * @param  {Integer} py a previous y coordinate of the component
             * @method relocated
             */
            this.relocated = function(px, py) {
                COMP_EVENT.source = this;
                COMP_EVENT.prevX  = px;
                COMP_EVENT.prevY  = py;
                pkg.events.fire("compMoved", COMP_EVENT);

                var p = this.parent,
                    w = this.width,
                    h = this.height;

                if (p !== null && w > 0 && h > 0) {
                    var x = this.x,
                        y = this.y,
                        nx = x < px ? x : px,
                        ny = y < py ? y : py;

                    //TODO: some mobile browser has bug: moving a component
                    //      leaves 0.5 sized traces to fix it 1 pixel extra
                    //      has to be added to all sides of repainted rect area
                    // nx--;
                    // ny--;

                    if (nx < 0) nx = 0;
                    if (ny < 0) ny = 0;

                    var w1 = p.width - nx,
                        w2 = w + (x > px ? x - px : px - x),
                        h1 = p.height - ny,
                        h2 = h + (y > py ? y - py : py - y);

                    // TODO: add crappy 2 for mobile (android)
                    p.repaint(nx, ny, (w1 < w2 ? w1 : w2),// + 2,
                                      (h1 < h2 ? h1 : h2));// + 2);
                }
            };

            /**
             * The method is implemented to be aware the component size updating
             * @param  {Integer} pw a previous width of the component
             * @param  {Integer} ph a previous height of the component
             * @method resized
             */
            this.resized = function(pw,ph) {
                COMP_EVENT.source = this;
                COMP_EVENT.prevWidth  = pw;
                COMP_EVENT.prevHeight = ph;
                pkg.events.fire("compSized", COMP_EVENT);

                if (this.parent !== null) {
                    this.parent.repaint(this.x, this.y,
                                        ((this.width  > pw) ? this.width  : pw),
                                        ((this.height > ph) ? this.height : ph));
                }
            };

            /**
             * Checks if the component has a focus
             * @return {Boolean} true if the component has focus
             * @method hasFocus
             */
            this.hasFocus = function(){
                return pkg.focusManager.hasFocus(this);
            };

            /**
             * Force the given component to catch focus if the component is focusable.
             * @method requestFocus
             */
            this.requestFocus = function(){
                pkg.focusManager.requestFocus(this);
            };

            /**
             * Force the given component to catch focus in the given timeout.
             * @param {Integer} [timeout] a timeout in milliseconds. The default value is 50
             * milliseconds
             * @method requestFocusIn
             */
            this.requestFocusIn = function(timeout) {
                if (arguments.length === 0) {
                    timeout = 50;
                }

                var $this = this;
                zebkit.util.tasksSet.runOnce(function () {
                    $this.requestFocus();
                }, timeout);
            };

            /**
             * Set the UI component visibility
             * @param  {Boolean} b a visibility state
             * @method setVisible
             * @chainable
             */
            this.setVisible = function (b) {
                if (this.isVisible !== b) {
                    this.isVisible = b;
                    this.invalidate();

                    COMP_EVENT.source = this;
                    pkg.events.fire("compShown", COMP_EVENT);

                    if (this.parent !== null) {
                        if (b) this.repaint();
                        else {
                            this.parent.repaint(this.x, this.y, this.width, this.height);
                        }
                    }
                }
                return this;
            };

            /**
             *  Set the UI component enabled state. Using this property
             *  an UI component can be excluded from getting input events
             *  @param  {Boolean} b a enabled state
             *  @method setEnabled
             *  @chainable
             */
            this.setEnabled = function (b){
                if (this.isEnabled !== b){
                    this.isEnabled = b;

                    COMP_EVENT.source = this;
                    pkg.events.fire("compEnabled", COMP_EVENT);
                    if (this.kids.length > 0) {
                        for(var i = 0;i < this.kids.length; i++) {
                            this.kids[i].setEnabled(b);
                        }
                    }
                    this.repaint();
                }
                return this;
            };

            /**
             * Set the UI component top, right, left, bottom paddings to the same given value
             * @param  {Integer} v the value that will be set as top, right, left, bottom UI
             * component paddings
             * @method setPadding
             * @chainable
             */

            /**
             * Set UI component top, left, bottom, right paddings. The paddings are
             * gaps between component border and painted area.
             * @param  {Integer} top a top padding
             * @param  {Integer} left a left padding
             * @param  {Integer} bottom a bottom padding
             * @param  {Integer} right a right padding
             * @method setPadding
             * @chainable
             */
            this.setPadding = function (top,left,bottom,right){
                if (arguments.length === 1) {
                    left = bottom = right = top;
                }

                if (this.top    !== top    || this.left  !== left  ||
                    this.bottom !== bottom || this.right !== right   )
                {
                    this.top = top;
                    this.left = left;
                    this.bottom = bottom;
                    this.right = right;
                    this.vrp();
                }
                return this;
            };

            /**
             * Set top padding
             * @param {Integer} top a top padding
             * @method  setTopPadding
             * @chainable
             */
            this.setTopPadding = function(top) {
                if (this.top !== top) {
                    this.top = top;
                    this.vrp();
                }
                return this;
            };

            /**
             * Set left padding
             * @param {Integer} left a left padding
             * @method  setLeftPadding
             * @chainable
             */
            this.setLeftPadding = function(left) {
                if (this.left !== left) {
                    this.left = left;
                    this.vrp();
                }
                return this;
            };

            /**
             * Set bottom padding
             * @param {Integer} bottom a bottom padding
             * @method  setBottomPadding
             * @chainable
             */
            this.setBottomPadding = function(bottom) {
                if (this.bottom !== bottom) {
                    this.bottom = bottom;
                    this.vrp();
                }
                return this;
            };

            /**
             * Set right padding
             * @param {Integer} right a right padding
             * @method  setRightPadding
             * @chainable
             */
            this.setRightPadding = function(right) {
                if (this.right !== right) {
                    this.right = right;
                    this.vrp();
                }
                return this;
            };

            /**
             * Set the border view
             * @param  {zebkit.ui.View|Function|String} v a border view or border "paint(g,x,y,w,h,c)"
             * rendering function or one of predefined border name: "plain", "sunken", "raised", "etched"
             * @method setBorder
             * @example
             *
             *      var pan = new zebkit.ui.Panel();
             *
             *      // set round border
             *      pan.setBorder(zebkit.ui.RoundBorder("red"));
             *
             *      ...
             *      // set one of predefined border
             *      pan.setBorder("plain");
             *
             * @chainable
             */
            this.setBorder = function (v) {
                var old = this.border;
                v = pkg.$view(v);
                if (v != old){
                    this.border = v;
                    this.notifyRender(old, v);

                    if ( old === null || v === null       ||
                         old.getTop()    !== v.getTop()    ||
                         old.getLeft()   !== v.getLeft()   ||
                         old.getBottom() !== v.getBottom() ||
                         old.getRight()  !== v.getRight()     )
                    {
                        this.invalidate();
                    }

                    if (v !== null && typeof v.activate !== 'undefined') {
                        v.activate(this.hasFocus() ?  "focuson": "focusoff", this);
                    }

                    this.repaint();
                }
                return this;
            };

            /**
             * Set the background. Background can be a color string or a zebkit.ui.View class
             * instance, or a function(g,x,y,w,h,c) that paints the background:
             *
             *     // set background color
             *     comp.setBackground("red");
             *
             *     // set a picture as a component background
             *     comp.setBackground(new zebkit.ui.Picture(...));
             *
             *     // set a custom rendered background
             *     comp.setBackground(function(g,x,y,w,h,target) {
             *         // paint a component background here
             *         g.setColor("blue");
             *         g.fillRect(x,y,w,h);
             *         g.drawLine(...);
             *         ...
             *     });
             *
             *
             * @param  {String|zebkit.ui.View|Function} v a background view, color or
             * background "paint(g,x,y,w,h,c)" rendering function.
             * @method setBackground
             * @chainable
             */
            this.setBackground = function (v){
                var old = this.bg;
                v = pkg.$view(v);
                if (v !== old) {
                    this.bg = v;
                    this.notifyRender(old, v);
                    this.repaint();
                }
                return this;
            };

            /**
             * Add the given children component or number of components to the given panel.
             * @protected
             * @param {zebkit.ui.Panel|Array|Object} a children component of number of
             * components to be added. The parameter can be:
             *
             *   - Component
             *   - Array of components
             *   - Dictionary object where every element is a component to be added and the key of
             *     the component is stored in the dictionary is considered as the component constraints
             *
             * @method setKids
             */
            this.setKids = function(a) {
                if (arguments.length === 1 && zebkit.instanceOf(a, pkg.Panel)) {
                   this.add(a);
                } else {
                    var i = 0;

                    // if components list passed as number of arguments
                    if (arguments.length > 1) {
                        for(i = 0; i < arguments.length; i++) {
                            var kid = arguments[i];
                            if (kid !== null) {
                                this.add(typeof kid.$new !== 'undefined' ? kid.$new() : kid);
                            }
                        }
                    } else {
                        if (Array.isArray(a)) {
                            for(i = 0; i < a.length; i++) {
                                if (a[i] !== null) {
                                    this.add(a[i]);
                                }
                            }
                        } else {
                            var kids = a;
                            for(var k in kids) {
                                if (kids.hasOwnProperty(k)) {
                                    this.add(k, kids[k]);
                                }
                            }
                        }
                    }
                }
            };

            /**
             * Called whenever the UI component gets or looses focus
             * @method focused
             * @protected
             */
            this.focused = function() {
                // extents of activate method indicates it is
                if (this.border !== null && typeof this.border.activate !== 'undefined') {
                    var id = this.hasFocus() ? "focuson" : "focusoff" ;
                    if (typeof this.border.views[id] !== 'undefined') {
                        this.border.activate(id, this);
                        this.repaint();
                    }
                }

                // TODO: think if the background has to be focus dependent
                // if (this.bg !== null && typeof this.bg.activate !== 'undefined') {
                //     var id = this.hasFocus() ? "focuson" : "focusoff" ;
                //     if (this.bg.views[id]) {
                //         this.bg.activate(id);
                //         this.repaint();
                //     }
                // }
            };

            /**
             * Remove all children components
             * @method removeAll
             * @chainable
             */
            this.removeAll = function (){
                if (this.kids.length > 0){
                    var size = this.kids.length, mx1 = Number.MAX_VALUE, my1 = mx1, mx2 = 0, my2 = 0;
                    for(; size > 0; size--){
                        var child = this.kids[size - 1];
                        if (child.isVisible === true){
                            var xx = child.x, yy = child.y;
                            mx1 = mx1 < xx ? mx1 : xx;
                            my1 = my1 < yy ? my1 : yy;
                            mx2 = Math.max(mx2, xx + child.width);
                            my2 = Math.max(my2, yy + child.height);
                        }
                        this.removeAt(size - 1);
                    }
                    this.repaint(mx1, my1, mx2 - mx1, my2 - my1);
                }
                return this;
            };

            /**
             * Bring the UI component to front
             * @method toFront
             * @chainable
             */
            this.toFront = function(){
                if (this.parent !== null && this.parent.kids[this.parent.kids.length-1] !== this){
                    var p = this.parent;
                    p.kids.splice(p.indexOf(this), 1);
                    p.kids[p.kids.length] = this;
                    p.vrp();
                }
                return this;
            };

            /**
             * Send the UI component to back
             * @method toBack
             * @chainable
             */
            this.toBack = function(){
                if (this.parent !== null && this.parent.kids[0] !== this){
                    var p = this.parent;
                    p.kids.splice(p.indexOf(this), 1);
                    p.kids.unshift(this);
                    p.vrp();
                }
                return this;
            };

            /**
             * Set the UI component size to its preferred size
             * @return {Object} a preferred size applied to the component.
             * The structure of the returned object is the following:

                { width:{Integer}, height:{Integer} }

             * @method toPreferredSize
             */
            this.toPreferredSize = function (){
                var ps = this.getPreferredSize();
                this.setSize(ps.width, ps.height);
                return ps;
            };

            /**
             * Build zebkit.ui.View that represents the UI component
             * @return {zebkit.ui.View} a view of the component
             * @param {zebkit.ui.Panel} target a target component
             * @method toView
             */
            this.toView = function(target) {
                return new pkg.CompRender(this);
            };

            // TODO: not stable API
            this.paintViewAt = function(g, ax, ay, v) {
                var x  = this.getLeft(),
                    y  = this.getTop(),
                    ps = v.getPreferredSize();

                if (ax === "center") {
                    x = Math.floor((this.width - ps.width)/2);
                } else if (ax === "right") {
                    x = this.width - this.getRight() - ps.width;
                }

                if (ay === "center") {
                    y = Math.floor((this.height - ps.height)/2);
                } else if (ay === "bottom") {
                    y = this.height - this.getBottom() - ps.height;
                }

                v.paint(g, x, y, ps.width, ps.height, this);
            };

            this[''] = function(l) {
                // !!! dirty trick to call super, for the sake of few milliseconds back
                //this.$super();
                if (typeof this.kids === "undefined") {
                    this.kids = [];
                }

                if (this.layout === null) {
                    this.layout = this;
                }

                if (this.clazz.inheritProperties === true) {
                    // instead of recursion collect stack in array than go through it
                    var hierarchy = [],
                        pp        = this.clazz;

                    // collect clazz hierarchy
                    while(pp.$parent !== null && pp.inheritProperties === true) {
                        pp = pp.$parent;
                        hierarchy[hierarchy.length] = pp;
                    }

                    // apply properties from the hierarchy
                    for(var i = hierarchy.length; i >= 0; i--) {
                        this.properties(hierarchy[i]);
                    }
                }
                this.properties(this.clazz);

                if (arguments.length > 0) {
                    if (l.constructor === Object) {  // TODO: not 100% method to detetect "{}" type
                        this.properties(l);
                    } else {
                        this.setLayout(l);
                    }
                }
            };
        }
    ]);

    /**
     * Root layer interface.
     * @class zebkit.ui.RootLayerMix
     * @interface zebkit.ui.RootLayerMix
     */
    pkg.RootLayerMix = zebkit.Interface([
        function $clazz() {
            /**
             * Root layer id.
             * @attribute id
             * @type {String}
             * @readOnly
             * @default "root"
             */
            this.id = "root";
        },

        function $prototype() {
            this.getFocusRoot = function() {
                return this;
            };
        }
    ]);

    /**
     * Root layer panel implementation.
     * @class zebkit.ui.RootLayer
     * @extends {zebkit.ui.Panel}
     * @uses {zebkit.ui.RootLayerMix}
     */
    pkg.RootLayer = Class(pkg.Panel, pkg.RootLayerMix, []);


    /**
     * Default normal font
     * @attribute font
     * @type {zebkit.ui.Font}
     * @for  zebkit.ui
     */
    pkg.font = new pkg.Font("Arial", 14);

    /**
     * Default small font
     * @attribute smallFont
     * @type {zebkit.ui.Font}
     * @for  zebkit.ui
     */
    pkg.smallFont = new pkg.Font("Arial", 10);

    /**
     * Default bold font
     * @attribute boldFont
     * @type {zebkit.ui.Font}
     * @for  zebkit.ui
     */
    pkg.boldFont = new pkg.Font("Arial", "bold", 12);

    /**
     * Build a view instance by the given object.
     * @param  {Object} v an object that can be used to build a view. The following variants
     * of object types are possible
     *
     *   - **null** null is returned
     *   - **String** if the string is color or border view id than "zebkit.util.rgb" or border view
     *     is returned. Otherwise an instance of zebkit.ui.StringRender is returned.
     *   -  **String** if the string starts from "#" or "rgb" it is considered as encoded color.  "zebkit.util.rgb"
     *     instance will be returned as the view
     *   - **Array** an instance of "zebkit.ui.CompositeView" is returned
     *   - **Function** in this case the passed method is considered as ans implementation of "paint(g, x, y, w, h, d)"
     *     method of "zebkit.ui.View" class. Ans instance of "zebki.ui.View" with the method implemented is returned.
     *   - **Object** an instance of "zebkit.ui.ViewSet" is returned
     *
     * @return {zebkit.ui.View} a view
     * @method $view
     * @example
     *
     *      // string render
     *      var view = zebkit.ui.$view("String render");
     *
     *      // color render
     *      var view = zebkit.ui.$view("red");
     *
     *      // composite view
     *      var view = zebkit.ui.$view([
     *          zebkit.ui.rgb.yellow,
     *          "Text Render"
     *      ]);
     *
     *      // custom view
     *      var view = zebkit.ui.$view(function(g,x,y,w,h,d) {
     *          g.drawLine(x, y, x + w, y + w);
     *          ...
     *       });
     *
     * @protected
     * @for zebkit.ui
     */
    pkg.$view = function(v) {
        if (v === null || typeof v.paint !== 'undefined') {
            return v;
        }

        if (zebkit.isString(v)) {
            if (typeof zebkit.util.rgb[v] !== 'undefined') {
                return zebkit.util.rgb[v];
            }

            if (typeof pkg.borders !== 'undefined' && typeof pkg.borders[v] !== 'undefined') {
                return pkg.borders[v];
            }

            if (v.length > 0 &&
                (v[0] === '#'        ||
                  ( v.length > 2 &&
                    v[0] === 'r' &&
                    v[1] === 'g' &&
                    v[2] === 'b'    )  ))
            {
                return new zebkit.util.rgb(v);
            }

            return new pkg.StringRender(v);
        }

        if (Array.isArray(v)) {
            return new pkg.CompositeView(v);
        }

        if (typeof v !== 'function') {
            return new pkg.ViewSet(v);
        }

        var vv = new pkg.View();
        vv.paint = v;
        return vv;
    };

    zebkit.util.rgb.prototype.paint = function(g,x,y,w,h,d) {
        if (this.s !== g.fillStyle) {
            g.fillStyle = this.s;
        }

        // fix for IE10/11, calculate intersection of clipped area
        // and the area that has to be filled. IE11/10 have a bug
        // that triggers filling more space than it is restricted
        // with clip
        if (typeof g.$states !== 'undefined') {
            var t  = g.$states[g.$curState],
                rx = x > t.x ? x : t.x,
                rw = Math.min(x + w, t.x + t.width) - rx;

            if (rw > 0)  {
                var ry = y > t.y ? y : t.y,
                rh = Math.min(y + h, t.y + t.height) - ry;

                if (rh > 0) g.fillRect(rx, ry, rw, rh);
            }
        } else {
            g.fillRect(x, y, w, h);
        }
    };

    zebkit.util.rgb.prototype.getPreferredSize = function() {
        return { width:0, height:0 };
    };

    zebkit.util.rgb.gap = 0;
    zebkit.util.rgb.prototype.getTop    =
    zebkit.util.rgb.prototype.getLeft   =
    zebkit.util.rgb.prototype.getRight  =
    zebkit.util.rgb.prototype.getBottom = function() {
        return this.gap;
    };

    /**
     * View class that is designed as a basis for various reusable decorative UI elements implementations
     * @class zebkit.ui.View
     * @constructor
     */
    pkg.View = Class([
        function $prototype() {
            this.gap = 2;

            /**
             * Get left gap. The method informs UI component that uses the view as
             * a border view how much space left side of the border occupies
             * @return {Integer} a left gap
             * @method getLeft
             */

             /**
              * Get right gap. The method informs UI component that uses the view as
              * a border view how much space right side of the border occupies
              * @return {Integer} a right gap
              * @method getRight
              */

             /**
              * Get top gap. The method informs UI component that uses the view as
              * a border view how much space top side of the border occupies
              * @return {Integer} a top gap
              * @method getTop
              */

             /**
              * Get bottom gap. The method informs UI component that uses the view as
              * a border view how much space bottom side of the border occupies
              * @return {Integer} a bottom gap
              * @method getBottom
              */
            this.getRight = this.getLeft = this.getBottom = this.getTop = function() {
                return this.gap;
            };

            /**
            * Return preferred size the view desires to have
            * @method getPreferredSize
            * @return {Object}
            */
            this.getPreferredSize = function() {
                return { width  : 0,
                         height : 0 };
            };

            /**
            * The method is called to render the decorative element on the given surface of the specified
            * UI component
            * @param {CanvasRenderingContext2D} g  graphical context
            * @param {Integer} x  x coordinate
            * @param {Integer} y  y coordinate
            * @param {Integer} w  required width
            * @param {Integer} h  required height
            * @param {zebkit.ui.Panel} c an UI component on which the view
            * element has to be drawn
            * @method paint
            */
            this.paint = function(g,x,y,w,h,c) {};
        }
    ]);

    /**
     * Render class extends "zebkit.ui.View" class with a notion
     * of target object. Render stores reference  to a target that
     * the render knows how to visualize. Basically Render is an
     * object visualizer. For instance, developer can implement
     * text, image and so other objects visualizers.
     * @param {Object} target a target object to be visualized
     * with the render
     * @constructor
     * @extends zebkit.ui.View
     * @class zebkit.ui.Render
     */
    pkg.Render = Class(pkg.View, [
        function(target) {
            this.setTarget(target);
        },

        function $prototype() {
            /**
             * Target object to be visualized
             * @attribute target
             * @default null
             * @readOnly
             * @type {Object}
             */
            this.target = null;

            /**
             * Set the given target object. The method triggers "targetWasChanged(oldTarget, newTarget)"
             * execution if the method is declared. Implement the method if you need to track a target
             * object updating.
             * @method setTarget
             * @param  {Object} o a target object to be visualized
             */
            this.setTarget = function(o) {
                if (this.target !== o) {
                    var old = this.target;
                    this.target = o;
                    if (typeof this.targetWasChanged !== 'undefined') {
                        this.targetWasChanged(old, o);
                    }
                }
            };
        }
    ]);

    /**
    * Sunken border view
    * @class zebkit.ui.Sunken
    * @constructor
    * @param {String} [brightest] a brightest border line color
    * @param {String} [moddle] a middle border line color
    * @param {String} [darkest] a darkest border line color
    * @extends zebkit.ui.View
    */
    pkg.Sunken = Class(pkg.View, [
        function (brightest,middle,darkest) {
            if (arguments.length > 0) this.brightest = brightest;
            if (arguments.length > 1) this.middle    = middle;
            if (arguments.length > 2) this.darkest   = darkest;
        },

        function $prototype() {
            /**
             * Brightest border line color
             * @attribute brightest
             * @readOnly
             * @type {String}
             * @default "white"
             */

            /**
             * Middle border line color
             * @attribute middle
             * @readOnly
             * @type {String}
             * @default "gray"
             */

            /**
             * Darkest border line color
             * @attribute darkest
             * @readOnly
             * @type {String}
             * @default "black"
             */
            this.brightest = "white";
            this.middle    = "gray" ;
            this.darkest   = "black";

            this.paint = function(g,x1,y1,w,h,d){
                var x2 = x1 + w - 1, y2 = y1 + h - 1;
                g.setColor(this.middle);
                g.drawLine(x1, y1, x2 - 1, y1);
                g.drawLine(x1, y1, x1, y2 - 1);
                g.setColor(this.brightest);
                g.drawLine(x2, y1, x2, y2 + 1);
                g.drawLine(x1, y2, x2, y2);
                g.setColor(this.darkest);
                g.drawLine(x1 + 1, y1 + 1, x1 + 1, y2);
                g.drawLine(x1 + 1, y1 + 1, x2, y1 + 1);
            };
        }
    ]);

    /**
    * Etched border view
    * @class zebkit.ui.Etched
    * @constructor
    * @param {String} [brightest] a brightest border line color
    * @param {String} [moddle] a middle border line color
    * @extends zebkit.ui.View
    */
    pkg.Etched = Class(pkg.View, [
        function (brightest, middle) {
            if (arguments.length > 0) this.brightest = brightest;
            if (arguments.length > 1) this.middle    = middle;
        },

        function $prototype() {
            /**
             * Brightest border line color
             * @attribute brightest
             * @readOnly
             * @type {String}
             * @default "white"
             */

            /**
             * Middle border line color
             * @attribute middle
             * @readOnly
             * @type {String}
             * @default "gray"
             */
            this.brightest = "white";
            this.middle    = "gray" ;

            this.paint = function(g,x1,y1,w,h,d){
                var x2 = x1 + w - 1, y2 = y1 + h - 1;
                g.setColor(this.middle);
                g.drawLine(x1, y1, x1, y2 - 1);
                g.drawLine(x2 - 1, y1, x2 - 1, y2);
                g.drawLine(x1, y1, x2, y1);
                g.drawLine(x1, y2 - 1, x2 - 1, y2 - 1);

                g.setColor(this.brightest);
                g.drawLine(x2, y1, x2, y2);
                g.drawLine(x1 + 1, y1 + 1, x1 + 1, y2 - 1);
                g.drawLine(x1 + 1, y1 + 1, x2 - 1, y1 + 1);
                g.drawLine(x1, y2, x2 + 1, y2);
            };
        }
    ]);

    /**
    * Raised border view
    * @class zebkit.ui.Raised
    * @param {String} [brightest] a brightest border line color
    * @param {String} [middle] a middle border line color
    * @constructor
    * @extends zebkit.ui.View
    */
    pkg.Raised = Class(pkg.View, [
        function(brightest, middle) {
            /**
             * Brightest border line color
             * @attribute brightest
             * @readOnly
             * @type {String}
             * @default "white"
             */

            /**
             * Middle border line color
             * @attribute middle
             * @readOnly
             * @type {String}
             * @default "gray"
             */

            if (arguments.length > 0) this.brightest = brightest;
            if (arguments.length > 1) this.middle    = middle;
        },

        function $prototype() {
            this.brightest = "white";
            this.middle    = "gray";

            this.paint = function(g,x1,y1,w,h,d){
                var x2 = x1 + w - 1, y2 = y1 + h - 1;
                g.setColor(this.brightest);
                g.drawLine(x1, y1, x2, y1);
                g.drawLine(x1, y1, x1, y2);
                g.setColor(this.middle);
                g.drawLine(x2, y1, x2, y2 + 1);
                g.drawLine(x1, y2, x2, y2);
            };
        }
    ]);

    /**
    * Dotted border view
    * @class zebkit.ui.Dotted
    * @param {String} [c] the dotted border color
    * @constructor
    * @extends zebkit.ui.View
    */
    pkg.Dotted = Class(pkg.View, [
        function (c){
            if (arguments.length > 0) this.color = c;
        },

        function $prototype() {
            /**
             * @attribute color
             * @readOnly
             * @type {String}
             * @default "black"
             */
            this.color = "black";

            this.paint = function(g,x,y,w,h,d){
                g.setColor(this.color);
                g.drawDottedRect(x, y, w, h);
            };
        }
    ]);


    pkg.Shape = Class(pkg.View, [
        function (c, w){
            if (arguments.length > 0) this.color = c;
            if (arguments.length > 1) this.width = this.gap = w;
        },

        function $prototype() {
            this.color = "gray";
            this.gap   = this.width = 1;

            this.paint = function(g,x,y,w,h,d) {
                if (g.lineWidth !== this.width) {
                    g.lineWidth = this.width;
                }

                this.outline(g,x,y,w,h,d);
                g.setColor(this.color);
                g.stroke();
            };
        }
    ]);

    pkg.TriangleShape = Class(pkg.Shape, [
        function $prototype() {
            this.outline = function(g,x,y,w,h,d) {
                g.beginPath();
                w -= 2 * this.width;
                h -= 2 * this.width;
                g.moveTo(x + w - 1, y);
                g.lineTo(x + w - 1, y + h - 1);
                g.lineTo(x, y + h - 1);
                g.closePath();
                return true;
            };
        }
    ]);

    /**
     * Border view. Can be used to render CSS-like border. Border can be applied to any
     * zebkit UI component by calling setBorder method:

            // create label component
            var lab = new zebkit.ui.Label("Test label");

            // set red border to the label component
            lab.setBorder(new zebkit.ui.Border("red"));

     * @param  {String}  [c] border color
     * @param  {Integer} [w] border width
     * @param  {Integer} [r] border corners radius
     * @constructor
     * @class zebkit.ui.Border
     * @extends zebkit.ui.View
     */
    pkg.Border = Class(pkg.View, [
        function(c, w, r) {
            if (arguments.length > 0) this.color = c;
            if (arguments.length > 1) this.width = this.gap = w;
            if (arguments.length > 2) this.radius = r;
        },

        function $prototype() {
            /**
             * Border color
             * @attribute color
             * @readOnly
             * @type {String}
             * @default "gray"
             */

            /**
             * Border line width
             * @attribute width
             * @readOnly
             * @type {Integer}
             * @default 1
             */

            /**
             * Border radius
             * @attribute radius
             * @readOnly
             * @type {Integer}
             * @default 0
             */

            this.color  = "gray";
            this.gap    = this.width = 1;
            this.radius = 0;
            this.sides  = 15;

            this.setSides = function(top, left, bottom, right) {
                this.sides = 0;
                for(var i = 0; i < arguments.length; i++) {
                    if (arguments[i] === "top") this.sides  |= 1;
                    else if (arguments[i] === "left"  ) this.sides  |= 2;
                    else if (arguments[i] === "bottom") this.sides  |= 4;
                    else if (arguments[i] === "right" ) this.sides  |= 8;
                }

                return this;
            };

            this.paint = function(g,x,y,w,h,d){
                if (this.color !== null && this.width > 0) {
                    var ps = g.lineWidth;

                    if (g.lineWidth !== this.width) {
                        g.lineWidth = this.width;
                    }

                    if (this.radius > 0) {
                        this.outline(g,x,y,w,h, d);
                        g.setColor(this.color);
                        g.stroke();
                    } else if (this.sides !== 15) {
                        g.setColor(this.color);
                        // top
                        if ((this.sides & 1) > 0) {
                            g.drawLine(x, y, x + w, y, this.width);
                        }

                        // right
                        if ((this.sides & 8) > 0) {
                            g.drawLine(x + w - this.width, y, x + w - this.width, y + h, this.width);
                        }

                        // bottom
                        if ((this.sides & 4) > 0) {
                            g.drawLine(x, y + h - this.width, x + w, y + h - this.width, this.width);
                        }

                        // left
                        if ((this.sides & 2) > 0) {
                            g.drawLine(x, y, x, y + h, this.width);
                        }
                    } else {
                        var dt = this.width / 2;
                        g.beginPath();
                        g.rect(x + dt, y + dt, w - this.width, h - this.width);
                        g.closePath();
                        g.setColor(this.color);
                        g.stroke();
                    }

                    if (g.lineWidth !== ps) g.lineWidth = ps;
                }
            };

            /**
             * Defines border outline for the given 2D Canvas context
             * @param  {CanvasRenderingContext2D} g
             * @param  {Integer} x x coordinate
             * @param  {Integer} y y coordinate
             * @param  {Integer} w required width
             * @param  {Integer} h required height
             * @param  {Integer} d target UI component
             * @method outline
             * @return {Boolean} true if the outline has to be applied as an
             * UI component shape
             */
            this.outline = function(g,x,y,w,h,d) {
                if (this.radius <= 0) {
                    return false;
                }

                var r  = this.radius,
                    dt = this.width / 2,
                    xx = x + w - dt,
                    yy = y + h - dt;

                x += dt;
                y += dt;

                // !!! this code can work improperly in IE 10 in Vista !
                // g.beginPath();
                // g.moveTo(x+r, y);
                // g.arcTo(xx, y, xx, yy, r);
                // g.arcTo(xx, yy, x, yy, r);
                // g.arcTo(x, yy, x, y, r);
                // g.arcTo(x, y, xx, y, r);
                // g.closePath();
                // return true;

                g.beginPath();
                g.moveTo(x + r, y);
                g.lineTo(xx - r, y);
                g.quadraticCurveTo(xx, y, xx, y + r);
                g.lineTo(xx, yy  - r);
                g.quadraticCurveTo(xx, yy, xx - r, yy);
                g.lineTo(x + r, yy);
                g.quadraticCurveTo(x, yy, x, yy - r);
                g.lineTo(x, y + r);
                g.quadraticCurveTo(x, y, x + r, y);
                g.closePath();
                return true;
            };
        }
    ]);

    /**
     * Round border view.
     * @param  {String}  [col] border color. Use null as the
     * border color value to prevent painting of the border
     * @param  {Integer} [width] border width
     * @constructor
     * @class zebkit.ui.RoundBorder
     * @extends zebkit.ui.View
     */
    pkg.RoundBorder = Class(pkg.View, [
        function(col, width) {
            if (arguments.length > 0) {
                if (zebkit.isNumber(col)) this.width = col;
                else {
                    this.color = col;
                    if (zebkit.isNumber(width)) this.width = width;
                }
            }
            this.gap = this.width;
        },

        function $prototype() {
            /**
             * Border width
             * @attribute width
             * @readOnly
             * @type {Integer}
             * @default 1
             */
            this.width = 1;

            /**
             * Border color
             * @attribute color
             * @readOnly
             * @type {String}
             * @default null
             */
            this.color = null;

            /**
             * Color to fill the inner area surrounded with the round border.
             * @attribute fillColor
             * @type {String}
             * @default null
             */
            this.fillColor = null;

            this.paint = function(g,x,y,w,h,d) {
                if (this.color !== null && this.width > 0) {
                    this.outline(g,x,y,w,h,d);
                    g.setColor(this.color);
                    g.stroke();
                    if (this.fillColor !== null) {
                       g.setColor(this.fillColor);
                       g.fill();
                    }
                }
            };

            this.outline = function(g,x,y,w,h,d) {
                g.lineWidth = this.width;
                if (w === h) {
                    g.beginPath();
                    g.arc(Math.floor(x + w / 2) + (w % 2 === 0 ? 0 :0.5),
                          Math.floor(y + h / 2) + (h % 2 === 0 ? 0 :0.5),
                          Math.floor((w - g.lineWidth)/2), 0, 2 * Math.PI, false);
                    g.closePath();
                } else {
                    g.ovalPath(x,y,w,h);
                }
                return true;
            };

            this.getPreferredSize = function() {
                var s = this.width * 8;
                return  {
                    width : s, height : s
                };
            };
        }
    ]);

    /**
     *  UI component render class. Renders the given target UI component
     *  on the given surface using the specified 2D context
     *  @param {zebkit.ui.Panel} [target] an UI component to be rendered
     *  @class zebkit.ui.CompRender
     *  @constructor
     *  @extends zebkit.ui.Render
     */
    pkg.CompRender = Class(pkg.Render, [
        function $prototype() {
            /**
             * Get preferred size of the render. The method doesn't calculates
             * preferred size it simply calls the target component "getPreferredSize"
             * method.
             * @method getPreferredSize
             * @return {Object} a preferred size
             *
             *      {width:<Integer>, height: <Integer>}
             */
            this.getPreferredSize = function(){
                return this.target === null || this.target.isVisible === false ? { width:0, height:0 }
                                                                               : this.target.getPreferredSize();
            };

            this.paint = function(g,x,y,w,h,d){
                var c = this.target;
                if (c !== null && c.isVisible) {
                    var prevW = -1, prevH = 0, parent = null;
                    if (w !== c.width || h !== c.height) {

                        if (c.getCanvas() !== null) {
                            parent = c.parent;
                            c.parent = null;
                        }

                        prevW = c.width;
                        prevH = c.height;
                        c.setSize(w, h);
                    }

                    // validate should be done here since setSize can be called
                    // above
                    c.validate();
                    g.translate(x, y);

                    try {
                        c.paintComponent(g);
                    } catch(e) {
                        if (parent !== null) {
                            c.parent = parent;
                        }
                        g.translate(-x, -y);
                        throw e;
                    }
                    g.translate(-x, -y);


                    if (prevW >= 0){
                        c.setSize(prevW, prevH);
                        if (parent !== null) {
                            c.parent = parent;
                        }
                        c.validate();
                    }
                }
            };
        }
    ]);

    /**
    * Vertical or horizontal linear gradient view
    * @param {String} startColor start color
    * @param {String} endColor end color
    * @param {String} [type] type of gradient
    *  "vertical" or "horizontal"
    * @constructor
    * @class zebkit.ui.Gradient
    * @extends zebkit.ui.View
    */
    pkg.Gradient = Class(pkg.View, [
        function() {
            /**
             * Gradient orientation: vertical or horizontal
             * @attribute orient
             * @readOnly
             * @default "vertical"
             * @type {String}
             */

            /**
             * Gradient start and stop colors
             * @attribute colors
             * @readOnly
             * @type {Array}
             */

            this.colors = Array.prototype.slice.call(arguments, 0);
            if (arguments.length > 2) {
                this.orient = arguments[arguments.length - 1];
                this.colors.pop();
            }
        },

        function $prototype() {
            this.orient = "vertical";
            this.gradient = null;
            this.gy2 = this.gy1 = this.gx2 = this.gx1 = 0;

            this.paint = function(g,x,y,w,h,dd){
                var d = (this.orient === "horizontal" ? [0,1]: [1,0]),
                    x1 = x * d[1],
                    y1 = y * d[0],
                    x2 = (x + w - 1) * d[1],
                    y2 = (y + h - 1) * d[0];

                if (this.gradient === null  || this.gx1 !== x1 ||
                    this.gx2 !== x2         || this.gy1 !== y1 ||
                    this.gy2 !== y2                              )
                {
                    this.gx1 = x1;
                    this.gx2 = x2;
                    this.gy1 = y1;
                    this.gy2 = y2;

                    this.gradient = g.createLinearGradient(x1, y1, x2, y2);
                    for(var i = 0; i < this.colors.length; i++) {
                        this.gradient.addColorStop(i, this.colors[i].toString());
                    }
                }

                g.fillStyle = this.gradient;
                g.fillRect(x, y, w, h);
            };
        }
    ]);

    /**
    * Radial gradient view
    * @param {String} startColor a start color
    * @param {String} stopColor a stop color
    * @constructor
    * @class zebkit.ui.Radial
    * @extends zebkit.ui.View
    */
    pkg.Radial = Class(pkg.View, [
        function() {
            this.colors = Array.prototype.slice.call(arguments, 0);
        },

        function $prototype() {
            this.gradient = null;

            this.paint = function(g,x,y,w,h,d){
                var cx1 = Math.floor(w / 2), cy1 = Math.floor(h / 2);
                // TODO: optimize this

                this.gradient = g.createRadialGradient(cx1, cy1, 10, cx1, cy1, w > h ? w : h);

                for(var i=0; i < this.colors.length;i++) {
                    this.gradient.addColorStop(i, this.colors[i].toString());
                }
                g.fillStyle = this.gradient;
                g.fillRect(x, y, w, h);
            };
        }
    ]);

    /**
    * Image render. Render an image target object or specified area of
    * the given target image object.
    * @param {Image} img the image to be rendered
    * @param {Integer} [x] a x coordinate of the rendered image part
    * @param {Integer} [y] a y coordinate of the rendered image part
    * @param {Integer} [w] a width of the rendered image part
    * @param {Integer} [h] a height of the rendered image part
    * @constructor
    * @class zebkit.ui.Picture
    * @extends zebkit.ui.Render
    */
    pkg.Picture = Class(pkg.Render, [
        function(img,x,y,w,h) {
            /**
             * A x coordinate of the image part that has to be rendered
             * @attribute x
             * @readOnly
             * @type {Integer}
             * @default 0
             */

            /**
             * A y coordinate of the image part that has to be rendered
             * @attribute y
             * @readOnly
             * @type {Integer}
             * @default 0
             */

            /**
             * A width  of the image part that has to be rendered
             * @attribute width
             * @readOnly
             * @type {Integer}
             * @default 0
             */

            /**
             * A height  of the image part that has to be rendered
             * @attribute height
             * @readOnly
             * @type {Integer}
             * @default 0
             */

            this.setTarget(img);
            if (arguments.length > 4) {
                this.x = x;
                this.y = y;
                this.width  = w;
                this.height = h;
            }
        },

        function $prototype() {
            this.x = this.y = this.width = this.height = 0;

            this.paint = function(g,x,y,w,h,d) {
                if (this.target !== null && this.target.complete === true && this.target.naturalWidth > 0 && w > 0 && h > 0){
                    if (this.width > 0) {
                        g.drawImage(this.target, this.x, this.y,
                                    this.width, this.height, x, y, w, h);
                    } else {
                        g.drawImage(this.target, x, y, w, h);
                    }
                }
            };

            this.getPreferredSize = function() {
                var img = this.target;
                return (img === null ||
                        img.naturalWidth <= 0 ||
                        img.complete !== true) ? { width:0, height:0 }
                                               : (this.width > 0) ? { width:this.width, height:this.height }
                                                                  : { width:img.width, height:img.height };
            };
        }
    ]);

    /**
    * Pattern render.
    * @class zebkit.ui.Pattern
    * @param {Image} [img] an image to be used as the pattern
    * @constructor
    * @extends zebkit.ui.Render
    */
    pkg.Pattern = Class(pkg.Render, [
        function $prototype() {
            /**
             * Buffered pattern
             * @type {Pattern}
             * @protected
             * @attribute pattern
             * @readOnly
             */
            this.pattern = null;

            this.paint = function(g,x,y,w,h,d) {
                if (this.pattern === null) {
                    this.pattern = g.createPattern(this.target, 'repeat');
                }
                g.beginPath();
                g.rect(x, y, w, h);
                g.closePath();
                g.fillStyle = this.pattern;
                g.fill();
            };

            this.targetWasChanged = function(o, n) {
                this.pattern = null;
            };
        }
    ]);

    /**
    * Composite view. The view allows developers to combine number of
    * views and renders its together.
    * @class zebkit.ui.CompositeView
    * @param {Object} ...views number of views to be composed.
    * @constructor
    * @extends zebkit.ui.View
    */
    pkg.CompositeView = Class(pkg.View, [
        function() {
            /**
             * Composed views array.
             * @attribute views
             * @type {Array}
             * @protected
             * @readOnly
             */
            this.views = [];

            var args = arguments.length === 1 ? arguments[0] : arguments;
            for(var i = 0; i < args.length; i++) {
                this.views[i] = pkg.$view(args[i]);
                this.$recalc(this.views[i]);
            }
        },

        function $prototype() {
            /**
             * Left padding
             * @readOnly
             * @private
             * @attribute left
             * @type {Integer}
             */

            /**
             * Right padding
             * @private
             * @readOnly
             * @attribute right
             * @type {Integer}
             */

            /**
             * Top padding
             * @private
             * @readOnly
             * @attribute top
             * @type {Integer}
             */

            /**
             * Bottom padding
             * @readOnly
             * @private
             * @attribute bottom
             * @type {Integer}
             */
            this.left = this.right = this.bottom = this.top = this.height = this.width = 0;

            this.getTop = function() {
                return this.top;
            };

            this.getLeft = function() {
                return this.left;
            };

            this.getBottom = function () {
                return this.bottom;
            };

            this.getRight = function () {
                return this.right;
            };

            this.getPreferredSize = function (){
                return { width:this.width, height:this.height};
            };

            this.$recalc = function(v) {
                var b = 0, ps = v.getPreferredSize();
                if (typeof v.getLeft !== 'undefined') {
                    b = v.getLeft();
                    if (b > this.left) this.left = b;
                }

                if (typeof v.getRight !== 'undefined') {
                    b = v.getRight();
                    if (b > this.right) this.right = b;
                }

                if (typeof v.getTop !== 'undefined') {
                    b = v.getTop();
                    if (b > this.top) this.top = b;
                }

                if (typeof v.getBottom !== 'undefined') {
                    b = v.getBottom();
                    if (b > this.bottom) this.bottom = b;
                }


                if (ps.width > this.width) this.width = ps.width;
                if (ps.height > this.height) this.height = ps.height;

                if (typeof this.voutline === 'undefined' && typeof v.outline !== 'undefined') {
                    this.voutline = v;
                }
            };

            /**
             * Iterate over composed views.
             * @param  {Function} f callback that is called for every iterated view. The callback
             * gets a view index and view itself as its argument.
             * @method iterate
             */
            this.iterate = function(f) {
                for(var i = 0; i < this.views.length; i++) {
                    f.call(this, i, this.views[i]);
                }
            };

            this.recalc = function() {
                this.left = this.right = this.bottom = this.top = this.height = this.width = 0;
                this.iterate(function(k, v) {
                    this.$recalc(v);
                });
            };

            this.ownerChanged = function(o) {
                this.iterate(function(k, v) {
                    if (v !== null && typeof v.ownerChanged !== 'undefined') {
                        v.ownerChanged(o);
                    }
                });
            };

            this.paint = function(g,x,y,w,h,d) {
                var ctx = false;
                for(var i = 0; i < this.views.length; i++) {
                    var v = this.views[i];
                    v.paint(g, x, y, w, h, d);

                    if (i < this.views.length - 1 && typeof v.outline === 'function' && v.outline(g, x, y, w, h, d)) {
                        if (ctx === false) {
                            g.save();
                            ctx = true;
                        }
                        g.clip();
                    }
                }

                if (ctx === true) {
                    g.restore();
                }
            };

            /**
             * Return number of composed views.
             * @return {Integer} number of composed view.
             * @method  count
             */
            this.count = function() {
                return this.views.length;
            };

            this.outline = function(g,x,y,w,h,d) {
                return typeof this.voutline !== 'undefined' && this.voutline.outline(g,x,y,w,h,d);
            };
        }
    ]);

    /**
    * ViewSet view. The view set is a special view container that includes
    * number of views accessible by a key and allows only one view be active
    * in a particular time. Active is view that has to be rendered. The view
    * set can be used to store number of decorative elements where only one
    * can be rendered depending from an UI component state.
    * @param {Object} args object that represents views instances that have
    * to be included in the ViewSet
    * @constructor
    * @class zebkit.ui.ViewSet
    * @extends zebkit.ui.CompositeView
    */
    pkg.ViewSet = Class(pkg.CompositeView, [
        function(args) {
            if (arguments.length === 0 || args === null) {
                throw new Error("" + args);
            }

            /**
             * Views set
             * @attribute views
             * @type Object
             * @default {}
             * @readOnly
            */
            this.views = {};
            this.$size = 0;

            for(var k in args) {
                this.views[k] = pkg.$view(args[k]);
                this.$size++;
                if (this.views[k] !== null) {
                    this.$recalc(this.views[k]);
                }
            }
            this.activate("*");
        },

        function $prototype() {
            /**
             * Active in the set view
             * @attribute activeView
             * @type View
             * @default null
             * @readOnly
            */
            this.activeView = null;

            this.paint = function(g,x,y,w,h,d) {
                if (this.activeView !== null) {
                    this.activeView.paint(g, x, y, w, h, d);
                }
            };

            this.count = function() {
                return $size;
            };

            /**
             * Activate the given view from the given set.
             * @param  {String} id a key of a view from the set to be activated. Pass
             * null to make current view to undefined state
             * @return {Boolean} true if new view has been activated, false otherwise
             * @method activate
             */
            this.activate = function(id) {
                var old = this.activeView;

                if (id === null) {
                    return (this.activeView = null) !== old;
                }

                if (this.views.hasOwnProperty(id)) {
                    return (this.activeView = this.views[id]) !== old;
                }

                if (id.length > 1 && id[0] !== '*' && id[id.length - 1] !== '*') {
                    var i = id.indexOf('.');
                    if (i > 0) {
                        var k = id.substring(0, i + 1) + '*';
                        if (this.views.hasOwnProperty(k)) {
                            return (this.activeView = this.views[k]) !== old;
                        } else {
                            k = "*" + id.substring(i);
                            if (this.views.hasOwnProperty(k)) {
                                return (this.activeView = this.views[k]) !== old;
                            }
                        }
                    }
                }

                return this.views.hasOwnProperty("*") ? (this.activeView = this.views["*"]) !== old
                                                      : false;
            };

            this.iterate = function(f) {
                for(var k in this.views) {
                    f.call(this, k, this.views[k]);
                }
            };
        }
    ]);

    /**
     * Line view.
     * @class  zebkit.ui.Line
     * @extends {zebkit.ui.View}
     * @constructor
     * @param  {String} [side] a side of rectangular area where the line has to be rendered. Use
     * "left", "top", "right" or "bottom" as the parameter value
     * @param  {String} [color] a line color
     * @param  {Integer} [width] a line width
     */
    pkg.LineView = Class(pkg.View, [
        function(side, color, lineWidth) {
            if (arguments.length > 0) this.side      = side;
            if (arguments.length > 1) this.color     = color;
            if (arguments.length > 2) this.lineWidth = lineWidth;
        },

        function $prototype() {
            /**
             * Side the line has to be rendered
             * @attribute side
             * @type {String}
             * @default "top"
             * @readOnly
             */
            this.side = "top";

            /**
             * Line color
             * @attribute color
             * @type {String}
             * @default "black"
             * @readOnly
             */
            this.color = "black";

            /**
             * Line width
             * @attribute lineWidth
             * @type {Integer}
             * @default 1
             * @readOnly
             */
            this.lineWidth = 1;

            this.paint = function(g,x,y,w,h,t) {
                g.setColor(this.color);
                g.beginPath();
                g.lineWidth = this.lineWidth;

                var d = this.lineWidth / 2;
                if (this.side === "top") {
                    g.moveTo(x, y + d);
                    g.lineTo(x + w - 1, y + d);
                } else if (this.side === "bottom") {
                    g.moveTo(x, y + h - d);
                    g.lineTo(x + w - 1, y + h - d);
                }
                g.stroke();
            };

            this.getPreferredSize = function() {
                return {
                    width  : this.lineWidth,
                    height : this.lineWidth
                };
            };
        }
    ]);

    /**
     * Arrow view. Tye view can be use to render triangle arrow element to one of the
     * following direction: "top", "left", "bottom", "right".
     * @param  {String} d an arrow view direction.
     * @param  {String} col an arrow view color.
     * @param  {Integer} w an arrow view width.
     * @param  {Integer} h an arrow view height.
     * @constructor
     * @class zebkit.ui.ArrowView
     * @extends {zebkit.ui.View}
     */
    pkg.ArrowView = Class(pkg.View, [
        function (d, col, w, h) {
            if (arguments.length > 0) this.direction = d;
            if (arguments.length > 1) this.color = col;
            if (arguments.length > 2) this.width = this.height = w;
            if (arguments.length > 3) this.height = h;
        },

        function $prototype() {
            /**
             *  Line width.
             *  @attribute lineWidth
             *  @type {Integer}
             *  @default 1
             */
            this.lineWidth = 1;

            /**
             *  Indicates if the arrow has to be filled with the arrow line color.
             *  @attribute fill
             *  @type {Boolean}
             *  @default true
             */
            this.fill = true;

            this.gap = 0;

            /**
             * Arrow color
             * @attribute color
             * @type {String}
             * @default "black"
             */
            this.color = "black";

            /**
             * Arrow width.
             * @attribute width
             * @type {Integer}
             * @default 8
             */

             /**
              * Arrow height.
              * @attribute height
              * @type {Integer}
              * @default 8
              */
            this.width = this.height = 8;

            /**
             * Arrow direction.
             * @attribute direction
             * @type {String}
             * @default "bottom"
             */
            this.direction = "bottom";

            this.outline = function(g, x, y, w, h, d) {
                x += this.gap;
                y += this.gap;
                w -= this.gap * 2;
                h -= this.gap * 2;

                var dt = this.lineWidth / 2,
                    w2 = Math.round(w / 2) - (w % 2 === 0 ? 0 : dt),
                    h2 = Math.round(h / 2) - (h % 2 === 0 ? 0 : dt);

                g.beginPath();

                if ("bottom" === this.direction) {
                    g.moveTo(x, y + dt);
                    g.lineTo(x + w - 1, y + dt);
                    g.lineTo(x + w2, y + h - dt);
                    g.lineTo(x + dt, y + dt);
                } else if ("top" === this.direction) {
                    g.moveTo(x, y + h - dt);
                    g.lineTo(x + w - 1, y + h - dt);
                    g.lineTo(x + w2, y);
                    g.lineTo(x + dt, y + h - dt);
                } else if ("left" === this.direction) {
                    g.moveTo(x + w - dt, y);
                    g.lineTo(x + w - dt, y + h - 1);
                    g.lineTo(x, y + h2);
                    g.lineTo(x + w + dt, y);
                } else if ("right" === this.direction) {
                    g.moveTo(x + dt, y);
                    g.lineTo(x + dt, y + h - 1);
                    g.lineTo(x + w, y + h2);
                    g.lineTo(x - dt, y);
                } else {
                    throw new Error("" + this.direction);
                }

                return true;
            };

            this.setGap = function(gap) {
                this.gap = gap;
                return this;
            };

            this.paint = function(g, x, y, w, h, d) {
                this.outline(g, x, y, w, h, d);
                g.setColor(this.color);
                g.lineWidth = this.lineWidth;

                if (this.fill === true) {
                    g.fill();
                } else {
                    g.stroke();
                }
            };

            this.getPreferredSize = function () {
                return { width  : this.width  + this.gap * 2,
                         height : this.height + this.gap * 2 };
            };
        }
    ]);

    /**
     * Base class to build text render implementations.
     * @class  zebkit.ui.BaseTextRender
     * @constructor
     * @param  {Object} [target]  target component to be rendered
     * @extends {zebkit.ui.Render}
     */
    pkg.BaseTextRender = Class(pkg.Render, [
        function $clazz() {
            this.font          =  pkg.font;
            this.color         = "gray";
            this.disabledColor = "white";
        },

        function $prototype(clazz) {
            /**
             * UI component that holds the text render
             * @attribute owner
             * @default null
             * @readOnly
             * @protected
             * @type {zebkit.ui.Panel}
             */
            this.owner = null;

            /**
             * Line indention
             * @attribute lineIndent
             * @type {Integer}
             * @default 1
             */
            this.lineIndent = 1;

            // implement position metric methods
            this.getMaxOffset = this.getLineSize = this.getLines = function() {
                return 0;
            };

            /**
             * Set the rendered text font.
             * @param  {String|zebkit.ui.Font} f a font as CSS string or
             * zebkit.ui.Font class instance
            *  @chainable
             * @method setFont
             */
            this.setFont = function(f) {
                if (zebkit.instanceOf(f, pkg.Font) === false && f !== null) {
                    f = zebkit.newInstance(pkg.Font, arguments);
                }

                if (f != this.font) {
                    this.font = f;

                    if (this.owner !== null && this.owner.isValid === true) {
                        this.owner.invalidate();
                    }

                    if (typeof this.invalidate !== 'undefined') {
                        this.invalidate();
                    }
                }
                return this;
            };

            /**
             * Resize font
             * @param  {String|Integer} size a new size of the font
             * @chainable
             * @method resizeFont
             */
            this.resizeFont = function(size) {
                return this.setFont(this.font.resize(size));
            };

            this.restyleFont = function(style) {
                return this.setFont(this.font.restyle(style));
            };

            this.getLineHeight = function() {
                return this.font.height;
            };

            /**
             * Set rendered text color
             * @param  {String} c a text color
             * @method setColor
             * @chainable
             */
            this.setColor = function(c) {
                if (c != this.color) {
                    this.color = c.toString();
                }
                return this;
            };

            /**
             * Called whenever an owner UI component has been changed
             * @param  {zebkit.ui.Panel} v a new owner UI component
             * @method ownerChanged
             */
            this.ownerChanged = function(v) {
                this.owner = v;
            };

            this.targetWasChanged = function(o, n) {
                if (this.owner !== null && this.owner.isValid) {
                    this.owner.invalidate();
                }

                if (typeof this.invalidate !== 'undefined') {
                    this.invalidate();
                }
            };
        }
    ]);

    /**
     * Lightweight implementation of single line string render. The render requires
     * a simple string as a target object.
     * @param {String} str a string to be rendered
     * @param {zebkit.ui.Font} [font] a text font
     * @param {String} [color] a text color
     * @constructor
     * @extends {zebkit.ui.BaseTextRender}
     * @class zebkit.ui.StringRender
     */
    pkg.StringRender = Class(pkg.BaseTextRender, [
        function $prototype() {
            this.stringWidth = -1;

            // for the sake of speed up construction of the widely used render
            // declare it none standard way.
            this[''] = function(txt, font, color) {
                this.setTarget(txt);

                /**
                 * Font to be used to render the target string
                 * @attribute font
                 * @readOnly
                 * @type {zebkit.ui.Font}
                 */
                this.font = arguments.length > 1 ? font : this.clazz.font;

                /**
                 * Color to be used to render the target string
                 * @readOnly
                 * @attribute color
                 * @type {String}
                 */
                this.color = arguments.length > 2 ? color : this.clazz.color;
            };

            // implement position metric methods
            this.getMaxOffset = function() {
                return this.target.length;
            };

            this.getLineSize = function(l) {
                return this.target.length + 1;
            };

            this.getLines = function() {
                return 1;
            };

            this.calcLineWidth = function() {
                if (this.stringWidth < 0) {
                    this.stringWidth = this.font.stringWidth(this.target);
                }
                return this.stringWidth;
            };

            this.invalidate = function() {
                this.stringWidth = -1;
            };

            this.paint = function(g,x,y,w,h,d) {
                // save a few milliseconds
                if (this.font.s !== g.font) {
                    g.setFont(this.font);
                }

                if (d !== null && typeof d.getStartSelection !== 'undefined') {
                    var startSel = d.getStartSelection(),
                        endSel   = d.getEndSelection();

                    if (startSel !== null && endSel !== null && startSel.col !== endSel.col && d.selectionView !== null) {
                        d.selectionView.paint(g, x + this.font.charsWidth(this.target, 0, startSel.col),
                                                 y,
                                                 this.font.charsWidth(this.target,
                                                                      startSel.col,
                                                                      endSel.col - startSel.col),
                                                 this.getLineHeight(), d);
                    }
                }

                // save a few milliseconds
                if (this.color !== g.fillStyle) {
                    g.fillStyle = this.color;
                }

                if (d !== null && d.isEnabled === false) {
                    g.fillStyle = d !== null &&
                                  d.disabledColor !== null &&
                                  typeof d.disabledColor !== 'undefined'  ? d.disabledColor
                                                                          : this.clazz.disabledColor;
                }

                g.fillText(this.target, x, y);
            };

            /**
             * Return a string that is rendered by this class
             * @return  {String} a string
             * @method getValue
             */
            this.getValue = function(){
                return this.target;
            };

            /**
             * Set the string to be rendered
             * @param  {String} s a string
             * @method setValue
             */
            this.setValue = function(s) {
                this.setTarget(s);
            };

            this.getLine = function(l) {
                if (l < 0 || l > 1) {
                    throw new RangeError();
                }
                return this.target;
            };

            this.getPreferredSize = function() {
                if (this.stringWidth < 0) {
                    this.stringWidth = this.font.stringWidth(this.target);
                }

                return {
                    width: this.stringWidth,
                    height: this.font.height
                };
            };
        }
    ]);

    /**
     * Text render that expects and draws a text model or a string as its target
     * @class zebkit.ui.TextRender
     * @constructor
     * @extends zebkit.ui.BaseTextRender
     * @uses zebkit.util.Position.Metric
     * @param  {String|zebkit.data.TextModel} text a text as string or text model object
     */
    pkg.TextRender = Class(pkg.BaseTextRender, zebkit.util.Position.Metric, [
        function $prototype() {
            // speed up constructor by avoiding super execution since
            // text render is one of the most used class
            this[''] = function(text) {
                /**
                 * Text color
                 * @attribute color
                 * @type {String}
                 * @default zebkit.ui.TextRender.color
                 * @readOnly
                 */
                this.color = this.clazz.color;

                /**
                 * Text font
                 * @attribute font
                 * @type {String|zebkit.ui.Font}
                 * @default zebkit.ui.TextRender.font
                 * @readOnly
                 */
                this.font = this.clazz.font;

                this.textWidth = this.textHeight = this.startInvLine = this.invLines = 0;

                //!!!
                //   since text render is widely used structure we do slight hack -
                //   don't call parent constructor
                //!!!
                this.setTarget(zebkit.isString(text) ? new zebkit.data.Text(text) : text);
            };

            /**
             * Get number of lines of target text
             * @return   {Integer} a number of line in the target text
             * @method getLines
             */
            this.getLines = function() {
                return this.target.getLines();
            };

            this.getLineSize = function(l) {
                return this.target.getLine(l).length + 1;
            };

            this.getMaxOffset = function() {
                return this.target.getTextLength();
            };

            /**
             * Paint the specified text line
             * @param  {CanvasRenderingContext2D} g graphical 2D context
             * @param  {Integer} x x coordinate
             * @param  {Integer} y y coordinate
             * @param  {Integer} line a line number
             * @param  {zebkit.ui.Panel} d an UI component on that the line has to be rendered
             * @method paintLine
             */
            this.paintLine = function(g,x,y,line,d) {
                g.fillText(this.getLine(line), x, y);
            };

            /**
             * Get text line by the given line number
             * @param  {Integer} r a line number
             * @return {String} a text line
             * @method getLine
             */
            this.getLine = function(r) {
                return this.target.getLine(r);
            };

            /**
             * Return a string that is rendered by this class
             * @return  {String} a string
             * @method getValue
             */
            this.getValue = function(){
                return this.target === null ? null : this.target.getValue();
            };

            /**
             * Set the text model content
             * @param  {String} s a text as string object
             * @method setValue
             */
            this.setValue = function (s) {
                this.target.setValue(s);
            };

            /**
             * Get the given text line width in pixels
             * @param  {Integer} line a text line number
             * @return {Integer} a text line width in pixels
             * @method lineWidth
             */
            this.calcLineWidth = function(line){
                if (this.invLines > 0) this.recalc();
                return this.target.$lineTags(line).$lineWidth;
            };

            /**
             * Called every time the target text metrics has to be recalculated
             * @method recalc
             */
            this.recalc = function() {
                if (this.invLines > 0 && this.target !== null){
                    var model = this.target, i = 0;
                    if (this.invLines > 0) {
                        for(i = this.startInvLine + this.invLines - 1; i >= this.startInvLine; i--) {
                            model.$lineTags(i).$lineWidth = this.font.stringWidth(this.getLine(i));
                        }
                        this.startInvLine = this.invLines = 0;
                    }

                    this.textWidth = 0;
                    var size = model.getLines();
                    for(i = 0; i < size; i++){
                        var len = model.$lineTags(i).$lineWidth;
                        if (len > this.textWidth) {
                            this.textWidth = len;
                        }
                    }
                    this.textHeight = this.getLineHeight() * size + (size - 1) * this.lineIndent;
                }
            };

            /**
             * Text model update listener handler
             * @param  {zebkit.data.TextModel} src text model object
             * @param  {Boolean} b
             * @param  {Integer} off an offset starting from that
             * the text has been updated
             * @param  {Integer} size a size (in character) of text part that
             * has been updated
             * @param  {Integer} ful a first affected by the given update line
             * @param  {Integer} updatedLines a number of text lines that have
             * been affected by text updating
             * @method textUpdated
             */
            this.textUpdated = function(src,b,off,size,ful,updatedLines){
                if (b === false) {
                    if (this.invLines > 0) {
                        var p1 = ful - this.startInvLine,
                            p2 = this.startInvLine + this.invLines - ful - updatedLines;
                        this.invLines = ((p1 > 0) ? p1 : 0) + ((p2 > 0) ? p2 : 0) + 1;
                        this.startInvLine = this.startInvLine < ful ? this.startInvLine : ful;
                    } else {
                        this.startInvLine = ful;
                        this.invLines = 1;
                    }

                    if (this.owner !== null && this.owner.isValid !== true) {
                        this.owner.invalidate();
                    }
                } else {
                    if (this.invLines > 0){
                        if (ful <= this.startInvLine) this.startInvLine += (updatedLines - 1);
                        else if (ful < (this.startInvLine + size)) {
                            size += (updatedLines - 1);
                        }
                    }
                    this.invalidate(ful, updatedLines);
                }
            };

            /**
             * Invalidate metrics for the specified range of lines.
             * @param  {Integer} start first line to be invalidated
             * @param  {Integer} size  number of lines to be invalidated
             * @method invalidate
             * @private
             */
            this.invalidate = function(start,size) {
                if (arguments.length === 0) {
                    start = 0;
                    size  = this.getLines();
                    if (size === 0) {
                        this.invLines = 0;
                        return;
                    }
                }

                if (size > 0 && (this.startInvLine !== start || size !== this.invLines)) {
                    if (this.invLines === 0){
                        this.startInvLine = start;
                        this.invLines = size;
                    } else {
                        var e = this.startInvLine + this.invLines;
                        this.startInvLine = start < this.startInvLine ? start : this.startInvLine;
                        this.invLines     = Math.max(start + size, e) - this.startInvLine;
                    }

                    if (this.owner !== null) {
                        this.owner.invalidate();
                    }
                }
            };

            this.getPreferredSize = function(){
                if (this.invLines > 0 && this.target !== null) {
                    this.recalc();
                }
                return { width:this.textWidth, height:this.textHeight };
            };

            this.paint = function(g,x,y,w,h,d) {
                var ts = g.$states[g.$curState];
                if (ts.width > 0 && ts.height > 0) {
                    var lineIndent   = this.lineIndent,
                        lineHeight   = this.getLineHeight(),
                        lilh         = lineHeight + lineIndent,
                        startInvLine = 0;

                    w = ts.width  < w ? ts.width  : w;
                    h = ts.height < h ? ts.height : h;

                    if (y < ts.y) {
                        startInvLine = Math.floor((lineIndent + ts.y - y) / lilh);
                        h += (ts.y - startInvLine * lineHeight - startInvLine * lineIndent);
                    } else {
                        if (y > (ts.y + ts.height)) return;
                    }

                    var size = this.getLines();
                    if (startInvLine < size){
                        var lines = Math.floor((h + lineIndent) / lilh) + (((h + lineIndent) % lilh > lineIndent) ? 1 : 0), i = 0;
                        if (startInvLine + lines > size) {
                            lines = size - startInvLine;
                        }
                        y += startInvLine * lilh;

                        // save few milliseconds
                        if (this.font.s !== g.font) {
                            g.setFont(this.font);
                        }

                        if (d === null || d.isEnabled === true){
                            // save few milliseconds
                            if (this.color != g.fillStyle) {
                                g.fillStyle = this.color;
                            }

                            var p1 = null, p2 = null, bsel = false;
                            if (lines > 0 && d !== null && typeof d.getStartSelection !== 'undefined') {
                                p1   = d.getStartSelection();
                                p2   = d.getEndSelection();
                                bsel = p1 !== null && (p1.row !== p2.row || p1.col !== p2.col);
                            }

                            for(i = 0; i < lines; i++){
                                if (bsel === true) {
                                    var line = i + startInvLine;
                                    if (line >= p1.row && line <= p2.row){
                                        var s  = this.getLine(line),
                                            lw = this.calcLineWidth(line),
                                            xx = x;

                                        if (line === p1.row) {
                                            var ww = this.font.charsWidth(s, 0, p1.col);
                                            xx += ww;
                                            lw -= ww;
                                            if (p1.row === p2.row) {
                                                lw -= this.font.charsWidth(s, p2.col, s.length - p2.col);
                                            }
                                        } else if (line === p2.row) {
                                            lw = this.font.charsWidth(s, 0, p2.col);
                                        }
                                        this.paintSelection(g, xx, y, lw === 0 ? 1 : lw, lilh, line, d);

                                        // restore color to paint text since it can be
                                        // res-set with paintSelection method
                                        if (this.color !== g.fillStyle) g.fillStyle = this.color;
                                    }
                                }

                                this.paintLine(g, x, y, i + startInvLine, d);
                                y += lilh;
                            }
                        } else {
                            var dcol = d !== null &&
                                       d.disabledColor !== null &&
                                       typeof d.disabledColor !== 'undefined' ? d.disabledColor
                                                                              : pkg.TextRender.disabledColor;

                            for(i = 0; i < lines; i++) {
                                g.setColor(dcol);
                                this.paintLine(g, x, y, i + startInvLine, d);
                                y += lilh;
                            }
                        }
                    }
                }
            };

            /**
             * Paint the specified text selection of the given line. The area
             * where selection has to be rendered is denoted with the given
             * rectangular area.
             * @param  {CanvasRenderingContext2D} g a canvas graphical context
             * @param  {Integer} x a x coordinate of selection rectangular area
             * @param  {Integer} y a y coordinate of selection rectangular area
             * @param  {Integer} w a width of of selection rectangular area
             * @param  {Integer} h a height of of selection rectangular area
             * @param  {Integer} line [description]
             * @param  {zebkit.ui.Panel} d a target UI component where the text
             * has to be rendered
             * @protected
             * @method paintSelection
             */
            this.paintSelection = function(g, x, y, w, h, line, d) {
                if (d.selectionView !== null) {
                    d.selectionView.paint(g, x, y, w, h, d);
                }
            };
        },

        function targetWasChanged(o,n){
            if (o !== null) o.off(this);
            if (n !== null) {
                n.on(this);
            }
            this.$super(o, n);
        }
    ]);

    pkg.WrappedTextRender = new Class(pkg.TextRender, [
        function $prototype() {
            this.brokenLines = null;
            this.lastWidth = -1;

            this.breakLine = function (w, startIndex, line, lines) {
                if (line === "") {
                    lines.push(line);
                } else {
                    var breakIndex = startIndex < line.length ? startIndex
                                                              : line.length - 1,
                        direction  = 0;

                    for(; breakIndex >= 0 && breakIndex < line.length ;) {
                        var substrLen = this.font.charsWidth(line, 0, breakIndex + 1);
                        if (substrLen < w) {
                            if (direction < 0) break;
                            else direction = 1;
                            breakIndex ++;
                        } else if (substrLen > w) {
                            breakIndex--;
                            if (direction > 0) break;
                            else               direction = -1;
                        } else {
                            break;
                        }
                    }

                    if (breakIndex >= 0) {
                        lines.push(line.substring(0, breakIndex + 1));
                        if (breakIndex < line.length - 1) {
                            this.breakLine(w, startIndex, line.substring(breakIndex + 1), lines);
                        }
                    }
                }
            };

            this.breakToLines = function (w) {
                var m = this.target, startIndex = 0, res = [];
                for(var i = 0; i < m.getLines(); i++) {
                    var line = m.getLine(i);
                    this.breakLine(w, startIndex, line, res);
                }
                return res;
            };

            this.getLines = function() {
                return this.brokenLines.length;
            };

            this.getLine = function(i) {
                return this.brokenLines[i];
            };
        },

        function invalidate(sl, len){
            this.$super(sl, len);
            if (this.brokenLines !== null) {
                this.brokenLines.length = 0;
            }
            this.lastWidth = -1;
        },

        function getPreferredSize(pw, ph) {
            if (arguments.length === 2) {
                if (this.lastWidth < 0 || this.lastWidth !== pw) {
                    this.lastWidth = pw;
                    this.brokenLines = this.breakToLines(pw);
                }
                return {
                    width  : pw,
                    height : this.brokenLines.length * this.getLineHeight() + (this.brokenLines.length - 1) * this.lineIndent
                };
            }
            return this.$super();
        },

        function paint(g,x,y,w,h,d) {
            if (this.lastWidth < 0 || this.lastWidth !== w) {
                this.lastWidth = w;
                this.brokenLines = this.breakToLines(w);
            }
            this.$super(g,x,y,w,h,d);
        }
    ]);

    pkg.DecoratedTextRender = zebkit.Class(pkg.TextRender, [
        function(text) {
            this.decorations = {
                underline : null,
                strike    : null
            };
            this.$super(text);
        },

        function $prototype() {
            this.lineWidth = 1;

            this.setDecoration = function(id, color) {
                if (id === null || typeof id === 'undefined') {
                    throw new Error();
                }
                this.decorations[id] = color;
                return this;
            };

            this.setDecorations = function(d) {
                this.decorations = zebkit.clone(d);
                // TODO: the method has to be replaced with addDecoration/clearDecoration
                if (typeof this.decorations.underline === 'undefined') {
                    this.decorations.underline = null;
                }

                if (typeof this.decorations.strike === 'undefined') {
                    this.decorations.strike = null;
                }

                return this;
            };
        },

        function paintLine(g,x,y,line,d) {
            this.$super(g,x,y,line,d);
            var lw = this.calcLineWidth(line),
                lh = this.getLineHeight(line);

            if (this.decorations.underline !== null) {
                g.lineWidth = this.lineWidth;
                g.setColor(this.decorations.underline);
                g.drawLine(x, y + lh - 1, x + lw, y  + lh - 1);
            }

            if (this.decorations.strike !== null) {
                var yy = y + Math.round(lh / 2) - 1;
                g.setColor(this.decorations.strike);
                g.lineWidth = this.lineWidth;
                g.drawLine(x, yy, x + lw, yy);
            }
        }
    ]);

    pkg.BoldTextRender = Class(pkg.TextRender, [
        function $clazz() {
            this.font = pkg.boldFont;
        }
    ]);

    /**
     * Password text render class. This class renders a secret text with hiding it with the given character.
     * @param {String|zebkit.data.TextModel} [text] a text as string or text model instance
     * @class zebkit.ui.PasswordText
     * @constructor
     * @extends zebkit.ui.TextRender
     */
    pkg.PasswordText = Class(pkg.TextRender, [
        function(text){
            if (arguments.length === 0) {
                text = new zebkit.data.SingleLineTxt("");
            }

            this.$super(text);
        },

        function $prototype() {
            /**
             * Echo character that will replace characters of hidden text
             * @attribute echo
             * @type {String}
             * @readOnly
             * @default "*"
             */
            this.echo = "*";

            /**
             * Indicates if the last entered character doesn't have to be replaced with echo character
             * @type {Boolean}
             * @attribute showLast
             * @default true
             * @readOnly
             */
            this.showLast = true;

            /**
             * Set the specified echo character. The echo character is used to hide secret text.
             * @param {String} ch an echo character
             * @method setEchoChar
             * @chainable
             */
            this.setEchoChar = function(ch){
                if (this.echo !== ch){
                    this.echo = ch;
                    if (this.target !== null) {
                        this.invalidate(0, this.target.getLines());
                    }
                }
                return this;
            };
        },

        function getLine(r){
            var buf = [], ln = this.$super(r);

            for(var i = 0;i < ln.length; i++) {
                buf[i] = this.echo;
            }

            if (this.showLast && ln.length > 0) {
                buf[ln.length - 1] = ln[ln.length - 1];
            }

            return buf.join('');
        }
    ]);

    pkg.TabBorder = Class(pkg.View, [
        function(t, w) {
            if (arguments.length > 1) {
                this.width  = w;
            }

            if (arguments.length > 0) {
                this.state = t;
            }

            this.left = this.top = this.bottom = this.right = 6 + this.width;
        },

        function $prototype() {
            this.state  = "out";
            this.width  = 1;

            this.fillColor1 = "#DCF0F7";
            this.fillColor2 = "white";
            this.fillColor3 = "#F3F3F3";

            this.onColor1 = "black";
            this.onColor2 = "#D9D9D9";
            this.offColor = "#A1A1A1";


            this.paint = function(g,x,y,w,h,d){
                var xx = x + w - 1,
                    yy = y + h - 1,
                    o  = d.parent.orient,
                    t  = this.state,
                    s  = this.width,
                    ww = 0,
                    hh = 0,
                    dt = s / 2;

                g.beginPath();
                g.lineWidth = s;
                switch(o) {
                    case "left":
                        g.moveTo(xx + 1, y + dt);
                        g.lineTo(x + s * 2, y + dt);
                        g.lineTo(x + dt , y + s * 2);
                        g.lineTo(x + dt, yy - s * 2 + dt);
                        g.lineTo(x + s * 2, yy + dt);
                        g.lineTo(xx + 1, yy + dt);

                        if (d.isEnabled === true){
                            g.setColor(t === "over" ? this.fillColor1 : this.fillColor2);
                            g.fill();
                        }

                        g.setColor((t === "selected" || t === "over") ? this.onColor1 : this.offColor);
                        g.stroke();

                        if (d.isEnabled === true) {
                            ww = Math.floor((w - 6) / 2);
                            g.setColor(this.fillColor3);
                            g.fillRect(xx - ww + 1, y + s, ww, h - s - 1);
                        }

                        if (t === "out") {
                            g.setColor(this.onColor2);
                            g.drawLine(x + 2*s + 1, yy - s, xx + 1, yy - s, s);
                        }
                        break;
                    case "right":
                        xx -= dt; // thick line grows left side and right side proportionally
                                  // correct it

                        g.moveTo(x, y + dt);
                        g.lineTo(xx - 2 * s, y + dt);

                        g.lineTo(xx, y + 2 * s);
                        g.lineTo(xx, yy - 2 * s);
                        g.lineTo(xx - 2 * s, yy + dt);
                        g.lineTo(x, yy + dt);

                        if (d.isEnabled === true){
                            g.setColor(t === "over" ? this.fillColor1 : this.fillColor2);
                            g.fill();
                        }

                        g.setColor((t === "selected" || t === "over") ? this.onColor1 : this.offColor);
                        g.stroke();

                        if (d.isEnabled === true) {
                            ww = Math.floor((w - 6) / 2);
                            g.setColor(this.fillColor3);
                            g.fillRect(x, y + s, ww, h - s - 1);
                        }

                        if (t === "out") {
                            g.setColor(this.onColor2);
                            g.drawLine(x, yy - s, xx - s - 1, yy - s, s);
                        }
                        break;
                    case "top":
                        g.moveTo(x + dt, yy + 1 );
                        g.lineTo(x + dt, y + s*2);
                        g.lineTo(x + s * 2, y + dt);
                        g.lineTo(xx - s * 2 + s, y + dt);
                        g.lineTo(xx + dt, y + s * 2);
                        g.lineTo(xx + dt, yy + 1);

                        if (d.isEnabled === true){
                            g.setColor(t === "over" ? this.fillColor1 : this.fillColor2);
                            g.fill();
                        }

                        g.setColor((t === "selected" || t === "over") ? this.onColor1 : this.offColor);
                        g.stroke();

                        if (d.isEnabled === true){
                            g.setColor(this.fillColor3);
                            hh = Math.floor((h - 6) / 2);
                            g.fillRect(x + s, yy - hh + 1 , w - s - 1, hh);
                        }

                        if (t === "selected") {
                            g.setColor(this.onColor2);
                            g.beginPath();
                            g.moveTo(xx + dt - s, yy + 1);
                            g.lineTo(xx + dt - s, y + s * 2);
                            g.stroke();
                        }

                        break;
                    case "bottom":
                        yy -= dt;

                        g.moveTo(x + dt, y);
                        g.lineTo(x + dt, yy - 2 * s);
                        g.lineTo(x + 2 * s + dt, yy);
                        g.lineTo(xx - 2 * s, yy);
                        g.lineTo(xx + dt, yy - 2 * s);
                        g.lineTo(xx + dt, y);

                        if (d.isEnabled === true){
                            g.setColor(t === "over" ? this.fillColor1 : this.fillColor2);
                            g.fill();
                        }

                        g.setColor((t === "selected" || t === "over") ? this.onColor1 : this.offColor);
                        g.stroke();

                        if (d.isEnabled === true){
                            g.setColor(this.fillColor3);
                            hh = Math.floor((h - 6) / 2);
                            g.fillRect(x + s, y, w - s - 1, hh);
                        }

                        if (t === "selected") {
                            g.setColor(this.onColor2);
                            g.beginPath();
                            g.moveTo(xx + dt - s, y);
                            g.lineTo(xx + dt - s, yy - s - 1);
                            g.stroke();
                        }
                        break;
                    default: throw new Error("Invalid tab alignment");
                }
            };

            this.getTop    = function () { return this.top;   };
            this.getBottom = function () { return this.bottom;};
            this.getLeft   = function () { return this.left;  };
            this.getRight  = function () { return this.right; };
        }
    ]);

    /**
     * Render class that allows developers to render a border with a title area.
     * The title area has to be specified by an UI component that uses the border
     * by defining "getTitleInfo()"" method. The method has to return object that
     * describes title size, location and alignment:
     *
     *
     *      {
     *        x: {Integer}, y: {Integer},
     *        width: {Integer}, height: {Integer},
     *        orient: {Integer}
     *      }
     *
     *
     * @class zebkit.ui.TitledBorder
     * @extends zebkit.ui.Render
     * @constructor
     * @param {zebkit.ui.View} border  a border to be rendered with a title area
     * @param {String} [lineAlignment] a line alignment. Specifies how
     * a title area has to be aligned relatively border line:
     *
     *       "bottom"  - title area will be placed on top of border line:
     *                    ___| Title area |___
     *
     *
     *      "center"   - title area will be centered relatively to border line:
     *                    ---| Title area |-----
     *
     *
     *      "top"      - title area will be placed underneath of border line:
     *                     ____              ________
     *                         |  Title area |
     *
     */
    pkg.TitledBorder = Class(pkg.Render, [
        function (b, a){
            if (arguments.length > 1) {
                this.lineAlignment = zebkit.util.$validateValue(a, "bottom", "top", "center");
            }
            this.setTarget(b);
        },

        function $prototype() {
            this.lineAlignment = "bottom";

            this.getTop  = function (){
                return this.target.getTop();
            };

            this.getLeft = function (){
                return this.target.getLeft();
            };

            this.getRight = function (){
                return this.target.getRight();
            };

            this.getBottom = function (){
                return this.target.getBottom();
            };

            this.outline = function (g,x,y,w,h,d) {
                var xx = x + w, yy = y + h;
                if (typeof d.getTitleInfo !== 'undefined') {
                    var r = d.getTitleInfo();
                    if (r !== null) {
                        switch(r.orient) {
                            case "bottom":
                                var bottom = this.target.getBottom();
                                switch (this.lineAlignment) {
                                    case "center" : yy = r.y + Math.floor((r.height - bottom)/ 2) + bottom; break;
                                    case "top"    : yy = r.y + r.height + bottom; break;
                                    case "bottom" : yy = r.y; break;
                                }
                                break;
                            case "top":
                                var top = this.target.getTop();
                                switch (this.lineAlignment) {
                                    case "center" : y = r.y + Math.floor((r.height - top)/2);   break; // y = r.y + Math.floor(r.height/ 2) ; break;
                                    case "top"    : y = r.y - top; break;
                                    case "bottom" : y = r.y + r.height; break;
                                }
                                break;
                            case "left":
                                var left = this.target.getLeft();
                                switch (this.lineAlignment) {
                                    case "center" : x = r.x + Math.floor((r.width - left) / 2); break;
                                    case "top"    : x = r.x - left; break;
                                    case "bottom" : x = r.x + r.width; break;
                                }
                                break;
                            case "right":
                                var right = this.target.getRight();
                                switch (this.lineAlignment) {
                                    case "center" : xx = r.x + Math.floor((r.width - right) / 2) + right; break;
                                    case "top"    : xx = r.x + r.width + right; break;
                                    case "bottom" : xx = r.x; break;
                                }
                                break;
                        }
                    }
                }

                if (this.target !== null &&
                    typeof this.target.outline !== 'undefined' &&
                    this.target.outline(g, x, y, xx - x, yy - y, d) === true)
                {
                    return true;
                }

                g.beginPath();
                g.rect(x, y, xx - x, yy - y);
                g.closePath();
                return true;
            };

            this.$isIn = function(clip, x, y, w, h) {
                var rx = clip.x > x ? clip.x : x,
                    ry = clip.y > y ? clip.y : y,
                    rw = Math.min(clip.x + clip.width, x + w) - rx,
                    rh = Math.min(clip.y + clip.height, y + h) - ry;
                return (clip.x === rx && clip.y === ry && clip.width === rw && clip.height === rh);
            };

            this.paint = function(g,x,y,w,h,d){
                if (typeof d.getTitleInfo !== 'undefined'){
                    var r = d.getTitleInfo();
                    if (r !== null) {
                        var xx = x + w, yy = y + h, t = g.$states[g.$curState];
                        switch (r.orient) {
                            case "top":
                                var top = this.target.getTop();
                                // compute border y
                                switch (this.lineAlignment) {
                                    case "center" : y = r.y + Math.floor((r.height - top) / 2) ; break;
                                    case "top"    : y = r.y - top; break;
                                    case "bottom" : y = r.y + r.height; break;
                                }

                                // skip rendering border if the border is not in clip rectangle
                                // This is workaround because of IE10/IE11 have bug what causes
                                // handling rectangular clip + none-rectangular clip side effect
                                // to "fill()" subsequent in proper working (fill without respect of
                                // clipping  area)
                                if (this.$isIn(t, x + this.target.getLeft(), y,
                                               w - this.target.getRight() - this.target.getLeft(),
                                               yy - y - this.target.getBottom()))
                                {
                                    return;
                                }

                                g.save();
                                g.beginPath();

                                g.moveTo(x, y);
                                g.lineTo(r.x, y);
                                g.lineTo(r.x, y + top);
                                g.lineTo(r.x + r.width, y + top);
                                g.lineTo(r.x + r.width, y);
                                g.lineTo(xx, y);
                                g.lineTo(xx, yy);
                                g.lineTo(x, yy);
                                g.lineTo(x, y);

                                break;
                            case "bottom":
                                var bottom = this.target.getBottom();
                                switch (this.lineAlignment) {
                                    case "center" : yy = r.y + Math.floor((r.height - bottom) / 2) + bottom; break;
                                    case "top"    : yy = r.y + r.height + bottom; break;
                                    case "bottom" : yy = r.y ; break;
                                }

                                if (this.$isIn(t, x + this.target.getLeft(), y + this.target.getTop(),
                                                  w - this.target.getRight() - this.target.getLeft(),
                                                  yy - y - this.target.getTop()))
                                {
                                    return;
                                }

                                g.save();
                                g.beginPath();

                                g.moveTo(x, y);
                                g.lineTo(xx, y);
                                g.lineTo(xx, yy);
                                g.lineTo(r.x + r.width, yy);
                                g.lineTo(r.x + r.width, yy - bottom);
                                g.lineTo(r.x, yy - bottom);
                                g.lineTo(r.x, yy);
                                g.lineTo(x, yy);
                                g.lineTo(x, y);

                                break;
                            case "left":
                                var left = this.target.getLeft();
                                switch (this.lineAlignment) {
                                    case "center" : x = r.x + Math.floor((r.width - left) / 2); break;
                                    case "top"    : x = r.x  - left; break;
                                    case "bottom" : x = r.x + r.width; break;
                                }

                                if (this.$isIn(t, x, y + this.target.getTop(),
                                               xx - x - this.target.getRight(),
                                               h - this.target.getTop() - this.target.getBottom()))
                                {
                                    return;
                                }

                                g.save();
                                g.beginPath();

                                g.moveTo(x, y);
                                g.lineTo(xx, y);
                                g.lineTo(xx, yy);
                                g.lineTo(x, yy);
                                g.lineTo(x, r.y + r.height);
                                g.lineTo(x + left, r.y + r.height);
                                g.lineTo(x + left, r.y);
                                g.lineTo(x, r.y);
                                g.lineTo(x, y);

                                break;
                            case "right":
                                var right = this.target.getRight();
                                switch (this.lineAlignment) {
                                    case "center" : xx = r.x + Math.floor((r.width - right) / 2) + right; break;
                                    case "top"    : xx = r.x  + r.width + right; break;
                                    case "bottom" : xx = r.x; break;
                                }

                                if (this.$isIn(t, x + this.target.getLeft(),
                                                  y + this.target.getTop(),
                                                  xx - x - this.target.getLeft(),
                                                  h - this.target.getTop() - this.target.getBottom()))
                                {
                                    return;
                                }

                                g.save();
                                g.beginPath();

                                g.moveTo(x, y);
                                g.lineTo(xx, y);
                                g.lineTo(xx, r.y);
                                g.lineTo(xx - right, r.y);
                                g.lineTo(xx - right, r.y + r.height);
                                g.lineTo(xx, r.y + r.height);
                                g.lineTo(xx, yy);
                                g.lineTo(x, yy);
                                g.lineTo(x, y);
                                break;
                            // throw error to avoid wrongly called restore method below
                            default: throw new Error("Invalid title orientation " + r.orient);
                        }

                        g.closePath();
                        g.clip();
                        this.target.paint(g, x, y, xx - x, yy - y, d);
                        g.restore();
                    }
                } else {
                    this.target.paint(g, x, y, w, h, d);
                }
            };
        }
    ]);

    pkg.CheckboxView = Class(pkg.View, [
        function(color) {
            if (arguments.length > 0) this.color = color;
        },

        function $prototype() {
            this.color = "rgb(65, 131, 255)";

            this.paint = function(g,x,y,w,h,d){
                g.beginPath();
                g.strokeStyle = this.color;
                g.lineWidth = 2;
                g.moveTo(x + 1, y + 2);
                g.lineTo(x + w - 3, y + h - 3);
                g.stroke();
                g.beginPath();
                g.moveTo(x + w - 2, y + 2);
                g.lineTo(x + 2, y + h - 2);
                g.stroke();
                g.lineWidth = 1;
            };
        }
    ]);

    pkg.BunldeView = Class(pkg.View, [
        function(dir, color) {
            if (arguments.length > 0) {
                this.direction = zebkit.util.$validateValue(dir, "vertical", "horizontal");
                if (arguments.length > 1) this.color = color;
            }
        },

        function $prototype() {
            this.color = "#AAAAAA";
            this.direction = "vertical";


            this.paint =  function(g,x,y,w,h,d) {
                g.beginPath();

                var  r = 0;
                if (this.direction === "vertical") {
                    r = w/2;
                    g.arc(x + r, y + r, r, Math.PI, 0, false);
                    g.lineTo(x + w, y + h - r);
                    g.arc(x + r, y + h - r, r, 0, Math.PI, false);
                    g.lineTo(x, y + r);
                } else {
                    r = h/2;
                    g.arc(x + r, y + r, r, 0.5 * Math.PI, 1.5 * Math.PI, false);
                    g.lineTo(x + w - r, y);
                    g.arc(x + w - r, y + h - r, r, 1.5 * Math.PI, 0.5 * Math.PI, false);
                    g.lineTo(x + r, y + h);
                }
                g.setColor(this.color);
                g.fill();
            };
        }
    ]);

    /**
     * The radio button ticker view.
     * @class  zebkit.ui.RadioView
     * @extends zebkit.ui.View
     * @constructor
     * @param {String} [col1] color one to render the outer cycle
     * @param {String} [col2] color tow to render the inner cycle
     */
    pkg.RadioView = Class(pkg.View, [
        function(col1, col2) {
            if (arguments.length > 0) {
                this.color1 = col1;
                if (arguments.length > 1) {
                    this.color2 = col2;
                }
            }
        },

        function $prototype() {
            this.color1 = "rgb(15, 81, 205)";
            this.color2 = "rgb(65, 131, 255)";

            this.paint = function(g,x,y,w,h,d){
                g.beginPath();
                if (g.fillStyle != this.color1) {
                    g.fillStyle = this.color1;
                }
                g.arc(Math.floor(x + w/2), Math.floor(y + h/2) , Math.floor(w/3 - 0.5), 0, 2* Math.PI, 1, false);
                g.fill();

                g.beginPath();
                if (g.fillStyle != this.color2) {
                    g.fillStyle = this.color2;
                }
                g.arc(Math.floor(x + w/2), Math.floor(y + h/2) , Math.floor(w/4 - 0.5), 0, 2* Math.PI, 1, false);
                g.fill();
            };
        }
    ]);

    /**
     * Toggle view element class
     * @class  zebkit.ui.ToggleView
     * @extends {zebkit.ui.View}
     * @constructor
     * @param  {Boolean} plus indicates the sign type plus (true) or minus (false)
     * @param  {String} color a color
     * @param  {String} bg a background
     */
    pkg.ToggleView = Class(pkg.View, [
        function(plus, color, bg, size) {
            if (arguments.length > 0) {
                this.plus = plus;
                if (arguments.length > 1) {
                    this.color = color;
                    if (arguments.length > 2) {
                        this.bg = bg;
                        if (arguments.length > 3) {
                            this.width = this.height = size;
                        }
                    }
                }
            }
        },

        function $prototype() {
            this.color = "white";
            this.bg    = "lightGray";
            this.plus  = false;
            this.br    = new pkg.Border("rgb(65, 131, 215)", 1, 3);
            this.width = this.height = 12;

            this.paint = function(g, x, y, w, h, d) {
                if (this.bg !== null && (this.br === null || this.br.outline(g, x, y, w, h, d) === false)) {
                    g.beginPath();
                    g.rect(x, y, w, h);
                }

                if (this.bg !== null) {
                    g.setColor(this.bg);
                    g.fill();
                }

                if (this.br !== null) {
                    this.br.paint(g, x, y, w, h, d);
                }

                g.setColor(this.color);
                g.lineWidth = 2;
                x += 2;
                w -= 4;
                h -= 4;
                y += 2;

                g.beginPath();
                g.moveTo(x, y + h / 2);
                g.lineTo(x + w, y + h / 2);
                if (this.plus) {
                    g.moveTo(x + w / 2, y);
                    g.lineTo(x + w / 2, y + h);
                }

                g.stroke();
                g.lineWidth = 1;
            };

            this.getPreferredSize = function() {
                return { width:this.width, height:this.height };
            };
        }
    ]);

    pkg.CaptionBgView = Class(pkg.View, [
        function(bg, gap, radius) {
            if (arguments.length > 0) {
                this.bg = bg;
                if (arguments.length > 1) {
                    this.gap = gap;

                    if (arguments.length > 2) {
                        this.radius = radius;
                    }
                }
            }
        },

        function $prototype() {
            this.gap = this.radius = 6;
            this.bg  = "#66CCFF";

            this.paint = function(g,x,y,w,h,d) {
                this.outline(g,x,y,w,h,d);
                g.setColor(this.bg);
                g.fill();
            };

            this.outline = function (g,x,y,w,h,d) {
                g.beginPath();
                g.moveTo(x + this.radius, y);
                g.lineTo(x + w - this.radius*2, y);
                g.quadraticCurveTo(x + w, y, x + w, y + this.radius);
                g.lineTo(x + w, y + h);
                g.lineTo(x, y + h);
                g.lineTo(x, y + this.radius);
                g.quadraticCurveTo(x, y, x + this.radius, y);
                return true;
            };
        }
    ]);


    /**
     * Focus event class.
     * @class zebkit.ui.FocusEvent
     * @constructor
     * @extends zebkit.util.Event
     */
    pkg.FocusEvent = Class(zebkit.util.Event, [
        function $prototype() {
            /**
             * Related to the event component. For focus gained event it should be a component
             * that lost focus. For focus lost event it should be a component that is going to
             * get a focus.
             * @attribute related
             * @readOnly
             * @default null
             * @type {zebkit.ui.Panel}
             */
            this.related = null;
        }
    ]);

    var FOCUS_EVENT = new pkg.FocusEvent();

    /**
     * Focus manager class defines the strategy of focus traversing among hierarchy of UI components.
     * It keeps current focus owner component and provides API to change current focus component
     * @class zebkit.ui.FocusManager
     * @constructor
     * @extends {zebkit.ui.Manager}
     */
    pkg.FocusManager = Class(pkg.Manager, [
        function $prototype() {
            /**
             * Reference to the current focus owner component.
             * @attribute focusOwner
             * @readOnly
             * @type {zebkit.ui.Panel}
             */
            this.focusOwner = null;

            this.$freeFocus = function(comp) {
                if ( this.focusOwner !== null &&
                    (this.focusOwner === comp || zebkit.layout.isAncestorOf(comp, this.focusOwner)))
                {
                    this.requestFocus(null);
                }
            };

            /**
             * Component enabled event handler
             * @param  {zebkit.ui.Panel} c a component
             * @method compEnabled
             */
            this.compEnabled = function(e) {
                var c = e.source;
                if (c.isVisible === true && c.isEnabled === false && this.focusOwner !== null) {
                    this.$freeFocus(c);
                }
            };

            /**
             * Component shown event handler
             * @param  {zebkit.ui.Panel} c a component
             * @method compShown
             */
            this.compShown = function(e) {
                var c = e.source;
                if (c.isEnabled === true && c.isVisible === false && this.focusOwner !== null) {
                    this.$freeFocus(c);
                }
            };

            /**
             * Component removed event handler
             * @param  {zebkit.ui.Panel} p a parent
             * @param  {Integer} i      a removed component index
             * @param  {zebkit.ui.Panel} c a removed component
             * @method compRemoved
             */
            this.compRemoved = function(e) {
                var c = e.kid;
                if (c.isEnabled === true && c.isVisible === true && this.focusOwner !== null) {
                    this.$freeFocus(c);
                }
            };

            /**
             * Test if the given component is a focus owner
             * @param  {zebkit.ui.Panel} c an UI component to be tested
             * @method hasFocus
             * @return {Boolean} true if the given component holds focus
             */
            this.hasFocus = function(c) {
                return this.focusOwner === c;
            };

            /**
             * Key pressed event handler.
             * @param  {zebkit.ui.KeyEvent} e a key event
             * @method keyPressed
             */
            this.keyPressed = function(e){
                if ("Tab" === e.code) {
                    var cc = this.ff(e.source, e.shiftKey ?  -1 : 1);
                    if (cc !== null) {
                        this.requestFocus(cc);
                    }
                    return true;
                }
            };

            this.findFocusable = function(c) {
                return (this.isFocusable(c) ? c : this.fd(c, 0, 1));
            };

            /**
             * Test if the given component can catch focus
             * @param  {zebkit.ui.Panel} c an UI component to be tested
             * @method isFocusable
             * @return {Boolean} true if the given component can catch a focus
             */
            this.isFocusable = function(c) {
                var d = c.getCanvas();
                if (d !== null &&
                       (c.canHaveFocus === true ||
                         (typeof c.canHaveFocus === "function" && c.canHaveFocus() === true)))
                {
                    for(;c !== d && c !== null; c = c.parent) {
                        if (c.isVisible === false || c.isEnabled === false) {
                            return false;
                        }
                    }
                    return c === d;
                }

                return false;
            };

            // looking recursively a focusable component among children components of
            // the given target  starting from the specified by index kid with the
            // given direction (forward or backward lookup)
            this.fd = function(t, index, d) {
                if (t.kids.length > 0){
                    var isNComposite = typeof t.catchInput === 'undefined' || t.catchInput === false;
                    for(var i = index; i >= 0 && i < t.kids.length; i += d) {
                        var cc = t.kids[i];

                        // check if the current children component satisfies
                        // conditions it can grab focus or any deeper in hierarchy
                        // component that can grab the focus exist
                        if (cc.isEnabled === true                                           &&
                            cc.isVisible === true                                           &&
                            cc.width      >  0                                              &&
                            cc.height     >  0                                              &&
                            (isNComposite || (t.catchInput !== true      &&
                                              t.catchInput(cc) === false)  )                &&
                            ( (cc.canHaveFocus === true || (typeof cc.canHaveFocus !== 'undefined'  &&
                                                            cc.canHaveFocus !== false &&
                                                            cc.canHaveFocus())            ) ||
                              (cc = this.fd(cc, d > 0 ? 0 : cc.kids.length - 1, d)) !== null)  )
                        {
                            return cc;
                        }
                    }
                }

                return null;
            };

            // find next focusable component
            // c - component starting from that a next focusable component has to be found
            // d - a direction of next focusable component lookup: 1 (forward) or -1 (backward)
            this.ff = function(c, d) {
                var top = c;
                while (top !== null && typeof top.getFocusRoot === 'undefined') {
                    top = top.parent;
                }

                if (top === null) {
                    return null;
                }

                top = top.getFocusRoot();
                if (top === null) {
                    return null;
                }

                if (typeof top.traverseFocus !== 'undefined') {
                    return top.traverseFocus(c, d);
                }

                for(var index = (d > 0) ? 0 : c.kids.length - 1; c !== top.parent; ){
                    var cc = this.fd(c, index, d);
                    if (cc !== null) {
                        return cc;
                    }
                    cc = c;
                    c = c.parent;
                    if (c !== null) index = d + c.indexOf(cc);
                }

                return this.fd(top, d > 0 ? 0 : top.kids.length - 1, d);
            };

            /**
             * Force to pass a focus to the given UI component
             * @param  {zebkit.ui.Panel} c an UI component to pass a focus
             * @method requestFocus
             */
            this.requestFocus = function(c) {
                if (c !== this.focusOwner && (c === null || this.isFocusable(c))) {
                    var oldFocusOwner = this.focusOwner;
                    if (c !== null) {
                        var nf = c.getEventDestination();
                        if (nf === null || oldFocusOwner === nf) {
                            return;
                        }
                        this.focusOwner = nf;
                    } else {
                        this.focusOwner = c;
                    }

                    if (oldFocusOwner !== null) {
                        var ofc = oldFocusOwner.getCanvas();
                        FOCUS_EVENT.source  = oldFocusOwner;
                        FOCUS_EVENT.related = this.focusOwner;
                        oldFocusOwner.focused();
                        pkg.events.fire("focusLost", FOCUS_EVENT);
                    }

                    if (this.focusOwner !== null) {
                        FOCUS_EVENT.source  = this.focusOwner;
                        FOCUS_EVENT.related = oldFocusOwner;
                        this.focusOwner.focused();
                        pkg.events.fire("focusGained", FOCUS_EVENT);
                    }
                }
            };

            /**
             * Pointer pressed event handler.
             * @param  {zebkit.ui.PointerEvent} e a pointer event
             * @method pointerPressed
             */
            this.pointerPressed = function(e){
                if (e.isAction()) {
                    this.requestFocus(e.source);
                }
            };
        }
    ]);


    // add shortcut event type
    pkg.events.regEvents("shortcutFired");

    /**
     * Shortcut event class
     * @constructor
     * @param  {zebkit.ui.Panel} src a source of the event
     * @param  {String} shortcut a shortcut name
     * @param  {String} keys a keys combination ("Control + KeyV")
     * @class zebkit.ui.ShortcutEvent
     * @extends {zebkit.util.Event}
     */
    pkg.ShortcutEvent = Class(zebkit.util.Event, [
        function(src, shortcut, keys) {
            this.source = src;

            /**
             * Shortcut name
             * @attribute shortcut
             * @readOnly
             * @type {String}
             */
            this.shortcut = shortcut;

            /**
             * Shortcut keys combination
             * @attribute keys
             * @readOnly
             * @type {String}
             */
            this.keys = keys;
        }
    ]);

    var SHORTCUT_EVENT = new pkg.ShortcutEvent();

    /**
     *  Shortcut manager supports short cut (keys) definition and listening. The shortcuts have to be defined in
     *  zebkit JSON configuration files. There are two sections:

        - **osx** to keep shortcuts for Mac OS X platform
        - **common** to keep shortcuts for all other platforms

     *  The JSON configuration entity has simple structure:


          {
            "common": {
                "UNDO": "Control + KeyZ",
                "REDO": "Control + Shift + KeyZ",
                 ...
            },
            "osx" : {
                "UNDO":  "MetaLeft + KeyZ",
                 ...
            }
          }

     *  The configuration contains list of shortcuts. Every shortcut is bound to a key combination that triggers it.
     *  Shortcut has a name and an optional list of arguments that have to be passed to a shortcut listener method.
     *  The optional arguments can be used to differentiate two shortcuts that are bound to the same command.
     *
     *  On the component level shortcut can be listened by implementing "shortcutFired(e)" listener handler.
     *  Pay attention to catch shortcut your component has to be focusable - be able to hold focus.
     *  For instance, to catch "UNDO" shortcut do the following:

            var pan = new zebkit.ui.Panel([
                function shortcutFired(e) {
                    // handle shortcut here
                    if (e.shortcut === "UNDO") {

                    }
                },

                // visualize the component gets focus
                function focused() {
                    this.$super();
                    this.setBackground(this.hasFocus()?"red":null);
                }
            ]);

            // let our panel to hold focus by setting appropriate property
            pan.canHaveFocus = true;


     *  @constructor
     *  @class zebkit.ui.ShortcutManager
     *  @extends {zebkit.ui.Manager}
     */
    pkg.ShortcutManager = Class(pkg.Manager, [
        function $prototype() {
            this.keyPath = [];

            /**
             * Key pressed event handler.
             * @param  {zebkit.ui.KeyEvent} e a key event
             * @method keyPressed
             */
            this.keyPressed = function(e) {
                if (e.code === null || this.keyPath.length > 5) {
                    this.keyPath = [];
                } else if (e.repeat === 1) {
                    this.keyPath[this.keyPath.length] = e.code;
                }

                var fo = pkg.focusManager.focusOwner;
                if (this.keyPath.length > 1) {
                    var sh = this.keyShortcuts;
                    for(var i = 0; i < this.keyPath.length; i++) {
                        var code = this.keyPath[i];
                        if (sh.hasOwnProperty(code)) {
                            sh = sh[code];
                        } else {
                            sh = null;
                            break;
                        }
                    }

                    if (sh !== null) {
                        SHORTCUT_EVENT.source   = fo;
                        SHORTCUT_EVENT.shortcut = sh;
                        SHORTCUT_EVENT.keys     = this.keyPath.join('+');
                        pkg.events.fire("shortcutFired", SHORTCUT_EVENT);
                    }
                }
            };

            this.keyReleased = function(e) {
                if (e.key === "Meta") {
                    this.keyPath = [];
                } else {
                    for(var i = 0; i < this.keyPath.length; i++) {
                        if (this.keyPath[i] === e.code) {
                            this.keyPath.splice(i, 1);
                            break;
                        }
                    }
                }
            };

            /**
             * Set shortcuts. Expected shortcuts format is:
             *
             *      { "<ID>"  : "Control + KeyZ", ... }
             *
             * or
             *
             *       { "<ID>"  :  ["Control + KeyZ", "Control + KeyV" ], ... }
             *
             * @param {shortcuts} shortcuts
             * @method setShortcuts
             */
            this.setShortcuts = function(shortcuts) {
                for (var id in shortcuts) {
                    var shortcut = shortcuts[id];
                    id = id.trim();

                    if (Array.isArray(shortcut) === false) {
                        shortcut = [ shortcut ];
                    }

                    for(var j = 0; j < shortcut.length; j++) {
                        var keys  = shortcut[j].replace(/\s+/g, '').split('+'),
                            st    = this.keyShortcuts,
                            len   = keys.length;

                        for(var i = 0; i < len; i++) {
                            var key = keys[i];
                            if (i === (len - 1)) {
                                st[key] = id;
                            } else if (st.hasOwnProperty(key) === false || zebkit.isString(st[key])) {
                                st[key] = {};
                            }

                            st = st[key];
                        }
                    }
                }
            };
        },

        function(shortcuts) {
            this.$super();

            // special structure that is a path from the first key of a sjortcut to the ID
            // for instance SELECTALL : [ "Control + KeyA", "Control + KeyW"], ... } will
            // be stored as:
            //  {
            //     "Control" : {
            //         "KeyA" : SELECTALL,
            //         "KeyW" : SELECTALL
            //     }
            //  }

            this.keyShortcuts = {};

            if (arguments.length > 0) {
                this.setShortcuts(shortcuts.common);
                if (zebkit.isMacOS === true && typeof shortcuts.osx !== 'undefined') {
                    this.setShortcuts(shortcuts.osx);
                }
            }
        }
    ]);


    /**
     * Class that holds mouse cursor constant.
     * @constructor
     * @class zebkit.ui.Cursor
     */
    pkg.Cursor = {
        /**
         * "default"
         * @const DEFAULT
         * @type {String}
         */
        DEFAULT     : "default",
        MOVE        : "move",
        WAIT        : "wait",
        TEXT        : "text",
        HAND        : "pointer",
        NE_RESIZE   : "ne-resize",
        SW_RESIZE   : "sw-resize",
        SE_RESIZE   : "se-resize",
        NW_RESIZE   : "nw-resize",
        S_RESIZE    : "s-resize",
        W_RESIZE    : "w-resize",
        N_RESIZE    : "n-resize",
        E_RESIZE    : "e-resize",
        COL_RESIZE  : "col-resize",
        HELP        : "help"
    };

    /**
     * Named views holder interface.
     * @class  zebkit.ui.$ViewsSetterMix
     * @interface  zebkit.ui.$ViewsSetterMix
     */
    pkg.$ViewsSetterMix = zebkit.Interface([
        function $prototype() {
            /**
             * Set views set.
             * @param {Object} v named views set.
             * @method setViews
             * @chainable
             */
            this.setViews = function(v){
                if (typeof this.views === 'undefined') {
                    this.views = {};
                }

                var b = false;
                for(var k in v) {
                    if (v.hasOwnProperty(k)) {
                        var nv = pkg.$view(v[k]);
                        if (this.views[k] !== nv) {
                            this.views[k] = nv;
                            b = true;
                        }
                    }
                }

                if (b === true) {
                    this.vrp();
                }
                return this;
            };
        }
    ]);

    /**
     * Shortcut to create a UI component by the given description. Depending on the description type
     * the following components are created:
     *
     *    - **String** zebkit.ui.Label
     *    - **Array** zebkit.ui.Combobox
     *    - **2D Array** zebkit.ui.grid.Grid
     *
     * @method $component
     * @protected
     * @param  {Object} desc a description
     * @return {zebkit.ui.Panel}  a created UI component
     */
    pkg.$component = function(desc, instance) {
        var hasInstance = arguments.length > 1;

        if (zebkit.isString(desc)) {
            //  [x] Text
            //  @(image-path:wxh) Text
            //  Text

            var m   = desc.match(/^(\[[x ]?\])/),
                txt = null;

            if (m !== null) {
                txt = desc.substring(m[1].length);
                var ch  = hasInstance && typeof instance.clazz.Checkbox !== 'undefined' ? new instance.clazz.Checkbox(txt)
                                                                                        : new pkg.Checkbox(txt);
                ch.setValue(m[1].indexOf('x') > 0);
                return ch;
            } else {
                m = desc.match(/^@\((.*)\)(\:[0-9]+x[0-9]+)?/);
                if (m !== null) {
                    var path = m[1];

                    txt  = desc.substring(path.length + 3 + (typeof m[2] !== 'undefined' ? m[2].length : 0)).trim();

                    var img = hasInstance && typeof instance.clazz.ImagePan !== 'undefined' ? new instance.clazz.ImagePan(path)
                                                                                            : new pkg.ImagePan(path);

                    if (typeof m[2] !== 'undefined') {
                        var s = m[2].substring(1).split('x'),
                            w = parseInt(s[0], 10),
                            h = parseInt(s[1], 10);

                        img.setPreferredSize(w, h);
                    }

                    if (txt.length === 0) {
                        return img;
                    }

                    return hasInstance && typeof instance.clazz.ImageLabel !== 'undefined' ? new instance.clazz.ImageLabel(txt, img)
                                                                                           : new pkg.ImageLabel(txt, img);
                } else {
                    return hasInstance && typeof instance.clazz.Label !== 'undefined' ? new instance.clazz.Label(desc)
                                                                                      : new pkg.Label(desc);
                }
            }
        } else if (Array.isArray(desc)) {
            if (desc.length > 0 && Array.isArray(desc[0])) {
                var model = new zebkit.data.Matrix(desc.length, desc[0].length);
                for(var row = 0; row < model.rows; row++) {
                    for(var col = 0; col < model.cols; col++) {
                        model.put(row, col, desc[row][col]);
                    }
                }
                return new pkg.grid.Grid(model);
            } else {
                var clz = hasInstance && typeof instance.clazz.Combo !== 'undefined' ? instance.clazz.Combo
                                                                                     : pkg.Combo,
                    combo = new clz(new clz.CompList(true)),
                    selectedIndex = -1;

                for(var i = 0; i < desc.length; i++) {
                    var ss = desc[i];
                    if (zebkit.isString(ss)) {
                        if (selectedIndex === -1 && ss.length > 1 && ss[0] === '*') {
                            selectedIndex = i;
                            desc[i] = ss.substring(1);
                        }
                    }
                    combo.list.add(pkg.$component(desc[i], combo.list));
                }

                combo.select(selectedIndex);
                return combo;
            }
        } else if (desc instanceof Image) {
            return hasInstance && typeof instance.clazz.ImagePan !== 'undefined' ? new instance.clazz.ImagePan(desc)
                                                                                 : new pkg.ImagePan(desc);
        } else if (zebkit.instanceOf(desc, pkg.View)) {
            var v = hasInstance && typeof instance.clazz.ViewPan !== 'undefined' ? new instance.clazz.ViewPan()
                                                                                 : new pkg.ViewPan();
            v.setView(desc);
            return v;
        }

        return desc;
    };

    /**
     *  UI component to keep and render the given "zebkit.ui.View" class
     *  instance. The target view defines the component preferred size
     *  and the component view.
     *  @class zebkit.ui.ViewPan
     *  @constructor
     *  @extends {zebkit.ui.Panel}
     */
    pkg.ViewPan = Class(pkg.Panel, [
        function $prototype() {
            /**
             * Reference to a view that the component visualize
             * @attribute view
             * @type {zebkit.ui.View}
             * @default null
             * @readOnly
             */
            this.view = null;

            this.paint = function (g){
                if (this.view !== null){
                    var l = this.getLeft(),
                        t = this.getTop();

                    this.view.paint(g, l, t, this.width  - l - this.getRight(),
                                             this.height - t - this.getBottom(), this);
                }
            };

            /**
             * Set the target view to be wrapped with the UI component
             * @param  {zebkit.ui.View|Function} v a view or a rendering
             * view "paint(g,x,y,w,h,c)" function
             * @method setView
             * @chainable
             */
            this.setView = function(v){
                var old = this.view;
                v = pkg.$view(v);

                if (v !== old) {
                    this.view = v;
                    this.notifyRender(old, v);
                    this.vrp();
                }

                return this;
            };

            /**
             * Override the parent method to calculate preferred size basing on a target view.
             * @param  {zebkit.ui.Panel} t a target container
             * @return {Object} return a target view preferred size if it is defined.
             * The returned structure is the following:
             *
             *     { width: {Integer}, height:{Integer} }
             *
             *  @method  calcPreferredSize
             */
            this.calcPreferredSize = function (t) {
                return this.view !== null ? this.view.getPreferredSize() : { width:0, height:0 };
            };
        }
    ]);

    /**
     *  Image panel UI component class. The component renders an image.
     *  @param {String|Image} <img> a path or direct reference to an image object.
     *  If the passed parameter is string it considered as path to an image.
     *  In this case the image will be loaded using the passed path.
     *  @class zebkit.ui.ImagePan
     *  @constructor
     *  @extends zebkit.ui.ViewPan
     */
    pkg.ImagePan = Class(pkg.ViewPan, [
        function(img, w, h) {
            this.setImage(arguments.length > 0 ? img : null);
            this.$super();
            if (arguments.length > 2) {
                this.setPreferredSize(w, h);
            }
        },

        function $prototype() {
            this.$runner = null;

            /**
             * Set image to be rendered in the UI component
             * @method setImage
             * @param {String|Image|zebkit.ui.Picture} img a path or direct reference to an
             * image or zebkit.ui.Picture render.
             * If the passed parameter is string it considered as path to an image.
             * In this case the image will be loaded using the passed path
             * @chainable
             */
            this.setImage = function(img) {
                var $this = this;

                if (img !== null) {
                    var isPic     = zebkit.instanceOf(img, pkg.Picture),
                        imgToLoad = isPic ? img.target : img ;

                    this.setView(isPic ? img : new pkg.Picture(img));


                    this.$runner = zebkit.util.image(imgToLoad);
                    this.$runner.then(function(img) {
                        $this.$runner = null;
                        $this.setView(isPic ? img : new pkg.Picture(img));
                        $this.vrp();

                        if (typeof $this.imageLoaded !== 'undefined') {
                            $this.imageLoaded(img);
                        }

                        // fire imageLoaded event to children
                        for(var t = $this.parent; t !== null; t = t.parent){
                            if (typeof t.childImageLoaded !== 'undefined') {
                                t.childImageLoaded(img);
                            }
                        }
                    }).catch(function(e) {
                        console.log(img);
                        zebkit.dumpError(e);

                        $this.$runner = null;
                        $this.setView(null);
                    });
                } else {
                    if (this.$runner === null) {
                        this.setView(null);
                    } else {
                        this.$runner.then(function() {
                            $this.setView(null);
                        });
                    }
                }
                return this;
            };
        }
    ]);

    /**
     * Line UI component class. Draw series of vertical or horizontal lines of using
     * the given line width and color. Vertical or horizontal line rendering s selected
     * depending on the line component size: if height is greater than width than vertical
     * line will be rendered.
     * @constructor
     * @class zebkit.ui.Line
     * @extends {zebkit.ui.Panel}
     */
    pkg.Line = Class(pkg.Panel, [
        function() {
            /**
             * Line colors
             * @attribute colors
             * @type {Array}
             * @readOnly
             * @default [ "gray" ]
             */
            this.$super();

            if (arguments.length > 0) {
                this.setColors.apply(this, arguments);
            }
        },

        function $prototype() {
            this.colors = [ "gray" ];

            /**
             * Line width
             * @attribute lineWidth
             * @type {Integer}
             * @default 1
             */
            this.lineWidth = 1;

            /**
             * Set line color
             * @param {String} c a color
             * @method  setColor
             * @chainable
             */
            this.setColor = function(c) {
                this.setColors(c);
                return this;
            };

            /**
             * Set set of colors to be used to paint the line. Number of colors defines the number of
             * lines to be painted.
             * @param {String} colors* colors
             * @method setLineColors
             * @chainable
             */
            this.setColors = function() {
                this.colors = (arguments.length === 1) ? (Array.isArray(arguments[0]) ? arguments[0].slice(0)
                                                                                      : [ arguments[0] ] )
                                                       : Array.prototype.slice.call(arguments);
                this.repaint();
                return this;
            };

            this.paint = function(g) {
                var isHor  = this.width > this.height,
                    left   = this.getLeft(),
                    right  = this.getRight(),
                    top    = this.getTop(),
                    bottom = this.getBottom(),
                    xy     = isHor ? top : left;

                for(var i = 0; i < this.colors.length; i++) {
                    if (this.colors[i] !== null) {
                        g.setColor(this.colors[i]);
                        if (isHor === true) {
                            g.drawLine(this.left, xy, this.width - right - left, xy, this.lineWidth);
                        } else {
                            g.drawLine(xy, top, xy, this.height - top - bottom, this.lineWidth);
                        }
                    }
                    xy += this.lineWidth;
                }
            };

            this.calcPreferredSize = function(target) {
                var s = this.colors.length * this.lineWidth;
                return { width: s, height:s};
            };
        }
    ]);

    /**
     * Label UI component class. The label can be used to visualize simple string or multi lines text or
     * the given text render implementation:

            // render simple string
            var l = new zebkit.ui.Label("Simple string");

            // render multi lines text
            var l = new zebkit.ui.Label(new zebkit.data.Text("Multiline\ntext"));

            // render password text
            var l = new zebkit.ui.Label(new zebkit.ui.PasswordText("password"));

     * @param  {String|zebkit.data.TextModel|zebkit.ui.TextRender} [r] a text to be shown with the label.
     * You can pass a simple string or an instance of a text model or an instance of text render as the
     * text value.
     * @class zebkit.ui.Label
     * @constructor
     * @extends zebkit.ui.ViewPan
     */
    pkg.Label = Class(pkg.ViewPan, [
        function (r) {
            if (arguments.length === 0) {
                this.setView(new pkg.StringRender(""));
            } else {
                // test if input string is string
                if (typeof r === "string" || r.constructor === String) {
                    this.setView(r.length === 0 || r.indexOf('\n') >= 0 ? new pkg.TextRender(new zebkit.data.Text(r))
                                                                        : new pkg.StringRender(r));
                } else if (typeof r.clazz         !== "undefined" &&
                           typeof r.getTextLength !== 'undefined' &&   // a bit faster tnan instanceOf checking if
                           typeof r.getLines      !== 'undefined'   )  // test if this is an instance of zebkit.data.TextModel
                {
                    this.setView(new pkg.TextRender(r));
                } else {
                    this.setView(r);
                }
            }
            this.$super();
        },

        function $prototype() {
            /**
             * Get the label text
             * @return {String} a zebkit label text
             * @method getValue
             */
            this.getValue = function() {
                return this.view.getValue();
            };

            /**
             * Set the text field text model
             * @param  {zebkit.data.TextModel|String} m a text model to be set
             * @method setModel
             * @chainable
             */
            this.setModel = function(m) {
                this.setView(zebkit.isString(m) ? new pkg.StringRender(m)
                                                : new pkg.TextRender(m));
                return this;
            };

            /**
             * Get a text model
             * @return {zebkit.data.TextModel} a text model
             * @method getModel
             */
            this.getModel = function() {
                return this.view !== null ? this.view.target : null;
            };

            /**
             * Get the label text color
             * @return {String} a zebkit label color
             * @method getColor
             */
            this.getColor = function (){
                return this.view.color;
            };

            /**
             * Get the label text font
             * @return {zebkit.ui.Font} a zebkit label font
             * @method getFont
             */
            this.getFont = function (){
                return this.view.font;
            };

            /**
             * Set the label text value
             * @param  {String} s a new label text
             * @method setValue
             * @chainable
             */
            this.setValue = function(s){
                if (s === null) s = "";

                var old = this.view.getValue();
                if (old !== s) {
                    this.view.setValue(s);
                    this.repaint();
                }

                return this;
            };

            /**
             * Set the label text color
             * @param  {String} c a text color
             * @method setColor
             * @chainable
             */
            this.setColor = function(c) {
                var old = this.view.color;
                if (old !== c) {
                    this.view.setColor(c);
                    this.repaint();
                }
                return this;
            };

            /**
             * Set the label text font
             * @param  {zebkit.ui.Font} f a text font
             * @method setFont
             * @chainable
             */
            this.setFont = function(f) {
                var old = this.view.font;
                this.view.setFont.apply(this.view, arguments);
                if (old != this.view.font) {
                    this.repaint();
                }
                return this;
            };
        }
    ]);

    /**
     * Shortcut class to render bold text in Label
     * @param {String|zebkit.ui.TextRender|zebkit.data.TextModel} [t] a text string,
     * text model or text render instance
     * @constructor
     * @class zebkit.ui.BoldLabel
     * @extends zebkit.ui.Label
     */
    pkg.BoldLabel = Class(pkg.Label, []);

    /**
     * Image label UI component. This is UI container that consists from an image
     * component and an label component.Image is located at the left size of text.
     * @param {Image|String} img an image or path to the image
     * @param {String|zebkit.ui.TextRender|zebkit.data.TextModel} txt a text string,
     * text model or text render instance
     * @constructor
     * @class zebkit.ui.ImageLabel
     * @extends {zebkit.ui.Panel}
     */
    pkg.ImageLabel = Class(pkg.Panel, [
        function(txt, path) {
            var img = zebkit.instanceOf(path, pkg.ImagePan) ? path : new this.clazz.ImagePan(path),
                lab = zebkit.instanceOf(txt, pkg.Panel)     ? txt  : new this.clazz.Label(txt);

            img.constraints = "image";
            lab.constraints = "label";

            // TODO: this is copy paste of Panel constructor to initialize fields that has to
            // be used for adding child components. these components have to be added before
            // properties() call. a bit dirty trick
            if (typeof this.kids === "undefined") {
                this.kids = [];
            }

            this.layout = new zebkit.layout.FlowLayout("left", "center", "horizontal", 6);

            // add before panel constructor thanks to copy pasted code above
            this.add(img);
            this.add(lab);

            this.$super();

            lab.setVisible(txt !== null);
        },

        function $clazz() {
            this.ImagePan = Class(pkg.ImagePan, []);
            this.Label    = Class(pkg.Label, []);
        },

        function $prototype() {
            /**
             * Set the specified caption
             * @param {String} c an image label caption text
             * @method setCaption
             * @chainable
             */
            this.setCaption = function(c) {
                var lab = this.byConstraints("label");
                lab.setValue(c);
                lab.setVisible(c !== null);
                return this;
            };

            /**
             * Set the specified label image
             * @param {String|Image} p a path to an image of image object
             * @method setImage
             * @chainable
             */
            this.setImage = function(p) {
                var lab = this.byConstraints("image");
                image.setImage(p);
                image.setVisible(p !== null);
                return this;
            };

            /**
             * Set the caption font
             * @param {zebkit.ui.Font} a font
             * @method setFont
             * @chainable
             */
            this.setFont = function() {
                var lab = this.byConstraints("label");
                if (lab !== null) {
                    lab.setFont.apply(lab, arguments);
                }
                return this;
            };

            /**
             * Set the caption color
             * @param {String} a color
             * @method setColor
             * @chainable
             */
            this.setColor = function (c) {
                var lab = this.byConstraints("label");
                if (lab !== null) {
                    lab.setColor(c);
                }
                return this;
            };

            /**
             * Get caption component
             * @return {zebkit.ui.Panel} a caption component
             * @method getCaption
             */
            this.getCaption = function () {
                return this.byConstraints("label");
            };

            /**
             * Set the image alignment.
             * @param {String} an alignment. Following values are possible:
             *
             *    - "left"
             *    - "right"
             *    - "top"
             *    - "bottom"
             *
             * @method  setImgAlignment
             * @chainable
             */
            this.setImgAlignment = function(a) {
                var b   = false,
                    img = this.byConstraints("image"),
                    i   = this.indexOf(img);

                if (a === "top" || a === "bottom") {
                    if (this.layout.direction !== "vertical") {
                        this.layout.direction = "vertical";
                        b = true;
                    }
                } else if (a === "left" || a === "right") {
                    if (this.layout.direction !== "horizontal") {
                        this.layout.direction = "horizontal";
                        b = true;
                    }
                }

                if (this.layout.ax !== "center") {
                    this.layout.ax = "center";
                    b = true;
                }

                if (this.layout.ay !== "center") {
                    this.layout.ay = "center";
                    b = true;
                }

                if ((a === "top" || a === "left") && i !== 0 ) {
                    this.insert("image", 0, this.removeAt(i));
                    b = false;
                } else if ((a === "bottom"  || a === "right") && i !== 1) {
                    this.add("image", this.removeAt(i));
                    b = false;
                }

                if (b) {
                    this.vrp();
                }

                return this;
            };

            /**
             * Set image preferred size.
             * @param {Integer} w a width and height if the second argument has not been specified
             * @param {Integer} [h] a height
             * @method setImgPreferredSize
             * @chainable
             */
            this.setImgPreferredSize = function (w, h) {
                if (arguments.length === 1) h = w;
                this.byConstraints("image").setPreferredSize(w, h);
                return this;
            };
        }
    ]);

    /**
     * Progress bar UI component class.
     * @class zebkit.ui.Progress
     * @constructor
     * @extends {zebkit.ui.Panel}
     */

    /**
     * Fired when a progress bar value has been updated

            progress.on(function(src, oldValue) {
                ...
            });

     *  @event fired
     *  @param {zebkit.ui.Progress} src a progress bar that triggers
     *  the event
     *  @param {Integer} oldValue a progress bar previous value
     */
    pkg.Progress = Class(pkg.Panel, [
        function () {
            this.setBundleView("darkBlue");
            this._ = new zebkit.util.Listeners();
            this.$super();
        },

        function $prototype() {
            /**
             * Progress bar value
             * @attribute value
             * @type {Integer}
             * @readOnly
             */
            this.value = 0;

            /**
             * Progress bar bundle width
             * @attribute bundleWidth
             * @type {Integer}
             * @readOnly
             * @default 6
             */

            /**
             * Progress bar bundle height
             * @attribute bundleHeight
             * @type {Integer}
             * @readOnly
             * @default 6
             */
            this.bundleWidth = this.bundleHeight = 6;

            /**
             * Gap between bundle elements
             * @default 2
             * @attribute gap
             * @type {Integer}
             * @readOnly
             */
            this.gap = 2;

            /**
             * Progress bar maximal value
             * @attribute maxValue
             * @type {Integer}
             * @readOnly
             * @default 20
             */
            this.maxValue = 20;


            this.bundleView = this.titleView = null;

            /**
             * Progress bar orientation
             * @default "horizontal"
             * @attribute orient
             * @type {String}
             * @readOnly
             */
            this.orient = "horizontal";

            this.paint = function(g){
                var left    = this.getLeft(),
                    right   = this.getRight(),
                    top     = this.getTop(),
                    bottom  = this.getBottom(),
                    rs      = (this.orient === "horizontal") ? this.width - left - right
                                                             : this.height - top - bottom,
                    bundleSize = (this.orient === "horizontal") ? this.bundleWidth
                                                                : this.bundleHeight;

                if (rs >= bundleSize){
                    var vLoc   = Math.floor((rs * this.value) / this.maxValue),
                        x      = left,
                        y      = this.height - bottom,
                        bundle = this.bundleView,
                        wh     = this.orient === "horizontal" ? this.height - top - bottom
                                                              : this.width - left - right;

                    while (x < (vLoc + left) && this.height - vLoc - bottom < y){
                        if (this.orient === "horizontal"){
                            bundle.paint(g, x, top, bundleSize, wh, this);
                            x += (bundleSize + this.gap);
                        } else {
                            bundle.paint(g, left, y - bundleSize, wh, bundleSize, this);
                            y -= (bundleSize + this.gap);
                        }
                    }

                    if (this.titleView !== null) {
                        var ps = this.bundleView.getPreferredSize();
                        this.titleView.paint(g, Math.floor((this.width  - ps.width ) / 2),
                                                Math.floor((this.height - ps.height) / 2),
                                                ps.width, ps.height, this);
                    }
                }
            };

            this.calcPreferredSize = function(l){
                var bundleSize = (this.orient === "horizontal") ? this.bundleWidth
                                                                : this.bundleHeight,
                    v1 = (this.maxValue * bundleSize) + (this.maxValue - 1) * this.gap,
                    ps = this.bundleView.getPreferredSize();

                ps = (this.orient === "horizontal") ? {
                                                         width :v1,
                                                         height:(this.bundleHeight >= 0 ? this.bundleHeight
                                                                                        : ps.height)
                                                      }
                                                    : {
                                                        width:(this.bundleWidth >= 0 ? this.bundleWidth
                                                                                     : ps.width),
                                                        height: v1
                                                      };
                if (this.titleView !== null) {
                    var tp = this.titleView.getPreferredSize();
                    ps.width  = Math.max(ps.width, tp.width);
                    ps.height = Math.max(ps.height, tp.height);
                }
                return ps;
            };
        },

        /**
         * Set the progress bar orientation
         * @param {String} o an orientation: "vertical" or "horizontal"
         * @method setOrientation
         * @chainable
         */
        function setOrientation(o){
            if (o !== this.orient) {
                this.orient = zebkit.util.$validateValue(o, "horizontal", "vertical");
                this.vrp();
            }
            return this;
        },

        /**
         * Set maximal integer value the progress bar value can rich
         * @param {Integer} m a maximal value the progress bar value can rich
         * @method setMaxValue
         * @chainable
         */
        function setMaxValue(m){
            if (m !== this.maxValue) {
                this.maxValue = m;
                this.setValue(this.value);
                this.vrp();
            }
            return this;
        },

        /**
         * Set the current progress bar value
         * @param {Integer} p a progress bar
         * @method setValue
         * @chainable
         */
        function setValue(p){
            p = p % (this.maxValue + 1);
            if (this.value !== p){
                var old = this.value;
                this.value = p;
                this._.fired(this, old);
                this.repaint();
            }
            return this;
        },

        /**
         * Set the given gap between progress bar bundle elements
         * @param {Integer} g a gap
         * @method setGap
         * @chainable
         */
        function setGap(g){
            if (this.gap !== g){
                this.gap = g;
                this.vrp();
            }
            return this;
        },

        /**
         * Set the progress bar bundle element view
         * @param {zebkit.ui.View} v a progress bar bundle view
         * @method setBundleView
         * @chainable
         */
        function setBundleView(v){
            if (this.bundleView != v){
                this.bundleView = pkg.$view(v);
                this.vrp();
            }
            return this;
        },

        /**
         * Set the progress bar bundle element size
         * @param {Integer} w a bundle element width
         * @param {Integer} h a bundle element height
         * @method setBundleSize
         * @chainable
         */
        function setBundleSize(w, h){
            if (w !== this.bundleWidth && h !== this.bundleHeight){
                this.bundleWidth  = w;
                this.bundleHeight = h;
                this.vrp();
            }
            return this;
        }
    ]);


    /**
     * State panel class. The class is UI component that allows to customize
     * the component  face, background and border depending on the component
     * state. Number and names of states the component can have is defined
     * by developers. To bind a view to the specified state use zebkit.ui.ViewSet
     * class. For instance if a component has to support two states : "state1" and
     * "state2" you can do it as following:

            // create state component
            var p = new zebkit.ui.StatePan();

            // define border view that contains views for "state1" and "state2"
            p.setBorder({
                "state1": new zebkit.ui.Border("red", 1),
                "state1": new zebkit.ui.Border("blue", 2)

            });

            // define background view that contains views for "state1" and "state2"
            p.setBorder({
                "state1": "yellow",
                "state1": "green"
            });

            // set component state
            p.setState("state1");

     * State component children components can listening when the state of the component
     * has been updated by implementing "parentStateUpdated(o,n,id)" method. It gets old
     * state, new state and a view id that is mapped to the new state.  The feature is
     * useful if we are developing a composite components whose children component also
     * should react to a state changing.
     * @class  zebkit.ui.StatePan
     * @constructor
     * @extends {zebkit.ui.ViewPan}
     */
    pkg.StatePan = Class(pkg.ViewPan, [
        function $prototype() {
            /**
             * Current component state
             * @attribute state
             * @readOnly
             * @default null
             * @type {Object}
             */
            this.state = null;

            /**
             * Set the component state
             * @param {Object} s a state
             * @method  setState
             * @chainable
             */
            this.setState = function(s) {
                if (s !== this.state){
                    var prev = this.state;
                    this.state = s;
                    this.stateUpdated(prev, s);
                }
                return this;
            };

            /**
             * Define the method if the state value has to be
             * somehow converted to a view id. By default the state value
             * itself is used as a view id.
             * @param {Object} s a state to be converted
             * @return {String} a view ID
             * @method toViewId
             */

            /**
             * Called every time the component state has been updated
             * @param  {Integer} o a previous component state
             * @param  {Integer} n a new component state
             * @method stateUpdated
             */
            this.stateUpdated = function(o, n) {
                var b  = false,
                    id = (typeof this.toViewId !== 'undefined' ? this.toViewId(n) : n);

                if (id !== null) {
                    for(var i = 0; i < this.kids.length; i++) {
                        var kid = this.kids[i];
                        if (typeof kid.setState !== 'undefined') {
                            kid.setState(id);
                        }
                    }

                    if (this.border !== null && typeof this.border.activate !== 'undefined') {
                        b = this.border.activate(id, this) === true || b;
                    }

                    if (this.view !== null && typeof this.view.activate !== 'undefined') {
                        b = this.view.activate(id, this) === true || b;
                    }

                    if (this.bg !== null && typeof this.bg.activate !== 'undefined') {
                        b = this.bg.activate(id, this) === true || b;
                    }

                    if (b) {
                        this.repaint();
                    }
                }
            };

            /**
             * Refresh state
             * @protected
             * @method syncState
             */
            this.syncState = function() {
                this.stateUpdated(this.state, this.state);
            };
        },

        function setView(v){
            if (v != this.view){
                this.$super(v);
                // check if the method called after constructor execution
                // otherwise sync is not possible
                if (typeof this.kids !== 'undefined') {
                    this.syncState(this.state, this.state);
                }
            }
            return this;
        },

        function setBorder(v){
            if (v != this.border){
                this.$super(v);
                this.syncState(this.state, this.state);
            }
            return this;
        },

        function setBackground(v){
            if (v != this.bg){
                this.$super(v);
                this.syncState(this.state, this.state);
            }
            return this;
        }
    ]);

    /**
     * Event state panel class. The class implements UI component whose face, border and
     * background view depends on its input events state. The component is good basis
     * for creation  dynamic view UI components.The state the component can be is:

        - **over** the pointer cursor is inside the component
        - **out** the pointer cursor is outside the component
        - **pressed over** the pointer cursor is inside the component and an action pointer
          button or key is pressed
        - **pressed out** the pointer cursor is outside the component and an action pointer
          button or key is pressed
        - **disabled** the component is disabled

     * The view border, background or face should be set as "zebkit.ui.ViewSet" where an required
     * for the given component state view is identified by an id. By default corresponding to
     * component states views IDs are the following: "over", "pressed.over", "out", "pressed.out",
     * "disabled".  Imagine for example we have two colors and we need to change between the colors
     * every time pointer cursor is over/out of the component:

         // create state panel
         var statePan = new zebkit.ui.EvStatePan();

         // add dynamically updated background
         statePan.setBackground(new zebkit.ui.ViewSet({
            "over": "red",
            "out": "blue"
         }));

     * Alone with background border view can be done also dynamic

         // add dynamically updated border
         statePan.setBorder(new zebkit.ui.ViewSet({
            "over": new zebkit.ui.Border("green", 4, 8),
            "out": null
         }));

     * Additionally the UI component allows developer to specify whether the component can hold
     * input focus and which UI component has to be considered as the focus marker. The focus marker
     * component is used as anchor to paint focus marker view. In simple case the view can be just
     * a border. So border will be rendered around the focus marker component:

         // create state panel that contains one label component
         var statePan = new zebkit.ui.EvStatePan();
         var lab      = new zebkit.ui.Label("Focus marker label");
         lab.setPadding(6);
         statePan.setPadding(6);
         statePan.setLayout(new zebkit.layout.BorderLayout());
         statePan.add("center", lab);

         // set label as an anchor for focus border indicator
         statePan.setFocusAnchorComponent(lab);
         statePan.setFocusMarkerView("plain");

     * @class zebkit.ui.EvStatePan
     * @constructor
     * @extends zebkit.ui.StatePan
     */
    var OVER         = "over",
        PRESSED_OVER = "pressed.over",
        OUT          = "out",
        PRESSED_OUT  = "pressed.out",
        DISABLED     = "disabled";

    pkg.EvStatePan = Class(pkg.StatePan,  [
        function $prototype() {
            this.state = OUT;
            this.$isIn = false;

            this.toViewId = function(state) {
                return state;
            };

            this._keyPressed = function(e) {
                if (this.state !== PRESSED_OVER &&
                    this.state !== PRESSED_OUT  &&
                    (e.code === "Enter" || e.code === "Space"))
                {
                    this.setState(PRESSED_OVER);
                }
            };

            this._keyReleased = function(e) {
                if (this.state === PRESSED_OVER || this.state === PRESSED_OUT){
                    var prev = this.state;
                    this.setState(OVER);
                    if (this.$isIn === false) this.setState(OUT);
                }
            };

            this._pointerEntered = function(e) {
                if (this.isEnabled === true) {
                    this.setState(this.state === PRESSED_OUT ? PRESSED_OVER : OVER);
                    this.$isIn = true;
                }
            };

            this._pointerPressed = function(e) {
                if (this.state !== PRESSED_OVER && this.state !== PRESSED_OUT && e.isAction()){
                    this.setState(PRESSED_OVER);
                }
            };

            this._pointerReleased = function(e) {
                if ((this.state === PRESSED_OVER || this.state === PRESSED_OUT) && e.isAction()){
                    if (e.source === this) {
                        this.setState(e.x >= 0 && e.y >= 0 && e.x < this.width && e.y < this.height ? OVER
                                                                                                    : OUT);
                    }
                    else {
                        var p = zebkit.layout.toParentOrigin(e.x, e.y, e.source, this);
                        this.$isIn = p.x >= 0 && p.y >= 0 && p.x < this.width && p.y < this.height;
                        this.setState(this.$isIn ? OVER : OUT);
                    }
                }
            };

            this.childKeyPressed = function(e) {
                this._keyPressed(e);
            };

            this.childKeyReleased = function(e) {
                this._keyReleased(e);
            };

            this.childPointerEntered = function(e) {
                this._pointerEntered(e);
            };

            this.childPointerPressed = function(e) {
                this._pointerPressed(e);
            };

            this.childPointerReleased = function(e) {
                this._pointerReleased(e);
            };

            this.childPointerExited = function(e) {
                // check if the pointer cursor is in of the source component
                // that means another layer has grabbed control
                if (e.x >= 0 && e.y >= 0 && e.x < e.source.width && e.y < e.source.height) {
                    this.$isIn = false;
                }
                else {
                    var p = zebkit.layout.toParentOrigin(e.x, e.y, e.source, this);
                    this.$isIn = p.x >= 0 && p.y >= 0 && p.x < this.width && p.y < this.height;
                }

                if (this.$isIn === false) {
                    this.setState(this.state === PRESSED_OVER ? PRESSED_OUT : OUT);
                }
            };

            /**
             * Define key pressed events handler
             * @param  {zebkit.ui.KeyEvent} e a key event
             * @method keyPressed
             */
            this.keyPressed = function(e){
                this._keyPressed(e);
            };

            /**
             * Define key released events handler
             * @param  {zebkit.ui.KeyEvent} e a key event
             * @method keyReleased
             */
            this.keyReleased = function(e){
                this._keyReleased(e);
            };

            /**
             * Define pointer entered events handler
             * @param  {zebkit.ui.PointerEvent} e a key event
             * @method pointerEntered
             */
            this.pointerEntered = function (e){
                this._pointerEntered();
            };

            /**
             * Define pointer exited events handler
             * @param  {zebkit.ui.PointerEvent} e a key event
             * @method pointerExited
             */
            this.pointerExited = function(e){
                if (this.isEnabled === true) {
                    this.setState(this.state === PRESSED_OVER ? PRESSED_OUT : OUT);
                    this.$isIn = false;
                }
            };

            /**
             * Define pointer pressed events handler
             * @param  {zebkit.ui.PointerEvent} e a key event
             * @method pointerPressed
             */
            this.pointerPressed = function(e){
                this._pointerPressed(e);
            };

            /**
             * Define pointer released events handler
             * @param  {zebkit.ui.PointerEvent} e a key event
             * @method pointerReleased
             */
            this.pointerReleased = function(e){
                this._pointerReleased(e);
            };

            /**
             * Define pointer dragged events handler
             * @param  {zebkit.ui.PointerEvent} e a key event
             * @method pointerDragged
             */
            this.pointerDragged = function(e){
                if (e.isAction()) {
                    var pressed = (this.state === PRESSED_OUT || this.state === PRESSED_OVER);
                    if (e.x > 0 && e.y > 0 && e.x < this.width && e.y < this.height) {
                        this.setState(pressed ? PRESSED_OVER : OVER);
                    } else {
                        this.setState(pressed ? PRESSED_OUT : OUT);
                    }
                }
            };
        },

        function setEnabled(b) {
            this.$super(b);
            this.setState(b ? OUT : DISABLED);
            return this;
        }
    ]);

    /**
     * Composite event state panel
     * @constructor
     * @extends {zebkit.ui.EvStatePan}
     * @class  zebkit.ui.CompositeEvStatePan
     */
    pkg.CompositeEvStatePan = Class(pkg.EvStatePan, [
        function $prototype() {
            /**
             * Indicates if the component can have focus
             * @attribute canHaveFocus
             * @readOnly
             * @type {Boolean}
             * @default true
             */
            this.canHaveFocus = true;

            /**
             * Indicates this composite component can make its children components
             * event transparent.
             * @attribute catchInput
             * @readOnly
             * @type {Boolean}
             * @default true
             */
            this.catchInput = true;

            /**
             * Component that has to be used as focus indicator anchor
             * @attribute focusComponent
             * @type {zebkit.ui.Panel}
             * @default null
             * @readOnly
             */
            this.focusComponent = null;

            /**
             * Reference to an anchor focus marker component
             * @attribute focusMarkerView
             * @readOnly
             * @type {zebkit.ui.Panel}
             */
            this.focusMarkerView = null;

            /**
             * Focus marker verical and horizontal gaps.
             * @attribute focusMarkerGaps
             * @type {Number}
             * @default 2
             */
            this.focusMarkerGaps = 2;

            this.paintOnTop = function(g){
                var fc = this.focusComponent;
                if (this.focusMarkerView !== null && fc !== null && this.hasFocus()) {
                    this.focusMarkerView.paint(g, fc.x - this.focusMarkerGaps,
                                                  fc.y - this.focusMarkerGaps,
                                                  this.focusMarkerGaps * 2 + fc.width,
                                                  this.focusMarkerGaps * 2 + fc.height,
                                                  this);
                }
            };

            /**
             * Set the view that has to be rendered as focus marker when the component gains focus.
             * @param  {String|zebkit.ui.View|Function} c a view.
             * The view can be a color or border string code or view
             * or an implementation of zebkit.ui.View "paint(g,x,y,w,h,t)" method.
             * @method setFocusMarkerView
             * @chainable
             */
            this.setFocusMarkerView = function (c){
                if (c != this.focusMarkerView){
                    this.focusMarkerView = pkg.$view(c);
                    this.repaint();
                }
                return this;
            };

            /**
             * Says if the component can hold focus or not
             * @param  {Boolean} b true if the component can gain focus
             * @method setCanHaveFocus
             */
            this.setCanHaveFocus = function(b){
                if (this.canHaveFocus !== b) {
                    var fm = pkg.focusManager;
                    if (b === false && fm.focusOwner === this) {
                        fm.requestFocus(null);
                    }
                    this.canHaveFocus = b;
                }
                return this;
            };

            /**
             * Set the specified children component to be used as focus marker view anchor component.
             * Anchor component is a component over that the focus marker view is painted.
             * @param  {zebkit.ui.Panel} c an anchor component
             * @method setFocusAnchorComponent
             * @chainable
             */
            this.setFocusAnchorComponent = function(c) {
                if (this.focusComponent !== c) {
                    if (c !== null && this.kids.indexOf(c) < 0) {
                        throw new Error("Focus component doesn't exist");
                    }
                    this.focusComponent = c;
                    this.repaint();
                }
                return this;
            };
        },

        function focused() {
            this.$super();
            this.repaint();
        },

        function kidRemoved(i,l){
            if (l === this.focusComponent) {
                this.focusComponent = null;
            }
            this.$super(i, l);
        }
    ]);


    /**
     * Special interface that provides set of method for state components to implement repeatable
     * state.
     * @class zebkit.ui.ButtonRepeatMix
     * @interface zebkit.ui.ButtonRepeatMix
     */
    pkg.ButtonRepeatMix = zebkit.Interface([
        function $prototype() {
            /**
             * Indicate if the button should
             * fire event by pressed event
             * @attribute isFireByPress
             * @type {Boolean}
             * @default false
             * @readOnly
             */
            this.isFireByPress = false;

            /**
             * Fire button event repeating period. -1 means
             * the button event repeating is disabled.
             * @attribute firePeriod
             * @type {Integer}
             * @default -1
             * @readOnly
             */
            this.firePeriod = -1;

            /**
             * Indicates a time the repeat state events have to start in
             * @attribute startIn
             * @type {Integer}
             * @readOnly
             * @default 400
             */
            this.startIn = 400;

            this.$repeatTask = null;

            /**
             * Set the mode the button has to fire events. Button can fire
             * event after it has been unpressed or immediately when it has
             * been pressed. Also button can start firing events periodically
             * when it has been pressed and held in the pressed state.
             * @param  {Boolean} b  true if the button has to fire event by
             * pressed event
             * @param  {Integer} firePeriod the period of time the button
             * has to repeat firing events if it has been pressed and
             * held in pressed state. -1 means event doesn't have
             * repeated
             * @param  {Integer} [startIn] the timeout when repeat events
             * has to be initiated
             * @method setFireParams
             */
            this.setFireParams = function (b, firePeriod, startIn){
                if (this.$repeatTask !== null) {
                    this.$repeatTask.shutdown();
                }

                this.isFireByPress = b;
                this.firePeriod = firePeriod;
                if (arguments.length > 2) {
                    this.startIn = startIn;
                }
                return this;
            };

            this.$fire = function() {
                this.fire();
                if (typeof this.fired !== 'undefined') {
                    this.fired();
                }
            };
        },

        function stateUpdated(o,n){
            this.$super(o, n);
            if (n === "pressed.over") {
                if (this.isFireByPress === true){
                    this.$fire();

                    if (this.firePeriod > 0) {
                        var $this = this;
                        this.$repeatTask = zebkit.util.tasksSet.run(function() {
                                if ($this.state === "pressed.over") {
                                    $this.$fire();
                                }
                            },
                            this.startIn,
                            this.firePeriod
                        );
                    }
                }
            } else {
                if (this.firePeriod > 0 && this.$repeatTask !== null) {
                    this.$repeatTask.shutdown();
                }

                if (n === "over" && (o === "pressed.over" && this.isFireByPress === false)) {
                    this.$fire();
                }
            }
        }
    ]);

    /**
     * Arrow button component. The component use arrow views as its icon.
     * @class zebkit.ui.ArrowButton
     * @constructor
     * @param  {String} direction an arrow icon direction. Use "left", "right", "top", "bottom" as
     * the parameter value.
     * @extends {zebkit.ui.EvStatePan}
     * @uses {zebkit.ui.ButtonRepeatMix}
     */

     /**
      * Fired when a button has been pressed

             var b = new zebkit.ui.ArrowButton("left");
             b.on(function (src) {
                 ...
             });

      * Button can be adjusted in respect how it generates the pressed event. Event can be
      * triggered by pressed or clicked even. Also event can be generated periodically if
      * the button is kept in pressed state.
      * @event fired
      * @param {zebkit.ui.ArrowButton} src a button that has been pressed
      */
    pkg.ArrowButton = Class(pkg.EvStatePan, zebkit.util.Fireable, pkg.ButtonRepeatMix, [
        function(direction) {
            this._ = new zebkit.util.Listeners();
            this.cursorType = pkg.Cursor.HAND;

            if (arguments.length > 0) {
                this.direction = zebkit.util.$validateValue(direction, "left", "right", "top", "bottom");
            }

            var clz = typeof this.clazz.$colors !== 'undefined' ? this.clazz : pkg.ArrowButton;
            this.setView({
                "out"          : new clz.ArrowView(this.direction, clz.$colors.out),
                "over"         : new clz.ArrowView(this.direction, clz.$colors.over),
                "pressed.over" : new clz.ArrowView(this.direction, clz.$colors["pressed.over"]),
                "disabled"     : new clz.ArrowView(this.direction, clz.$colors.disabled)
            });

            this.$super();
            this.syncState(this.state, this.state);
        },

        function $clazz() {
            this.ArrowView = Class(pkg.ArrowView, []);

            this.$colors = {
                "out"          : "gray",
                "over"         : "white",
                "pressed.over" : "white",
                "disabled"     : "lightGray"
            };
        },

        function $prototype() {
            /**
             * Arrow icon view direction
             * @attribute direction
             * @type {String}
             * @default "left"
             * @readOnly
             */
            this.direction = "left";

            /**
             * Set arrow view orientation.
             * @param {String} d an orientation of triangle arrow
             * @method setArrowDirection
             * @chainable
             */
            this.setArrowDirection = function(d) {
                this.iterateArrowViews(function(k, v) {
                    if (v !== null) v.direction = d;
                });
                this.repaint();
                return this;
            };

            /**
             * Set arrow view size.
             * @param {Integer} w an arrow view width
             * @param {Integer} h an arrow view height
             * @method setArrowSize
             * @chainable
             */
            this.setArrowSize = function(w, h) {
                if (arguments.length < 2) h = w;
                this.iterateArrowViews(function(k, v) {
                    if (v !== null) {
                        v.width  = w;
                        v.height = h;
                    }
                });
                this.vrp();
                return this;
            };

            /**
             * Set arrow views states colors.
             * @param {String} pressedColor a pressed state color
             * @param {String} overColor an over state color
             * @param {String} outColor an out state color
             * @method setArrowColors
             * @chainable
             */
            this.setArrowColors = function(pressedColor, overColor, outColor) {
                var views = this.view.views;
                if (views.out !== null && typeof views.out !== 'undefined') {
                    views.out.color = outColor;
                }

                if (views.over.color !== null && typeof views.over !== 'undefined') {
                    views.over.color = overColor;
                }

                if (views["pressed.over"] !== null && typeof views["pressed.over"] !== 'undefined') {
                    views["pressed.over"].color = pressedColor;
                }

                this.repaint();
                return this;
            };

            /**
             * Iterate button arrows views.
             * @param  {Function} callback a callback that is called for every found arrow view.
             * The method gets the view id and view itself as its arguments.
             * @chainable
             * @method iterateArrowViews
             */
            this.iterateArrowViews = function(callback) {
                var views = this.view.views;
                for(var k in views) {
                    if (views.hasOwnProperty(k)) {
                        callback.call(this, k, views[k]);
                    }
                }
                return this;
            };
        }
    ]);

    /**
     *  Button UI component. Button is composite component whose look and feel can
     *  be easily customized:

            // create image button
            var button = new zebkit.ui.Button(new zebkit.ui.ImagePan("icon1.gif"));

            // create image + caption button
            var button = new zebkit.ui.Button(new zebkit.ui.ImageLabel("Caption", "icon1.gif"));

            // create multilines caption button
            var button = new zebkit.ui.Button("Line1\nLine2");


     *  @class  zebkit.ui.Button
     *  @constructor
     *  @param {String|zebkit.ui.Panel|zebkit.ui.View} [t] a button label.
     *  The label can be a simple text or an UI component.
     *  @extends zebkit.ui.CompositeEvStatePan
     *  @uses  zebkit.ui.ButtonRepeatMix
     */

    /**
     * Fired when a button has been pressed

            var b = new zebkit.ui.Button("Test");
            b.on(function (src) {
                ...
            });

     * Button can be adjusted in respect how it generates the pressed event. Event can be
     * triggered by pressed or clicked even. Also event can be generated periodically if
     * the button is kept in pressed state.
     * @event buttonPressed
     * @param {zebkit.ui.Button} src a button that has been pressed
     *
     */
    pkg.Button = Class(pkg.CompositeEvStatePan, zebkit.util.Fireable, pkg.ButtonRepeatMix, [
        function(t) {
            this._ = new zebkit.util.Listeners();

            this.$super();

            if (arguments.length > 0 && t !== null) {
                t = pkg.$component(t, this);
                this.add(t);
                this.setFocusAnchorComponent(t);
            }
        },

        function $clazz() {
            this.Label = Class(pkg.Label, []);

            this.ViewPan = Class(pkg.ViewPan, [
                function(v) {
                    this.$super();
                    this.setView(v);
                },

                function $prototype() {
                    this.setState = function(id) {
                        if (this.view !== null && typeof this.view.activate !== 'undefined') {
                            this.activate(id);
                        }
                    };
                }
            ]);

            this.ImageLabel = Class(pkg.ImageLabel, []);
        },

        function $prototype() {
            /**
             * Indicates the component can have focus
             * @attribute canHaveFocus
             * @type {Boolean}
             * @default true
             */
            this.canHaveFocus = true;
        }
    ]);

    /**
     * The standard UI checkbox component switch manager implementation. The manager holds
     * boolean state of a checkbox UI component. There are few ways how a checkbox can
     * switch its state: standard checkbox or radio group. In general we have a deal with
     * one switchable UI component that can work in different modes. Thus we can re-use
     * one UI, but customize it with appropriate switch manager. That is the main idea of
     * having the class.
     * @constructor
     * @class  zebkit.ui.SwitchManager
     * @uses   {zebkit.EventProducer}
     */

    /**
     * Fired when a state has been updated

            var ch = new zebkit.ui.Checkbox("Test");
            ch.manager.on(function (src, ui) {
                ...
            });

     * @event stateUpdated
     * @param {zebkit.ui.SwitchManager} src a switch manager that controls and tracks the event
     * @param {zebkit.ui.Checkbox} ui  an UI component that triggers the event
     */
    pkg.SwitchManager = Class(zebkit.EventProducer, [
        function() {
            this._ = new zebkit.util.Listeners();
        },

        function $prototype() {
            this.value = false;

            /**
             * Get current state of the given UI component
             * @param  {zebkit.ui.Checkbox} o an ui component
             * @return {Boolean}  a boolean state
             * @method getValue
             */
            this.getValue = function(o) {
                return this.value;
            };

            /**
             * Set the state for the given UI component
             * @param  {zebkit.ui.Checkbox} o an ui component
             * @param  {Boolean} b  a boolean state
             * @method setValue
             * @chainable
             */
            this.setValue = function(o, b) {
                if (this.getValue(o) !== b){
                    this.value = b;
                    this.updated(o, b);
                }
                return this;
            };

            /**
             * Toggle the current state
             * @param  {zebkit.ui.Checkbox} o an ui component
             * @method toggle
             * @chainable
             */
            this.toggle = function(o) {
                this.setValue(o, !this.getValue(o));
                return this;
            };

            /**
             * Called every time a state has been updated.
             * @param  {zebkit.ui.Checkbox} o an ui component for which the state has been updated
             * @param  {Boolean} b  a new boolean state of the UI component
             * @method stateUpdated
             */
            this.updated = function(o, b){
                if (o !== null) o.switched(b);
                this._.fired(this, o);
            };

            /**
             * Call when the manager has been installed for the given UI component
             * @protected
             * @param  {zebkit.ui.Checkbox} o an UI component the switch manager is designated
             * @method install
             */
            this.install = function(o) {
                o.switched(this.getValue(o));
            };

            /**
             * Call when the manager has been uninstalled for the given UI component
             * @protected
             * @param  {zebkit.ui.Checkbox} o an UI component the switch manager is not anymore used
             * @method uninstall
             */
            this.uninstall = function(o) {};
        }
    ]);

    /**
     * Radio group switch manager implementation. This is an extension of "zebkit.ui.SwicthManager" to
     * support radio group switching behavior. You can use it event with normal checkbox:

           // create group of check boxes that will work as a radio group
           var gr  = new zebkit.ui.Group();
           var ch1 = new zebkit.ui.Checkbox("Test 1", gr);
           var ch2 = new zebkit.ui.Checkbox("Test 2", gr);
           var ch3 = new zebkit.ui.Checkbox("Test 3", gr);

     * @class  zebkit.ui.Group
     * @constructor
     * @extends zebkit.ui.SwitchManager
     */
    pkg.Group = Class(pkg.SwitchManager, [
        function(un) {
            this.$super();
            this.selected = null;
            if (arguments.length > 0) {
                this.allowNoneSelected = un;
            }
        },

        function $prototype() {
            this.allowNoneSelected = false;

            this.getValue = function(o) {
                return o === this.selected;
            };

            this.setValue = function(o, b){
                if (this.allowNoneSelected && b === false && this.selected !== null) {
                    var old = this.selected;
                    this.selected = null;
                    this.updated(old, false);
                } else if (b && this.selected !== o) {
                    this.clearSelected();
                    this.selected = o;
                    this.updated(this.selected, true);
                }
                return this;
            };

            this.clearSelected = function() {
                if (this.selected !== null) {
                    var old = this.selected;
                    this.selected = null;
                    this.updated(old, false);
                }
            };
        }
    ]);

    /**
     * Switchable component interface
     * @class  zebkit.ui.Switchable
     * @interface zebkit.ui.Switchable
     */
    pkg.Switchable = zebkit.Interface([
        function $prototype() {
            this.manager = null;

            /**
             * Set the check box state
             * @param  {Boolean} b a state
             * @method setValue
             * @chainable
             */
            this.setValue = function(b) {
                this.manager.setValue(this, b);
                return this;
            };

            /**
             * Toggle the component current state
             * @method toggle
             * @chainable
             */
            this.toggle = function() {
                this.manager.toggle(this);
                return this;
            };

            /**
             * Get the check box state
             * @return {Boolean} a check box state
             * @method getValue
             */
            this.getValue = function() {
                return this.manager ? this.manager.getValue(this) : false;
            };

            /**
             * Set the specified switch manager
             * @param {zebkit.ui.SwicthManager} m a switch manager
             * @method setSwicthManager
             * @chainable
             */
            this.setSwitchManager = function(m){
                /**
                 * A switch manager
                 * @attribute manager
                 * @readOnly
                 * @type {zebkit.ui.SwitchManager}
                 */
                if (m === null || typeof m === 'undefined') {
                    throw new Error("Null switch manager");
                }

                if (this.manager !== m) {
                    if (this.manager !== null) this.manager.uninstall(this);
                    this.manager = m;
                    this.manager.install(this);
                }

                return this;
            };
        }
    ]);


    /**
     * Check-box UI component. The component is a container that consists from two other UI components:

        - Box component to keep checker indicator
        - Label component to paint label

     * Developers are free to customize the component as they want. There is no limitation regarding
     * how the box and label components have to be laid out, which UI components have to be used as
     * the box or label components, etc. The check box extends state panel component and re-map states
     * to own views IDs:

       - **"pressed.out"** - checked and pointer cursor is out
       - **"out"** - un-checked and pointer cursor is out
       - **"pressed.disabled"** - disabled and checked,
       - **"disabled"** - disabled and un-checked ,
       - **"pressed.over"** - checked and pointer cursor is over
       - **"over"** - un-checked and pointer cursor is out

     *
     * Customize is quite similar to what explained for zebkit.ui.EvStatePan:
     *

            // create checkbox component
            var ch = new zebkit.ui.Checkbox("Checkbox");

            // change border when the component checked to green
            // otherwise set it to red
            ch.setBorder(new zebkit.ui.ViewSet({
                "*": new zebkit.ui.Border("red"),
                "pressed.*": new zebkit.ui.Border("green")
            }));

            // customize checker box children UI component to show
            // green for checked and red for un-cheked states
            ch.kids[0].setView(new zebkit.ui.ViewSet({
                "*": "red",
                "pressed.*": "green"
            }));
            // sync current state with new look and feel
            ch.syncState();

     * Listening checked event should be done by registering a listener in the check box switch manager
     * as follow:

            // create checkbox component
            var ch = new zebkit.ui.Checkbox("Checkbox");

            // register a checkbox listener
            ch.manager.on(function(sm) {
                var s = sm.getValue();
                ...
            });

     * @class  zebkit.ui.Checkbox
     * @extends zebkit.ui.CompositeEvStatePan
     * @uses  zebkit.ui.Switchable
     * @constructor
     * @param {String|zebkit.ui.Panel} [label] a label
     * @param {zebkit.ui.SwitchManager} [m] a switch manager
     */
    pkg.Checkbox = Class(pkg.CompositeEvStatePan, pkg.Switchable, [
        function (c, m) {
            if (arguments.length < 2) {
                m = new pkg.SwitchManager();
            }

            if (arguments.length > 0) {
                if (c !== null && zebkit.isString(c)) {
                    c = new this.clazz.Label(c);
                }
            }

            this.$super();

            /**
             * Reference to box component
             * @attribute box
             * @type {zebkit.ui.Panel}
             * @readOnly
             */
            this.box = new this.clazz.Box();
            this.add(this.box);

            if (c !== null) {
                this.add(c);
                this.setFocusAnchorComponent(c);
            }

            this.setSwitchManager(m);
        },

        function $clazz() {
            /**
             * The box UI component class that is used by default with the check box component.
             * @constructor
             * @class zebkit.ui.Checkbox.Box
             * @extends zebkit.ui.ViewPan
             */
            this.Box = Class(pkg.StatePan, []);

            /**
             * @for zebkit.ui.Checkbox
             */
            this.Label = Class(pkg.Label, []);
        },

        function $prototype() {
            /**
             * Callback method that is called whenever a state of switch
             * manager has been updated.
             * @param  {Boolean} b a new state
             * @method switched
             */
            this.switched = function(b){
                this.stateUpdated(this.state, this.state);
            };

            /**
             * Map the specified state into its symbolic name.
             * @protected
             * @param  {String} state a state
             * @return {String} a symbolic name of the state
             * @method toViewId
             */
            this.toViewId = function(state){
                if (this.isEnabled === true) {
                    if (this.getValue()) {
                        return (this.state === "over") ? "pressed.over" : "pressed.out";
                    }
                    return (this.state === "over") ? "over" : "out";
                }
                return this.getValue() ? "pressed.disabled" : "disabled";
            };
        },

        function keyPressed(e){
            if (zebkit.instanceOf(this.manager, pkg.Group) && this.getValue()){
                var d = 0;
                if (e.code === "ArrowLeft" || e.code === "ArrowUp") {
                    d = -1;
                } else if (e.code === "ArrowRight" || e.code === "ArrowDown") {
                    d = 1;
                }

                if (d !== 0) {
                    var p = this.parent;
                    for(var i = p.indexOf(this) + d;i < p.kids.length && i >= 0; i += d){
                        var l = p.kids[i];
                        if (l.isVisible === true &&
                            l.isEnabled === true &&
                            zebkit.instanceOf(l, pkg.Checkbox) &&
                            l.manager === this.manager      )
                        {
                            l.requestFocus();
                            l.setValue(true);
                            break;
                        }
                    }
                    return ;
                }
            }
            this.$super(e);
        },

        function stateUpdated(o, n) {
            if (o === "pressed.over" && n === "over") {
                this.toggle();
            }
            this.$super(o, n);
        },

        function kidRemoved(index,c) {
            if (this.box === c) {
                this.box = null;
            }
            this.$super(index,c);
        }
    ]);

    /**
     * Radio-box UI component class. This class is extension of "zebkit.ui.Checkbox" class that sets group
     * as a default switch manager. The other functionality id identical to checkbox component. Generally
     * speaking this class is a shortcut for radio box creation.
     * @class  zebkit.ui.Radiobox
     * @constructor
     * @param {String|zebkit.ui.Panel} [label] a label
     * @param {zebkit.ui.Group} [m] a switch manager
     * @extends {zebkit.ui.Checkbox}
     */
    pkg.Radiobox = Class(pkg.Checkbox, [
        function(c, group) {
            if (arguments.length < 2) {
                this.$super(c, new pkg.Group());
            } else {
                this.$super(c, group);
            }
        }
    ]);

    /**
     * UI link component class.
     * @class zebkit.ui.Link
     * @param {String} s a link text
     * @constructor
     * @extends zebkit.ui.Button
     */
    pkg.Link = Class(pkg.Button, [
        function(s) {
            // do it before super
            this.view = new pkg.DecoratedTextRender(s);
            this.overDecoration = "underline";

            this.$super(null);

            // if colors have not been set with default property set it here
            if (this.colors === null) {
                this.colors  = {
                    "pressed.over" : "blue",
                    "out"          : "white",
                    "over"         : "white",
                    "pressed.out"  : "black",
                    "disabled"     : "gray"
                };
            }

            this.stateUpdated(this.state, this.state);
        },

        function $prototype() {
            this.colors = null;

            /**
             * Mouse cursor type.
             * @attribute cursorType
             * @default zebkit.ui.Cursor.HAND;
             * @type {String}
             * @readOnly
             */
            this.cursorType = pkg.Cursor.HAND;

            /**
             * Set link font
             * @param {zebkit.ui.Font} f a font
             * @method setFont
             * @chainable
             */
            this.setFont = function(f) {
                var old = this.view !== null ? this.view.font
                                             : null;

                this.view.setFont.apply(this.view, arguments);
                if (old !== this.view.font) {
                    this.vrp();
                }
                return this;
            };

            /**
             * Set the link text color for the specified link state
             * @param {String} state a link state
             * @param {String} c a link text color
             * @method  setColor
             * @chainable
             */
            this.setColor = function(state,c){
                if (this.colors[state] !== c){
                    this.colors[state] = c;
                    this.syncState();
                }
                return this;
            };

            this.setColors = function(colors) {
                this.colors = zebkit.clone(colors);
                this.syncState();
                return this;
            };

            this.setValue = function(s) {
                this.view.setValue(s.toString());
                this.repaint();
                return this;
            };
        },

        function stateUpdated(o, n){
            this.$super(o, n);

            var k = this.toViewId(n),
                b = false;

            if (this.view !== null &&
                this.view.color !== this.colors[k] &&
                this.colors[k]  !== null &&
                typeof this.colors[k] !== 'undefined')
            {
                this.view.setColor(this.colors[k]);
                b = true;
            }

            if (this.view.decorations != null && this.overDecoration != null && this.isEnabled) {
                if (n === "over") {
                    this.view.setDecoration(this.overDecoration, this.colors[k]);
                    b = true;
                } else if (this.view.decorations[this.overDecoration] != null) {
                    this.view.setDecoration(this.overDecoration, null);
                    b = true;
                }
            }

            if (b) {
                this.repaint();
            }
        }
    ]);

    // cannot be declared in Button.$clazz since Link appears later and link inherits Button class
    pkg.Button.Link = Class(pkg.Link, []);


    /**
     * Toolbar UI component. Handy way to place number of click able elements
     * @class zebkit.ui.Toolbar
     * @constructor
     * @extends {zebkit.ui.Panel}
     */

    /**
     * Fired when a toolbar element has been pressed

            var t = new zebkit.ui.Toolbar();

            // add three pressable icons
            t.addImage("icon1.jpg");
            t.addImage("icon2.jpg");
            t.addLine();
            t.addImage("ico3.jpg");

            // catch a toolbar icon has been pressed
            t.on(function (src) {
                ...
            });

     * @event pressed
     * @constructor
     * @param {zebkit.ui.Panel} src a toolbar element that has been pressed
     */
    pkg.Toolbar = Class(pkg.Panel, [
        function () {
            this._ = new zebkit.util.Listeners();
            this.$super();
        },

        function $clazz() {
            this.ToolPan = Class(pkg.EvStatePan, [
                function(c) {
                    this.$super(new zebkit.layout.BorderLayout());
                    this.add("center", c);
                },

                function getContentComponent() {
                    return this.kids[0];
                },

                function stateUpdated(o, n) {
                    this.$super(o, n);
                    if (o === "pressed.over" && n === "over") {
                        this.parent._.fired(this);
                    }
                }
            ]);

            this.ImagePan = Class(pkg.ImagePan, []);
            this.Line     = Class(pkg.Line, []);
            this.Checkbox = Class(pkg.Checkbox, []);
            this.Radiobox = Class(pkg.Radiobox, []);

            // TODO: combo is not available in  this module yet
            // ui + ui.list has to be combined as one package
            //this.Combo    = Class(pkg.Combo, []);
        },

        function $prototype() {
            /**
             * Test if the given component is a decorative element
             * in the toolbar
             * @param  {zebkit.ui.Panel}  c a component
             * @return {Boolean} return true if the component is
             * decorative element of the toolbar
             * @method isDecorative
             * @protected
             */
            this.isDecorative = function(c){
                return zebkit.instanceOf(c, pkg.EvStatePan) === false;
            };

            /**
             * Add a radio box as the toolbar element that belongs to the
             * given group and has the specified content component
             * @param {zebkit.ui.Group} g a radio group the radio box belongs
             * @param {zebkit.ui.Panel} c a content
             * @return {zebkit.ui.Panel} a component that has been added
             * @method addRadio
             */
            this.addRadio = function(g,c) {
                var cbox = new this.clazz.Radiobox(c, g);
                cbox.setCanHaveFocus(false);
                return this.add(cbox);
            };

            /**
             * Add a check box as the toolbar element with the specified content
             * component
             * @param {zebkit.ui.Panel} c a content
             * @return {zebkit.ui.Panel} a component that has been added
             * @method addSwitcher
             */
            this.addSwitcher = function(c){
                var cbox = new this.clazz.Checkbox(c);
                cbox.setCanHaveFocus(false);
                return this.add(cbox);
            };

            /**
             * Add an image as the toolbar element
             * @param {String|Image} img an image or a path to the image
             * @return {zebkit.ui.Panel} a component that has been added
             * @method addImage
             */
            this.addImage = function(img) {
                this.validateMetric();
                return this.add(new this.clazz.ImagePan(img));
            };

            /**
             * Add line to the toolbar component. Line is a decorative ]
             * element that logically splits toolbar elements. Line as any
             * other decorative element doesn't fire event
             * @return {zebkit.ui.Panel} a component that has been added
             * @method addLine
             */
            this.addLine = function(){
                var line = new this.clazz.Line();
                line.constraints = "stretch";
                return this.addDecorative(line);
            };
        },

        /**
         * Add the given component as decorative element of the toolbar.
         * Decorative elements don't fire event and cannot be pressed
         * @param {zebkit.ui.Panel} c a component
         * @return {zebkit.ui.Panel} a component that has been added
         * @method addDecorative
         */
        function addDecorative(c) {
            return this.$getSuper("insert").call(this, this.kids.length, null, c);
        },

        function insert(i,id,d){
            if (d === "-") {
                var line = new this.clazz.Line();
                line.constraints = "stretch";
                return this.$super(i, null, line);
            } else if (Array.isArray(d)) {
                d = new this.clazz.Combo(d);
            }
            return this.$super(i, id, new this.clazz.ToolPan(d));
        }
    ]);


    /**
     *  Border panel UI component class. The component renders titled border around the
     *  given  content UI component. Border title can be placed on top or
     *  bottom border line and aligned horizontally (left, center, right). Every
     *  zebkit UI component can be used as a border title element.
     *  @param {zebkit.ui.Panel|String} [title] a border panel title. Can be a
     *  string or any other UI component can be used as the border panel title
     *  @param {zebkit.ui.Panel} [content] a content UI component of the border
     *  panel
     *  @param {Integer} [constraints] a title constraints. The constraints gives
     *  a possibility to place border panel title in different places. Generally
     *  the title can be placed on the top or bottom part of the border panel.
     *  Also the title can be aligned horizontally.
     *
     *  ```JavaScript
     *     // create border panel with a title located at the
     *     // top and aligned at the canter
     *     var bp = new zebkit.ui.BorderPan("Title",
     *                                     new zebkit.ui.Panel(),
     *                                     "top", "center");
     *  ```
     *
     *  @constructor
     *  @class zebkit.ui.BorderPan
     *  @extends {zebkit.ui.Panel}
     */
    pkg.BorderPan = Class(pkg.Panel, [
        function(title, center, o, a) {
            if (arguments.length > 0) {
                title = pkg.$component(title, this);
            }

            if (arguments.length > 2) {
                this.orient = o;
            }

            if (arguments.length > 3) {
                this.alignment = a;
            }

            /**
             * Border panel label component
             * @attribute label
             * @type {zebkit.ui.Panel}
             * @readOnly
             */

            this.$super();
            if (arguments.length > 0) this.add("caption", title);
            if (arguments.length > 1) this.add("center", center);
        },

        function $clazz() {
            this.Label = Class(pkg.Label, []);
            this.ImageLabel = Class(pkg.ImageLabel, []);
            this.Checkbox = Class(pkg.Checkbox, []);
        },

        function $prototype() {
            /**
             * Border panel label content component
             * @attribute content
             * @type {zebkit.ui.Panel}
             * @readOnly
             */
            this.label = this.content = null;

            /**
             * Vertical gap. Define top and bottom paddings between
             * border panel border and the border panel content
             * @attribute vGap
             * @type {Integer}
             * @readOnly
             * @default 0
             */

             /**
              * Horizontal gap. Define left and right paddings between
              * border panel border and the border panel content
              * @attribute hGap
              * @type {Integer}
              * @readOnly
              * @default 0
              */
            this.vGap = this.hGap = 2;

             /**
              * Border panel label indent
              * @type {Integer}
              * @attribute indent
              * @readOnly
              * @default 4
              */
            this.indent = 4;

            /**
             * Border panel title area arrangement. Border title can be placed
             * either at the top or bottom area of border panel component.
             * @type {String}
             * @attribute orient
             * @readOnly
             * @default "top"
             */
            this.orient = "top";

            /**
             * Border panel title horizontal alignment.
             * @type {String}
             * @attribute alignment
             * @readOnly
             * @default "left"
             */
            this.alignment = "left";

             /**
              * Get the border panel title info. The information
              * describes a rectangular area the title occupies, the
              * title location and alignment
              * @return {Object} a title info
              *
              *  {
              *      x: {Integer}, y: {Integer},
              *      width: {Integer}, height: {Integer},
              *      orient: {Integer}
              *  }
              *
              * @method getTitleInfo
              * @protected
              */
            this.getTitleInfo = function() {
                return (this.label !== null) ? { x      : this.label.x,
                                                 y      : this.label.y,
                                                 width  : this.label.width,
                                                 height : this.label.height,
                                                 orient: this.orient }
                                             : null;
            };

            this.calcPreferredSize = function(target){
                var ps = this.content !== null && this.content.isVisible === true ? this.content.getPreferredSize()
                                                                                  : { width:0, height:0 };
                if (this.label !== null && this.label.isVisible === true){
                    var lps = this.label.getPreferredSize();
                    ps.height += lps.height;
                    ps.width = Math.max(ps.width, lps.width + this.indent);
                }
                ps.width  += (this.hGap * 2);
                ps.height += (this.vGap * 2);
                return ps;
            };

            this.doLayout = function (target){
                var h = 0,
                    right  = this.getRight(),
                    left   = this.getLeft(),
                    top    = this.orient === "top"   ? this.top    : this.getTop(),
                    bottom = this.orient === "bottom"? this.bottom : this.getBottom();

                if (this.label !== null && this.label.isVisible === true){
                    var ps = this.label.getPreferredSize();
                    h = ps.height;
                    this.label.setBounds((this.alignment === "left") ? left + this.indent
                                                                      : ((this.alignment === "right") ? this.width - right - ps.width - this.indent
                                                                                                       : Math.floor((this.width - ps.width) / 2)),
                                         (this.orient === "bottom") ? (this.height - bottom - ps.height) : top,
                                         ps.width, h);
                }

                if (this.content !== null && this.content.isVisible === true){
                    this.content.setBounds(left + this.hGap,
                                           (this.orient === "bottom" ? top : top + h) + this.vGap,
                                            this.width  - right - left - 2 * this.hGap,
                                            this.height - top - bottom - h - 2 * this.vGap);
                }
            };

            /**
             * Set vertical and horizontal paddings between the border panel border and the content
             * of the border panel
             * @param {Integer} vg a top and bottom paddings
             * @param {Integer} hg a left and right paddings
             * @method setGaps
             * @chainable
             */
            this.setGaps = function(vg, hg){
                if (this.vGap !== vg || hg !== this.hGap){
                    this.vGap = vg;
                    this.hGap = hg;
                    this.vrp();
                }
                return this;
            };

            /**
             * Set border panel title orientation. The title area can be
             * placed either at the top or at the bottom of border panel
             * component.
             * @param {String} o a border title orientation. Can be "top" or "bottom"
             * @method setOrientation
             * @chainable
             */
            this.setOrientation = function(o) {
                if (this.orient !== o) {
                    this.orient = zebkit.util.$validateValue(o, "top", "bottom");
                    this.vrp();
                }
                return this;
            };

            /**
             * Set border panel title horizontal alignment.
             * @param {String} a a horizontal alignment. Use "left", "right", "center" as
             * the parameter value.
             * @method setAlignment
             * @chainable
             */
            this.setAlignment = function(a) {
                if (this.alignment !== a) {
                    this.alignment = zebkit.util.$validateValue(a, "left", "right", "center");
                    this.vrp();
                }
                return this;
            };
        },

        function setBorder(br) {
            br = pkg.$view(br);
            if (zebkit.instanceOf(br, pkg.TitledBorder) === false) {
                br = new pkg.TitledBorder(br, "center");
            }
            return this.$super(br);
        },

        function kidAdded(index, ctr, lw) {
            this.$super(index, ctr, lw);
            if ((ctr === null && this.content === null) || "center" === ctr) {
                this.content = lw;
            } else if (this.label === null) {
                this.label = lw;
            }
        },

        function kidRemoved(index,lw){
            this.$super(index, lw);
            if (lw === this.label) {
                this.label = null;
            } else if (this.content === lw) {
                this.content = null;
            }
        }
    ]);

    /**
     * Splitter panel UI component class. The component splits its area horizontally or vertically into two areas.
     * Every area hosts an UI component. A size of the parts can be controlled by pointer cursor dragging. Gripper
     * element is children UI component that can be customized. For instance:

          // create split panel
          var sp = new zebkit.ui.SplitPan(new zebkit.ui.Label("Left panel"),
                                          new zebkit.ui.Label("Right panel"));

          // customize gripper background color depending on its state
          sp.gripper.setBackground(new zebkit.ui.ViewSet({
               "over" : "yellow"
               "out" : null,
               "pressed.over" : "red"
          }));


     * @param {zebkit.ui.Panel} [first] a first UI component in splitter panel
     * @param {zebkit.ui.Panel} [second] a second UI component in splitter panel
     * @param {String} [o] an orientation of splitter element: "vertical" or "horizontal"
     * @class zebkit.ui.SplitPan
     * @constructor
     * @extends {zebkit.ui.Panel}
     */
    pkg.SplitPan = Class(pkg.Panel, [
        function(f,s,o) {
            if (arguments.length > 2) {
                this.orient = o;
            }

            this.$super();

            if (arguments.length > 0) this.add("left", f);
            if (arguments.length > 1) this.add("right", s);
            this.add("center", new this.clazz.Bar(this));
        },

        function $clazz() {
            this.Bar = Class(pkg.EvStatePan, [
                function(target) {
                    this.target = target;
                    this.$super();
                },

                function $prototype() {
                    this.prevLoc = 0;

                    this.pointerDragged = function(e){
                        var x = this.x + e.x, y = this.y + e.y;
                        if (this.target.orient === "vertical"){
                            if (this.prevLoc !== x){
                                x = this.target.normalizeBarLoc(x);
                                if (x > 0){
                                    this.prevLoc = x;
                                    this.target.setGripperLoc(x);
                                }
                            }
                        } else {
                            if (this.prevLoc !== y) {
                                y = this.target.normalizeBarLoc(y);
                                if (y > 0){
                                    this.prevLoc = y;
                                    this.target.setGripperLoc(y);
                                }
                            }
                        }
                    };

                    this.pointerDragStarted = function (e){
                        var x = this.x + e.x,
                            y = this.y + e.y;

                        if (e.isAction()) {
                            if (this.target.orient === "vertical"){
                                x = this.target.normalizeBarLoc(x);
                                if (x > 0) this.prevLoc = x;
                            } else {
                                y = this.target.normalizeBarLoc(y);
                                if (y > 0) this.prevLoc = y;
                            }
                        }
                    };

                    this.pointerDragEnded = function(e){
                        var xy = this.target.normalizeBarLoc(this.target.orient === "vertical" ? this.x + e.x
                                                                                               : this.y + e.y);
                        if (xy > 0) this.target.setGripperLoc(xy);
                    };

                    this.getCursorType = function(t, x, y) {
                        return (this.target.orient === "vertical" ? pkg.Cursor.W_RESIZE
                                                                  : pkg.Cursor.N_RESIZE);
                    };
                }
            ]);
        },

        function $prototype() {
            /**
             * A minimal size of the left (or top) sizable panel
             * @attribute leftMinSize
             * @type {Integer}
             * @readOnly
             * @default 50
             */

            /**
             * A minimal size of right (or bottom) sizable panel
             * @attribute rightMinSize
             * @type {Integer}
             * @readOnly
             * @default 50
             */

            /**
             * Indicates if the splitter bar can be moved
             * @attribute isMoveable
             * @type {Boolean}
             * @readOnly
             * @default true
             */

            /**
             * A gap between gripper element and first and second UI components
             * @attribute gap
             * @type {Integer}
             * @readOnly
             * @default 1
             */

            /**
             * A reference to gripper UI component
             * @attribute gripper
             * @type {zebkit.ui.Panel}
             * @readOnly
             */

            /**
             * A reference to left (top) sizable UI component
             * @attribute leftComp
             * @type {zebkit.ui.Panel}
             * @readOnly
             */

            /**
             * A reference to right (bottom) sizable UI component
             * @attribute rightComp
             * @type {zebkit.ui.Panel}
             * @readOnly
             */

            this.leftMinSize = this.rightMinSize = 50;
            this.isMoveable = true;
            this.gap = 1;
            this.orient = "vertical";

            this.minXY = this.maxXY = 0;
            this.barLocation = 70;
            this.leftComp = this.rightComp = this.gripper = null;

            this.normalizeBarLoc = function(xy){
                if (xy < this.minXY) xy = this.minXY;
                else {
                    if (xy > this.maxXY) xy = this.maxXY;
                }
                return (xy > this.maxXY || xy < this.minXY) ?  -1 : xy;
            };

            /**
             * Set split panel orientation.
             * @param  {String} o an orientation ("horizontal" or "vertical")
             * @method setOrientation
             * @chainable
             */
            this.setOrientation = function(o) {
                if (o !== this.orient) {
                    this.orient = zebkit.util.$validateValue(o, "horizontal", "vertical");
                    this.vrp();
                }
                return this;
            };

            /**
             * Set gripper element location
             * @param  {Integer} l a location of the gripper element
             * @method setGripperLoc
             * @chainable
             */
            this.setGripperLoc = function(l){
                if (l !== this.barLocation){
                    this.barLocation = l;
                    this.vrp();
                }
                return this;
            };

            this.calcPreferredSize = function(c){
                var fSize = pkg.$getPS(this.leftComp),
                    sSize = pkg.$getPS(this.rightComp),
                    bSize = pkg.$getPS(this.gripper);

                if (this.orient === "horizontal"){
                    bSize.width = Math.max(((fSize.width > sSize.width) ? fSize.width : sSize.width), bSize.width);
                    bSize.height = fSize.height + sSize.height + bSize.height + 2 * this.gap;
                }
                else {
                    bSize.width = fSize.width + sSize.width + bSize.width + 2 * this.gap;
                    bSize.height = Math.max(((fSize.height > sSize.height) ? fSize.height : sSize.height), bSize.height);
                }
                return bSize;
            };

            this.doLayout = function(target){
                var right  = this.getRight(),
                    top    = this.getTop(),
                    bottom = this.getBottom(),
                    left   = this.getLeft(),
                    bSize  = pkg.$getPS(this.gripper);

                if (this.orient === "horizontal"){
                    var w = this.width - left - right;
                    if (this.barLocation < top) this.barLocation = top;
                    else {
                        if (this.barLocation > this.height - bottom - bSize.height) {
                            this.barLocation = this.height - bottom - bSize.height;
                        }
                    }

                    if (this.gripper !== null){
                        if (this.isMoveable){
                            this.gripper.setBounds(left, this.barLocation, w, bSize.height);
                        } else {
                            this.gripper.toPreferredSize();
                            this.gripper.setLocation(Math.floor((w - bSize.width) / 2), this.barLocation);
                        }
                    }

                    if (this.leftComp !== null){
                        this.leftComp.setBounds(left, top, w, this.barLocation - this.gap - top);
                    }

                    if (this.rightComp !== null){
                        this.rightComp.setLocation(left, this.barLocation + bSize.height + this.gap);
                        this.rightComp.setSize(w, this.height - this.rightComp.y - bottom);
                    }
                } else {
                    var h = this.height - top - bottom;
                    if (this.barLocation < left) this.barLocation = left;
                    else {
                        if (this.barLocation > this.width - right - bSize.width) {
                            this.barLocation = this.width - right - bSize.width;
                        }
                    }

                    if (this.gripper !== null){
                        if (this.isMoveable === true){
                            this.gripper.setBounds(this.barLocation, top, bSize.width, h);
                        } else{
                            this.gripper.setBounds(this.barLocation, Math.floor((h - bSize.height) / 2),
                                                   bSize.width, bSize.height);
                        }
                    }

                    if (this.leftComp !== null){
                        this.leftComp.setBounds(left, top, this.barLocation - left - this.gap, h);
                    }

                    if (this.rightComp !== null){
                        this.rightComp.setLocation(this.barLocation + bSize.width + this.gap, top);
                        this.rightComp.setSize(this.width - this.rightComp.x - right, h);
                    }
                }
            };

            /**
             * Set gap between gripper element and sizable panels
             * @param  {Integer} g a gap
             * @method setGap
             * @chainable
             */
            this.setGap = function (g){
                if (this.gap !== g){
                    this.gap = g;
                    this.vrp();
                }
                return this;
            };

            /**
             * Set the minimal size of the left (or top) sizeable panel
             * @param  {Integer} m  a minimal possible size
             * @method setLeftMinSize
             * @chainable
             */
            this.setLeftMinSize = function (m){
                if (this.leftMinSize !== m){
                    this.leftMinSize = m;
                    this.vrp();
                }
                return this;
            };

            /**
             * Set the minimal size of the right (or bottom) sizeable panel
             * @param  {Integer} m  a minimal possible size
             * @method setRightMinSize
             * @chainable
             */
            this.setRightMinSize = function(m){
                if (this.rightMinSize !== m){
                    this.rightMinSize = m;
                    this.vrp();
                }
                return this;
            };

            /**
             * Set the given gripper movable state
             * @param  {Boolean} b the gripper movable state.
             * @method setGripperMovable
             */
            this.setGripperMovable = function (b){
                if (b !== this.isMoveable){
                    this.isMoveable = b;
                    this.vrp();
                }
                return this;
            };
        },

        function kidAdded(index, ctr, c){
            this.$super(index, ctr, c);

            if ((ctr === null && this.leftComp === null) || "left" === ctr) {
                this.leftComp = c;
            } else if ((ctr === null && this.rightComp === null) || "right" === ctr) {
                this.rightComp = c;
            } else {
                if ("center" === ctr) this.gripper = c;
                else throw new Error("" + ctr);
            }
        },

        function kidRemoved(index,c){
            this.$super(index, c);
            if (c === this.leftComp) this.leftComp = null;
            else {
                if (c === this.rightComp) {
                    this.rightComp = null;
                } else {
                    if (c === this.gripper) this.gripper = null;
                }
            }
        },

        function resized(pw,ph) {
            var ps = this.gripper.getPreferredSize();
            if (this.orient === "vertical"){
                this.minXY = this.getLeft() + this.gap + this.leftMinSize;
                this.maxXY = this.width - this.gap - this.rightMinSize - ps.width - this.getRight();
            }
            else {
                this.minXY = this.getTop() + this.gap + this.leftMinSize;
                this.maxXY = this.height - this.gap - this.rightMinSize - ps.height - this.getBottom();
            }
            this.$super(pw, ph);
        }
    ]);

    /**
     * Extendable  UI panel class. Implement collapsible panel where
     * a user can hide of show content by pressing special control
     * element:

            // create extendable panel that contains list as its content
            var ext = zebkit.ui.CollapsiblePan("Title", new zebkit.ui.List([
                "Item 1",
                "Item 2",
                "Item 3"
            ]));


     * @constructor
     * @class zebkit.ui.CollapsiblePan
     * @uses zebkit.ui.Switchable
     * @extends {zebkit.ui.Panel}
     * @param {zebkit.ui.Panel|String} l a title label text or
     * @param {zebkit.ui.Panel} c a content of the extender panel
     * component
     */

     /**
      * Fired when extender is collapsed or extended

             var ex = new zebkit.ui.CollapsiblePan("Title", pan);
             ex.on(function (src, isCollapsed) {
                 ...
             });

      * @event fired
      * @param {zebkit.ui.CollapsiblePan} src an extender UI component that generates the event
      * @param {Boolean} isCollapsed a state of the extender UI component
      */
    pkg.CollapsiblePan = Class(pkg.Panel, pkg.Switchable, [
        function(lab, content, sm){
            this.$super();

            /**
             * Title panel
             * @type {zebkit.ui.Panel}
             * @attribute titlePan
             * @readOnly
             */
            this.titlePan = new this.clazz.TitlePan();
            this.add("top", this.titlePan);

            this.titlePan.add(new this.clazz.TogglePan(this));
            this.titlePan.add(pkg.$component(arguments.length === 0 || lab === null ? "" : lab, this));

            /**
             * Content panel
             * @type {zebkit.ui.Panel}
             * @readOnly
             * @attribute contentPan
             */
            if (arguments.length > 1 && content !== null) {
                this.contentPan = content;
                this.add("center", this.contentPan);
            }

            this.setSwitchManager(arguments.length > 2 ? sm : new pkg.SwitchManager());
        },

        function $clazz() {
            this.Label = Class(pkg.Label,[]);

            this.ImageLabel = Class(pkg.ImageLabel,[]);

            this.TitlePan = Class(pkg.StatePan,[]);

            this.TogglePan = Class(pkg.StatePan, [
                function(sw) {
                    if (zebkit.instanceOf(sw, pkg.Switchable) === false) {
                        throw new Error("Passed component has to implement Switchable interface");
                    }
                    this.switchable = sw;
                    this.$super();
                },

                function $prototype() {
                    this.switchable = null;
                    this.cursorType = pkg.Cursor.HAND;

                    this.pointerPressed = function(e){
                        if (e.isAction()) {
                            this.switchable.toggle();
                        }
                    };
                }
            ]);

            this.GroupPan = Class(pkg.Panel, [
                function $clazz() {
                    this.Group = Class(pkg.Group, [
                        function(target) {
                            this.target = target;
                            this.$super(true);
                        },

                        function setValue(o, v) {
                            var selected = this.selected;
                            this.$super(o, v);

                            if (v === false && selected !== null && this.selected === null) {
                                var i = this.target.indexOf(selected);
                                i = (i + 1) % this.target.kids.length;
                                if (this.target.kids[i] !== selected) {
                                    this.setValue(this.target.kids[i], true);
                                }
                            }
                            return this;
                        }
                    ]);
                },

                function $prototype() {
                    this.doLayout = function(t) {
                        var y     = t.getTop(),
                            x     = t.getLeft(),
                            w     = t.width - x - t.getRight(),
                            eh    = t.height - y - t.getBottom(),
                            kid   = null,
                            i     = 0;

                        // setup sizes for not selected item and calculate the vertical
                        // space that can be used for an expanded item
                        for(i = 0; i < t.kids.length; i++) {
                            kid = t.kids[i];
                            if (kid.isVisible) {
                                if (kid.getValue() === false) {
                                    var psh = kid.getPreferredSize().height;
                                    eh -= psh;
                                    kid.setSize(w, psh);
                                }
                            }
                        }

                        for(i = 0; i < t.kids.length; i++) {
                            kid = t.kids[i];
                            if (kid.isVisible) {
                                kid.setLocation(x, y);
                                if (kid.getValue()) {
                                    kid.setSize(w, eh);
                                }
                                y += kid.height;
                            }
                        }
                    };

                    this.calcPreferredSize = function(t) {
                        var w = 0, h = 0;
                        for(var i = 0; i < t.kids.length; i++) {
                            var kid = t.kids[i];
                            if (kid.isVisible) {
                                var ps = kid.getPreferredSize();
                                h += ps.height;
                                if (ps.width > w) w = ps.width;
                            }
                        }
                        return { width: w, height:h };
                    };

                    this.compAdded = function(e) {
                        e.kid.setSwitchManager(this.group);
                        if (this.group.selected === null) {
                            this.group.setValue(e.kid, true);
                        }
                    };

                    this.compRemoved = function(e) {
                        if (this.group.selected === e.kid) {
                            this.group.setValue(e.kid, false);
                        }
                        e.kid.setSwitchManager(null);
                    };
                },

                function() {
                    this.group = new this.clazz.Group(this);
                    this.$super();
                    for(var i = 0; i < arguments.length; i++) {
                        arguments[i].setSwitchManager(this.group);
                        this.add(arguments[i]);
                    }
                }
            ]);
        },

        function $prototype() {
            this.contentPan = null;
            this.titlePan   = null;

            this.switched = function() {
                var value = this.getValue();
                if (this.contentPan !== null) {
                    this.contentPan.setVisible(value);
                }

                if (this.titlePan !== null) {
                    this.titlePan.setState(value ? "on" : "off" );
                }
            };

            this.compEnabled = function (e) {
                if (this.titlePan !== null) {
                    var v = this.getValue();
                    this.titlePan.setState(this.isEnable ? (v ? "on" : "off")
                                                         : (v ? "dison" : "disoff") );
                }
            };

            this.compRemoved = function (e) {
                if (this.titlePan === e.kid) {
                    this.titlePan = null;
                } else if (e.kid === this.contentPan) {
                    this.contentPan = null;
                }
            };
        }
    ]);

    /**
     * Status bar UI component class
     * @class zebkit.ui.StatusBar
     * @constructor
     * @param {Integer} [gap] a gap between status bar children elements
     * @extends {zebkit.ui.Panel}
     */
    pkg.StatusBarPan = Class(pkg.Panel, [
        function (gap){
            if (arguments.length === 0) {
                gap = 2;
            }

            this.setPadding(gap, 0, 0, 0);
            this.$super(new zebkit.layout.PercentLayout("horizontal", gap));
        },

        function $prototype() {
            /**
             * Set the specified border to be applied for status bar children components
             * @param {zebkit.ui.View} v a border
             * @method setBorderView
             * @chainable
             */
            this.setBorderView = function(v){
                if (v != this.borderView){
                    this.borderView = v;
                    for(var i = 0; i < this.kids.length; i++) {
                        this.kids[i].setBorder(this.borderView);
                    }
                    this.repaint();
                }
                return this;
            };
        },

        function insert(i,s,d){
            d.setBorder(this.borderView);
            this.$super(i, s, d);
        }
    ]);

    /**
     * Panel class that uses zebkit.layout.StackLayout as a default layout manager.
     * @class  zebkit.ui.StackPan
     * @constructor
     * @extends {zebkit.ui.Panel}
     */
    pkg.StackPan = Class(pkg.Panel, [
        function() {
            this.$super(new zebkit.layout.StackLayout());
            for(var i = 0; i < arguments.length; i++) {
                this.add(arguments[i]);
            }
        }
    ]);


    /**
     * Scroll manager class.
     * @param {zebkit.ui.Panel} t a target component to be scrolled
     * @constructor
     * @class zebkit.ui.ScrollManager
     */

     /**
      * Fired when a target component has been scrolled

            scrollManager.on(function(px, py) {
                ...
            });

      * @event scrolled
      * @param  {Integer} px a previous x location target component scroll location
      * @param  {Integer} py a previous y location target component scroll location
      */

     /**
      * Fired when a scroll state has been updated

            scrollManager.scrollStateUpdated = function(x, y, px, py) {
                ...
            };

      * @event scrollStateUpdated
      * @param  {Integer} x a new x location target component scroll location
      * @param  {Integer} y a new y location target component scroll location
      * @param  {Integer} px a previous x location target component scroll location
      * @param  {Integer} py a previous y location target component scroll location
      */
    pkg.ScrollManager = Class(zebkit.EventProducer, [
        function(c) {
            this._  = new this.clazz.Listeners();

            /**
             * Target UI component for that the scroll manager has been instantiated
             * @attribute target
             * @type {zebkit.ui.Panel}
             * @readOnly
             */
            this.target = c;
        },

        function $clazz() {
            this.Listeners = zebkit.util.ListenersClass("scrolled");
        },

        function $prototype() {
            this.sx = this.sy = 0;

            /**
             * Get current target component x scroll location
             * @return {Integer} a x scroll location
             * @method getSX
             */
            this.getSX = function() {
                return this.sx;
            };

            /**
             * Get current target component y scroll location
             * @return {Integer} a y scroll location
             * @method getSY
             */
            this.getSY = function() {
                return this.sy;
            };

            /**
             * Set a target component scroll x location to the
             * specified value
             * @param  {Integer} v a x scroll location
             * @method scrollXTo
             */
            this.scrollXTo = function(v){
                this.scrollTo(v, this.getSY());
            };

            /**
             * Set a target component scroll y location to the
             * specified value
             * @param  {Integer} v a y scroll location
             * @method scrollYTo
             */
            this.scrollYTo = function(v){
                this.scrollTo(this.getSX(), v);
            };

            /**
             * Scroll the target component into the specified location
             * @param  {Integer} x a x location
             * @param  {Integer} y a y location
             * @method scrollTo
             */
            this.scrollTo = function(x, y){
                var psx = this.getSX(),
                    psy = this.getSY();

                if (psx !== x || psy !== y){
                    this.sx = x;
                    this.sy = y;
                    if (typeof this.scrollStateUpdated !== 'undefined') this.scrollStateUpdated(x, y, psx, psy);
                    if (typeof this.target.catchScrolled !== 'undefined') this.target.catchScrolled(psx, psy);
                    this._.scrolled(psx, psy);
                }
                return this;
            };

            /**
             * Make visible the given rectangular area of the
             * scrolled target component
             * @param  {Integer} x a x coordinate of top left corner
             * of the rectangular area
             * @param  {Integer} y a y coordinate of top left corner
             * of the rectangular area
             * @param  {Integer} w a width of the rectangular area
             * @param  {Integer} h a height of the rectangular area
             * @method makeVisible
             * @chainable
             */
            this.makeVisible = function(x,y,w,h){
                var p = pkg.calcOrigin(x, y, w, h, this.getSX(), this.getSY(), this.target);
                this.scrollTo(p[0], p[1]);
                return this;
            };
        }
    ]);

    /**
     * Scroll bar UI component
     * @param {String} [t] orientation of the scroll bar components:

            "vertical" - vertical scroll bar
            "horizontal"- horizontal scroll bar

     * @class zebkit.ui.Scroll
     * @constructor
     * @extends {zebkit.ui.Panel}
     * @uses {zebkit.util.Position.Metric}
     * @uses  {zebkit.util.Position.Metric}
     */
    pkg.Scroll = Class(pkg.Panel, zebkit.util.Position.Metric, [
        function(t) {
            if (arguments.length > 0) {
                this.orient = zebkit.util.$validateValue(t, "vertical", "horizontal");
            }

            /**
             * Increment button
             * @attribute incBt
             * @type {zebkit.ui.Button}
             * @readOnly
             */

            /**
             * Decrement button
             * @attribute decBt
             * @type {zebkit.ui.Button}
             * @readOnly
             */

            /**
             * Scroll bar bundle component
             * @attribute bundle
             * @type {zebkit.ui.Panel}
             * @readOnly
             */

            this.bundleLoc = 0;
            this.startDragLoc = Number.MAX_VALUE;
            this.$super(this);

            var b = (this.orient === "vertical");
            this.add("center", b ? new pkg.Scroll.VBundle()    : new pkg.Scroll.HBundle());
            this.add("top"   , b ? new pkg.Scroll.VDecButton() : new pkg.Scroll.HDecButton());
            this.add("bottom", b ? new pkg.Scroll.VIncButton() : new pkg.Scroll.HIncButton());

            this.setPosition(new zebkit.util.SingleColPosition(this));
        },

        function $clazz() {
            this.isDragable = true;

            this.ArrowButton = Class(pkg.ArrowButton, [
                function $prototype() {
                    this.isFireByPress  = true;
                    this.firePeriod     = 20;
                }
            ]);

            this.VIncButton = Class(this.ArrowButton, []);
            this.VDecButton = Class(this.ArrowButton, []);
            this.HIncButton = Class(this.ArrowButton, []);
            this.HDecButton = Class(this.ArrowButton, []);

            this.VBundle = Class(pkg.Panel, []);
            this.HBundle = Class(pkg.Panel, []);

            this.MIN_BUNDLE_SIZE = 16;
        },

        function $prototype() {
            this.incBt = this.decBt = this.bundle = this.position = null;

            /**
             * Maximal possible value
             * @attribute max
             * @type {Integer}
             * @readOnly
             * @default 100
             */
            this.extra = this.max  = 100;

            /**
             * Page increment value
             * @attribute pageIncrement
             * @type {Integer}
             * @readOnly
             * @default 20
             */
            this.pageIncrement = 20;

            /**
             * Unit increment value
             * @attribute unitIncrement
             * @type {Integer}
             * @readOnly
             * @default 5
             */
            this.unitIncrement = 5;


            this.orient = "vertical";

            /**
             * Evaluate if the given point is in scroll bar bundle element
             * @param  {Integer}  x a x location
             * @param  {Integer}  y a y location
             * @return {Boolean}   true if the point is located inside the
             * scroll bar bundle element
             * @method isInBundle
             */
            this.isInBundle = function(x,y){
                var bn = this.bundle;
                return (bn !== null &&
                        bn.isVisible === true &&
                        bn.x <= x && bn.y <= y &&
                        bn.x + bn.width > x &&
                        bn.y + bn.height > y);
            };

            this.amount = function(){
                var db = this.decBt;
                return (this.orient === "vertical") ? this.incBt.y - db.y - db.height
                                                  : this.incBt.x - db.x - db.width;
            };

            this.pixel2value = function(p) {
                var db = this.decBt;
                return (this.orient === "vertical") ? Math.floor((this.max * (p - db.y - db.height)) / (this.amount() - this.bundle.height))
                                                    : Math.floor((this.max * (p - db.x - db.width )) / (this.amount() - this.bundle.width));
            };

            this.value2pixel = function(){
                var db = this.decBt, bn = this.bundle, off = this.position.offset;
                return (this.orient === "vertical") ? db.y + db.height +  Math.floor(((this.amount() - bn.height) * off) / this.max)
                                                    : db.x + db.width  +  Math.floor(((this.amount() - bn.width) * off) / this.max);
            };


            /**
             * Define composite component catch input method
             * @param  {zebkit.ui.Panel} child a children component
             * @return {Boolean} true if the given children component has to be input events transparent
             * @method catchInput
             */
            this.catchInput = function (child){
                return child === this.bundle || (this.bundle.kids.length > 0 &&
                                                 zebkit.layout.isAncestorOf(this.bundle, child));
            };

            this.posChanged = function(target,po,pl,pc){
                if (this.bundle !== null) {
                    if (this.orient === "horizontal") {
                        this.bundle.setLocation(this.value2pixel(), this.getTop());
                    } else {
                        this.bundle.setLocation(this.getLeft(), this.value2pixel());
                    }
                }
            };

            this.getLines     = function ()     { return this.max; };
            this.getLineSize  = function (line) { return 1; };
            this.getMaxOffset = function ()     { return this.max; };

            this.fired = function(src){
                this.position.setOffset(this.position.offset + ((src === this.incBt) ? this.unitIncrement
                                                                                     : -this.unitIncrement));
            };

            /**
             * Define pointer dragged events handler
             * @param  {zebkit.ui.PointerEvent} e a pointer event
             * @method pointerDragged
             */
            this.pointerDragged = function(e){
                if (Number.MAX_VALUE !== this.startDragLoc) {
                    this.position.setOffset(this.pixel2value(this.bundleLoc -
                                                             this.startDragLoc +
                                                             ((this.orient === "horizontal") ? e.x : e.y)));
                }
            };

            /**
             * Define pointer drag started  events handler
             * @param  {zebkit.ui.PointerEvent} e a pointer event
             * @method pointerDragStarted
             */
            this.pointerDragStarted = function (e){
                if (this.isDragable === true && this.isInBundle(e.x, e.y)) {
                    this.startDragLoc = this.orient === "horizontal" ? e.x : e.y;
                    this.bundleLoc    = this.orient === "horizontal" ? this.bundle.x : this.bundle.y;
                }
            };

            /**
             * Define pointer drag ended events handler
             * @param  {zebkit.ui.PointerEvent} e a pointer event
             * @method pointerDragEnded
             */
            this.pointerDragEnded = function(e) {
                this.startDragLoc = Number.MAX_VALUE;
            };

            /**
             * Define pointer clicked events handler
             * @param  {zebkit.ui.PointerEvent} e a pointer event
             * @method pointerClicked
             */
            this.pointerClicked = function (e){
                if (this.isInBundle(e.x, e.y) === false && e.isAction()){
                    var d = this.pageIncrement;
                    if (this.orient === "vertical"){
                        if (e.y < (this.bundle !== null ? this.bundle.y : Math.floor(this.height / 2))) d =  -d;
                    } else {
                        if (e.x < (this.bundle !== null ? this.bundle.x : Math.floor(this.width / 2))) d =  -d;
                    }
                    this.position.setOffset(this.position.offset + d);
                }
            };

            this.calcPreferredSize = function (target){
                var ps1 = pkg.$getPS(this.incBt),
                    ps2 = pkg.$getPS(this.decBt),
                    ps3 = pkg.$getPS(this.bundle);

                if (this.orient === "horizontal"){
                    ps1.width += (ps2.width + ps3.width);
                    ps1.height = Math.max((ps1.height > ps2.height ? ps1.height : ps2.height), ps3.height);
                } else {
                    ps1.height += (ps2.height + ps3.height);
                    ps1.width = Math.max((ps1.width > ps2.width ? ps1.width : ps2.width), ps3.width);
                }
                return ps1;
            };

            this.doLayout = function(target){
                var right  = this.getRight(),
                    top    = this.getTop(),
                    bottom = this.getBottom(),
                    left   = this.getLeft(),
                    ew     = this.width - left - right,
                    eh     = this.height - top - bottom,
                    b      = (this.orient === "horizontal"),
                    ps1    = pkg.$getPS(this.decBt),
                    ps2    = pkg.$getPS(this.incBt),
                    minbs  = this.clazz.MIN_BUNDLE_SIZE;

                this.decBt.setBounds(left, top, b ? ps1.width
                                                  : ew,
                                                b ? eh
                                                  : ps1.height);


                this.incBt.setBounds(b ? this.width - right - ps2.width : left,
                                     b ? top : this.height - bottom - ps2.height,
                                     b ? ps2.width : ew,
                                     b ? eh : ps2.height);

                if (this.bundle !== null && this.bundle.isVisible === true){
                    var am = this.amount();
                    if (am > minbs) {
                        var bsize = Math.max(Math.min(Math.floor((this.extra * am) / this.max), am - minbs), minbs);
                        this.bundle.setBounds(b ? this.value2pixel() : left,
                                              b ? top   : this.value2pixel(),
                                              b ? bsize : ew,
                                              b ? eh    : bsize);
                    } else {
                        this.bundle.setSize(0, 0);
                    }
                }
            };

            /**
             * Set the specified maximum value of the scroll bar component
             * @param {Integer} m a maximum value
             * @method setMaximum
             * @chainable
             */
            this.setMaximum = function (m){
                if (m !== this.max) {
                    this.max = m;
                    if (this.position.offset > this.max) {
                        this.position.setOffset(this.max);
                    }
                    this.vrp();
                }
                return this;
            };

            /**
             * Set the scroll bar value.
             * @param {Integer} v a scroll bar value.
             * @method setValue
             * @chainable
             */
            this.setValue = function(v){
                this.position.setOffset(v);
                return this;
            };

            this.setPosition = function(p){
                if (p !== this.position){
                    if (this.position !== null) this.position.off(this);
                    this.position = p;

                    if (this.position !== null){
                        this.position.on(this);
                        this.position.setMetric(this);
                        this.position.setOffset(0);
                    }
                }
                return this;
            };

            this.setExtraSize = function(e){
                if (e !== this.extra){
                    this.extra = e;
                    this.vrp();
                }
                return this;
            };
        },

        function kidAdded(index,ctr,lw) {
            this.$super(index, ctr, lw);

            if ("center" === ctr) {
                this.bundle = lw;
            } else if ("bottom" === ctr) {
                this.incBt = lw;
                this.incBt.on(this);
            } else if ("top" === ctr) {
                this.decBt = lw;
                this.decBt.on(this);
            } else {
                throw new Error("Invalid constraints : " + ctr);
            }
        },

        function kidRemoved(index,lw) {
            this.$super(index, lw);
            if (lw === this.bundle) {
                this.bundle = null;
            } else if (lw === this.incBt) {
                this.incBt.off(this);
                this.incBt = null;
            } else if (lw === this.decBt) {
                this.decBt.off(this);
                this.decBt = null;
            }
        }
    ]);

    /**
     * Scroll UI panel. The component is used to manage scrolling for a children UI component
     * that occupies more space than it is available. The usage is very simple, just put an
     * component you want to scroll horizontally or/and vertically in the scroll panel:

            // scroll vertically and horizontally a large picture
            var scrollPan = new zebkit.ui.ScrollPan(new zebkit.ui.ImagePan("largePicture.jpg"));

            // scroll vertically  a large picture
            var scrollPan = new zebkit.ui.ScrollPan(new zebkit.ui.ImagePan("largePicture.jpg"),
                                                   "vertical");

            // scroll horizontally a large picture
            var scrollPan = new zebkit.ui.ScrollPan(new zebkit.ui.ImagePan("largePicture.jpg"),
                                                   "horizontal");



     * @param {zebkit.ui.Panel} [c] an UI component that has to be placed into scroll panel
     * @param {String} [scrolls] a scroll bars that have to be shown. Use "vertical", "horizontal"
     * or "both" string value to control scroll bars visibility. By default the value is "both"
     * @constructor
     * @param {Boolean} [autoHide] a boolean value that says if the scrollbars have to work in
     * auto hide mode. Pass true to switch scrollbars in auto hide mode. By default the value is
     * false
     * @class zebkit.ui.ScrollPan
     * @extends {zebkit.ui.Panel}
     */
    pkg.ScrollPan = Class(pkg.Panel, [
        function (c, scrolls, autoHide) {
            if (arguments.length < 2)  {
                scrolls = "both";
            }

            /**
             * Vertical scroll bar component
             * @attribute vBar
             * @type {zebkit.ui.Scroll}
             * @readOnly
             */

            /**
             * Horizontal scroll bar component
             * @attribute hBar
             * @type {zebkit.ui.Scroll}
             * @readOnly
             */

            /**
             * Scrollable target component
             * @attribute scrollObj
             * @type {zebkit.ui.Panel}
             * @readOnly
             */

            this.$isPosChangedLocked = false;
            this.$super();

            if (arguments.length > 0 && c !== null) {
                this.add("center", c);
            }

            if (arguments.length < 2 || scrolls === "both" || scrolls === "horizontal") {
                this.add("bottom", new pkg.Scroll("horizontal"));
            }

            if (arguments.length < 2 || scrolls === "both" || scrolls === "vertical") {
                this.add("right", new pkg.Scroll("vertical"));
            }

            if (arguments.length > 2) {
                this.setAutoHide(autoHide);
            }
        },

        function $clazz() {
            this.ContentPanLayout = Class(zebkit.layout.Layout, [
                function $prototype() {
                    this.calcPreferredSize = function(t) {
                        return t.kids[0].getPreferredSize();
                    };

                    this.doLayout = function(t) {
                        var kid = t.kids[0];
                        if (kid.constraints === "stretch") {
                            var ps = kid.getPreferredSize(),
                                w  = t.parent.hBar !== null ? ps.width : t.width,
                                h  = t.parent.vBar !== null ? ps.height : t.height;
                            kid.setSize(w, h);
                        } else {
                            kid.toPreferredSize();
                        }
                    };
                }
            ]);

            var SM = this.ContentPanScrollManager = Class(pkg.ScrollManager, [
                function $prototype() {
                    this.getSX = function() {
                        return this.target.x;
                    };

                    this.getSY = function() {
                        return this.target.y;
                    };

                    this.scrollStateUpdated = function(sx,sy,psx,psy) {
                        this.target.setLocation(sx, sy);
                    };
                }
            ]);

            var contentPanLayout = new this.ContentPanLayout();
            this.ContentPan = Class(pkg.Panel, [
                function(c) {
                    this.$super(contentPanLayout);
                    this.scrollManager = new SM(c);
                    this.add(c);
                }
            ]);
        },

        function $prototype() {
            this.hBar = this.vBar = this.scrollObj = null;

            /**
             * Indicate if the scroll bars should be hidden
             * when they are not active
             * @attribute autoHide
             * @type {Boolean}
             * @readOnly
             */
            this.autoHide  = false;

            this.$interval = 0;

            /**
             * Set the given auto hide state.
             * @param  {Boolean} b an auto hide state.
             * @method setAutoHide
             * @chainable
             */
            this.setAutoHide = function(b) {
                if (this.autoHide !== b) {
                    this.autoHide = b;
                    if (this.hBar !== null) {
                        if (this.hBar.incBt !== null) this.hBar.incBt.setVisible(b === false);
                        if (this.hBar.decBt !== null) this.hBar.decBt.setVisible(b === false);
                        if (b === true) {
                            this.hBar.toBack();
                        } else {
                            this.hBar.toFront();
                        }
                    }

                    if (this.vBar !== null) {
                        if (this.vBar.incBt !== null) this.vBar.incBt.setVisible(b === false);
                        if (this.vBar.decBt !== null) this.vBar.decBt.setVisible(b === false);
                        if (b === true) {
                            this.vBar.toBack();
                        } else {
                            this.vBar.toFront();
                        }
                    }

                    if (this.$interval !== 0) {
                        zebkit.environment.clearInterval(this.$interval);
                        $this.$interval = 0;
                    }

                    this.vrp();
                }
                return this;
            };

            /**
             * Scroll horizontally and vertically to the given positions
             * @param  {Integer} sx a horizontal position
             * @param  {Integer} sy a vertical position
             * @method scrollTo
             */
            this.scrollTo = function(sx, sy) {
                this.scrollObj.scrollManager.scrollTo(sx, sy);
            };

            /**
             * Scroll horizontally
             * @param  {Integer} sx a position
             * @method scrollXTo
             */
            this.scrollXTo = function(sx) {
                this.scrollObj.scrollManager.scrollXTo(sx);
            };

            /**
             * Scroll vertically
             * @param  {Integer} sy a position
             * @method scrollYTo
             */
            this.scrollYTo = function(sx, sy) {
                this.scrollObj.scrollManager.scrollYTo(sy);
            };

            this.doScroll = function(dx, dy, source) {
                var b = false, v = 0;

                if (dy !== 0 && this.vBar !== null && this.vBar.isVisible === true) {
                    v =  this.vBar.position.offset + dy;
                    if (v >= 0) this.vBar.position.setOffset(v);
                    else        this.vBar.position.setOffset(0);
                    b = true;
                }

                if (dx !== 0 && this.hBar !== null && this.hBar.isVisible === true) {
                    v =  this.hBar.position.offset + dx;
                    if (v >= 0) this.hBar.position.setOffset(v);
                    else        this.hBar.position.setOffset(0);
                    b = true;
                }

                return b;
            };

            /**
             * Scroll manager listener method that is called every time
             * a target component has been scrolled
             * @param  {Integer} psx previous scroll x location
             * @param  {Integer} psy previous scroll y location
             * @method  scrolled
             */
            this.scrolled = function (psx,psy){
                this.validate();
                try {
                    this.$isPosChangedLocked = true;

                    if (this.hBar !== null) {
                        this.hBar.position.setOffset( -this.scrollObj.scrollManager.getSX());
                    }

                    if (this.vBar !== null) {
                        this.vBar.position.setOffset( -this.scrollObj.scrollManager.getSY());
                    }

                    if (this.scrollObj.scrollManager == null) this.invalidate();

                    this.$isPosChangedLocked = false;
                } catch(e) { this.$isPosChangedLocked = false; throw e; }
            };

            this.calcPreferredSize = function (target){
                return pkg.$getPS(this.scrollObj);
            };

            this.doLayout = function (target){
                var sman   = (this.scrollObj === null) ? null : this.scrollObj.scrollManager,
                    right  = this.getRight(),
                    top    = this.getTop(),
                    bottom = this.getBottom(),
                    left   = this.getLeft(),
                    ww     = this.width  - left - right,  maxH = ww,
                    hh     = this.height - top  - bottom, maxV = hh,
                    so     = this.scrollObj.getPreferredSize(),
                    vps    = this.vBar === null ? { width:0, height:0 } : this.vBar.getPreferredSize(),
                    hps    = this.hBar === null ? { width:0, height:0 } : this.hBar.getPreferredSize();

                // compensate scrolled vertical size by reduction of horizontal bar height if necessary
                // autoHidded scrollbars don't have an influence to layout
                if (this.hBar !== null && this.autoHide === false &&
                      (so.width  > ww ||
                      (so.height > hh && so.width > (ww - vps.width))))
                {
                    maxV -= hps.height;
                }
                maxV = so.height > maxV ? (so.height - maxV) :  -1;

                // compensate scrolled horizontal size by reduction of vertical bar width if necessary
                // autoHidded scrollbars don't have an influence to layout
                if (this.vBar !== null && this.autoHide === false &&
                      (so.height > hh ||
                      (so.width > ww && so.height > (hh - hps.height))))
                {
                    maxH -= vps.width;
                }
                maxH = so.width > maxH ? (so.width - maxH) :  -1;

                var sy = sman.getSY(), sx = sman.getSX();
                if (this.vBar !== null) {
                    if (maxV < 0) {
                        if (this.vBar.isVisible === true){
                            this.vBar.setVisible(false);
                            sman.scrollTo(sx, 0);
                            this.vBar.position.setOffset(0);
                        }
                        sy = 0;
                    } else {
                        this.vBar.setVisible(true);
                    }
                }

                if (this.hBar !== null){
                    if (maxH < 0){
                        if (this.hBar.isVisible === true){
                            this.hBar.setVisible(false);
                            sman.scrollTo(0, sy);
                            this.hBar.position.setOffset(0);
                        }
                    } else {
                        this.hBar.setVisible(true);
                    }
                }

                if (this.scrollObj.isVisible === true) {
                    this.scrollObj.setBounds(left, top,
                                             ww - (this.autoHide === false && this.vBar !== null && this.vBar.isVisible === true ? vps.width  : 0),
                                             hh - (this.autoHide === false && this.hBar !== null && this.hBar.isVisible === true ? hps.height : 0));
                }

                if (this.$interval === 0 && this.autoHide === true) {
                    hps.height = vps.width = 0;
                }

                if (this.hBar !== null && this.hBar.isVisible === true){
                    this.hBar.setBounds(left, this.height - bottom - hps.height,
                                        ww - (this.vBar !== null && this.vBar.isVisible === true ? vps.width : 0),
                                        hps.height);
                    this.hBar.setMaximum(maxH);
                }

                if (this.vBar !== null && this.vBar.isVisible === true){
                    this.vBar.setBounds(this.width - right - vps.width, top,
                                        vps.width,
                                        hh -  (this.hBar !== null && this.hBar.isVisible === true ? hps.height : 0));
                    this.vBar.setMaximum(maxV);
                }
            };

            this.posChanged = function (target,prevOffset,prevLine,prevCol){
                if (this.$isPosChangedLocked === false) {
                    //  show if necessary hidden scroll bar(s)
                    if (this.autoHide === true) {
                        // make sure autohide thread has not been initiated and make sure it makes sense
                        // to initiate the thread (one of the scroll bar has to be visible)
                        if (this.$interval === 0 && ((this.vBar !== null && this.vBar.isVisible === true) ||
                                                     (this.hBar !== null && this.hBar.isVisible === true)    ))
                        {
                            var $this = this;

                            // show scroll bar(s)
                            if (this.vBar !== null) this.vBar.toFront();
                            if (this.hBar !== null) this.hBar.toFront();
                            this.vrp();

                            // pointer move should keep scroll bars visible and pointer entered exited
                            // events have to be caught to track if pointer cursor is on a scroll
                            // bar. add temporary listeners
                            $this.$hiddingCounter = 2;
                            $this.$targetBar      = null;
                            var listener = pkg.events.on({
                                pointerMoved: function(e) {
                                    $this.$hiddingCounter = 1;
                                },

                                pointerExited: function(e) {
                                    $this.$targetBar = null;
                                },

                                pointerEntered: function(e) {
                                    if (e.source === $this.vBar) {
                                        $this.$targetBar = $this.vBar;
                                    } else {
                                        if (e.source === $this.hBar) {
                                            $this.$targetBar = $this.hBar;
                                            return;
                                        }

                                        $this.$targetBar = null;
                                    }
                                }
                            });

                            // start thread to autohide shown scroll bar(s)
                            this.$interval = zebkit.environment.setInterval(function() {
                                if ($this.$hiddingCounter-- === 0 && $this.$targetBar === null) {
                                    zebkit.environment.clearInterval($this.$interval);
                                    $this.$interval = 0;
                                    pkg.events.off(listener);
                                    $this.doLayout();
                                }
                            }, 500);
                        }
                    }

                    if (this.vBar !== null && this.vBar.position === target) {
                        this.scrollObj.scrollManager.scrollYTo(-this.vBar.position.offset);
                    } else if (this.hBar !== null && this.hBar.position === target) {
                        this.scrollObj.scrollManager.scrollXTo(-this.hBar.position.offset);
                    }
                }
            };

            this.setIncrements = function (hUnit,hPage,vUnit,vPage) {
                if (this.hBar !== null){
                    if (hUnit !==  -1) this.hBar.unitIncrement = hUnit;
                    if (hPage !==  -1) this.hBar.pageIncrement = hPage;
                }

                if (this.vBar !== null){
                    if (vUnit !==  -1) this.vBar.unitIncrement = vUnit;
                    if (vPage !==  -1) this.vBar.pageIncrement = vPage;
                }
                return this;
            };
        },

        function insert(i,ctr,c) {
            if ("center" === ctr) {
                if (c.scrollManager == null) {
                    c = new this.clazz.ContentPan(c);
                }

                this.scrollObj = c;
                c.scrollManager.on(this);
            } else {
                if ("bottom" === ctr || "top" === ctr){
                    this.hBar = c;
                } else if ("left" === ctr || "right" === ctr) {
                    this.vBar = c;
                } else {
                    throw new Error("Invalid constraints");
                }

                // valid for scroll bar only
                if (c.incBt !== null) c.incBt.setVisible(!this.autoHide);
                if (c.decBt !== null) c.decBt.setVisible(!this.autoHide);
                c.position.on(this);
            }

            return this.$super(i, ctr, c);
        },

        function kidRemoved(index, comp){
            this.$super(index, comp);
            if (comp === this.scrollObj){
                this.scrollObj.scrollManager.off(this);
                this.scrollObj = null;
            } else if (comp === this.hBar) {
                this.hBar.position.off(this);
                this.hBar = null;
            } else if (comp === this.vBar) {
                this.vBar.position.off(this);
                this.vBar = null;
            }
        }
    ]);

    /**
     * Mobile scroll manager class. Implements inertial scrolling in zebkit mobile application.
     * @class zebkit.ui.MobileScrollMan
     * @extends zebkit.ui.Manager
     * @constructor
     */
    pkg.MobileScrollMan = Class(pkg.Manager, [
        function $prototype() {
            this.$timer = this.identifier = this.target = null;

            /**
             * Define pointer drag started events handler.
             * @param  {zebkit.ui.PointerEvent} e a pointer event
             * @method pointerDragStarted
             */
            this.pointerDragStarted = function(e) {
                if (e.touchCounter === 1 && e.pointerType === "touch") {
                    this.$identifier = e.identifier;
                    this.$target     = e.source;

                    // detect scrollable component
                    while (this.$target !== null && typeof this.$target.doScroll === 'undefined') {
                        this.$target = this.$target.parent;
                    }

                    if (this.$target !== null && typeof this.$target.pointerDragged !== 'undefined') {
                         this.$target = null;
                    }
                }
            };

            /**
             * Define pointer dragged events handler.
             * @param  {zebkit.ui.PointerEvent} e a pointer event
             * @method pointerDragged
             */
            this.pointerDragged = function(e) {
                if (e.touchCounter   === 1            &&
                    this.$target    !==  null         &&
                    this.$identifier === e.identifier &&
                    e.direction     !==  null            )
                {
                    this.$target.doScroll(-e.dx, -e.dy, "touch");
                }
            };

            this.$taskMethod = function() {
                var bar = this.$target.vBar,
                    o   = bar.position.offset;

                // this is linear function with angel 42. every next value will
                // be slightly lower prev. one. theoretically angel 45 should
                // bring to infinite scrolling :)
                this.$dt = Math.tan(42 * Math.PI / 180) * this.$dt;
                bar.position.setOffset(o - Math.round(this.$dt));
                this.$counter++;

                if (o === bar.position.offset) {
                    this.$target = null;
                    zebkit.environment.clearInterval(this.$timer);
                    this.$timer = null;
                }
            };

            /**
             * Define pointer drag ended events handler.
             * @param  {zebkit.ui.PointerEvent} e a pointer event
             * @method pointerDragEnded
             */
            this.pointerDragEnded = function(e) {
                if (this.$target !== null &&
                    this.$timer  === null  &&
                    this.$identifier === e.identifier &&
                    (e.direction === "bottom" || e.direction === "top") &&
                    this.$target.vBar !== null &&
                    this.$target.vBar.isVisible &&
                    e.dy !== 0)
                {
                    this.$dt = 2 * e.dy;
                    this.$counter = 0;
                    var $this = this;
                    this.$timer = zebkit.environment.setInterval(function() {
                        $this.$taskMethod($this);
                    }, 50);
                }
            };

            /**
             * Define pointer pressed events handler.
             * @param  {zebkit.ui.PointerEvent} e a pointer event
             * @method pointerPressed
             */
            this.pointerPressed = function(e) {
                if (this.$timer !== null) {
                    zebkit.environment.clearInterval(this.$timer);
                    this.$timer = null;
                }
                this.$target = null;
            };
        }
    ]);


    /**
     * Slider UI component class.
     * @class  zebkit.ui.Slider
     * @param {String} [o]  a slider orientation ("vertical or "horizontal")
     * @constructor
     * @extends {zebkit.ui.Panel}
     */
    pkg.Slider = Class(pkg.Panel, pkg.$ViewsSetterMix, [
        function (o) {
            this._ = new zebkit.util.Listeners();
            this.views = {
                gauge: null
            };

            if (arguments.length > 0) {
                this.orient = zebkit.util.$validateValue(o, "vertical", "horizontal");
            }

            this.setValues(0, 20, [0, 5, 10], 2, 1);
            this.setScaleStep(1);

            this.$super();
            this.views.bundle = (this.orient === "horizontal" ? this.views.hbundle : this.views.vbundle);
            if (typeof this.views.bundle === 'undefined') {
                this.views.bundle = null;
            }

            this.provider = new this.clazz.ViewProvider();
        },

        function $clazz() {
            this.ViewProvider = Class([
                function(color, font) {
                    this.render = new pkg.BoldTextRender("");

                    zebkit.properties(this, this.clazz);

                    if (arguments.length > 0) {
                        this.color = color;
                    }

                    if (arguments.length > 1) {
                        this.font = font;
                    }

                    this.render.setColor(this.color);
                    this.render.setFont(this.font);
                },

                function $prototype() {
                    this.color = "white";
                    this.font  = new pkg.Font("Arial", "bold", 12);

                    this.getView = function(d, o) {
                        this.render.setValue(o !== null && typeof o !== 'undefined' ? o.toString() : "");
                        return this.render;
                    };
                }
            ]);
        },

        function $prototype() {
            this.max = this.min = this.value = this.roughStep = this.exactStep = 0;
            this.netSize = this.gap = 3;
            this.correctDt = this.scaleStep = this.psW = this.psH = 0;
            this.intervals = this.pl = null;
            this.canHaveFocus = true;
            this.orient = "horizontal";

            this.isShowScale = this.isShowTitle = true;
            this.dragged = this.isIntervalMode = false;

            /**
             * Get a value
             * @return {Integer} a value
             * @method getValue
             */
            this.getValue = function() {
                return this.value;
            };

            this.paintNums = function(g,loc){
                if (this.isShowTitle === true)
                    for(var i = 0; i < this.pl.length; i++) {
                        var render = this.provider.getView(this, this.getPointValue(i)),
                            d      = render.getPreferredSize();

                        if (this.orient === "horizontal") {
                            render.paint(g, this.pl[i] - Math.floor(d.width / 2), loc, d.width, d.height, this);
                        } else {
                            render.paint(g, loc, this.pl[i] - Math.floor(d.height / 2),  d.width, d.height, this);
                        }
                    }
            };

            this.getScaleSize = function(){
                var bs = this.views.bundle === null ? { width: 0, height:0 }
                                                    : this.views.bundle.getPreferredSize();
                return (this.orient === "horizontal" ? this.width - this.getLeft() -
                                                       this.getRight() - bs.width
                                                     : this.height - this.getTop() -
                                                       this.getBottom() - bs.height);
            };

            this.pointerDragged = function(e){
                if (this.dragged) {
                    this.setValue(this.findNearest(e.x + (this.orient === "horizontal" ? this.correctDt : 0),
                                                   e.y + (this.orient === "horizontal" ? 0 : this.correctDt)));
                }
            };

            this.paint = function(g) {
                var i = 0;

                if (this.pl === null){
                    this.pl = Array(this.intervals.length);
                    var l = this.min;
                    for(i = 0; i < this.pl.length; i ++ ){
                        l += this.intervals[i];
                        this.pl[i] = this.value2loc(l);
                    }
                }

                var left   = this.getLeft(),
                    top    = this.getTop(),
                    right  = this.getRight(),
                    bottom = this.getBottom(),
                    bnv    = this.views.bundle,
                    gauge  = this.views.gauge,
                    bs     = bnv === null ? { width: 0, height: 0 } : bnv.getPreferredSize(),
                    gs     = gauge === null ? { width: 0, height: 0 } : gauge.getPreferredSize(),
                    w      = this.width - left - right - 2,
                    h      = this.height - top - bottom - 2;

                if (this.orient === "horizontal"){
                    var topY = top + Math.floor((h - this.psH) / 2) + 1, by = topY;
                    if (this.isEnabled === true) {
                        if (gauge !== null) {
                            gauge.paint(g, left + 1,
                                           topY + Math.floor((bs.height - gs.height) / 2),
                                           w, gs.height, this);
                        }
                    } else {
                        g.setColor("gray");
                        g.strokeRect(left + 1, topY + Math.floor((bs.height - gs.height) / 2), w, gs.height);
                    }

                    topY += bs.height;
                    if (this.isShowScale === true){
                        topY += this.gap;
                        g.setColor(this.isEnabled === true ? this.scaleColor : "gray");
                        g.beginPath();
                        for(i = this.min;i <= this.max; i += this.scaleStep){
                            var xx = this.value2loc(i) + 0.5;
                            g.moveTo(xx, topY);
                            g.lineTo(xx, topY + this.netSize);
                        }

                        for(i = 0; i < this.pl.length; i++) {
                            g.moveTo(this.pl[i] + 0.5, topY);
                            g.lineTo(this.pl[i] + 0.5, topY + 2 * this.netSize);
                        }
                        g.stroke();
                        topY += (2 * this.netSize);
                    }
                    this.paintNums(g, topY);
                    if (bnv !== null) {
                        bnv.paint(g, this.getBundleLoc(this.value), by, bs.width, bs.height, this);
                    }
                } else {
                    var leftX = left + Math.floor((w - this.psW) / 2) + 1, bx = leftX;
                    if (this.isEnabled === true) {
                        if (gauge !== null) {
                            gauge.paint(g, leftX + Math.floor((bs.width - gs.width) / 2),
                                           top + 1, gs.width, h, this);
                        }
                    } else {
                        g.setColor("gray");
                        g.strokeRect(leftX + Math.floor((bs.width - gs.width) / 2),
                                     top + 1, gs.width, h);
                    }

                    leftX += bs.width;
                    if (this.isShowScale === true) {
                        leftX += this.gap;
                        g.setColor(this.scaleColor);
                        g.beginPath();
                        for(i = this.min;i <= this.max; i += this.scaleStep){
                            var yy = this.value2loc(i) + 0.5;
                            g.moveTo(leftX, yy);
                            g.lineTo(leftX + this.netSize, yy);
                        }

                        for(i = 0;i < this.pl.length; i ++ ) {
                            g.moveTo(leftX, this.pl[i] + 0.5);
                            g.lineTo(leftX + 2 * this.netSize, this.pl[i] + 0.5);
                        }

                        g.stroke();
                        leftX += (2 * this.netSize);
                    }

                    this.paintNums(g, leftX);
                    if (bnv !== null) {
                        bnv.paint(g, bx, this.getBundleLoc(this.value), bs.width, bs.height, this);
                    }
                }

                if (this.hasFocus() && this.views.marker != null) {
                    this.views.marker.paint(g, left, top, w + 2, h + 2, this);
                }
            };

            this.findNearest = function(x,y){
                var v = this.loc2value(this.orient === "horizontal" ? x : y);
                if (this.isIntervalMode){
                    var nearest = Number.MAX_VALUE, res = 0;
                    for(var i = 0;i < this.intervals.length; i ++ ){
                        var pv = this.getPointValue(i), dt = Math.abs(pv - v);
                        if (dt < nearest){
                            nearest = dt;
                            res = pv;
                        }
                    }
                    return res;
                }

                v = this.exactStep * Math.floor((v + v % this.exactStep) / this.exactStep);
                if (v > this.max) {
                    v = this.max;
                } else if (v < this.min) {
                    v = this.min;
                }
                return v;
            };

            this.value2loc = function (v){
                var ps = this.views.bundle === null ? { width:0, height:0 } : this.views.bundle.getPreferredSize(),
                    l  = Math.floor((this.getScaleSize() * (v - this.min)) / (this.max - this.min));
                return  (this.orient === "vertical") ? this.height - Math.floor(ps.height/2) - this.getBottom() - l
                                                     : this.getLeft() + Math.floor(ps.width/2) + l;
            };

            this.loc2value = function(xy){
                var ps = this.views.bundle === null ? { width:0, height:0 } : this.views.bundle.getPreferredSize(),
                    sl = (this.orient === "vertical") ? this.getLeft() + Math.floor(ps.width/2)
                                                      : this.getTop()  + Math.floor(ps.height/2),
                    ss = this.getScaleSize();

                if (this.orient === "vertical") {
                    xy = this.height - xy;
                }

                if (xy < sl) {
                    xy = sl;
                } else if (xy > sl + ss) {
                    xy = sl + ss;
                }

                return this.min + Math.floor(((this.max - this.min) * (xy - sl)) / ss);
            };

            this.nextValue = function(value,s,d){
                if (this.isIntervalMode) {
                    return this.getNeighborPoint(value, d);
                }

                var v = value + (d * s);
                if (v > this.max) {
                    v = this.max;
                } else if (v < this.min) {
                    v = this.min;
                }

                return v;
            };

            this.getBundleLoc = function(v){
                var bs = this.views.bundle === null ? { width:0, height:0 } : this.views.bundle.getPreferredSize();
                return this.value2loc(v) - (this.orient === "horizontal" ? Math.floor(bs.width / 2)
                                                                         : Math.floor(bs.height / 2));
            };

            this.getBundleBounds = function (v){
                var bs = this.views.bundle === null ? { width:0, height:0 } : this.views.bundle.getPreferredSize();
                return this.orient === "horizontal"? {
                                                       x:this.getBundleLoc(v),
                                                       y:this.getTop() + Math.floor((this.height - this.getTop() - this.getBottom() - this.psH) / 2) + 1,
                                                       width:bs.width,
                                                       height:bs.height
                                                     }
                                                   : {
                                                       x:this.getLeft() + Math.floor((this.width - this.getLeft() - this.getRight() - this.psW) / 2) + 1,
                                                       y:this.getBundleLoc(v),
                                                       width:bs.width,
                                                       height:bs.height
                                                     };
            };

            this.getNeighborPoint = function (v,d){
                var left  = this.min + this.intervals[0],
                    right = this.getPointValue(this.intervals.length - 1),
                    i     = 0,
                    start = 0;

                if (v < left) {
                    return left;
                } else if (v > right) {
                    return right;
                }

                if (d > 0) {
                    start = this.min;
                    for(i = 0;i < this.intervals.length; i ++ ){
                        start += this.intervals[i];
                        if(start > v) return start;
                    }
                    return right;
                } else {
                    start = right;
                    for(i = this.intervals.length - 1;i >= 0; i--) {
                        if (start < v) return start;
                        start -= this.intervals[i];
                    }
                    return left;
                }
            };

            this.calcPreferredSize = function(l) {
                return { width:this.psW + 2, height: this.psH + 2 };
            };

            this.recalc = function(){
                var ps = this.views.bundle !== null ? this.views.bundle.getPreferredSize()
                                                    : { width: 0, height:0 },
                    ns = this.isShowScale ? (this.gap + 2 * this.netSize) : 0,
                    dt = this.max - this.min,
                    hMax = 0,
                    wMax = 0;

                if (this.isShowTitle && this.intervals.length > 0){
                    for(var i = 0;i < this.intervals.length; i ++ ){
                        var d = this.provider.getView(this, this.getPointValue(i)).getPreferredSize();
                        if (d.height > hMax) hMax = d.height;
                        if (d.width  > wMax) wMax = d.width;
                    }
                }
                if (this.orient === "horizontal"){
                    this.psW = dt * 2 + ps.width;
                    this.psH = ps.height + ns + hMax;
                } else {
                    this.psW = ps.width + ns + wMax;
                    this.psH = dt * 2 + ps.height;
                }
            };

            this.setValue = function(v) {
                if (v < this.min || v > this.max) {
                    throw new Error("Value is out of bounds: " + v);
                }

                var prev = this.value;
                if (this.value !== v){
                    this.value = v;
                    this._.fired(this, prev);
                    this.repaint();
                }

                return this;
            };

            this.getPointValue = function (i){
                var v = this.min + this.intervals[0];
                for(var j = 0; j < i; j++, v += this.intervals[j]);
                return v;
            };

            this.keyPressed = function(e){
                var b = this.isIntervalMode,
                    v = null;
                switch(e.code) {
                    case "ArrowDown":
                    case "ArrowLeft":
                        v = this.nextValue(this.value, this.exactStep,-1);
                        if (v >= this.min) this.setValue(v);
                        break;
                    case "ArrowUp":
                    case "ArrowRight":
                        v = this.nextValue(this.value, this.exactStep, 1);
                        if (v <= this.max) this.setValue(v);
                        break;
                    case "Home": this.setValue(b ? this.getPointValue(0) : this.min);break;
                    case "End":  this.setValue(b ? this.getPointValue(this.intervals.length - 1)
                                                 : this.max);
                                 break;
                }
            };

            this.pointerPressed = function (e){
                if (e.isAction()){
                    var x = e.x, y = e.y, bb = this.getBundleBounds(this.value);
                    if (x < bb.x || y < bb.y || x >= bb.x + bb.width || y >= bb.y + bb.height) {
                        var l = ((this.orient === "horizontal") ? x : y), v = this.loc2value(l);
                        if (this.value != v) {
                            this.setValue(this.isJumpOnPress ? v
                                                             : this.nextValue(this.value,
                                                                              this.roughStep,
                                                                              v < this.value ? -1:1));
                        }
                    }
                }
            };

            this.pointerDragStarted = function(e){
                var r = this.getBundleBounds(this.value);

                if (e.x >= r.x && e.y >= r.y &&
                    e.x < r.x + r.width &&
                    e.y < r.y + r.height)
                {
                    this.dragged = true;
                    this.correctDt = this.orient === "horizontal" ? r.x + Math.floor(r.width  / 2) - e.x
                                                                  : r.y + Math.floor(r.height / 2) - e.y;
                }
            };

            this.pointerDragEnded = function(e) {
                this.dragged = false;
            };
        },

        function focused() {
            this.$super();
            this.repaint();
        },

        function setScaleGap(g) {
            if (g !== this.gap){
                this.gap = g;
                this.vrp();
            }
            return this;
        },

        function setScaleColor(c) {
            if (c !== this.scaleColor) {
                this.scaleColor = c;
                if (this.provider === this) this.render.setColor(c);
                this.repaint();
            }
            return this;
        },

        function setScaleStep(s){
            if (s !== this.scaleStep){
                this.scaleStep = s;
                this.repaint();
            }
            return this;
        },

        function setShowScale(b) {
            if (this.isShowScale !== b){
                this.isShowScale = b;
                this.vrp();
            }
            return this;
        },

        function setShowTitle(b) {
            if (this.isShowTitle !== b){
                this.isShowTitle = b;
                this.vrp();
            }
            return this;
        },

        function setViewProvider(p){
            if (p !== this.provider){
                this.provider = p;
                this.vrp();
            }
            return this;
        },

        function setValues(min,max,intervals,roughStep,exactStep) {
            if (roughStep <= 0 || exactStep < 0 || min >= max ||
                min + roughStep > max || min + exactStep > max  )
            {
                throw new Error("[" + min + "," + max + "], " + roughStep + "," + exactStep);
            }

            var i = 0, start = min;

            for(i = 0; i < intervals.length; i ++ ){
                start += intervals[i];
                if (start > max || intervals[i] < 0) throw new Error();
            }

            this.min = min;
            this.max = max;
            this.roughStep = roughStep;
            this.exactStep = exactStep;
            this.intervals = Array(intervals.length);

            for(i = 0; i < intervals.length; i++){
                this.intervals[i] = intervals[i];
            }

            if (this.value < min || this.value > max) {
                this.setValue(this.isIntervalMode ? min + intervals[0] : min);
            }
            this.vrp();

            return this;
        },

        function invalidate(){
            this.pl = null;
            this.$super();
        }
    ]);


    /**
     * Tabs UI panel. The component is used to organize switching between number of pages where every
     * page is an UI component.
     *
     * Filling tabs component with pages is the same to how you add an UI component to a panel. For
     * instance in the example below three pages with "Titl1", "Title2", "Title3" are added:

          var tabs = new zebkit.ui.Tabs();
          tabs.add("Title1", new zebkit.ui.Label("Label as a page"));
          tabs.add("Title2", new zebkit.ui.Button("Button as a page"));
          tabs.add("Title3", new zebkit.ui.TextArea("Text area as a page"));

     *  You can access tabs pages UI component the same way like you access a panel children components

         ...
         tabs.kids[0] // access the first page

     *  And you can remove it with standard panel inherited API:

         ...
         tabs.removeAt(0); // remove first tab page


     *  To customize tab page caption and icon you should access tab object and do it with API it provides:


            // update a tab caption
            tabs.getTab(0).setCaption("Test");

            // update a tab icon
            tabs.getTab(0).setIcon("my.gif");

            // set a particular font and color for the tab in selected state
            tabs.getTab(0).setColor(true, "blue");
            tabs.getTab(0).setFont(true, new zebkit.ui.Font("Arial", "bold", 16));

            // set other caption for the tab in not selected state
            tabs.getTab(0).setCaption(false, "Test");

     * @param {String} [o] the tab panel orientation:

          "top"
          "bottom"
          "left"
          "right"

     * @class zebkit.ui.Tabs
     * @constructor
     * @extends {zebkit.ui.Panel}
     */

    /**
     * Fired when a new tab page has been selected

          tabs.on(function(src, selectedIndex) {
             ...
          });

     * @event selected
     * @param {zebkit.ui.Tabs} src a tabs component that triggers the event
     * @param {Integer} selectedIndex a tab page index that has been selected
     */
    pkg.Tabs = Class(pkg.Panel, pkg.$ViewsSetterMix, [
        function(o) {
            /**
             * Selected tab page index
             * @attribute selectedIndex
             * @type {Integer}
             * @readOnly
             */
            this.vgap = this.hgap = this.tabAreaX = 0;
            this.repaintWidth = this.repaintHeight = this.repaintX = this.repaintY = 0;

            this.tabAreaY = this.tabAreaWidth = this.tabAreaHeight = 0;
            this.overTab = this.selectedIndex = -1;

            this._ = new zebkit.util.Listeners();
            this.pages = [];
            this.views = {};

            if (typeof pkg.Tabs.font      !== 'undefined') this.render.setFont(pkg.Tabs.font);
            if (typeof pkg.Tabs.fontColor !== 'undefined') this.render.setColor(pkg.Tabs.fontColor);

            this.$super();

            // since alignment pass as the constructor argument the setter has to be called after $super
            // because $super can re-set title alignment

            if (arguments.length > 0) {
                this.setAlignment(o);
            }
        },

        function $clazz() {
            /**
             * Tab view class that defines the tab page title and icon
             * @param {String|Image} [icon]  an path to an image or image object
             * @param {String} [caption] a tab caption
             * @class zebkit.ui.Tabs.TabView
             * @extends {zebkit.ui.CompRender}
             * @constructor
             */
            this.TabView = Class(pkg.CompRender, [
                function(icon, caption) {
                    if (arguments.length === 0) {
                        caption = "";
                    } else if (arguments.length === 1) {
                        caption = icon;
                        icon = null;
                    }

                    var tp = new this.clazz.TabPan();
                    this.$super(tp);

                    var $this = this;
                    tp.getImagePan().imageLoaded = function(img) {
                        $this.vrp();

                        // if the icon has zero width and height the repaint
                        // doesn't trigger validation. So let's do it on
                        // parent level
                        if ($this.owner !== null && $this.owner.parent !== null) {
                            $this.owner.repaint();
                        }
                    };

                    var r1 = new this.clazz.captionRender(caption),
                        r2 = new this.clazz.captionRender(caption);

                    r2.setColor(this.clazz.fontColor);
                    r1.setColor(this.clazz.selectedFontColor);
                    r2.setFont (this.clazz.font);
                    r1.setFont (this.clazz.selectedFont);

                    this.getCaptionPan().setView(
                        new pkg.ViewSet(
                            {
                                "selected": r1,
                                "*"       : r2
                            },
                            [
                                function setFont(id, f) {
                                    var v = this.views[id];
                                    if (v) {
                                        v.setFont(s);
                                        this.recalc();
                                    }
                                    return this;
                                },

                                function setCaption(id, s) {
                                    var v = this.views[id];
                                    if (v) {
                                        v.setValue(s);
                                        this.recalc();
                                    }
                                    return this;
                                },

                                function getCaption(id) {
                                    var v = this.views[id];
                                    return v == null ? null : v.getValue();
                                }
                            ]
                        )
                    );

                    this.setIcon(icon);
                },

                function $clazz() {
                    this.captionRender = pkg.StringRender;

                    this.font = pkg.font;

                    this.TabPan = Class(pkg.Panel, [
                        function() {
                            this.$super();
                            this.add(new pkg.ImagePan(null));
                            this.add(new pkg.ViewPan());
                        },

                        function getImagePan() {
                            return this.kids[0];
                        },

                        function getViewPan() {
                            return this.kids[1];
                        }
                    ]);
                },

                function $prototype() {
                    this.owner = null;

                    this.ownerChanged = function(v) {
                        this.owner = v;
                    };

                    this.vrp = function() {
                        if (this.owner !== null) this.owner.vrp();
                    };

                    /**
                     * Set the given tab caption for the specified tab or both - selected and not selected - states.
                     * @param {Boolean} [b] the tab state. true means selected state.
                     * @param {String} s the tab caption
                     * @method setCaption
                     * @chainable
                     */
                    this.setCaption = function(b, s) {
                        if (arguments.length === 1) {
                            this.setCaption(true, b);
                            this.setCaption(false, b);
                        } else {
                            this.getCaptionPan().view.setCaption(this.$toId(b), s);
                            this.vrp();
                        }
                        return this;
                    };

                    /**
                     * Get the tab caption for the specified tab state
                     * @param {Boolean} b the tab state. true means selected state.
                     * @return {String} the tab caption
                     * @method getCaption
                     */
                    this.getCaption = function (b) {
                        return this.getCaptionPan().view.getCaption(this.$toId(b));
                    };

                    /**
                     * Set the given tab caption text color for the specified tab or both
                     * selected and not selected states.
                     * @param {Boolean} [b] the tab state. true means selected state.
                     * @param {String} c the tab caption
                     * @method setColor
                     * @chainable
                     */
                    this.setColor = function(b, c) {
                        if (arguments.length === 1) {
                            this.setColor(true, b);
                            this.setColor(false, b);
                        } else {
                            var v = this.getCaptionPan().view.views[this.$toId(b)];
                            if (v) {
                                v.setColor(c);
                                this.vrp();
                            }
                        }
                        return this;
                    };

                    /**
                     * Set the given tab caption text font for the specified or both
                     * selected not slected states.
                     * @param {Boolean} [b] the tab state. true means selected state.
                     * @param {zebkit.ui.Font} f the tab text font
                     * @method setFont
                     * @chainable
                     */
                    this.setFont = function(b, f) {
                        if (arguments.length === 1) {
                            this.setFont(true, b);
                            this.setFont(false, b);
                        } else {
                            this.getCaptionPan().view.setFont(this.$toId(b), f);
                            this.vrp();
                        }
                        return this;
                    };

                    this.getCaptionPan = function () {
                        return this.target.getViewPan();
                    };

                    /**
                     * Set the tab icon.
                     * @param {String|Image} c an icon path or image object
                     * @method setIcon
                     * @chainable
                     */
                    this.setIcon = function (c) {
                        this.target.getImagePan().setImage(c);
                        this.target.getImagePan().setVisible(c !== null);
                        return this;
                    };

                    /**
                     * The method is invoked every time the tab selection state has been updated
                     * @param {zebkit.ui.Tabs} tabs the tabs component the tab belongs
                     * @param {Integer} i an index of the tab
                     * @param {Boolean} b a new state of the tab
                     * @method selected
                     */
                    this.selected = function(tabs, i, b) {
                        this.getCaptionPan().view.activate(this.$toId(b), this);
                    };

                    this.$toId = function(b) {
                        return b ? "selected" : "*";
                    };
                }
            ]);
        },

        /**
         * @for zebkit.ui.Tabs
         */
        function $prototype() {
            /**
             * Tab orientation
             * @attribute orient
             * @type {String}
             * @readOnly
             */
            this.orient = "top";

            /**
             * Sides gap
             * @attribute sideSpace
             * @type {Integer}
             * @readOnly
             * @default 1
             */
            this.sideSpace = 1;

            /**
             * Declare can have focus attribute to make the component focusable
             * @type {Boolean}
             * @attribute canHaveFocus
             * @readOnly
             */
            this.canHaveFocus = true;

            /**
             * Define pointer moved event handler
             * @param  {zebkit.ui.PointerEvent} e a key event
             * @method pointerMoved
             */
            this.pointerMoved = function(e) {
                var i = this.getTabAt(e.x, e.y);
                if (this.overTab !== i) {
                    this.overTab = i;
                    if (this.views.over) {
                        this.repaint(this.repaintX, this.repaintY,
                                     this.repaintWidth, this.repaintHeight);
                    }
                }
            };

            /**
             * Define pointer drag ended event handler
             * @param  {zebkit.ui.PointerEvent} e a key event
             * @method pointerDragEnded
             */
            this.pointerDragEnded = function(e) {
                var i = this.getTabAt(e.x, e.y);
                if (this.overTab !== i) {
                    this.overTab = i;
                    if (this.views.over) {
                        this.repaint(this.repaintX, this.repaintY,
                                     this.repaintWidth, this.repaintHeight);
                    }
                }
            };

            /**
             * Define pointer exited event handler
             * @param  {zebkit.ui.PointerEvent} e a key event
             * @method pointerExited
             */
            this.pointerExited = function(e) {
                if (this.overTab >= 0) {
                    this.overTab = -1;
                    if (this.views.over) {
                        this.repaint(this.repaintX, this.repaintY,
                                     this.repaintWidth, this.repaintHeight);
                    }
                }
            };

            /**
             * Navigate to a next tab page following the given direction starting
             * from the given page
             * @param  {Integer} page a starting page index
             * @param  {Integer} d a navigation direction. 1 means forward and -1 means backward
             * navigation.
             * @return {Integer} a new tab page index
             * @method next
             */
            this.next = function (page, d){
                for(; page >= 0 && page < Math.floor(this.pages.length / 2); page += d) {
                    if (this.isTabEnabled(page) === true) {
                        return page;
                    }
                }
                return -1;
            };

            this.getTitleInfo = function(){
                var b   = (this.orient === "left" || this.orient === "right"),
                    res = b ? { x      : this.tabAreaX,
                                y      : 0,
                                width  : this.tabAreaWidth,
                                height : 0,
                                orient : this.orient }
                            : { x      : 0,
                                y      : this.tabAreaY,
                                width  : 0,
                                height : this.tabAreaHeight,
                                orient : this.orient };

                if (this.selectedIndex >= 0){
                    var r = this.getTabBounds(this.selectedIndex);
                    if (b) {
                        res.y = r.y;
                        res.height = r.height;
                    } else {
                        res.x = r.x;
                        res.width = r.width;
                    }
                }
                return res;
            };

            /**
             * Test if the given tab page is in enabled state
             * @param  {Integer} index a tab page index
             * @return {Boolean} a tab page state
             * @method isTabEnabled
             */
            this.isTabEnabled = function (index){
                return this.kids[index].isEnabled;
            };

            this.paintOnTop = function(g){
                var ts = g.$states[g.$curState];
                // stop painting if the tab area is outside of clip area
                if (zebkit.util.isIntersect(this.repaintX, this.repaintY,
                                            this.repaintWidth, this.repaintHeight,
                                            ts.x, ts.y, ts.width, ts.height))
                {
                    if (this.selectedIndex > 0) {
                        var r = this.getTabBounds(this.selectedIndex);
                    }

                    var i = 0;

                    for(i = 0; i < this.selectedIndex; i++) {
                        this.paintTab(g, i);
                    }

                    for(i = this.selectedIndex + 1;i < Math.floor(this.pages.length / 2); i++) {
                        this.paintTab(g, i);
                    }

                    if (this.selectedIndex >= 0){
                        this.paintTab(g, this.selectedIndex);
                        if (this.hasFocus()) {
                            this.drawMarker(g, this.getTabBounds(this.selectedIndex));
                        }
                    }
                }
            };

            /**
             * Draw currently activate tab page marker.
             * @param  {CanvasRenderingContext2D} g a graphical context
             * @param  {Object} r a tab page title rectangular area
             * @method drawMarker
             */
            this.drawMarker = function(g,r){
                var marker = this.views.marker;
                if (marker) {
                    //TODO: why only "out" is checked ?
                    var bv   = this.views.out,
                        left = bv ? bv.getLeft() : 0,
                        top  = bv ? bv.getTop()  : 0;
                    marker.paint(g, r.x + left, r.y + top,
                                    r.width  - left - (bv == null ? 0 : bv.getRight()),
                                    r.height - top  - (bv == null ? 0 : bv.getBottom()), this);
                }
            };

            /**
             * Paint the given tab page title
             * @param  {CanvasRenderingContext2D} g a graphical context
             * @param  {Integer} pageIndex a tab page index
             * @method paintTab
             */
            this.paintTab = function (g, pageIndex){
                var b       = this.getTabBounds(pageIndex),
                    page    = this.kids[pageIndex],
                    tab     = this.views.out,
                    tabover = this.views.over,
                    tabon   = this.views.selected,
                    v       = this.pages[pageIndex * 2],
                    ps      = v.getPreferredSize();

                if (this.selectedIndex === pageIndex && tabon) {
                    tabon.paint(g, b.x, b.y, b.width, b.height, page);
                } else if (tab) {
                    tab.paint(g, b.x, b.y, b.width, b.height, page);
                }

                if (this.overTab >= 0 && this.overTab === pageIndex && tabover) {
                    tabover.paint(g, b.x, b.y, b.width, b.height, page);
                }

                v.paint(g, b.x + Math.floor((b.width  - ps.width ) / 2),
                           b.y + Math.floor((b.height - ps.height) / 2),
                           ps.width, ps.height, page);
            };

            /**
             * Get the given tab page title rectangular bounds
             * @param  {Integer} i a tab page index
             * @return {Object} a tab page rectangular bounds
             *
             *    {x:{Integer}, y:{Integer}, width:{Integer}, height:{Integer}}
             *
             * @protected
             * @method getTabBounds
             */
            this.getTabBounds = function(i){
                return this.pages[2 * i + 1];
            };

            this.calcPreferredSize = function(target){
                var max = zebkit.layout.getMaxPreferredSize(target);
                if (this.orient === "bottom" || this.orient === "top"){
                    max.width = Math.max(max.width, 2 * this.sideSpace + this.tabAreaWidth);
                    max.height += this.tabAreaHeight + this.sideSpace;
                } else {
                    max.width += this.tabAreaWidth + this.sideSpace;
                    max.height = Math.max(max.height, 2 * this.sideSpace + this.tabAreaHeight);
                }
                return max;
            };

            this.doLayout = function(target) {
                var right  = this.orient === "right"  ? this.right  : this.getRight(),
                    top    = this.orient === "top"    ? this.top    : this.getTop(),
                    bottom = this.orient === "bottom" ? this.bottom : this.getBottom(),
                    left   = this.orient === "left"   ? this.left   : this.getLeft(),
                    b      = (this.orient === "top" || this.orient === "bottom");

                if (b) {
                    this.repaintX = this.tabAreaX = left ;
                    this.repaintY = this.tabAreaY = (this.orient === "top") ? top
                                                                            : this.height - bottom - this.tabAreaHeight;
                    if (this.orient === "bottom") {
                        this.repaintY -= (this.border !== null ? this.border.getBottom() : 0);
                    }
                } else {
                    this.repaintX = this.tabAreaX = (this.orient === "left" ? left
                                                                            : this.width - right - this.tabAreaWidth);
                    this.repaintY = this.tabAreaY = top ;
                    if (this.orient === "right") {
                        this.repaintX -= (this.border !== null ? this.border.getRight() : 0);
                    }
                }

                var count = this.kids.length,
                    sp    = 2 * this.sideSpace,
                    xx    = (this.orient === "right"  ? this.tabAreaX : this.tabAreaX + this.sideSpace),
                    yy    = (this.orient === "bottom" ? this.tabAreaY : this.tabAreaY + this.sideSpace),
                    r     = null,
                    i     = 0;

                for(i = 0; i < count; i++ ){
                    r = this.getTabBounds(i);

                    r.x = xx;
                    r.y = yy;

                    if (b) {
                        xx += r.width;
                        if (i === this.selectedIndex) {
                            xx -= sp;
                            if (this.orient === "bottom") {
                                r.y -= (this.border !== null ? this.border.getBottom() : 0);
                            }
                        }
                    } else {
                        yy += r.height;
                        if (i === this.selectedIndex) {
                            yy -= sp;
                            if (this.orient === "right") {
                                r.x -= (this.border !== null ? this.border.getRight() : 0);
                            }
                        }
                    }
                }

                // make visible tab title
                if (this.selectedIndex >= 0){
                    var dt = 0;

                    r = this.getTabBounds(this.selectedIndex);
                    if (b) {
                        r.x -= this.sideSpace;
                        r.y -= ((this.orient === "top") ? this.sideSpace : 0);
                        dt = (r.x < left) ? left - r.x
                                          : (r.x + r.width > this.width - right) ? this.width - right - r.x - r.width : 0;
                    } else {
                        r.x -= (this.orient === "left") ? this.sideSpace : 0;
                        r.y -= this.sideSpace;
                        dt = (r.y < top) ? top - r.y
                                         : (r.y + r.height > this.height - bottom) ? this.height - bottom - r.y - r.height : 0;
                    }

                    for(i = 0;i < count; i ++ ){
                        var br = this.getTabBounds(i);
                        if (b) br.x += dt;
                        else   br.y += dt;
                    }
                }

                for(i = 0;i < count; i++){
                    var l = this.kids[i];
                    if (i === this.selectedIndex) {
                        if (b) {
                            l.setBounds(left + this.hgap,
                                        ((this.orient === "top") ? top + this.repaintHeight : top) + this.vgap,
                                        this.width - left - right - 2 * this.hgap,
                                        this.height - this.repaintHeight - top - bottom - 2 * this.vgap);
                        } else {
                            l.setBounds(((this.orient === "left") ? left + this.repaintWidth : left) + this.hgap,
                                        top + this.vgap,
                                        this.width - this.repaintWidth - left - right - 2 * this.hgap,
                                        this.height - top - bottom - 2 * this.vgap);
                        }
                    } else {
                        l.setSize(0, 0);
                    }
                }
            };

            /**
             * Define recalc method to compute the component metrical characteristics
             * @method recalc
             */
            this.recalc = function(){
                var count = Math.floor(this.pages.length / 2);
                if (count > 0) {
                    this.tabAreaHeight = this.tabAreaWidth = 0;

                    var bv   = this.views.out ? this.views.out : null,
                        b    = (this.orient === "left" || this.orient === "right"),
                        max  = 0,
                        i    = 0,
                        r    = null,
                        hadd = bv === null ? 0 : bv.getLeft() + bv.getRight(),
                        vadd = bv === null ? 0 : bv.getTop()  + bv.getBottom();

                    for(i = 0; i < count; i++){
                        var ps =  this.pages[i * 2] != null ? this.pages[i * 2].getPreferredSize()
                                                            : { width:0, height:0};

                        r = this.getTabBounds(i);
                        if (b) {
                            r.height = ps.height + vadd;
                            if (ps.width + hadd > max) max = ps.width + hadd;
                            this.tabAreaHeight += r.height;
                        } else {
                            r.width = ps.width + hadd;
                            if (ps.height + vadd > max) max = ps.height + vadd;
                            this.tabAreaWidth += r.width;
                        }
                    }

                    // align tabs widths or heights to have the same size
                    for(i = 0; i < count; i++ ){
                        r = this.getTabBounds(i);
                        if (b) r.width  = max;
                        else   r.height = max;
                    }

                    if (b) {
                        this.tabAreaWidth   = max + this.sideSpace;
                        this.tabAreaHeight += (2 * this.sideSpace);
                        this.repaintHeight  = this.tabAreaHeight;
                        this.repaintWidth   = this.tabAreaWidth + (this.border !== null ? (this.orient === "left" ? this.border.getLeft()
                                                                                                                  : this.border.getRight())
                                                                                        : 0);
                    } else {
                        this.tabAreaWidth += (2 * this.sideSpace);
                        this.tabAreaHeight = this.sideSpace + max;
                        this.repaintWidth  = this.tabAreaWidth;
                        this.repaintHeight = this.tabAreaHeight + (this.border !== null ? (this.orient === "top" ? this.border.getTop()
                                                                                                                 : this.border.getBottom())
                                                                                        : 0);
                    }

                    // make selected tab page title bigger
                    if (this.selectedIndex >= 0) {
                        r = this.getTabBounds(this.selectedIndex);
                        if (b) {
                            r.height += 2 * this.sideSpace;
                            r.width += this.sideSpace +  (this.border !== null ? (this.orient === "left" ? this.border.getLeft()
                                                                                                         : this.border.getRight())
                                                                               : 0);
                        } else {
                            r.height += this.sideSpace + (this.border !== null ? (this.orient === "top" ? this.border.getTop()
                                                                                                        : this.border.getBottom())
                                                                               : 0);
                            r.width += 2 * this.sideSpace;
                        }
                    }
                }
            };

            /**
             * Get tab index located at the given location
             * @param  {Integer} x a x coordinate
             * @param  {Integer} y a y coordinate
             * @return {Integer} an index of the tab that is
             * detected at the given location. -1 if no any
             * tab can be found
             * @method getTabAt
             */
            this.getTabAt = function(x,y){
                this.validate();
                if (x >= this.tabAreaX && y >= this.tabAreaY &&
                    x < this.tabAreaX + this.tabAreaWidth    &&
                    y < this.tabAreaY + this.tabAreaHeight     )
                {
                    var tb = null;

                    // handle selected as a special case since it can overlap neighborhood titles
                    if (this.selectedIndex >= 0) {
                        tb = this.getTabBounds(this.selectedIndex);
                        if (x >= tb.x && y >= tb.y && x < tb.x + tb.width && y < tb.y + tb.height) {
                            return i;
                        }
                    }

                    for(var i = 0; i < Math.floor(this.pages.length / 2); i++) {
                        if (this.selectedIndex !== i) {
                            tb = this.getTabBounds(i);
                            if (x >= tb.x && y >= tb.y && x < tb.x + tb.width && y < tb.y + tb.height) {
                                return i;
                            }
                        }
                    }
                }
                return -1;
            };

            /**
             * Define key pressed event handler
             * @param  {zebkit.ui.KeyEvent} e a key event
             * @method keyPressed
             */
            this.keyPressed = function(e){
                if (this.selectedIndex !== -1 && this.pages.length > 0){
                    var nxt = 0;
                    switch(e.code) {
                        case "ArrowUp":
                        case "ArrowLeft":
                            nxt = this.next(this.selectedIndex - 1,  -1);
                            if (nxt >= 0) this.select(nxt);
                            break;
                        case "ArrowDown":
                        case "ArrowRight":
                            nxt = this.next(this.selectedIndex + 1, 1);
                            if (nxt >= 0) this.select(nxt);
                            break;
                    }
                }
            };

            /**
             * Define pointer clicked  event handler
             * @param  {zebkit.ui.PointerEvent} e a key event
             * @method pointerClicked
             */
            this.pointerClicked = function(e){
                if (e.isAction()){
                    var index = this.getTabAt(e.x, e.y);
                    if (index >= 0 && this.isTabEnabled(index)) this.select(index);
                }
            };

            /**
             * Switch to the given tab page
             * @param  {Integer} index a tab page index to be navigated
             * @method select
             * @chainable
             */
            this.select = function(index){
                if (this.selectedIndex !== index){
                    var prev = this.selectedIndex;
                    this.selectedIndex = index;

                    if (prev >= 0) {
                        this.pages[prev * 2].selected(this, prev, false);
                    }

                    if (index >= 0) {
                        this.pages[index * 2].selected(this, index, true);
                    }

                    this._.fired(this, this.selectedIndex);
                    this.vrp();
                }

                return this;
            };

            /**
             * Get the given tab. Using the tab you can control tab caption,
             * icon.
             * @param {Integer} pageIndex a tab page index
             * @return  {zebkit.ui.Tabs.TabView}
             * @method getTab
             */
            this.getTab = function(pageIndex){
                return this.pages[pageIndex * 2];
            };

            /**
             * Set tab side spaces.
             * @param {Integer} sideSpace  [description]
             * @method setSideSpace
             * @chainable
             */
            this.setSideSpace = function(sideSpace){
                if (sideSpace !== this.sideSpace) {
                    this.sideSpace = sideSpace;
                    this.vrp();
                }
                return this;
            };

            this.setPageGaps = function (vg,hg){
                if (this.vgap !== vg || hg !== this.hgap){
                    this.vgap = vg;
                    this.hgap = hg;
                    this.vrp();
                }
                return this;
            };

            /**
             * Set the tab page element alignments
             * @param {String} o an alignment. The valid value is one of the following:
             * "left", "right", "top", "bottom"
             * @method  setAlignment
             * @chainable
             */
            this.setAlignment = function(o){
                if (this.orient !== o) {
                    this.orient = zebkit.util.$validateValue(o, "top", "bottom", "left", "right");
                    this.vrp();
                }
                return this;
            };

            /**
             * Set enabled state for the given tab page
             * @param  {Integer} i a tab page index
             * @param  {Boolean} b a tab page enabled state
             * @method enableTab
             * @chainable
             */
            this.enableTab = function(i,b){
                var c = this.kids[i];
                if (c.isEnabled !== b){
                    c.setEnabled(b);
                    if (b === false && this.selectedIndex === i) {
                        this.select(-1);
                    }
                    this.repaint();
                }
                return this;
            };

            /**
             *  Set number of views to render different Tab component elements
             *  @param {Object} a set of views as dictionary where key is a view
             *  name and the value is a view instance, string(for color), or render
             *  function. The following view elements can be passed:
             *
             *
             *      {
             *         "out"       : <view to render not selected tab page>,
             *         "over"      : <view to render a tab page when pointer is over>
             *         "selected"  : <a view to render selected tab page>
             *         "marker"    : <a marker view to be rendered around tab page title>
             *      }
             *
             *
             *  @method  setViews
             */
        },

        function focused(){
            this.$super();
            if (this.selectedIndex >= 0){
                var r = this.getTabBounds(this.selectedIndex);
                this.repaint(r.x, r.y, r.width, r.height);
            } else if (this.hasFocus() === false) {
                this.select(this.next(0, 1));
            }
        },

        function kidAdded(index,constr,c) {
            // correct wrong selection if inserted tab index is less or equals
            if (this.selectedIndex >= 0 && index <= this.selectedIndex) {
                this.selectedIndex++;
            }

            if (this.selectedIndex < 0) {
                this.select(this.next(0, 1));
            }

            return this.$super(index, constr, c);
        },

        function insert(index, constr, c) {
            var render = null;
            if (zebkit.instanceOf(constr, this.clazz.TabView)) {
                render = constr;
            } else {
                render = new this.clazz.TabView((constr === null ? "Page " + index
                                                                 : constr ));
                render.ownerChanged(this); // TODO: a little bit ugly but setting an owner is required to
                                           // keep tabs component informed when an icon has been updated
            }

            this.pages.splice(index * 2, 0, render, { x:0, y:0, width:0, height:0 });

            var r = this.$super(index, constr, c);
            // since we have added new page the repainting area is wider than
            // the added component (tab elements), so repaint the whole tab
            // component
            this.repaint();
            return r;
        },

        function removeAt(i){
            if (this.selectedIndex >= 0 && i <= this.selectedIndex) {
                if (i === this.selectedIndex) {
                    this.select(-1);
                } else {
                    this.selectedIndex--;
                    this.repaint();
                }
            }
            this.pages.splice(i * 2, 2);
            return this.$super(i);
        },

        function removeAll(){
            this.select(-1);
            this.pages.splice(0, this.pages.length);
            this.pages.length = 0;
            this.$super();
        },

        function setSize(w,h){
            if (this.width !== w || this.height !== h) {
                if (this.orient === "right" || this.orient === "bottom") {
                    this.tabAreaX = -1;
                }
                this.$super(w, h);
            }
            return this;
        }
    ]);


    /**
     * Text field UI component. The component is designed to enter single line, multi lines or password text.
     * The component implement text field functionality from the scratch. It supports the following features

        - Text selection
        - Redu/Undo actions
        - Native WEB clipboard
        - Basic text navigation
        - Read-only mode
        - Left or right text alignment

     * @constructor
     * @param {String|zebkit.data.TextModel|zebkit.ui.TextRender} [txt] a text the text field component
     * has to be filled. The parameter can be a simple string, text model or text render class instance.
     * @param {Integer} [maxCol] a maximal size of entered text. -1 means the size of the edited text
     * has no length limit.
     * @class zebkit.ui.TextField
     * @extends zebkit.ui.Label
     */
    pkg.TextField = Class(pkg.Label, [
        function (render, maxCol){
            this.history = Array(100);
            this.historyPos = -1;
            this.redoCounter = this.undoCounter = this.curY = this.curW = this.curH = 0;
            this.scrollManager = new pkg.ScrollManager(this);

            if (arguments.length === 0) {
                maxCol = -1;
                render = new pkg.TextRender(new zebkit.data.SingleLineTxt());
            } else if (arguments.length > 1) {
                if (arguments.length === 1) {
                    if (zebkit.isNumber(render)) {
                        maxCol = render;
                        render = null;
                    } else {
                        maxCol = -1;
                    }
                }

                if (zebkit.isString(render)) {
                    render = new pkg.TextRender(new zebkit.data.SingleLineTxt(render));
                } else if (zebkit.instanceOf(render, zebkit.data.TextModel)) {
                    render = new pkg.TextRender(render);
                }
            }

            this.$super(render);
            if (maxCol > 0) {
                this.setPSByRowsCols(-1, maxCol);
            }
        },

        function $clazz() {
            /**
             * Text field hint text render
             * @constructor
             * @class zebkit.ui.TextField.HintRender
             * @extends {zebkit.ui.StringRender}
             */
            this.HintRender = Class(pkg.StringRender, []);
        },

        /**
         * @for zebkit.ui.TextField
         */
        function $prototype() {
            this.$blinkTask = null;

            /**
             * Selection view.
             * @attribute selectionView
             * @type {zebkit.ui.View}
             */
            this.selectionView = this.hint = null;

            this.vkMode    = "indirect";
            this.startLine = this.startCol = this.endLine = this.endCol = this.curX = 0;
            this.startOff  = this.endOff = -1;

            /**
             * Selection color
             * @attribute  selection
             * @type {String}
             * @readOnly
             */
            this.selection = this.position = null;

            /**
             * Specify the text field cursor blinking period in milliseconds.
             * -1 means no blinkable cursor
             * @type {Number}
             * @default -1
             * @readOnly
             * @attribute blinkigPeriod
             */
            this.blinkingPeriod = -1;
            this.blinkMe        = true;
            this.blinkMeCounter = 0;

            /**
             * Cursor type
             * @attribute cursorType
             * @type {String}
             * @default zebkit.ui.Cursor.TEXT;
             */
            this.cursorType = pkg.Cursor.TEXT;

            /**
             * Text alignment
             * @attribute textAlign
             * @type {String}
             * @default "left"
             */
            this.textAlign = "left";

            /**
             * Cursor view
             * @attribute curView
             * @type {zebkit.ui.View}
             * @readOnly
             */
            this.curView = null;

            /**
             * Indicate if the text field is editable
             * @attribute  isEditable
             * @type {Boolean}
             * @default true
             * @readOnly
             */
            this.canHaveFocus = this.isEditable = true;

            /**
             * Set the specified blinking period of the text field cursor
             * @param {Integer} [period] a text field cursor blinking period (in milliseconds),
             * use -1 to disable cursor blinking. If the argument is not passed the default (500ms)
             * blinking period will be applied.
             * @method setBlinking
             * @chainable
             */
            this.setBlinking = function(period) {
                if (arguments.length === 0) {
                    period = 500;
                }

                if (period !== this.blinkingPeriod) {
                    this.blinkingPeriod = period;
                    this.repaintCursor();
                }
                return this;
            };

            /**
             * Set the text algnment.
             * @method setTextAlignment
             * @param {String} a a text alignment. Use "left" or "right" as the parameter value
             * @chainable
             */
            this.setTextAlignment = function(a) {
                if (this.textAlign !== a) {
                    this.textAlign = a;
                    this.vrp();
                }
                return this;
            };

            this.textUpdated = function(src, b, off, size, startLine, lines) {
                if (this.position !== null) {
                    if (b === true) {
                        // Check if a selection presents
                        // and clear it.  We do it here because it is important
                        // to remove any selected text after update since:
                        //   -- not every update brings to real text update, so we have remove selected text
                        //      only if real text update has happened
                        //   -- update can make selection start and end location invalid, so we have to take in
                        //      account before we remove it
                        if (this.startOff !== this.endOff) {
                            var start = this.startOff < this.endOff ? this.startOff : this.endOff,
                                end   = this.startOff > this.endOff ? this.startOff : this.endOff;

                            // if start of selection is less or equals
                            // to inserted text offset than we have to correct
                            // insertion area start and end offsets
                            if (off <= start) {
                                start += size;
                                end += size;
                            } else {
                                // if offset of an inserted text if greater than start of
                                // a selection but less or equals to end of the selection
                                // we have to correct insertion offset to start (since the
                                // selected text is going to be removed)
                                if (off <= end) {
                                    if (off < end) end += size;
                                    off = start;
                                }
                            }

                            //this.endOff = this.startOff = -1; // clear selection
                            this.remove(start, end - start);
                        }

                        this.endOff = this.startOff = -1; // clear selection
                        this.position.inserted(off, size);
                    } else {
                        this.position.removed(off, size);
                    }
                }
            };

            /**
             * Compute a text column and row by the given location.
             * @param  {Integer} x  a x coordinate
             * @param  {Integer} y  a y coordinate
             * @return {Object} a text row and column as an object { row:, col }.
             * @method  getTextRowColAt
             */
            this.getTextRowColAt = function(x, y) {
                var lines = this.getLines();

                // normalize text location to virtual (zero, zero)
                y -= (this.scrollManager.getSY() + this.getTop());
                x -= this.scrollManager.getSX();
                if (this.textAlign === "left") {
                    x -= this.getLeft();
                } else {
                    x -= (this.width - this.view.getPreferredSize().width - this.getRight());
                }

                if (x >= 0 && y >= 0 && lines > 0) {
                    var lh = this.view.getLineHeight(),
                        li = this.view.lineIndent,
                        row = (y < 0) ? 0 : Math.floor((y + li) / (lh + li)) + ((y + li) % (lh + li) > li ? 1 : 0) -1;

                    if (row < lines && row >= 0) {
                        var s    = this.view.getLine(row),
                            pdt  = 1000000,
                            pcol = -1;

                        for(var col = Math.floor((x / this.view.calcLineWidth(row)) * s.length); col >= 0 && col <= s.length;) {
                            var l  = this.view.font.charsWidth(s, 0, col),
                                dt = Math.abs(l - x);

                            if (dt >= pdt) {
                                return { row : row, col : pcol };
                            }

                            pdt  = dt;
                            pcol = col;
                            col += (l > x ? -1: 1);
                        }

                        return { row : row, col : s.length };
                    }
                }
                return null;
            };

            this.findNextWord = function(t, line, col, d){
                if (line < 0 || line >= t.getLines()) {
                    return null;
                }

                var ln = t.getLine(line);
                col += d;
                if (col < 0 && line > 0) {
                    return { row: line - 1, col : t.getLine(line - 1).length };
                } else if (col > ln.length && line < t.getLines() - 1) {
                    return { row : line + 1, col : 0 };
                }

                var b = false;
                for(; col >= 0 && col < ln.length; col += d){
                    if (b) {
                        if (d > 0) {
                            if (zebkit.util.isLetter(ln[col])) return { row:line, col:col };
                        } else {
                            if (!zebkit.util.isLetter(ln[col])) return { row : line, col: col + 1 };
                        }
                    } else  {
                        b = d > 0 ? !zebkit.util.isLetter(ln[col]) : zebkit.util.isLetter(ln[col]);
                    }
                }
                return (d > 0 ? { row: line, col : ln.length }: { row : line, col : 0 } );
            };

            // collect text model lines into string by the given start and end offsets
            // r     - text view
            // start - start offset
            // end   - end offset
            this.getSubString = function(r, start, end){
                var res = [],
                    sr = start.row,
                    er = end.row;

                for(var i = sr; i < er + 1; i++){
                    var ln = r.getLine(i);
                    if (i !== sr) {
                        res.push('\n');
                    } else {
                        ln = ln.substring(start.col);
                    }

                    if (i === er) {
                        ln = ln.substring(0, end.col - ((sr === er) ? start.col : 0));
                    }
                    res.push(ln);
                }
                return res.join('');
            };

            /**
             * Remove selected text
             * @method removeSelected
             */
            this.removeSelected = function(){
                if (this.hasSelection()){
                    var start = this.startOff < this.endOff ? this.startOff : this.endOff;
                    this.remove(start, (this.startOff > this.endOff ? this.startOff : this.endOff) - start);
                    this.clearSelection();
                }
            };

            /**
             * Start selection.
             * @protected
             * @method  startSelection
             */
            this.startSelection = function() {
                if (this.startOff < 0 && this.position !== null){
                    var pos = this.position;
                    this.endLine = this.startLine = pos.currentLine;
                    this.endCol = this.startCol = pos.currentCol;
                    this.endOff = this.startOff = pos.offset;
                }
            };

            this.keyTyped = function(e) {
                if (this.isEditable === true &&
                    e.ctrlKey === false &&
                    e.metaKey === false &&
                    e.key !== '\t')
                {
                    this.write(this.position.offset, e.key);
                }
            };

            /**
             * Select all text.
             * @method  selectAll
             * @chainable
             */
            this.selectAll = function() {
                this.select(0, this.getMaxOffset());
                return this;
            };

            /**
             * Shortcut event handler
             * @param  {java.ui.ShortcutEvent} e a shortcut event
             * @method shortcutFired
             */
            this.shortcutFired = function(e) {
                if (e.shortcut === "SELECTALL") {
                    this.selectAll();
                } else {
                    var d  = (e.shortcut === "PREVWORDSELECT" || e.shortcut === "PREVWORD") ? -1 : 1;

                    if (e.shortcut === "PREVWORDSELECT" ||
                        e.shortcut === "NEXTWORDSELECT" ||
                        e.shortcut === "NEXTPAGESELECT" ||
                        e.shortcut === "PREVPAGESELECT"   )
                    {
                        this.startSelection();
                    }

                    switch (e.shortcut) {
                        case "UNDO"          : this.undo(); break;
                        case "REDO"          : this.redo(); break;
                        case "NEXTPAGESELECT":
                        case "NEXTPAGE"      :  this.position.seekLineTo("down", this.pageSize()); break;
                        case "PREVPAGESELECT":
                        case "PREVPAGE"      :  this.position.seekLineTo("up", this.pageSize()); break;
                        case "NEXTWORDSELECT":
                        case "PREVWORDSELECT":
                        case "PREVWORD":
                        case "NEXTWORD" : {
                            var p = this.findNextWord(this.view.target, this.position.currentLine,
                                                                        this.position.currentCol, d);
                            if (p !== null) {
                                this.position.setRowCol(p.row, p.col);
                            }
                        } break;
                    }
                }
            };

            this.keyPressed = function(e) {
                if (this.isFiltered(e) === false)  {
                    var position    = this.position;

                    if (e.shiftKey) {
                        this.startSelection();
                    }

                    switch(e.code) {
                        case "ArrowDown" : position.seekLineTo("down"); break;
                        case "ArrowUp"   : position.seekLineTo("up"); break;
                        case "ArrowLeft" :
                            if (e.ctrlKey === false && e.metaKey === false) {
                                position.seek(-1);
                            }
                            break;
                        case "ArrowRight":
                            if (e.ctrlKey === false && e.metaKey === false) {
                                position.seek(1);
                            }
                            break;
                        case "End":
                            if (e.ctrlKey) {
                                position.seekLineTo("down", this.getLines() - position.currentLine - 1);
                            } else {
                                position.seekLineTo("end");
                            }
                            break;
                        case "Home":
                            if (e.ctrlKey) {
                                position.seekLineTo("up", position.currentLine);
                            } else {
                                position.seekLineTo("begin");
                            }
                            break;
                        case "PageDown" :
                            position.seekLineTo("down", this.pageSize());
                            break;
                        case "PageUp" :
                            position.seekLineTo("up", this.pageSize());
                            break;
                        case "Delete":
                            if (this.hasSelection() && this.isEditable === true) {
                                this.removeSelected();
                            } else {
                                if (this.isEditable === true) {
                                    this.remove(position.offset, 1);
                                }
                            } break;
                        case "Backspace":
                            if (this.isEditable === true) {
                                if (this.hasSelection()) {
                                    this.removeSelected();
                                } else {
                                    if (this.isEditable === true && position.offset > 0){
                                        position.seek(-1);
                                        this.remove(position.offset, 1);
                                    }
                                }
                            } break;
                        default: return ;
                    }

                    if (e.shiftKey === false) {
                        this.clearSelection();
                    }
                }
            };

            /**
             * Test if the given key pressed event has to be processed
             * @protected
             * @param  {zebkit.ui.KeyEvent} e a key event
             * @return {Boolean} true if the given key pressed event doesn't
             * have be processed
             * @method isFiltered
             */
            this.isFiltered = function(e){
                var code = e.code;
                return code === "Shift" || code === "Control" ||
                       code === "Tab"   || code === "Alt"     ||
                       e.altKey;
            };

            /**
             * Remove the specified part of edited text
             * @param  {Integer} pos a start position of a removed text
             * @param  {Integer} size a size of removed text
             * @method remove
             */
            this.remove = function (pos,size){
                if (this.isEditable === true) {
                    var position = this.position;
                    if (pos >= 0 && (pos + size) <= this.getMaxOffset()) {
                        if (size < 10000) {
                            this.historyPos = (this.historyPos + 1) % this.history.length;
                            this.history[this.historyPos] = [-1, pos, this.getValue().substring(pos, pos+size)];
                            if (this.undoCounter < this.history.length) this.undoCounter++;
                        }

                        if (this.view.target.remove(pos, size)) {
                            this.repaint();
                            return true;
                        }
                    }
                }
                return false;
            };

            /**
             * Insert the specified text into the edited text at the given position
             * @param  {Integer} pos a start position of a removed text
             * @param  {String} s a text to be inserted
             * @return {Boolean} true if repaint has been requested
             * @method write
             */
            this.write = function (pos,s) {
                if (this.isEditable === true) {
                    // TODO: remove hard coded undo/redo deepness value
                    if (s.length < 10000) {
                        this.historyPos = (this.historyPos + 1) % this.history.length;
                        this.history[this.historyPos] = [1, pos, s.length];
                        if (this.undoCounter < this.history.length) {
                            this.undoCounter++;
                        }
                    }

                    if (this.view.target.write(s, pos)) {
                        this.repaint();
                        return true;
                    }
                }
                return false;
            };

            this.recalc = function() {
                var r = this.view;
                if (this.position.offset >= 0) {
                    var l = r.getLine(this.position.currentLine);
                    if (this.textAlign === "left") {
                        this.curX = r.font.charsWidth(l, 0, this.position.currentCol) + this.getLeft();
                    } else {
                        this.curX = this.width - this.getRight() - this.view.getPreferredSize().width +
                                    r.font.charsWidth(l, 0, this.position.currentCol);
                    }

                    this.curY = this.position.currentLine * (r.getLineHeight() + r.lineIndent) +
                                this.getTop();
                }

                this.curH = r.getLineHeight() - 1;
            };

            this.catchScrolled = function(psx,psy){
                this.repaint();
            };

            /**
             * Draw the text field cursor
             * @protected
             * @param  {CanvasRenderingContext2D} g a 2D context
             * @method drawCursor
             */
            this.drawCursor = function (g) {
                if (this.position.offset >= 0 &&
                    this.curView !== null     &&
                    this.blinkMe              &&
                    this.hasFocus()              )
                {
                    if (this.textAlign === "left") {
                        this.curView.paint(g, this.curX, this.curY,
                                              this.curW, this.curH, this);
                    } else {
                        this.curView.paint(g, this.curX - this.curW, this.curY,
                                              this.curW, this.curH, this);
                    }
                }
            };

            this.pointerDragStarted = function (e){
                if (e.isAction() && this.getMaxOffset() > 0) {
                    this.startSelection();
                }
            };

            this.pointerDragEnded =function (e){
                if (e.isAction() && this.hasSelection() === false) {
                    this.clearSelection();
                }
            };

            this.pointerDragged = function (e){
                if (e.isAction()){
                    var p = this.getTextRowColAt(e.x, e.y);
                    if (p !== null) this.position.setRowCol(p.row, p.col);
                }
            };

            /**
             * Select the specified part of the edited text
             * @param  {Integer} startOffset a start position of a selected text
             * @param  {Integer} endOffset  an end position of a selected text
             * @method select
             * @chainable
             */
            this.select = function (startOffset,endOffset){
                if (endOffset < startOffset ||
                    startOffset < 0 ||
                    endOffset > this.getMaxOffset())
                {
                    throw new Error("Invalid selection offsets");
                }

                if (this.startOff !== startOffset || endOffset !== this.endOff) {
                    if (startOffset === endOffset) {
                        this.clearSelection();
                    } else {
                        this.startOff = startOffset;
                        var p = this.position.getPointByOffset(startOffset);
                        this.startLine = p[0];
                        this.startCol  = p[1];
                        this.endOff    = endOffset;
                        p = this.position.getPointByOffset(endOffset);
                        this.endLine = p[0];
                        this.endCol = p[1];
                        this.repaint();
                    }
                }

                return this;
            };

            /**
             * Test if the text field has a selected text
             * @return {Boolean} true if the text field has a selected text
             * @method hasSelection
             */
            this.hasSelection = function () {
                return this.startOff !== this.endOff;
            };

            this.posChanged = function (target,po,pl,pc){
                this.recalc();
                var position = this.position;
                if (position.offset >= 0) {

                    this.blinkMeCounter = 0;
                    this.blinkMe = true;

                    var lineHeight = this.view.getLineHeight(),
                        top        = this.getTop();

                    this.scrollManager.makeVisible(this.textAlign === "left" ? this.curX
                                                                             : this.curX - this.curW,
                                                    this.curY, this.curW, lineHeight);

                    if (pl >= 0) {
                        // means selected text exists, than we have to correct selection
                        // according to the new position
                        if (this.startOff >= 0){
                            this.endLine = position.currentLine;
                            this.endCol  = position.currentCol;
                            this.endOff  = position.offset;
                        }

                        var minUpdatedLine = pl < position.currentLine ? pl : position.currentLine,
                            li             = this.view.lineIndent,
                            bottom         = this.getBottom(),
                            left           = this.getLeft(),
                            y1             = lineHeight * minUpdatedLine + minUpdatedLine * li +
                                             top + this.scrollManager.getSY();

                        if (y1 < top) {
                            y1 = top;
                        }

                        if (y1 < this.height - bottom){
                            var h = ((pl > position.currentLine ? pl
                                                                : position.currentLine) - minUpdatedLine + 1) * (lineHeight + li);
                            if (y1 + h > this.height - bottom) {
                                h = this.height - bottom - y1;
                            }
                            this.repaint(left, y1, this.width - left - this.getRight(), h);
                        }
                    } else {
                        this.repaint();
                    }
                }
            };

            this.paintOnTop = function(g) {
                if (this.hint !== null && this.getMaxOffset() === 0) {
                    var ps = this.hint.getPreferredSize(),
                        yy = Math.floor((this.height - ps.height)/2),
                        xx = ("left" === this.textAlign) ? this.getLeft() + this.curW
                                                         : this.width - ps.width - this.getRight() - this.curW;

                    this.hint.paint(g, xx, yy, this.width, this.height, this);
                }
            };

            /**
             * Set the specified hint text to be drawn with the given font and color.
             * The hint is not-editable text that is shown in empty text field to help
             * a user to understand which input the text field expects.
             * @param {String|zebkit.ui.View|Function} hint a hint text, view or view render method
             * @method setHint
             * @chainable
             */
            this.setHint = function(hint) {
                this.hint = zebkit.isString(hint) ? new this.clazz.HintRender(hint) : pkg.$view(hint);
                this.repaint();
                return this;
            };

            /**
             * Performs undo operation
             * @method undo
             * @chainable
             */
            this.undo = function() {
                if (this.undoCounter > 0) {
                    var h = this.history[this.historyPos];

                    this.historyPos--;
                    if (h[0] === 1) {
                        this.remove(h[1], h[2]);
                    }
                    else {
                        this.write (h[1], h[2]);
                    }

                    this.undoCounter -= 2;
                    this.redoCounter++;

                    this.historyPos--;
                    if (this.historyPos < 0) {
                        this.historyPos = this.history.length - 1;
                    }

                    this.repaint();
                }
                return this;
            };

            /**
             * Performs redo operation
             * @method redo
             * @chainable
             */
            this.redo = function() {
                if (this.redoCounter > 0) {
                    var h = this.history[(this.historyPos + 1) % this.history.length];
                    if (h[0] === 1) this.remove(h[1], h[2]);
                    else            this.write (h[1], h[2]);
                    this.redoCounter--;
                    this.repaint();
                }
                return this;
            };

            /**
             * Get a starting position (row and column) of a selected text
             * @return {Array} a position of a selected text. First element
             * of is a row and second column of selected text. null if
             * there is no any selected text
             * @method getStartSelection
             */
            this.getStartSelection = function(){
                return this.startOff !== this.endOff ? ((this.startOff < this.endOff) ? { row: this.startLine, col: this.startCol }
                                                                                      : { row: this.endLine, col: this.endCol } )
                                                     : null;
            };

            /**
             * Get an ending position (row and column) of a selected text
             * @return {Array} a position of a selected text. First element
             * of is a row and second column of selected text. null if
             * there is no any selected text
             * @method getEndSelection
             */
            this.getEndSelection = function(){
                return this.startOff !== this.endOff ? ((this.startOff < this.endOff) ? { row : this.endLine,   col : this.endCol   }
                                                                                      : { row : this.startLine, col : this.startCol })
                                                     : null;
            };

            /**
             * Get a selected text
             * @return {String} a selected text
             * @method getSelectedText
             */
            this.getSelectedText = function(){
                return this.startOff !== this.endOff ? this.getSubString(this.view,
                                                                         this.getStartSelection(),
                                                                         this.getEndSelection())
                                                     : null;
            };

            this.getLines = function() {
                return this.position === null ? -1 : this.position.metrics.getLines();
            };

            this.getMaxOffset = function() {
                return this.position === null ? -1 : this.position.metrics.getMaxOffset();
            };

            this.focusGained = function (e){
                if (this.position.offset < 0) {
                    this.position.setOffset(this.textAlign === "left" || this.getLines() > 1 ? 0 : this.getMaxOffset());
                } else {
                    if (this.hint !== null) {
                        this.repaint();
                    } else {
                        this.repaintCursor();
                    }
                }

                if (this.isEditable === true && this.blinkingPeriod > 0) {
                    this.blinkMeCounter = 0;
                    this.blinkMe = true;

                    var $this = this;
                    this.$blinkTask = zebkit.util.tasksSet.run(function() {
                            $this.blinkMeCounter = ($this.blinkMeCounter + 1) % 3;
                            if ($this.blinkMeCounter === 0) {
                                $this.blinkMe = !$this.blinkMe;
                                $this.repaintCursor();
                            }
                        },
                        ~~(this.blinkingPeriod / 3),
                        ~~(this.blinkingPeriod / 3)
                    );
                }
            };

            this.focusLost = function(e) {
                this.repaintCursor();
                if (this.isEditable === true) {
                    if (this.hint !== null) this.repaint();

                    if (this.blinkingPeriod > 0) {
                        if (this.$blinkTask !== null) {
                            this.$blinkTask.shutdown();
                            this.$blinkTask = null;
                        }
                        this.blinkMe = true;
                    }
                }
            };

            /**
             * Force text field cursor repainting.
             * @method repaintCursor
             * @protected
             */
            this.repaintCursor = function() {
                if (this.curX > 0 && this.curW > 0 && this.curH > 0) {
                    this.repaint(this.curX + this.scrollManager.getSX(),
                                 this.curY + this.scrollManager.getSY(),
                                 this.curW, this.curH);
                }
            };

            /**
             * Clear a text selection.
             * @method clearSelection
             * @chainable
             */
            this.clearSelection = function() {
                if (this.startOff >= 0){
                    var b = this.hasSelection();
                    this.endOff = this.startOff = -1;
                    if (b) {
                        this.repaint();
                    }
                }
                return this;
            };

            this.pageSize = function (){
                var height = this.height - this.getTop() - this.getBottom(),
                    indent = this.view.lineIndent,
                    textHeight = this.view.getLineHeight();

                return (((height + indent) / (textHeight + indent) + 0.5) | 0) +
                       (((height + indent) % (textHeight + indent) > indent) ? 1 : 0);
            };

            this.clipPaste = function(txt){
                if (txt !== null) {
                    this.removeSelected();
                    this.write(this.position.offset, txt);
                }
            };

            this.clipCopy = function() {
                return this.getSelectedText();
            };

            /**
             * Cut selected text
             * @return {String} a text that has been selected and cut
             * @method  cut
             */
            this.cut = function() {
                var t = this.getSelectedText();
                if (this.isEditable === true) this.removeSelected();
                return t;
            };

            /**
             * Set the specified cursor position controller
             * @param {zebkit.util.Position} p a position controller
             * @method setPosition
             * @chainable
             */
            this.setPosition = function (p){
                if (this.position !== p) {
                    if (this.position !== null) {
                        this.position.off(this);
                    }
                    this.position = p;
                    if (this.position !== null) {
                        this.position.on(this);
                    }
                    this.invalidate();
                }

                return this;
            };

            /**
             * Set the cursor view. The view defines rendering of the text field
             * cursor.
             * @param {zebkit.ui.View} v a cursor view
             * @method setCursorView
             * @chainable
             */
            this.setCursorView = function (v){
                // TODO: cursor size should be set by property
                this.curW = 1;
                this.curView = pkg.$view(v);
                //this.curW = this.curView !== null ? this.curView.getPreferredSize().width : 1;
                this.vrp();

                return this;
            };

            /**
             * Adjust the size of the text field component to be enough to place the given
             * number of rows and columns.
             * @param {Integer} r a row of the text the height of the text field has to be adjusted
             * @param {Integer} c a column of the text the width of the text field has to be adjusted
             * @method setPSByRowsCols
             * @chainable
             */
            this.setPSByRowsCols = function (r,c){
                var tr = this.view,
                    w  = (c > 0) ? (tr.font.stringWidth("W") * c)
                                 : this.psWidth,
                    h  = (r > 0) ? (r * tr.getLineHeight() + (r - 1) * tr.lineIndent)
                                 : this.psHeight;
                this.setPreferredSize(w, h);
                return this;
            };

            /**
             * Control the text field editable state
             * @param {Boolean} b true to make the text field editable
             * @method setEditable
             * @chainable
             */
            this.setEditable = function (b){
                if (b !== this.isEditable){
                    this.isEditable = b;
                    if (b && this.blinkingPeriod > 0 && this.hasFocus()) {
                        if (this.$blinkTask !== null) {
                            this.$blinkTask.shutdown();
                        }
                        this.blinkMe = true;
                    }
                    this.vrp();
                }
                return this;
            };

            this.pointerDoubleClicked = function(e){
                if (e.isAction()) {
                    this.select(0, this.getMaxOffset());
                }
            };

            this.pointerPressed = function(e){
                if (e.isAction()) {
                    if (e.shiftKey) {
                        this.startSelection();
                    } else {
                        this.clearSelection();
                    }

                    var p = this.getTextRowColAt(e.x, e.y);
                    if (p !== null) this.position.setRowCol(p.row, p.col);
                }
            };

            /**
             * Set selection view
             * @param {String} c a selection color
             * @method setSelectionView
             * @chainable
             */
            this.setSelectionView = function(c) {
                if (c != this.selectionView) {
                    this.selectionView = pkg.$view(c);

                    if (this.hasSelection()) {
                        this.repaint();
                    }
                }
                return this;
            };

            this.calcPreferredSize = function (t) {
                var ps = this.view.getPreferredSize();
                ps.width += this.curW;
                return ps;
            };

            //!!! to maximize optimize performance the method duplicates part of ViewPan.paint() code
            this.paint = function(g){
                var sx = this.scrollManager.getSX(),
                    sy = this.scrollManager.getSY(),
                    l  = this.getLeft(),
                    t  = this.getTop(),
                    r  = this.getRight();

                try {
                    g.translate(sx, sy);

                    if (this.textAlign === "left") {
                        this.view.paint(g, l, t,
                                        this.width  - l - r,
                                        this.height - t - this.getBottom(), this);
                    } else {
                        this.view.paint(g, this.width - r - this.view.getPreferredSize().width, t,
                                           this.width  - l - r,
                                           this.height - t - this.getBottom(), this);
                    }

                    this.drawCursor(g);
                } catch(e) {
                    g.translate(-sx, -sy);
                    throw e;
                }
                g.translate(-sx, -sy);
            };
        },

        function setView(v){
            if (v != this.view) {
                if (this.view !== null && this.view.target !== null && typeof this.view.target.on !== 'undefined') {
                    this.view.target.off(this);
                }

                this.$super(v);
                if (this.position === null) {
                    this.setPosition(new zebkit.util.Position(this.view));
                } else {
                    this.position.setMetric(this.view);
                }

                if (this.view !== null && this.view.target !== null && typeof this.view.target.on !== 'undefined') {
                    this.view.target.on(this);
                }
            }
            return this;
        },

        /**
         * Set the text content of the text field component
         * @param {String} s a text the text field component has to be filled
         * @method setValue
         * @chainable
         */
        function setValue(s) {
            var txt = this.getValue();
            if (txt !== s){
                if (this.position !== null) {
                    this.position.setOffset(0);
                }
                this.scrollManager.scrollTo(0, 0);
                this.$super(s);
            }
            return this;
        },

        function setEnabled(b){
            this.clearSelection();
            this.$super(b);
            return this;
        }
    ]);

    /**
     * Text area UI component. The UI component to render multi-lines text.
     * @class zebkit.ui.TextArea
     * @constructor
     * @param {String} [txt] a text
     * @extends zebkit.ui.TextField
     */
    pkg.TextArea = Class(pkg.TextField, [
        function(txt) {
            if (arguments.length === 0) txt = "";
            this.$super(new zebkit.data.Text(txt));
        }
    ]);

    /**
     * Password text field.
     * @class zebkit.ui.PassTextField
     * @constructor
     * @param {String} txt password text
     * @param {Integer} [maxSize] maximal size
     * @param {Boolean} [showLast] indicates if last typed character should
     * not be disguised with a star character
     * @extends zebkit.ui.TextField
     */
    pkg.PassTextField = Class(pkg.TextField, [
        function(txt, size, showLast) {
            if (arguments.length === 1) {
                showLast = false;
                size     = -1;

                if (zebkit.isBoolean(txt)) {
                    showLast = txt;
                    txt      = "";
                } else if (zebkit.isNumber(txt)) {
                    size = txt;
                    txt = "";
                }
            } else if (arguments.length === 0) {
                showLast = false;
                size     = -1;
                txt      = "";
            } else if (arguments.length === 2) {
                showLast = false;
            }

            var pt = new pkg.PasswordText(new zebkit.data.SingleLineTxt(txt, size));
            pt.showLast = showLast;
            this.$super(pt);
            if (size > 0) {
                this.setPSByRowsCols(-1, size);
            }
        },

        /**
         * Set flag that indicates if the last password character has to be visible.
         * @param {Boolean} b a boolean flag that says if last password character has
         * to be visible.
         * @method setShowLast
         * @chainable
         */
        function setShowLast(b) {
            if (this.showLast !== b) {
                this.view.showLast = b;
                this.repaint();
            }
            return this;
        }
    ]);


    /**
     * Base UI list component class that has to be extended with a
     * concrete list component implementation. The list component
     * visualizes list data model (zebkit.data.ListModel).
     * @class  zebkit.ui.BaseList
     * @constructor
     * @param {zebkit.data.ListModel|Array} [m] a list model that should be passed as an instance
     * of zebkit.data.ListModel or as an array.
     * @param {Boolean} [b] true if the list navigation has to be triggered by
     * pointer cursor moving
     * @extends {zebkit.ui.Panel}
     * @uses {zebkit.util.Position.Metric}
     * @uses {zebkit.ui.$ViewsSetterMix}
     */

    /**
     * Fire when a list item has been selected:
     *
     *     list.on("selected", function(src, prev) {
     *         ...
     *     });
     *
     * @event selected
     * @param {zebkit.ui.BaseList} src a list that triggers the event
     * @param {Integer|Object} prev a previous selected index, return null if the selected item has been re-selected
     */
    pkg.BaseList = Class(pkg.Panel, zebkit.util.Position.Metric, pkg.$ViewsSetterMix, [
        function (m, b) {
            if (arguments.length === 0) {
                m = [];
                b = false;
            } else if (arguments.length === 1) {
                if (zebkit.isBoolean(m))  {
                    b = m;
                    m = [];
                } else {
                    b = false;
                }
            } else {
                if (m === null) m = [];
            }


            /**
             * Currently selected list item index
             * @type {Integer}
             * @attribute selectedIndex
             * @default -1
             * @readOnly
             */
            this.selectedIndex = -1;

            this._ = new this.clazz.Listeners();

            /**
             * Indicate the current mode the list items selection has to work
             * @readOnly
             * @default false
             * @attribute isComboMode
             * @type {Boolean}
             */
            this.isComboMode = b;

            /**
             * Scroll manager
             * @attribute scrollManager
             * @readOnly
             * @protected
             * @type {zebkit.ui.ScrollManager}
             */
            this.scrollManager = new pkg.ScrollManager(this);

            this.$super();

            // position manager should be set before model initialization
            this.setPosition(new zebkit.util.Position(this));

            /**
             * List model
             * @readOnly
             * @attribute model
             */
            this.setModel(m);
        },

        function $clazz() {
            this.Listeners = zebkit.util.ListenersClass("selected");
        },

        function $prototype() {
            this.scrollManager = this.position = this.model = null;

            this.canHaveFocus = true;
            /**
             * List model the component visualizes
             * @attribute model
             * @type {zebkit.data.ListModel}
             * @readOnly
             */

            /**
             * Select the specified list item.
             * @param {Object} v a list item to be selected. Use null as
             * the parameter value to clean an item selection
             * @return {Integer} an index of a selected item
             * @method setValue
             */
            this.setValue = function(v) {
                if (v === null) {
                    this.select(-1);
                } else if (this.model !== null) {
                    for(var i = 0; i < this.model.count(); i++) {
                        if (this.model.get(i) === v && this.isItemSelectable(i)) {
                            this.select(i);
                            return i;
                        }
                    }
                }
                return -1;
            };

            /**
             * Get the list component selected item
             * @return {Object} a selected item
             * @method getValue
             */
            this.getValue = function() {
                return this.getSelected();
            };

            /**
             * Test if the given item is selectable.
             * @param  {Integer}  i an item index
             * @return {Boolean}  true if the given item is selectable
             * @method isItemSelectable
             */
            this.isItemSelectable = function(i) {
                return true;
            };

            /**
             * Get selected list item
             * @return {Object} an item
             * @method getSelected
             */
            this.getSelected = function(){
                return this.selectedIndex < 0 ? null
                                              : this.model.get(this.selectedIndex);
            };

            this.lookupItem = function(ch){
                var count = this.model === null ? 0 : this.model.count();
                if (zebkit.util.isLetter(ch) && count > 0){
                    var index = this.selectedIndex < 0 ? 0 : this.selectedIndex + 1;
                    ch = ch.toLowerCase();
                    for(var i = 0;i < count - 1; i++){
                        var idx  = (index + i) % count,
                            item = this.model.get(idx).toString();

                        if (this.isItemSelectable(idx) && item.length > 0 && item[0].toLowerCase() === ch) {
                            return idx;
                        }
                    }
                }
                return -1;
            };

            /**
             * Test if the given list item is selected
             * @param  {Integer}  i an item index
             * @return {Boolean}  true if the item with the given index is selected
             * @method isSelected
             */
            this.isSelected = function(i) {
                return i === this.selectedIndex;
            };

            /**
             * Called when a pointer (pointer or finger on touch screen) is moved
             * to a new location
             * @param  {Integer} x a pointer x coordinate
             * @param  {Integer} y a pointer y coordinate
             * @method $pointerMoved
             * @protected
             */
            this.$pointerMoved = function(x, y){
                if (this.isComboMode === true && this.model !== null) {
                    var index = this.getItemIdxAt(x, y);
                    if (index !== this.position.offset && (index < 0 || this.isItemSelectable(index) === true)) {
                        this.$triggeredByPointer = true;

                        if (index < 0) this.position.setOffset(null);
                        else this.position.setOffset(index);
                        this.notifyScrollMan(index);

                        this.$triggeredByPointer = false;
                    }
                }
            };

            /**
             * Return the given list item location.
             * @param  {Integer} i a list item index
             * @return {Object}  a location of the list item. The result is object that
             * has the following structure:
                    { x:{Integer}, y:{Integer} }
             * @method getItemLocation
             */
            this.getItemLocation = function(index) {
                this.validate();

                var y = this.getTop() + this.scrollManager.getSY();
                for(var i = 0; i < index; i++) {
                    y += this.getItemSize(i).height;
                }

                return { x:this.getLeft(), y:y };
            };

            /**
             * Return the given list item size.
             * @param  {Integer} i a list item index
             * @return {Object}  a size of the list item. The result is object that
             * has the following structure:
                    { width:{Integer}, height:{Integer} }
             * @method getItemSize
             */
            this.getItemSize = function (i){
                throw new Error("Not implemented");
            };

            this.getLines = function() {
                return this.model === null ? 0 : this.model.count();
            };

            this.getLineSize = function(l) {
                return 1;
            };

            this.getMaxOffset = function() {
                return this.getLines() - 1;
            };

            this.catchScrolled = function(psx,psy) {
                this.repaint();
            };

            /**
             * Detect an item by the specified location
             * @param  {Integer} x a x coordinate
             * @param  {Integer} y a y coordinate
             * @return {Integer} a list item that is located at the given position.
             * -1 if no any list item can be found.
             * @method getItemIdxAt
             */
            this.getItemIdxAt = function(x,y) {
                return -1;
            };

            /**
             * Calculate maximal width and maximal height the items in the list have
             * @protected
             * @return {Integer} a max items size
             * @method calcMaxItemSize
             */
            this.calcMaxItemSize = function (){
                var maxH = 0,
                    maxW = 0;

                this.validate();
                if (this.model !== null) {
                    for(var i = 0;i < this.model.count(); i++){
                        var is = this.getItemSize(i);
                        if (is.height > maxH) maxH = is.height;
                        if (is.width  > maxW) maxW = is.width;
                    }
                }
                return { width:maxW, height:maxH };
            };

            /**
             * Force repainting of the given list items
             * @protected
             * @param  {Integer} p an index of the first list item to be repainted
             * @param  {Integer} n an index of the second list item to be repainted
             * @method repaintByOffsets
             */
            this.repaintByOffsets = function(p, n) {
                this.validate();
                var xx    = this.width - this.getRight(),
                    l     = 0,
                    count = this.model === null ? 0
                                                : this.model.count();

                if (p >= 0 && p < count){
                    l = this.getItemLocation(p);
                    this.repaint(l.x, l.y, xx - l.x, this.getItemSize(p).height);
                }

                if (n >= 0 && n < count){
                    l = this.getItemLocation(n);
                    this.repaint(l.x, l.y, xx - l.x, this.getItemSize(n).height);
                }
            };

            /**
             * Draw the given list view element identified by the given id
             * on the given list item.
             * @param  {CanvasRenderingContext2D} g     a graphical context
             * @param  {String}     id    a view id
             * @param  {Integer}    index a list item index
             * @protected
             * @method drawViewAt
             */
            this.drawViewAt = function(g, id, index) {
                if (index >= 0 && this.views.hasOwnProperty(id) && this.views[id] !== null && this.isItemSelectable(index)) {
                    var is  = this.getItemSize(index),
                        l   = this.getItemLocation(index);

                    this.drawView(g, id, this.views[id],
                                  l.x, l.y,
                                  is.width ,
                                  is.height);
                }
            };

            /**
             * Draw the given list view element identified by the given id
             * at the specified location.
             * @param  {CanvasRenderingContext2D} g     a graphical context
             * @param  {String}     id    a view id
             * @param  {Integer}    x a x coordinate the view has to be drawn
             * @param  {Integer}    y a y coordinate the view has to be drawn
             * @param  {Integer}    w a view width
             * @param  {Integer}    h a view height
             * @protected
             * @method drawView
             */
            this.drawView = function(g, id, v, x, y, w ,h) {
                this.views[id].paint(g, x, y, w, h, this);
            };

            this.update = function(g) {
                if (this.isComboMode === true || this.hasFocus() === true)  {
                    this.drawViewAt(g, "marker", this.position.offset);
                }
                this.drawViewAt(g, "select", this.selectedIndex);
            };

            this.paintOnTop = function(g) {
                if (this.isComboMode === true || this.hasFocus())  {
                    this.drawViewAt(g, "top.marker", this.position.offset);
                }
            };

            /**
             * Select the given list item
             * @param  {Integer} index an item index to be selected
             * @method select
             */
            this.select = function(index){
                if (index === null || typeof index === 'undefined') {
                    throw new Error("Null index");
                }

                if (this.model !== null && index >= this.model.count()){
                    throw new RangeError(index);
                }

                if (this.selectedIndex !== index) {
                    if (index < 0 || this.isItemSelectable(index)) {
                        var prev = this.selectedIndex;
                        this.selectedIndex = index;
                        this.notifyScrollMan(index);
                        this.repaintByOffsets(prev, this.selectedIndex);
                        this.fireSelected(prev);
                    }
                } else {
                    this.fireSelected(null);
                }
            };

            /**
             * Fire selected event
             * @param  {Integer|null} prev a previous selected item index. null if the
             * same item has been re-selected
             * @method fireSelected
             * @protected
             */
            this.fireSelected = function(prev) {
                this._.selected(this, prev);
            };

            this.pointerClicked = function(e) {
                if (this.model !== null && e.isAction() && this.model.count() > 0) {
                    this.$select(this.position.offset < 0 ? 0 : this.position.offset);
                }
            };

            this.pointerReleased = function(e){
                if (this.model !== null    &&
                    this.model.count() > 0 &&
                    e.isAction()           &&
                    this.position.offset !== this.selectedIndex)
                {
                    this.position.setOffset(this.selectedIndex);
                }
            };

            this.pointerPressed = function(e){
                if (e.isAction() && this.model !== null && this.model.count() > 0) {
                    var index = this.getItemIdxAt(e.x, e.y);
                    if (index >= 0 && this.position.offset !== index && this.isItemSelectable(index)) {
                        this.position.setOffset(index);
                    }
                }
            };

            this.pointerDragged = this.pointerMoved = this.pointerEntered = function(e){
                this.$pointerMoved(e.x, e.y);
            };

            this.pointerExited  = function(e){
                this.$pointerMoved(-10, -10);
            };

            this.pointerDragEnded = function(e){
                if (this.model !== null && this.model.count() > 0 && this.position.offset >= 0) {
                    this.select(this.position.offset < 0 ? 0 : this.position.offset);
                }
            };

            this.keyPressed = function(e){
                if (this.model !== null && this.model.count() > 0){
                    var po = this.position.offset;
                    switch(e.code) {
                        case "End":
                            if (e.ctrlKey) {
                                this.position.setOffset(this.position.metrics.getMaxOffset());
                            } else {
                                this.position.seekLineTo("end");
                            }
                            break;
                        case "Home":
                            if (e.ctrlKey) this.position.setOffset(0);
                            else this.position.seekLineTo("begin");
                            break;
                        case "ArrowRight": this.position.seek(1); break;
                        case "ArrowDown" : this.position.seekLineTo("down"); break;
                        case "ArrowLeft" : this.position.seek(-1);break;
                        case "ArrowUp"   : this.position.seekLineTo("up");break;
                        case "PageUp"    : this.position.seek(this.pageSize(-1));break;
                        case "PageDown"  : this.position.seek(this.pageSize(1));break;
                        case "Space"     :
                        case "Enter"     : this.$select(this.position.offset); break;
                    }
                }
            };

            /**
             * Select the given list item. The method is called when an item
             * selection is triggered by a user interaction: key board, or pointer
             * @param  {Integer} o an item index
             * @method $select
             * @protected
             */
            this.$select = function(o) {
                this.select(o);
            };

            /**
             * Define key typed events handler
             * @param  {zebkit.ui.KeyEvent} e a key event
             * @method keyTyped
             */
            this.keyTyped = function (e){
                var i = this.lookupItem(e.key);
                if (i >= 0) this.$select(i);
            };

            this.elementInserted = function(target, e,index){
                this.invalidate();
                if (this.selectedIndex >= 0 && this.selectedIndex >= index) {
                    this.selectedIndex++;
                }
                this.position.inserted(index, 1);
                this.repaint();
            };

            this.elementRemoved = function(target, e,index){
                this.invalidate();
                if (this.selectedIndex === index || this.model.count() === 0) {
                    this.select(-1);
                } else {
                    if (this.selectedIndex > index) {
                        this.selectedIndex--;
                    }
                }
                this.position.removed(index, 1);
                this.repaint();
            };

            this.elementSet = function (target, e, pe,index){
                if (this.selectedIndex === index) {
                    this.select(-1);
                }
                this.vrp();
            };

            /**
             * Find a next selectable list item starting from the given offset
             * with the specified direction
             * @param  {Integer} off a start item index to perform search
             * @param  {Integer} d   a direction increment. Cam be -1 or 1
             * @return {Integer} a next selectable item index
             * @method findSelectable
             * @protected
             */
            this.findSelectable = function(off, d) {
                var c = this.model.count(), i = 0, dd = Math.abs(d);
                while (this.isItemSelectable(off) === false && i < c) {
                    off = (c + off + d) % c;
                    i += dd;
                }
                return i < c ? off : -1;
            };

            this.posChanged = function (target,prevOffset,prevLine,prevCol){
                var off = this.position.offset;
                if (off >= 0) {
                    off = this.findSelectable(off, prevOffset < off ? 1 : -1);

                    if (off !== this.position.offset) {
                        this.position.setOffset(off);
                        this.repaintByOffsets(prevOffset, off);
                        return;
                    }
                }

                if (this.isComboMode === true) {
                    this.notifyScrollMan(off);
                } else {
                    this.select(off);
                }

                // this.notifyScrollMan(off);
                this.repaintByOffsets(prevOffset, off);
            };


            /**
             * Set the list model to be rendered with the list component
             * @param {zebkit.data.ListModel} m a list model
             * @method setModel
             * @chainable
             */
            this.setModel = function (m){
                if (m !== this.model){
                    if (m !== null && Array.isArray(m)) {
                        m = new zebkit.data.ListModel(m);
                    }

                    if (this.model !== null && typeof this.model._ !== 'undefined') {
                        this.model.off(this);
                    }

                    this.model = m;

                    if (this.model !== null && typeof this.model._ !== 'undefined') {
                        this.model.on(this);
                    }

                    this.vrp();
                }
                return this;
            };

            /**
             * Set the given position controller. List component uses position to
             * track virtual cursor.
             * @param {zebkit.util.Position} c a position
             * @method setPosition
             * @chainable
             */
            this.setPosition = function(c) {
                if (c !== this.position) {
                    if (this.position !== null) {
                        this.position.off(this);
                    }
                    this.position = c;
                    this.position.on(this);
                    this.position.setMetric(this);
                    this.repaint();
                }

                return this;
            };

            /**
             * Set the list items view provider. Defining a view provider allows developers
             * to customize list item rendering.
             * @param {Object|Function} v a view provider class instance or a function that
             * says which view has to be used for the given list model data. The function
             * has to satisfy the following method signature: "function(list, modelItem, index)"
             * @method setViewProvider
             * @chainable
             */
            this.setViewProvider = function (v){
                if (this.provider !== v){
                    if (typeof v === "function") {
                        var o = new zebkit.Dummy();
                        o.getView = v;
                        v = o;
                    }

                    this.provider = v;
                    this.vrp();
                }
                return this;
            };

            this.notifyScrollMan = function (index){
                if (index >= 0 && this.scrollManager !== null) {
                    this.validate();
                    var is = this.getItemSize(index);

                    if (is.width > 0 && is.height > 0) {
                        var l = this.getItemLocation(index);
                        this.scrollManager.makeVisible(l.x - this.scrollManager.getSX(),
                                                       l.y - this.scrollManager.getSY(),
                                                       is.width, is.height);
                    }
                }
            };

            /**
             * The method returns the page size that has to be scroll up or down
             * @param  {Integer} d a scrolling direction. -1 means scroll up, 1 means scroll down
             * @return {Integer} a number of list items to be scrolled
             * @method pageSize
             * @protected
             */
            this.pageSize = function(d){
                var offset = this.position.offset;
                if (offset >= 0) {
                    var vp = pkg.$cvp(this, {});
                    if (vp !== null) {
                        var sum = 0, i = offset;
                        for(;i >= 0 && i <= this.position.metrics.getMaxOffset() && sum < vp.height; i += d){
                            sum += (this.getItemSize(i).height);
                        }
                        return i - offset - d;
                    }
                }
                return 0;
            };
        },

        /**
         * Sets the views for the list visual elements. The following elements are
         * supported:
         *
         *   - "select" -  a selection view element
         *   - "top.marker" - a position marker view element that is rendered  on top of list item
         *   - "marker" - a position marker view element
         *
         * @param {Object} views view elements
         * @method setViews
         */
        function focused(){
            this.$super();
            this.repaint();
        }
    ]);

    /**
     * The class is list component implementation that visualizes zebkit.data.ListModel.
     * It is supposed the model can have any type of items. Visualization of the items
     * is customized by defining a view provider.
     *
     * The general use case:

            // create list component that contains three item
            var list = new zebkit.ui.List([
                "Item 1",
                "Item 2",
                "Item 3"
            ]);

            ...
            // add new item
            list.model.add("Item 4");

            ...
            // remove first item
            list.model.removeAt(0);


     * To customize list items views you can redefine item view provider as following:

            // suppose every model item is an array that contains two elements,
            // first element points to the item icon and the second element defines
            // the list item text
            var list = new zebkit.ui.List([
                [ "icon1.gif", "Caption 1" ],
                [ "icon2.gif", "Caption 1" ],
                [ "icon3.gif", "Caption 1" ]
            ]);

            // define new list item views provider that represents every
            // list model item as icon with a caption
            list.setViewProvider(new zebkit.ui.List.ViewProvider([
                function getView(target, value, i) {
                    var caption = value[1];
                    var icon    = value[0];
                    return new zebkit.ui.CompRender(new zebkit.ui.ImageLabel(caption, icon));
                }
            ]));

     * @class  zebkit.ui.List
     * @extends zebkit.ui.BaseList
     * @constructor
     * @param {zebkit.data.ListModel|Array} [model] a list model that should be passed as an instance
     * of zebkit.data.ListModel or as an array.
     * @param {Boolean} [isComboMode] true if the list navigation has to be triggered by
     * pointer cursor moving
     */
    pkg.List = Class(pkg.BaseList, [
        function (m, b){
            /**
             * Index of the first visible list item
             * @readOnly
             * @attribute firstVisible
             * @type {Integer}
             * @private
             */
            this.firstVisible = -1;

            /**
             * Y coordinate of the first visible list item
             * @readOnly
             * @attribute firstVisibleY
             * @type {Integer}
             * @private
             */
            this.firstVisibleY = this.psWidth_ = this.psHeight_ = 0;

            /**
             * Internal flag to track list items visibility status. It is set
             * to false to trigger list items metrics and visibility recalculation
             * @attribute visValid
             * @type {Boolean}
             * @private
             */
            this.visValid = false;
            this.setViewProvider(new this.clazz.ViewProvider());
            this.$supera(arguments);
        },

        function $clazz() {
            /**
             * List view provider class. This implementation renders list item using string
             * render. If a list item is an instance of "zebkit.ui.View" class than it will
             * be rendered as the view.
             * @class zebkit.ui.List.ViewProvider
             * @constructor
             * @param {String|zebkit.ui.Font} [f] a font to render list item text
             * @param {String} [c] a color to render list item text
             */
            this.ViewProvider = Class([
                function(f, c) {
                    /**
                     * Reference to text render that is used to paint a list items
                     * @type {zebkit.ui.StringRender}
                     * @attribute text
                     * @readOnly
                     */

                    this.render = new pkg.StringRender("");
                    zebkit.properties(this, this.clazz);
                    if (arguments.length > 0) this.render.setFont(f);
                    if (arguments.length > 1) this.render.setColor(c);
                },

                function $prototype() {
                    this.setColor = function(c) {
                        this.render.setColor(c);
                        return this;
                    };

                    this.setFont = function(f) {
                        this.render.setFont(f);
                        return this;
                    };

                    /**
                     * Get a view for the given model data element of the
                     * specified list component
                     * @param  {zebkit.ui.List} target a list component
                     * @param  {Object} value  a data model value
                     * @param  {Integer} i  an item index
                     * @return {zebkit.ui.View}  a view to be used to render
                     * the given list component item
                     * @method getView
                     */
                    this.getView = function(target, value, i) {
                        // TODO: this copy paste from grid caption render. Think it is possible to generalize it
                        // alone with setFont and setColor methods
                        if (value !== null) {
                            if (typeof value.toView !== 'undefined') return value.toView();
                            if (typeof value.paint  !== 'undefined') return value;
                            this.render.setValue(value.toString());
                            return this.render;
                        } else {
                            return null;
                        }
                    };
                }
            ]);

            /**
             * @for zebkit.ui.List
             */
        },

        function $prototype() {
            this.heights = this.widths = this.vArea = null;

            /**
             * Extra list item side gaps
             * @type {Integer}
             * @attribute gap
             * @default 2
             * @readOnly
             */
            this.gap = 2;

            /**
             * Set the left, right, top and bottom a list item paddings
             * @param {Integer} g a left, right, top and bottom a list item paddings
             * @method setItemGap
             * @chainable
             */
            this.setItemGap = function(g){
                if (this.gap !== g){
                    this.gap = g;
                    this.vrp();
                }
                return this;
            };

            this.paint = function(g){
                this.vVisibility();
                if (this.firstVisible >= 0){
                    var sx = this.scrollManager.getSX(),
                        sy = this.scrollManager.getSY();

                    try {
                        g.translate(sx, sy);
                        var y        = this.firstVisibleY,
                            x        = this.getLeft(),
                            yy       = this.vArea.y + this.vArea.height - sy,
                            count    = this.model.count(),
                            dg       = this.gap * 2;

                        for (var i = this.firstVisible; i < count; i++){
                            if (i !== this.selectedIndex && typeof this.provider.getCellColor === 'function') {
                                var bc = this.provider.getCellColor(this, i);
                                if (bc !== null) {
                                    g.setColor(bc);
                                    g.fillRect(x, y, this.width, this.heights[i]);
                                }
                            }

                            this.provider.getView(this, this.model.get(i), i)
                                         .paint(g, x + this.gap, y + this.gap,
                                                   this.widths[i] - dg,
                                                   this.heights[i]- dg, this);

                            y += this.heights[i];
                            if (y > yy) break;
                        }

                        g.translate(-sx,  -sy);
                    } catch(e) {
                        g.translate(-sx,  -sy);
                        throw e;
                    }
                }
            };

            this.recalc = function(){
                this.psWidth_ = this.psHeight_ = 0;
                if (this.model !== null) {
                    var count = this.model.count();
                    if (this.heights === null || this.heights.length !== count) {
                        this.heights = Array(count);
                    }

                    if (this.widths  === null || this.widths.length  !== count) {
                        this.widths = Array(count);
                    }

                    var provider = this.provider;
                    if (provider !== null) {
                        var dg = 2*this.gap;
                        for(var i = 0;i < count; i++){
                            var ps = provider.getView(this, this.model.get(i), i).getPreferredSize();
                            this.heights[i] = ps.height + dg;
                            this.widths [i] = ps.width  + dg;

                            if (this.widths[i] > this.psWidth_) {
                                this.psWidth_ = this.widths[i];
                            }
                            this.psHeight_ += this.heights[i];
                        }
                    }
                }
            };

            this.calcPreferredSize = function(l){
                return { width : this.psWidth_,
                         height: this.psHeight_ };
            };

            this.vVisibility = function(){
                this.validate();
                var prev = this.vArea;
                this.vArea = pkg.$cvp(this, {});

                if (this.vArea === null) {
                    this.firstVisible = -1;
                } else  {
                    if (this.visValid === false ||
                        (prev === null || prev.x !== this.vArea.x ||
                         prev.y !== this.vArea.y || prev.width !== this.vArea.width ||
                         prev.height !== this.vArea.height))
                    {
                        var top = this.getTop();
                        if (this.firstVisible >= 0){
                            var dy = this.scrollManager.getSY();
                            while (this.firstVisibleY + dy >= top && this.firstVisible > 0){
                                this.firstVisible--;
                                this.firstVisibleY -= this.heights[this.firstVisible];
                            }
                        } else {
                            this.firstVisible  = 0;
                            this.firstVisibleY = top;
                        }

                        if (this.firstVisible >= 0) {
                            var count = this.model === null ? 0 : this.model.count(),
                                hh    = this.height - this.getBottom();

                            for(; this.firstVisible < count; this.firstVisible++) {
                                var y1 = this.firstVisibleY + this.scrollManager.getSY(),
                                    y2 = y1 + this.heights[this.firstVisible] - 1;

                                if ((y1 >= top && y1 < hh) || (y2 >= top && y2 < hh) || (y1 < top && y2 >= hh)) {
                                    break;
                                }

                                this.firstVisibleY += (this.heights[this.firstVisible]);
                            }

                            if (this.firstVisible >= count) this.firstVisible =  -1;
                        }
                        this.visValid = true;
                    }
                }
            };

            this.getItemLocation = function(index){
                this.validate();
                var y = this.getTop() + this.scrollManager.getSY();
                for(var i = 0; i < index; i++) {
                    y += this.heights[i];
                }
                return { x:this.getLeft(), y : y };
            };

            this.getItemSize = function(i){
                this.validate();
                return { width:this.widths[i], height:this.heights[i] };
            };

            this.getItemIdxAt = function(x,y){
                this.vVisibility();
                if (this.vArea !== null && this.firstVisible >= 0) {
                    var yy    = this.firstVisibleY + this.scrollManager.getSY(),
                        hh    = this.height - this.getBottom(),
                        count = this.model.count();

                    for (var i = this.firstVisible; i < count; i++) {
                        if (y >= yy && y < yy + this.heights[i]) {
                            return i;
                        }
                        yy += (this.heights[i]);
                        if (yy > hh) break;
                    }
                }
                return  -1;
            };
        },

        function invalidate(){
            this.visValid = false;
            this.firstVisible = -1;
            this.$super();
        },

        function drawView(g,id,v,x,y,w,h) {
            this.$super(g, id, v, x, y, this.width - this.getRight() - x, h);
        },

        function catchScrolled(psx,psy){
            this.firstVisible = -1;
            this.visValid = false;
            this.$super(psx, psy);
        }
    ]);

    /**
     * List component consider its children UI components as a list model items. Every added to the component
     * UI children component becomes a list model element. The implementation allows developers to use
     * other UI components as its elements what makes list item view customization very easy and powerful:

            // use image label as the component list items
            var list = new zebkit.ui.CompList();
            list.add(new zebkit.ui.ImageLabel("Caption 1", "icon1.gif"));
            list.add(new zebkit.ui.ImageLabel("Caption 2", "icon2.gif"));
            list.add(new zebkit.ui.ImageLabel("Caption 3", "icon3.gif"));


     * @class zebkit.ui.CompList
     * @constructor
     * @extends zebkit.ui.BaseList
     * @param {zebkit.data.ListModel|Array} [model] a list model that should be passed as an instance
     * of zebkit.data.ListModel or as an array.
     * @param {Boolean} [isComboMode] true if the list navigation has to be triggered by
     * pointer cursor moving
     */
    pkg.CompList = Class(pkg.BaseList, [
        function (m, b) {
            this.model = this;

            this.setViewProvider(new zebkit.Dummy([
                function $prototype() {
                    this.render = new pkg.CompRender();
                    this.getView = function (target,obj,i) {
                        this.render.setTarget(obj);
                        return this.render;
                    };
                }
            ]));

            this.$supera(arguments);
        },

        function $clazz() {
            this.Label      = Class(pkg.Label, []);
            this.ImageLabel = Class(pkg.ImageLabel, []);
            this.Listeners  = this.$parent.Listeners.ListenersClass("elementInserted", "elementRemoved", "elementSet");
        },

        function $prototype() {
            this.max = null;

            this.get = function(i) {
                if (i < 0 || i >= this.kids.length) {
                    throw new RangeError(i);
                }
                return this.kids[i];
            };

            this.contains = function (c) {
                return this.indexOf(c) >= 0;
            };

            this.count = function () {
                return this.kids.length;
            };

            this.catchScrolled = function(px, py) {};

            this.getItemLocation = function(i) {
                return { x:this.kids[i].x, y:this.kids[i].y };
            };

            this.getItemSize = function(i) {
                return this.kids[i].isVisible === false ? { width:0, height: 0 }
                                                        : { width:this.kids[i].width, height:this.kids[i].height};
            };

            this.recalc = function (){
                this.max = zebkit.layout.getMaxPreferredSize(this);
            };

            this.calcMaxItemSize = function() {
                this.validate();
                return { width:this.max.width, height:this.max.height };
            };

            this.getItemIdxAt = function(x, y) {
                return zebkit.layout.getDirectAt(x, y, this);
            };

            this.isItemSelectable = function(i) {
                return this.model.get(i).isVisible === true &&
                       this.model.get(i).isEnabled === true;
            };

            this.catchInput = function (child){
                if (this.isComboMode !== true) {
                    var p = child;
                    while (p !== this) {
                        if (p.stopCatchInput === true) return false;
                        p = p.parent;
                    }
                }
                return true;
            };

            this.setModel = function(m){
                if (Array.isArray(m)) {
                    for(var i = 0; i < m.length; i++) {
                        this.add(m[i]);
                    }
                } else {
                    throw new Error("Invalid comp list model");
                }

                return this;
            };
        },

        function setPosition(c){
            if (c !== this.position){
                if (zebkit.instanceOf(this.layout, zebkit.util.Position.Metric)) {
                    c.setMetric(this.layout);
                }
                this.$super(c);
            }
            return this;
        },

        function setLayout(layout){
            if (layout !== this.layout){
                this.scrollManager = new pkg.ScrollManager(this, [
                    function $prototype() {
                        this.calcPreferredSize = function(t) {
                            return layout.calcPreferredSize(t);
                        };

                        this.doLayout = function(t){
                            layout.doLayout(t);
                            for(var i = 0; i < t.kids.length; i++){
                                var kid = t.kids[i];
                                if (kid.isVisible === true) {
                                    kid.setLocation(kid.x + this.getSX(),
                                                    kid.y + this.getSY());
                                }
                            }
                        };

                        this.scrollStateUpdated = function(sx,sy,px,py){
                            this.target.vrp();
                        };
                    }
                ]);

                this.$super(this.scrollManager);
                if (this.position !== null) {
                    this.position.setMetric(zebkit.instanceOf(layout, zebkit.util.Position.Metric) ? layout : this);
                }
            }

            return this;
        },

        function setAt(i, item) {
            if (i < 0 || i >= this.kids.length) {
                throw new RangeError(i);
            }
            return this.$super(i, item);
        },

        function insert(i, constr, e) {
            if (arguments.length === 2) {
                e = constr;
                constr = null;
            }

            if (i < 0 || i > this.kids.length) {
                throw new RangeError(i);
            }
            return this.$super(i, constr, zebkit.instanceOf(e, pkg.Panel) ? e : new this.clazz.Label("" + e));
        },

        function kidAdded(index,constr,e){
            this.$super(index,constr,e);
            this.model._.elementInserted(this, e, index);
        },

        function kidRemoved(index,e) {
            this.$super(index,e);
            this.model._.elementRemoved(this, e, index);
        }
    ]);


    /**
     * Combo box UI component class. Combo uses a list component to show in drop down window.
     * You can use any available list component implementation:

            // use simple list as combo box drop down window
            var combo = new zebkit.ui.Combo(new zebkit.ui.List([
                "Item 1",
                "Item 2",
                "Item 3"
            ]));


            // use component list as combo box drop down window
            var combo = new zebkit.ui.Combo(new zebkit.ui.CompList([
                "Item 1",
                "Item 2",
                "Item 3"
            ]));


            // let combo box decides which list component has to be used
            var combo = new zebkit.ui.Combo([
                "Item 1",
                "Item 2",
                "Item 3"
            ]);

     * @class zebkit.ui.Combo
     * @extends {zebkit.ui.Panel}
     * @constructor
     * @param {Array|zebkit.ui.BaseList} data an combo items array or a list component
     */

    /**
     * Fired when a new value in a combo box component has been selected

         combo.on("selected", function(combo, value) {
             ...
         });

     * @event selected
     * @param {zebkit.ui.Combo} combo a combo box component where a new value
     * has been selected
     * @param {Object} value a previously selected index
     */

    /**
     * Implement the event handler method to detect when a combo pad window
     * is shown or hidden

         var p = new zebkit.ui.Combo();
         p.padShown = function(src, b) { ... }; // add event handler

     * @event padShown
     * @param {zebkit.ui.Combo} src a combo box component that triggers the event
     * @param {Boolean} b a flag that indicates if the combo pad window has been
     * shown (true) or hidden (false)
    */
    pkg.Combo = Class(pkg.Panel, [
        function(list, editable) {
            if (arguments.length === 1 && zebkit.isBoolean(list)) {
                editable = list;
                list = null;
            }

            if (arguments.length === 0) {
                editable = false;
            }

            if (arguments.length === 0 || list === null) {
                list = new this.clazz.List(true);
            }

            /**
             * Reference to combo box list component
             * @attribute list
             * @readOnly
             * @type {zebkit.ui.BaseList}
             */
            if (zebkit.instanceOf(list, pkg.BaseList) === false) {
                list = list.length > 0 && zebkit.instanceOf(list[0], pkg.Panel) ? new this.clazz.CompList(list, true)
                                                                                : new this.clazz.List(list, true);
            }

            /**
             * Maximal size the combo box height can have
             * @attribute maxPadHeight
             * @readOnly
             * @type {Integer}
             */
            this.maxPadHeight = 0;

            this.$lockListSelEvent = false;
            this._ = new this.clazz.Listeners();
            this.setList(list);

            this.$super();

            this.add("center", editable ? new this.clazz.EditableContentPan()
                                        : new this.clazz.ReadonlyContentPan());
            this.add("right", new this.clazz.Button());
        },


        function $clazz() {
            this.Listeners = zebkit.util.ListenersClass("selected");

            /**
             * UI panel class that is used to implement combo box content area
             * @class  zebkit.ui.Combo.ContentPan
             * @extends {zebkit.ui.Panel}
             * @constructor
             */
            this.ContentPan = Class(pkg.Panel, [
                function $prototype() {
                    /**
                     * Called whenever the given combo box value has been updated with the specified
                     * value. Implement the method to synchronize content panel with updated combo
                     * box value
                     * @method comboValueUpdated
                     * @param {zebkit.ui.Combo} combo a combo box component that has been updated
                     * @param {Object} value a value with which the combo box has been updated
                     */
                    this.comboValueUpdated = function(combo, value) {};

                    /**
                     * Indicates if the content panel is editable. Set the property to true
                     * to indicate the content panel implementation is editable. Editable
                     * means the combo box content can be editable by a user
                     * @attribute isEditable
                     * @type {Boolean}
                     * @readOnly
                     * @default undefined
                     */

                    /**
                     * Get a combo box the content panel belongs
                     * @method getCombo
                     * @return {zebkit.ui.Combo} a combo the content panel belongs
                     */
                    this.getCombo = function() {
                        for (var p = this.parent; p !== null && zebkit.instanceOf(p, pkg.Combo) === false; p = p.parent);
                        return p;
                    };
                }
            ]);

            /**
             * Combo box list pad component class
             * @extends zebkit.ui.ScrollPan
             * @class  zebkit.ui.Combo.ComboPadPan
             * @constructor
             * @param {zebkit.ui.Panel} c a target component
             */
            this.ComboPadPan = Class(pkg.ScrollPan, [
                function $prototype() {
                    this.$closeTime = 0;

                    this.adjustToComboSize = true;

                    this.owner = null;

                    /**
                     * A reference to combo that uses the list pad component
                     * @attribute owner
                     * @type {zebkit.ui.Combo}
                     * @readOnly
                     */
                    this.childKeyPressed = function(e){
                        if (e.code === "Escape" && this.parent !== null) {
                            this.removeMe();
                            if (this.owner !== null) this.owner.requestFocus();
                        }
                    };
                },

                function setParent(l) {
                    this.$super(l);
                    if (l === null && this.owner !== null) {
                        this.owner.requestFocus();
                    }

                    this.$closeTime = l === null ? new Date().getTime() : 0;
                }
            ]);

            /**
             * Read-only content area combo box component panel class
             * @extends zebkit.ui.Combo.ContentPan
             * @constructor
             * @class  zebkit.ui.Combo.ReadonlyContentPan
             */
            this.ReadonlyContentPan = Class(this.ContentPan, [
                function $prototype() {
                    this.calcPsByContent = false;

                    this.getCurrentView = function() {
                        var list = this.getCombo().list,
                            selected = list.getSelected();

                        return selected !== null ? list.provider.getView(list, selected, list.selectedIndex)
                                                 : null;
                    };

                    this.paintOnTop = function(g){
                        var v = this.getCurrentView();
                        if (v !== null) {
                            var ps = v.getPreferredSize();
                            v.paint(g, this.getLeft(),
                                       this.getTop() + Math.floor((this.height - this.getTop() - this.getBottom() - ps.height) / 2),
                                       this.width, ps.height, this);
                        }
                    };

                    this.setCalcPsByContent = function(b) {
                        if (this.calcPsByContent !== b) {
                            this.calcPsByContent = b;
                            this.vrp();
                        }
                        return this;
                    };

                    this.calcPreferredSize = function(l) {
                        var p = this.getCombo();
                        if (p !== null && this.calcPsByContent !== true) {
                            return p.list.calcMaxItemSize();
                        }
                        var cv = this.getCurrentView();
                        return cv === null ? { width: 0, height: 0} : cv.getPreferredSize();
                    };

                    this.comboValueUpdated = function(combo, value) {
                        if (this.calcPsByContent === true) this.invalidate();
                    };
                }
            ]);

            /**
             * Editable content area combo box component panel class
             * @class zebkit.ui.Combo.EditableContentPan
             * @constructor
             * @extends zebkit.ui.Combo.ContentPan
             */

            /**
             * Fired when a content value has been updated.

            content.on(function(contentPan, newValue) {
                ...
            });

             * @param {zebkit.ui.Combo.ContentPan} contentPan a content panel that
             * updated its value
             * @param {Object} newValue a new value the content panel has been set
             * with
             * @event  contentUpdated
             */
            this.EditableContentPan = Class(this.ContentPan, [
                function $clazz() {
                    this.TextField = Class(pkg.TextField, []);
                    this.Listeners = zebkit.util.ListenersClass("contentUpdated");
                },

                function $prototype() {
                    this.canHaveFocus = true;

                    this.textUpdated = function(src,b,off,size,startLine,lines){
                        if (this.dontGenerateUpdateEvent === false) {
                            this._.contentUpdated(this, this.textField.getValue());
                        }
                    };

                    /**
                     * Called when the combo box content has been updated
                     * @param {zebkit.ui.Combo} combo a combo where the new value has been set
                     * @param {Object} v a new combo box value
                     * @method comboValueUpdated
                     */
                    this.comboValueUpdated = function(combo, v){
                        this.dontGenerateUpdateEvent = true;
                        try {
                            var txt = (v === null ? "" : v.toString());
                            this.textField.setValue(txt);
                            this.textField.select(0, txt.length);
                        } finally {
                            this.dontGenerateUpdateEvent = false;
                        }
                    };
                },

                function focused(){
                    this.$super();
                    this.textField.requestFocus();
                },

                function() {
                    this.$super();
                    this._ = new this.clazz.Listeners();

                    this.isEditable = true;

                    this.dontGenerateUpdateEvent = false;

                    /**
                     * A reference to a text field component the content panel uses as a
                     * value editor
                     * @attribute textField
                     * @readOnly
                     * @private
                     * @type {zebkit.ui.TextField}
                     */
                    this.textField = new this.clazz.TextField("",  -1);
                    this.textField.view.target.on(this);
                    this.add("center", this.textField);
                }
            ]);

            this.Button = Class(pkg.Button, [
                function() {
                    this.setFireParams(true,  -1);
                    this.$super();
                }
            ]);

            this.List = Class(pkg.List, []);
            this.CompList = Class(pkg.CompList, []);
        },

        /**
         * @for zebkit.ui.Combo
         */
        function $prototype() {
            this.list = null;

            /**
             * Reference to combo box button component
             * @attribute button
             * @readOnly
             * @type {zebkit.ui.Panel}
             */

            /**
             * Reference to combo box content component
             * @attribute content
             * @readOnly
             * @type {zebkit.ui.Panel}
             */

            /**
             * Reference to combo box pad component
             * @attribute winpad
             * @readOnly
             * @type {zebkit.ui.Panel}
             */

            /**
             * Reference to selection view
             * @attribute selectionView
             * @readOnly
             * @type {zebkit.ui.View}
             */

            this.selectionView = this.button = this.content = this.winpad = null;


            this.paint = function(g){
                if (this.content       !== null &&
                    this.selectionView !== null &&
                    this.hasFocus())
                {
                    this.selectionView.paint(g, this.content.x,
                                                this.content.y,
                                                this.content.width,
                                                this.content.height,
                                                this);
                }
            };

            this.catchInput = function (child) {
                return child !== this.button && (this.content === null || this.content.isEditable !== true);
            };

            this.canHaveFocus = function() {
                return this.winpad.parent === null && (this.content !== null && this.content.isEditable !== true);
            };

            this.contentUpdated = function(src, text){
                if (src === this.content) {
                    try {
                        this.$lockListSelEvent = true;
                        if (text === null) {
                            this.list.select(-1);
                        } else {
                            var m = this.list.model;
                            for(var i = 0;i < m.count(); i++){
                                var mv = m.get(i);
                                if (mv !== text) {
                                    this.list.select(i);
                                    break;
                                }
                            }
                        }
                    } finally {
                        this.$lockListSelEvent = false;
                    }
                    this._.selected(this, text);
                }
            };

            /**
             * Select the given value from the list as the combo box value
             * @param  {Integer} i an index of a list element to be selected
             * as the combo box value
             * @method select
             * @chainable
             */
            this.select = function(i) {
                this.list.select(i);
                return this;
            };

            // This method has been added to support selectedIndex property setter
            this.setSelectedIndex = function(i) {
                this.select(i);
                return this;
            };

            /**
             * Set combo box value selected value.
             * @param {Object} v a value
             * @method  setValue
             */
            this.setValue = function(v) {
                return this.list.setValue(v);
            };

            /**
             * Get the current combo box selected value
             * @return {Object} a value
             * @method getValue
             */
            this.getValue = function() {
                return this.list.getValue();
            };

            /**
             * Define pointer pressed events handler
             * @param  {zebkit.ui.PointerEvent} e a pointer event
             * @method pointerPressed
             */
            this.pointerPressed = function (e) {
                if (e.isAction() && this.content !== null                 &&
                    (new Date().getTime() - this.winpad.$closeTime) > 100 &&
                    e.x > this.content.x && e.y > this.content.y          &&
                    e.x < this.content.x + this.content.width             &&
                    e.y < this.content.y + this.content.height              )
                {
                    this.showPad();
                }
            };

            /**
             * Test if the combo window pad is shown
             * @return {Boolean} true if the combo window pad is shown
             * @method isPadShown
             */
            this.isPadShown = function() {
                return this.winpad !== null && this.winpad.parent !== null && this.winpad.isVisible === true;
            };

            /**
             * Hide combo drop down list
             * @method hidePad
             * @chainable
             */
            this.hidePad = function() {
                var d = this.getCanvas();
                if (d !== null && this.winpad.parent !== null) {
                    this.winpad.removeMe();
                    this.requestFocus();
                }
                return this;
            };

            /**
             * Show combo drop down list
             * @method showPad
             * @chainable
             */
            this.showPad = function(){
                var canvas = this.getCanvas();
                if (canvas !== null) {
                    var ps  = this.winpad.getPreferredSize(),
                        p   = zebkit.layout.toParentOrigin(0, 0, this.winpad.adjustTo == null ? this : this.winpad.adjustTo),
                        py  = p.y;

                    // if (this.winpad.hbar && ps.width > this.width) {
                    //     ps.height += this.winpad.hbar.getPreferredSize().height;
                    // }

                    if (this.maxPadHeight > 0 && ps.height > this.maxPadHeight) {
                        ps.height = this.maxPadHeight;
                    }

                    if (py + this.height + ps.height > canvas.height) {
                        if (py - ps.height >= 0) {
                            py -= (ps.height + this.height);
                        } else {
                            var hAbove = canvas.height - py - this.height;
                            if (py > hAbove) {
                                ps.height = py;
                                py -= (ps.height + this.height);
                            } else {
                                ps.height = hAbove;
                            }
                        }
                    }

                    this.winpad.setBounds(p.x,
                                          py + (this.winpad.adjustTo == null ? this.height
                                                                             : this.winpad.adjustTo.height),
                                          this.winpad.adjustTo == null ? (this.winpad.adjustToComboSize === true ? this.width
                                                                                                                 : ps.width)
                                                                       : this.winpad.adjustTo.width,
                                          ps.height);

                    this.list.notifyScrollMan(this.list.selectedIndex);
                    canvas.getLayer(pkg.PopupLayerMix.id).add(this, this.winpad);
                    this.list.requestFocus();
                    if (typeof this.padShown !== 'undefined') {
                        this.padShown(true);
                    }

                    return this;
                }
            };

            /**
             * Bind the given list component to the combo box component.
             * @param {zebkit.ui.BaseList} l a list component
             * @method setList
             * @chainable
             */
            this.setList = function(l){
                if (this.list !== l) {
                    this.hidePad();

                    if (this.list !== null) this.list.off(this);
                    this.list = l;
                    if (typeof this.list._ !== 'undefined') this.list.on(this);

                    var $this = this;
                    this.winpad = new this.clazz.ComboPadPan(this.list, [
                        function setParent(p) {
                            this.$super(p);
                            if (typeof $this.padShown !== 'undefined') {
                                $this.padShown($this, p !== null);
                            }
                        }
                    ]);

                    this.winpad.owner = this;
                    if (this.content !== null) {
                        this.content.comboValueUpdated(this, this.list.getSelected());
                    }
                    this.vrp();
                }
                return this;
            };

            /**
             * Define key pressed events handler
             * @param  {zebkit.ui.KeyEvent} e a key event
             * @method keyPressed
             */
            this.keyPressed = function (e) {
                if (this.list !== null && this.list.model !== null) {
                    var index = this.list.selectedIndex;
                    switch(e.code) {
                        case "Enter"     : this.showPad(); break;
                        case "ArrowLeft" :
                        case "ArrowUp"   : if (index > 0) this.list.select(index - 1); break;
                        case "ArrowDown" :
                        case "ArrowRight": if (this.list.model.count() - 1 > index) this.list.select(index + 1); break;
                    }
                }
            };

            /**
             * Define key typed  events handler
             * @param  {zebkit.ui.KeyEvent} e a key event
             * @method keyTyped
             */
            this.keyTyped = function(e) {
                this.list.keyTyped(e);
            };

            /**
             * Set the given combo box selection view
             * @param {zebkit.ui.View} c a view
             * @method setSelectionView
             * @chainable
             */
            this.setSelectionView = function (c){
                if (c !== this.selectionView) {
                    this.selectionView = pkg.$view(c);
                    this.repaint();
                }
                return this;
            };

            /**
             * Set the maximal height of the combo box pad element.
             * @param {Integer} h a maximal combo box pad size
             * @method setMaxPadHeight
             * @chainable
             */
            this.setMaxPadHeight = function(h){
                if (this.maxPadHeight !== h) {
                    this.hidePad();
                    this.maxPadHeight = h;
                }
                return this;
            };

            /**
             * Make the commbo editable
             * @param {Boolean} b  true to make the combo ediatable
             * @chainable
             * @method setEditable
             */
            this.setEditable = function(b) {
                if (this.content === null || this.content.isEditable !== b) {
                    var ctr = "center";
                    if (this.content !== null) {
                        ctr = this.content.constraints;
                        this.content.removeMe();
                    }
                    this.add(ctr, b ? new this.clazz.EditableContentPan()
                                    : new this.clazz.ReadonlyContentPan());
                }
                return this;
            };

            /**
             * Combo box button listener method. The method triggers showing
             * combo box pad window when the combo button has been pressed
             * @param  {zebkit.ui.Button} src a button that has been pressed
             * @method fired
             */
            this.fired = function(src) {
                if ((new Date().getTime() - this.winpad.$closeTime) > 100) {
                    this.showPad();
                }
            };

            /**
             * Combo pad list listener method. Called every time an item in
             * combo pad list has been selected.
             * @param  {zebkit.ui.BaseList} src a list
             * @param  {Integer} data a selected index
             * @method selected
             * @protected
             */
            this.selected = function(src, data) {
                if (this.$lockListSelEvent === false) {
                    this.hidePad();
                    if (this.content !== null) {
                        this.content.comboValueUpdated(this, this.list.getSelected());
                        if (this.content.isEditable === true) {
                            this.content.requestFocus();
                        }
                        this.repaint();
                    }
                    this._.selected(this, data);
                }
            };
        },

        function focused(){
            this.$super();
            this.repaint();
        },

        function kidAdded(index, s, c){
            if (zebkit.instanceOf(c, pkg.Combo.ContentPan)) {
                if (this.content !== null) {
                    throw new Error("Content panel is set");
                }

                this.content = c;

                if (this.list !== null) {
                    c.comboValueUpdated(this, this.list.getSelected());
                }
            } else if (this.button === null) {
                this.button = c;
            }

            if (zebkit.instanceOf(c, zebkit.util.Fireable)) {
                c.on(this);
            }

            this.$super(index, s, c);
        },

        function kidRemoved(index,l) {
            if (zebkit.instanceOf(l, zebkit.util.Fireable)) {
                l.off(this);
            }

            if (this.content === l) {
                this.content = null;
            } else if (this.button === l) {
                this.button = null;
            }

            this.$super(index, l);
        },

        function setVisible(b) {
            if (b === false) {
                this.hidePad();
            }
            this.$super(b);
            return this;
        },

        function setParent(p) {
            if (p === null) this.hidePad();
            this.$super(p);
        }
    ]);


    pkg.events.regEvents("menuItemSelected");

    /**
     * Menu event class
     * @constructor
     * @class zebkit.ui.MenuEvent
     * @extends {zebkit.util.Event}
     */
    pkg.MenuEvent = Class(zebkit.util.Event, [
        function $prototype() {
            /**
             * Index of selected menu item
             * @type {Integer}
             * @attribute index
             * @readOnly
             */
            this.index = -1;

            /**
             * Selected menu item component
             * @type {zebkit.ui.Panel}
             * @attribute item
             * @readOnly
             */
            this.item = null;

            /**
             * Fill menu event with specified parameters
             * @param  {zebkit.ui.Menu} src a source of the menu event
             * @param  {Integer} index an index of selected menu item
             * @param  {zebkit.ui.Panel} item a selected menu item
             * @protected
             * @chainable
             * @method $fillWith
             */
            this.$fillWith = function(src, index, item) {
                this.source = src;
                this.index  = index;
                this.item   = item;
                return this;
            };
        }
    ]);

    var MENU_EVENT = new pkg.MenuEvent();

    /**
     * Show the given popup menu.
     * @param  {zebkit.ui.Panel} context  an UI component of zebkit hierarchy
     * @param  {zebkit.ui.Menu}  menu a menu to be shown
     * @for  zebkit.ui
     * @method showPopupMenu
     */
    pkg.showPopupMenu = function(context, menu) {
        context.getCanvas().getLayer(pkg.PopupLayerMix.id).add(menu);
    };

    /**
     * Menu item panel class. The component holds menu item content like caption, icon, sub-menu
     * sign elements. The area of the component is split into three parts: left, right and center.
     * Central part keeps content, left side keeps checked sign element and the right side keeps
     * sub-menu sign element.
     * @param  {String|zebkit.ui.Panel} caption a menu item caption string or component. Caption
     * string can encode the item id, item icon and item checked state. For instance:
     *
     *   - **"Menu Item [@menu_item_id]"** - triggers creation of menu item component
     *     with "Menu Item" caption and "menu_item_id" id property value
     *   - **"[x] Menu Item"** - triggers creation of checked menu item component
     *     with checked on state
     *   - **"@('mypicture.gif') Menu Item"** - triggers creation of menu item
     *      component with "Menu Item" caption and loaded mypicture.gif icon
     *
     * @example
     *
     *
     *     // create menu item with icon and "Item 1" title
     *     var mi = new zebkit.ui.MenuItem("@('mypicture.gif') Item 1");
     *
     *
     * @class zebkit.ui.MenuItem
     * @extends {zebkit.ui.Panel}
     * @constructor
     */
    pkg.MenuItem = Class(pkg.Panel, [
        function (c) {
            this.$super();
            this.add(new this.clazz.CheckStatePan());

            if (zebkit.isString(c)) {
                var m = c.match(/(\s*\@\(.*\)\s*)?(\s*\[\s*\]|\s*\[\s*x\s*\]|\s*\(\s*x\s*\)|\s*\(\s*\))?\s*(.*)/);
                if (m === null) {
                    throw new Error("Invalid menu item: " + c);
                }

                if (typeof m[2] !== 'undefined') {
                    var s = m[2].trim();
                    this.setCheckManager(s[0] === '(' ? new pkg.Group() : new pkg.SwitchManager());
                    this.manager.setValue(this, m[2].indexOf('x') > 0);
                }

                var img = null;
                if (typeof m[1] !== 'undefined') {
                    img = m[1].substring(m[1].indexOf("@(") + 2, m[1].lastIndexOf(")")).trim();
                    if (img[0] === "'") {
                       img = img.substring(1, img.length-1);
                    } else {
                        var parts = img.split('.'),
                            scope = zebkit.$global;

                        img = null;
                        for (var i = 0; i < parts.length; i++) {
                            scope = scope[parts[i]];
                            if (typeof scope === 'undefined' || scope === null) {
                                break;
                            }
                        }
                        img = scope;
                    }
                }

                c = m[3];
                m = c.match(/(.*)\s*\[\s*@([a-zA-Z_][a-zA-Z0-9_]+)\s*]\s*/);
                if (m !== null) {
                    this.id = m[2].trim();
                    c       = m[1].trim();
                } else {
                    this.id = c.toLowerCase().replace(/[ ]+/, '_');
                }

                c = new pkg.ImageLabel(new this.clazz.Label(c), img);
            } else {
                this.getCheck().setVisible(false);
            }

            this.add(c);
            this.add(new this.clazz.SubImage());

            this.setEnabled(c.isEnabled);
            this.setVisible(c.isVisible);
        },

        function $clazz() {
            this.SubImage      = Class(pkg.StatePan, []);
            this.Label         = Class(pkg.Label,    []);
            this.CheckStatePan = Class(pkg.ViewPan,  []);
        },

        function $prototype() {
            /**
             * Gap between checked, content and sub menu arrow components
             * @attribute gap
             * @type {Integer}
             * @readOnly
             * @default 8
             */
            this.gap = 8;

            /**
             * Switch manager that is set to make the item checkable
             * @type {zebkit.ui.SwitchManager | zebkit.ui.Group}
             * @attribute manager
             * @readOnly
             */
            this.manager = null;

            /**
             * Callback method that is called every time the menu item has
             * been selected.
             * @method  itemSelected
             */
            this.itemSelected = function() {
                var content = this.getContent();
                if (zebkit.instanceOf(content, pkg.Checkbox)) {
                    content.setValue(!content.getValue());
                }

                if (this.manager !== null) {
                    this.manager.setValue(this, !this.manager.getValue(this));
                }
            };

            /**
             * Set the menu item icon.
             * @param {String|Image} img a path to an image or image object
             * @method setIcon
             * @chainable
             */
            this.setIcon = function(img) {
                this.getContent().setImage(img);
                return this;
            };

            /**
             * Set the menu item caption.
             * @param {String} caption a caption
             * @method setCaption
             * @chainable
             */
            this.setCaption = function(caption) {
                this.getContent().setCaption(caption);
                return this;
            };

            /**
             * Callback method that is called every time a checked state
             * of the menu item has been updated
             * @param {Boolean} b a new checked state
             * @method switched
             * @protected
             */
            this.switched = function(b) {
                this.kids[0].view.activate(b ? (this.isEnabled === true ? "on" : "on.disabled") : "off", this);
            };

            /**
             * Get check state component
             * @return {zebkit.ui.Panel} a check state component
             * @method getCheck
             * @protected
             */
            this.getCheck = function() {
                return this.kids[0];
            };

            /**
             * Get content component
             * @return {zebkit.ui.Panel} a content component
             * @method getContent
             * @protected
             */
            this.getContent = function() {
                return this.kids.length > 0 ? this.kids[1] : null;
            };

            /**
             * Get menu item child component to render sub item arrow element
             * @return {zebkit.ui.Panel} a sub item arrow component
             * @method getSub
             * @protected
             */
            this.getSub = function() {
                return this.kids.length > 1 ? this.kids[2] : null;
            };

            /**
             * Hide sub menu arrow component
             * @method hideSub
             */
            this.hideSub = function() {
                this.getSub().setVisible(false);
            };

            this.activateSub = function(b) {
                var kid = this.getSub();
                kid.setState(b ? "arrow" : "*");
                if (this.parent !== null && this.parent.noSubIfEmpty === true) {
                    kid.setVisible(b);
                }
            };

            this.calcPreferredSize = function (target){
                var cc = 0, pw = 0, ph = 0;

                for(var i = 0; i < target.kids.length; i++) {
                    var k = target.kids[i];
                    if (k.isVisible === true) {
                        var ps = k.getPreferredSize();
                        pw += ps.width + (cc > 0 ? this.gap : 0);
                        if (ps.height > ph) ph = ps.height;
                        cc ++;
                    }
                }

                return { width:pw, height:ph };
            };

            this.doLayout = function(target){
                var left    = this.getCheck(),
                    right   = this.getSub(),
                    content = this.getContent(),
                    t       = target.getTop(),
                    l       = target.getLeft(),
                    eh      = target.height - t - target.getBottom(),
                    ew      = target.width  - l - target.getRight();

                if (left !== null && left.isVisible === true) {
                    left.toPreferredSize();
                    left.setLocation(l, t + Math.floor((eh - left.height)/2));
                    l += this.gap + left.width;
                    ew -= (this.gap + left.width);
                }

                if (right !== null && right.isVisible === true) {
                    right.toPreferredSize();
                    right.setLocation(target.width - target.getRight() - right.width,
                                      t + Math.floor((eh - right.height)/2));
                    ew -= (this.gap + right.width);
                }

                if (content !== null && content.isVisible === true) {
                    content.toPreferredSize();
                    if (content.width > ew) {
                        content.setSize(ew, content.height);
                    }
                    content.setLocation(l, t + Math.floor((eh - content.height)/2));
                }
            };

            /**
             * Set the menu item checked state
             * @param {Boolean} b a checked state
             * @method setCheckState
             * @chainable
             */
            this.setCheckState = function(b) {
                if (this.manager === null) {
                    this.setCheckManager(new pkg.SwitchManager());
                }
                this.manager.setValue(this, b);
                return this;
            };

            /**
             * Get menu item checked state
             * @return {Boolean} a menu item checked state
             * @method getCheckState
             */
            this.getCheckState = function() {
                return this.manager.getValue(this);
            };

            /**
             * Set the menu item checked state manager.
             * @param {zebkit.ui.SwitchManager|zebkit.ui.Group} man a switch manager
             * @method setCheckManager
             * @chainable
             */
            this.setCheckManager = function(man) {
                if (this.manager !== man) {
                    if (this.manager !== null) {
                        this.manager.uninstall(this);
                    }
                    this.manager = man;
                    this.manager.install(this);
                }
                return this;
            };
        },

        /**
         * Override setParent method to catch the moment when the
         * item is inserted to a menu
         * @param {zebkit.ui.Panel} p a parent
         * @method setParent
         */
        function setParent(p) {
            this.$super(p);
            if (p !== null && p.noSubIfEmpty === true) {
                this.getSub().setVisible(false);
            }
        },

        function setEnabled(b) {
            this.$super(b);
            // sync menu item enabled state with checkable element state
            if (this.manager !== null) {
                this.switched(this.manager.getValue(this));
            }
            return this;
        }
    ]).hashable();

    /**
     * Menu UI component class. The class implements popup menu UI component.

         var m = new Menu({
            "Menu Item 1" : [
                "[x] SubMenu Checked Item 1",
                "[ ] SubMenu Unchecked Item 2",
                "-",   // line
                "[ ] SubMenu Unchecked Item 3"
            ],
            "Menu Item 2" : null,
            "Menu Item 3" : null
         });

     *
     * @class zebkit.ui.Menu
     * @constructor
     * @param {Object} [list] menu items description
     * @extends {zebkit.ui.CompList}
     */
    pkg.Menu = Class(pkg.CompList, [
        function (d) {
            this.menus = {};

            this.$super([], zebkit.isBoolean(d) ? d : true);

            if (Array.isArray(d)) {
                for(var i = 0; i < d.length; i++) {
                    this.add(d[i]);
                }
            } else {
                for(var k in d) {
                    if (d.hasOwnProperty(k)) {
                        var sub = d[k];
                        this.add(k);
                        if (sub != null) {
                            this.setMenuAt(this.kids.length - 1, zebkit.instanceOf(sub, pkg.Menu) ? sub : new pkg.Menu(sub));
                        }
                    }
                }
            }
        },

        function $clazz() {
            this.MenuItem = Class(pkg.MenuItem, [
                function $clazz() {
                    this.Label = Class(pkg.MenuItem.Label, []);
                }
            ]);

            this.Line = Class(pkg.Line, []);
            this.Line.prototype.$isDecorative = true;
        },

        function $prototype() {
            this.$parentMenu = null;

            this.canHaveFocus = true;
            this.noSubIfEmpty = false;

            /**
             * Test if the given menu item is a decorative (not selectable) menu item.
             * Menu item is considered as decorative if it has been added with addDecorative(...)
             * method or has "$isDecorative" property set to "true"
             * @param  {Integer}  i a menu item index
             * @return {Boolean}  true if the given menu item is decorative
             * @method isDecorative
             */
            this.isDecorative = function(i){
                return this.kids[i].$isDecorative === true || this.kids[i].$$isDecorative === true;
            };

            /**
             * Define component events handler.
             * @param  {zebkit.ui.CompEvent} e  a component event
             * @method  childCompEnabled
             */
            this.childCompEnabled = this.childCompShown = function(e) {
                var src = e.source;
                for(var i = 0;i < this.kids.length; i++){
                    if (this.kids[i] === src) {
                        // clear selection if an item becomes not selectable
                        if (this.isItemSelectable(i) === false) {
                            if (i === this.selectedIndex) this.select(-1);
                        }
                        break;
                    }
                }
            };

            /**
             * Get a menu item by the given index
             * @param  {Integer} i a menu item index
             * @return {zebkit.ui.Panel} a menu item component
             * @method getMenuItem
             */
            this.getMenuItem = function(i) {
                if (zebkit.isString(i) === true) {
                    var item = this.byPath(i);
                    if (item !== null) return item;
                    for (var k in this.menus) {
                        item = this.menus[k].getMenuItem(i);
                        if (item !== null) return item;
                    }
                }
                return this.kids[i];
            };

            /**
             * Test if the menu has a selectable item
             * @return {Boolean} true if the menu has at least one selectable item
             * @method hasSelectableItems
             */
            this.hasSelectableItems = function(){
                for(var i = 0; i < this.kids.length; i++) {
                    if (this.isItemSelectable(i)) return true;
                }
                return false;
            };

            /**
             * Define pointer exited events handler
             * @param  {zebkit.ui.PointerEvent} e a pointer event
             * @method pointerExited
             */
            this.pointerExited = function(e){
                this.position.setOffset(null);
            };

            /**
             * Get a sub menu for the given menu item
             * @param  {Integer} index a menu item index
             * @return {zebkit.ui.Menu} a sub menu or null if no sub menu
             * is defined for the given menu item
             * @method getMenuAt
             */
            this.getMenuAt = function(index) {
                if (index < this.kids.length) {
                    var hash = this.kids[index].$hash$;
                    return this.menus.hasOwnProperty(hash) ? this.menus[hash] : null;
                } else {
                    return null;
                }
            };

            /**
             * Set the given menu as a sub-menu for the specified menu item
             * @param {Integer} i an index of a menu item for that a sub menu
             * has to be attached
             * @param {zebkit.ui.Menu} m a sub menu to be attached
             * @method setMenuAt
             * @chainable
             */
            this.setMenuAt = function (i, m) {
                if (m === this) {
                    throw new Error("Menu cannot be sub-menu of its own");
                }

                if (this.isDecorative(i)) {
                    throw new Error("Decorative element cannot have a sub-menu");
                }

                var p = this.kids[i];
                if (typeof p.activateSub !== 'undefined') {
                    var sub = this.menus[p];
                    if (m !== null) {
                        if (sub == null) {
                            p.activateSub(true);
                        }
                    } else if (sub != null) {
                        p.activateSub(false);
                    }
                }

                // if the menu is shown and the menu item is selected
                if (this.parent !== null && i === this.selectedIndex) {
                    this.select(-1);
                }

                if (typeof p.$hash$ === 'undefined') {
                    throw new Error("Invalid key");
                }

                this.menus[p] = m;
                return this;
            };

            /**
             * Get the specified sub-menu index
             * @param  {zebkit.ui.Menu} menu a sub menu
             * @return {Integer} a sub menu index. -1 if the menu is
             * not a sub menu of the given menu
             * @method indexMenuOf
             */
            this.indexMenuOf = function(menu) {
                for(var i = 0; i < this.kids.length; i++) {
                    if (this.menus[this.kids[i]] === menu) {
                        return i;
                    }
                }
                return -1;
            };

            /**
             * Called when the menu or a sub-menu has been canceled (key ESCAPE has been pressed).
             * @param  {zebkit.ui.Menu} m a menu (or sub menu) that has been canceled
             * @method $canceled
             * @protected
             */
            this.$canceled = function(m) {
                if (this.$parentMenu !== null && typeof this.$canceled !== 'undefined') {
                    this.$parentMenu.$canceled(m);
                }
            };

            /**
             * Get the top menu in the given shown popup menu hierarchy
             * @return {zebkit.ui.Menu} a top menu
             * @method $topMenu
             * @protected
             */
            this.$topMenu = function() {
                if (this.parent !== null) {
                    var t = this,
                        p = null;

                    while ((p = t.$parentMenu) !== null) t = p;
                    return t;
                }
                return null;
            };

            this.doScroll = function(dx, dy, source) {
                var sy = this.scrollManager.getSY(),
                    ps = this.layout.calcPreferredSize(this),
                    eh = this.height - this.getTop() - this.getBottom();

                if (this.height < ps.height && sy + ps.height >= eh && sy - dy <= 0) {
                    var nsy = sy - dy;
                    if (nsy + ps.height < eh) {
                        nsy = eh - ps.height;
                    }
                    if (sy !== nsy) this.scrollManager.scrollYTo(nsy);
                }
            };

            /**
             * Hide the menu and all visible sub-menus
             * @method $hideMenu
             * @protected
             */
            this.$hideMenu = function() {
                if (this.parent !== null) {
                    var ch = this.$childMenu();
                    if (ch !== null) {
                        ch.$hideMenu();
                    }

                    this.removeMe();
                    this.select(-1);
                }
            };

            /**
             * Get a sub menu that is shown at the given moment.
             * @return {zebkit.ui.Menu} a child sub menu. null if no child sub-menu
             * has been shown
             * @method $childMenu
             * @protected
             */
            this.$childMenu = function() {
                if (this.parent !== null) {
                    for(var k in this.menus) {
                        var m = this.menus[k];
                        if (m.$parentMenu === this) {
                            return m;
                        }
                    }
                }
                return null;
            };

            /**
             * Show the given sub menu
             * @param  {zebkit.ui.Menu} sub a sub menu to be shown
             * @method $showSubMenu
             * @protected
             */
            this.$showSubMenu = function(sub) {
                sub.setLocation(this.x + this.width - 10,
                                this.y + this.kids[this.selectedIndex].y);
                sub.toPreferredSize();
                this.parent.add(sub);
                sub.requestFocus();
            };

            this.triggerSelectionByPos = function(i) {
                return this.getMenuAt(i) !== null && this.$triggeredByPointer === true;
            };
        },

        /**
         * Override key pressed events handler to handle key events according to
         * context menu component requirements
         * @param  {zebkit.ui.KeyEvent} e a key event
         * @method keyPressed
         */
        function keyPressed(e){
            if (e.code === "Escape") {
                if (this.parent !== null) {
                    var p = this.$parentMenu;
                    this.$canceled(this);
                    this.$hideMenu();
                    if (p !== null) p.requestFocus();
                }
            } else {
                this.$super(e);
            }
        },

        function insert(i, ctr, c) {
            if (zebkit.isString(c)) {
                return this.$super(i, ctr, (c.match(/^\-+$/) !== null) ? new this.clazz.Line()
                                                                       : new this.clazz.MenuItem(c));
            }
            return this.$super(i, ctr, c);
        },

        function setParent(p) {
            if (p !== null) {
                this.select(-1);
                this.position.setOffset(null);
            } else {
                this.$parentMenu = null;
            }
            this.$super(p);
        },

        /**
         * Add the specified component as a decorative item of the menu
         * @param {zebkit.ui.Panel} c an UI component
         * @method addDecorative
         */
        function addDecorative(c) {
            if (c.$isDecorative !== true) {
                c.$$isDecorative = true;
            }
            this.$getSuper("insert").call(this, this.kids.length, null, c);
        },

        function kidRemoved(i, c) {
            if (typeof c.$$isDecorative !== 'undefined') {
                delete c.$$isDecorative;
            }
            this.setMenuAt(i, null);
            this.$super(i, c);
        },

        function isItemSelectable(i) {
            return this.$super(i) && this.isDecorative(i) === false;
        },

        function posChanged(target,prevOffset,prevLine,prevCol) {
            var off = target.offset;

            if (off >= 0) {
                var rs = null;

                // hide previously shown sub menu if position has been re-newed
                if (this.selectedIndex >= 0  && off !== this.selectedIndex) {
                    var sub = this.getMenuAt(this.selectedIndex);
                    if (sub !== null) {
                        sub.$hideMenu();
                        rs = -1; // request to clear selection
                        this.requestFocus();
                    }
                }

                // request fire selection if the menu is shown and position has moved to new place
                if (this.parent !== null && off !== this.selectedIndex && this.isItemSelectable(off)) {
                    if (this.triggerSelectionByPos(off)) rs = off;
                }

                if (rs !== null) {
                    this.select(rs);
                }
            }

            this.$super(target, prevOffset, prevLine, prevCol);
        },

        function fireSelected(prev) {
            if (this.parent !== null) {
                var sub = null;

                if (this.selectedIndex >= 0) {
                    sub = this.getMenuAt(this.selectedIndex);
                    if (sub !== null) { // handle sub menu here
                        if (sub.parent !== null) {
                            // hide menu since it has been already shown
                            sub.$hideMenu();
                        } else {
                            // show menu
                            sub.$parentMenu = this;
                            this.$showSubMenu(sub);
                        }
                    } else {
                        // handle an item menu selection here.
                        // hide the whole menu hierarchy
                        var k = this.kids[this.selectedIndex];
                        if (typeof k.itemSelected !== 'undefined') {
                          k.itemSelected();
			  pkg.events.fire("menuItemSelected",
					  MENU_EVENT.$fillWith(this,
                                                               this.selectedIndex,
                                                               this.kids[this.selectedIndex]));
                        }

                        // an atomic menu, what means a menu item has been selected
                        // remove this menu an all parents menus
                        var top = this.$topMenu();
                        if (top !== null) {
                            top.$hideMenu();
                        }
                    }

                } else if (prev >= 0) {
                    // hide child menus if null item has been selected
                    sub = this.getMenuAt(prev);
                    if (sub !== null && sub.parent !== null) {
                        // hide menu since it has been already shown
                        sub.$hideMenu();
                    }
                }
            }
            this.$super(prev);
        }
    ]);

    /**
     * Menu bar UI component class. Menu bar can be build in any part of UI application.
     * There is no restriction regarding the placement of the component.

            var canvas = new zebkit.ui.zCanvas(300,200);
            canvas.setLayout(new zebkit.layout.BorderLayout());

            var mbar = new zebkit.ui.Menubar({
                "Item 1": {
                    "Subitem 1.1":null,
                    "Subitem 1.2":null,
                    "Subitem 1.3":null
                },
                "Item 2": {
                    "Subitem 2.1":null,
                    "Subitem 2.2":null,
                    "Subitem 2.3":null
                },
                "Item 3": null
            });

            canvas.root.add("bottom", mbar);

     * @class zebkit.ui.Menubar
     * @constructor
     * @extends zebkit.ui.Menu
     */
    pkg.Menubar = Class(pkg.Menu, [
        function $clazz() {
            this.MenuItem = Class(pkg.MenuItem, [
                function $clazz() {
                    this.Label = Class(pkg.MenuItem.Label, []);
                },

                function(c) {
                    this.$super(c);
                    this.hideSub();
                    this.getCheck().setVisible(false);
                }
            ]);
        },

        function $prototype() {
            this.canHaveFocus = false;

            this.triggerSelectionByPos = function (i) {
                return this.isItemSelectable(i) && this.selectedIndex >= 0;
            };

            // making menu bar not removable from its layer by overriding the method
            this.$hideMenu = function() {
                var child = this.$childMenu();
                if (child !== null) {
                    child.$hideMenu();
                }

                this.select(-1);
            };

            this.$showSubMenu = function(menu) {
                var d   = this.getCanvas(),
                    k   = this.kids[this.selectedIndex],
                    pop = d.getLayer(pkg.PopupLayer.id);

                if (menu.hasSelectableItems()) {
                    var abs = zebkit.layout.toParentOrigin(0, 0, k);
                    menu.setLocation(abs.x, abs.y + k.height + 1);
                    menu.toPreferredSize();
                    pop.add(menu);
                    menu.requestFocus();
                }
            };
        },

        function $canceled(m) {
            this.select(-1);
        },

        // called when an item is selected by user with pointer click or key
        function $select(i) {
            // if a user again pressed the same item consider it as
            // de-selection
            if (this.selectedIndex >= 0 && this.selectedIndex === i) {
                i = -1;
            }

            this.$super(i);
        }
    ]);

    pkg.PopupLayerLayout = Class(zebkit.layout.Layout, [
        function $prototype() {
            this.calcPreferredSize = function (target){
                return { width:0, height:0 };
            };

            this.doLayout = function(target) {
                for(var i = 0; i < target.kids.length; i++){
                    var m = target.kids[i];
                    if (zebkit.instanceOf(m, pkg.Menu)) {
                        var ps = m.getPreferredSize(),
                            xx = (m.x + ps.width  > target.width ) ? target.width  - ps.width  : m.x,
                            yy = (m.y + ps.height > target.height) ? target.height - ps.height : m.y;

                        m.setSize(ps.width, ps.height);
                        if (xx < 0) xx = 0;
                        if (yy < 0) yy = 0;
                        m.setLocation(xx, yy);
                    }
                }
            };
        }
    ]);

    /**
     * UI popup layer interface that defines common part of popup layer
     * implementation.
     * @class zebkit.ui.PopupLayerMix
     * @interface zebkit.ui.PopupLayerMix
     */
    pkg.PopupLayerMix = zebkit.Interface([
        function $clazz() {
            this.id = "popup";
        },

        function $prototype() {
            this.$prevFocusOwner = null;

            this.getFocusRoot = function() {
                return this;
            };

            this.childFocusGained = function(e) {
                if (zebkit.instanceOf(e.source, pkg.Menu)) {
                    if (e.related !== null && zebkit.layout.isAncestorOf(this, e.related) === false ) {
                        this.$prevFocusOwner = e.related;
                    }
                } else {
                    // means other than menu type of component grabs the focus
                    // in this case we should not restore focus when the popup
                    // component will be removed
                    this.$prevFocusOwner = null;
                }

                // save the focus owner whose owner was not a pop up layer
                if (e.related !== null && zebkit.layout.isAncestorOf(this, e.related) === false && zebkit.instanceOf(e.source, pkg.Menu)) {
                    this.$prevFocusOwner = e.related;
                }
            };

            this.isTriggeredWith = function(e) {
                return e.isAction() === false && (e.identifier === "rmouse" || e.touchCounter === 2);
            };

            /**
             * Define children components input events handler.
             * @param  {zebkit.ui.KeyEvent} e an input event
             * @method childKeyPressed
             */
            this.childKeyPressed = function(e){
                var p = e.source.$parentMenu;
                if (typeof p !== 'undefined' && p !== null) {
                    switch (e.code) {
                        case "ArrowRight" :
                            if (p.selectedIndex < p.model.count() - 1) {
                                p.requestFocus();
                                p.position.seekLineTo("down");
                            }
                            break;
                        case "ArrowLeft" :
                            if (p.selectedIndex > 0) {
                                p.requestFocus();
                                p.position.seekLineTo("up");
                            }
                            break;
                    }
                }
            };

            this.$topMenu = function() {
                if (this.kids.length > 0) {
                    for (var i = this.kids.length - 1; i >= 0; i--) {
                        if (zebkit.instanceOf(this.kids[i], pkg.Menu)) {
                            return this.kids[i].$topMenu();
                        }
                    }
                }
                return null;
            };

            this.compRemoved = function(e) {
                // if last component has been removed and the component is a menu
                // than try to restore focus owner
                if (this.$prevFocusOwner !== null && this.kids.length === 0 && zebkit.instanceOf(e.kid, pkg.Menu)) {
                    this.$prevFocusOwner.requestFocus();
                    this.$prevFocusOwner = null;
                }
            };

            this.layerPointerClicked = function (e) {
                if (this.kids.length === 0 && this.isTriggeredWith(e)) {
                    var popup = null;
                    if (typeof e.source.popup !== 'undefined' && e.source.popup !== null) {
                        popup = e.source.popup;
                    } else if (typeof e.source.getPopup !== 'undefined') {
                        popup = e.source.getPopup(e.source, e.x, e.y);
                    }

                    if (popup !== null) {
                        popup.setLocation(e.absX, e.absY);
                        this.add(popup);
                        popup.requestFocus();
                    }

                    return true;
                }
                return false;
            };
        },

        function layerPointerPressed(e) {
            // if a shown menu exists
            if (this.kids.length > 0) {
                // if pressed has happened over a popup layer no a menu
                if (this.$getSuper("getComponentAt").call(this, e.x, e.y) === this) {
                    var top = this.$topMenu();
                    if (top !== null) {
                        // if top menu is menu bar. menu bar is located in other layer
                        // we need check if the pressed has happened not over the
                        // menu bar
                        if (zebkit.instanceOf(top, pkg.Menubar)) {
                            var origin = zebkit.layout.toParentOrigin(top);
                            if (e.x >= origin.x && e.y >= origin.y && e.x < origin.x + top.width && e.y < origin.y + top.height) {
                                return;
                            }
                        }

                        // hide all shown menu
                        top.$hideMenu();
                    }

                    // still have a pop up components, than remove it
                    if (this.kids.length > 0) {
                        this.removeAll();
                    }
                }
            }
        },

        function getComponentAt(x, y) {
            // if there is a component on popup layer and the component is
            // not the popup layer itself than return the component otherwise
            // return null what delegates getComponentAt() to other layer
            if (this.kids.length > 0) {
                var comp = this.$super(x, y);
                if (comp !== this) {
                    return comp;
                }
            }
            return null;
        }
    ]);

    pkg.PopupLayer = Class(pkg.Panel, pkg.PopupLayerMix, []);


    pkg.events.regEvents('winOpened', 'winActivated');

    /**
     * Window component event
     * @constructor
     * @class zebkit.ui.WinEvent
     * @extends {zebkit.util.Event}
     */
    pkg.WinEvent = Class(zebkit.util.Event, [
        function $prototype() {
            /**
             * Indicates if the window has been shown
             * @attribute isShown
             * @type {Boolean}
             * @readOnly
             */
            this.isShown = false;

            /**
             * Indicates if the window has been activated
             * @attribute isActive
             * @type {Boolean}
             * @readOnly
             */
             this.isActive = false;

            /**
             * Layer the source window belongs to
             * @type {zebkit.ui.Panel}
             * @attribute layer
             * @readOnly
             */
            this.layer = null;

            /**
             * Fill the event with parameters
             * @param  {zebkit.ui.Panel}  src  a source window
             * @param  {zebkit.ui.Panel}  layer  a layer the window belongs to
             * @param  {Boolean} isActive boolean flag that indicates the window status
             * @param  {Boolean} isShown  boolean flag that indicates the window visibility
             * @chainable
             * @method  $fillWidth
             */
            this.$fillWith = function(src, layer, isActive, isShown) {
                this.source = src;

                this.layer    = layer;
                this.isActive = isActive;
                this.isShown  = isShown;
                return this;
            };
        }
    ]);

    var WIN_EVENT = new pkg.WinEvent();

    /**
     * Show the given UI component as a modal window
     * @param  {zebkit.ui.Panel} context  an UI component of zebkit hierarchy
     * @param  {zebkit.ui.Panel} win a component to be shown as the modal window
     * @for  zebkit.ui
     * @method showModalWindow
     */
    pkg.showModalWindow = function(context, win) {
        pkg.showWindow(context, "modal", win);
    };

    /**
     * Show the given UI component as a window
     * @param  {zebkit.ui.Panel} context  an UI component of zebkit hierarchy
     * @param  {String} [type] a type of the window: "modal", "mdi", "info". The default
     * value is "info"
     * @param  {zebkit.ui.Panel} win a component to be shown as the window
     * @for  zebkit.ui
     * @method showWindow
     */
    pkg.showWindow = function(context, type, win) {
        if (arguments.length < 3) {
            win  = type;
            type = "info";
        }
        return context.getCanvas().getLayer("win").addWin(type, win);
    };

    /**
     * Activate the given window or a window the specified component belongs
     * @param  {zebkit.ui.Panel} win an UI component to be activated
     * @for zebkit.ui
     * @method activateWindow
     */
    pkg.activateWindow = function(win) {
        var l = win.getCanvas().getLayer("win");
        l.activate(zebkit.layout.getDirectChild(l, win));
    };

    /**
     * Window layer class. Window layer is supposed to be used for showing
     * modal and none modal internal window. There are special ready to use
     * "zebkit.ui.Window" UI component that can be shown as internal window, but
     * zebkit allows developers to show any UI component as modal or none modal
     * window. Add an UI component to window layer to show it as modal o none
     * modal window:

            // create canvas
            var canvas   = new zebkit.ui.zCanvas();

            // get windows layer
            var winLayer = canvas.getLayer(zebkit.ui.WinLayerMix.id);

            // create standard UI window component
            var win = new zebkit.ui.Window();
            win.setBounds(10,10,200,200);

            // show the created window as modal window
            winLayer.addWin("modal", win);

     * Also shortcut method can be used

            // create canvas
            var canvas   = new zebkit.ui.zCanvas();

            // create standard UI window component
            var win = new zebkit.ui.Window();
            win.setBounds(10,10,200,200);

            // show the created window as modal window
            zebkit.ui.showModalWindow(canvas, win);

     * Window layer supports three types of windows:

        - **"modal"** a modal window catches all input till it will be closed
        - **"mdi"** a MDI window can get focus, but it doesn't block switching
        focus to other UI elements
        - **"info"** an INFO window cannot get focus. It is supposed to show
        some information like tooltip.

     * @class zebkit.ui.WinLayer
     * @constructor
     * @extends {zebkit.ui.HtmlCanvas}
     */
    pkg.WinLayerMix = zebkit.Interface([
        function $clazz() {
            this.id = "win";
        },

        function $prototype() {
            /**
             * Currently activated as a window children component
             * @attribute activeWin
             * @type {zebkit.ui.Panel}
             * @readOnly
             * @protected
             */
            this.activeWin = null;

            this.topModalIndex = -1;

            this.layerPointerPressed = function(e) {
                if (this.kids.length > 0) {

                    // I) check most probable variant - pressed has occurred inside an active window that
                    // is placed on the top of all other windows
                    if (this.activeWin !== null) {
                        if (this.indexOf(this.activeWin) === this.kids.length - 1) {
                            var x1 = this.activeWin.x,
                                y1 = this.activeWin.y,
                                x2 = x1 + this.activeWin.width,
                                y2 = y1 + this.activeWin.height;

                            // pressed has occurred inside the topest active window, so let process
                            // goes normally by calling winLayer.getComponetAt(x,y)
                            if (e.x >= x1 && e.y >= y1 && e.x <= x2 && e.y <= y2) {
                                return false;
                            }
                        }
                    }

                    // II) otherwise looking for a window starting from the topest one where the
                    // pressed event has occurred. Pay attention modal window can open MDI windows
                    for(var i = this.kids.length - 1; i >= 0 && i >= this.topModalIndex; i--) {
                        var d = this.kids[i];

                        if (d.isVisible === true  &&   // check pressed is inside of a MDI window that
                            d.isEnabled === true  &&   // is shown after currently active modal window
                            d.winType  !== "info" &&
                            e.x >= d.x            &&
                            e.y >= d.y            &&
                            e.x < d.x + d.width   &&
                            e.y < d.y + d.height     )
                        {
                            if (d !== this.activeWin) {
                                this.activate(d);
                                return true;
                            } else {
                                return false;  // we are inside activated modal window
                            }
                        }
                    }

                    // III) Check if have to deactivate active MDI window since on prev. step we could not find
                    // a target window  what means pressed was outside of a window
                    if (this.topModalIndex < 0 && this.activeWin !== null) { // no a modal window has been shown
                        this.activate(null);
                        return false;
                    }

                    return this.topModalIndex >= 0;
                }

                return false;
            };

            this.layerKeyPressed = function(e){
                if (this.kids.length > 0 &&
                    e.code === "Tab"     &&
                    e.shiftKey === true     )
                {
                    if (this.activeWin === null) {
                        this.activate(this.kids[this.kids.length - 1]);
                    } else {
                        var winIndex = this.kids.indexOf(this.activeWin) - 1;
                        if (winIndex < this.topModalIndex || winIndex < 0) {
                            winIndex = this.kids.length - 1;
                        }
                        this.activate(this.kids[winIndex]);
                    }

                    return true;
                }
                return false;
            };

            /**
             * Define children components input events handler.
             * @param  {zebkit.ui.FocusEvent} e a focus event
             * @method childFocusGained
             */
            this.childFocusGained = function (e) {
                this.activate(zebkit.layout.getDirectChild(this, e.source));
            };

            this.getFocusRoot = function() {
                return this.activeWin;
            };

            this.getWinType = function(w) {
                return w.winType;
            };

            /**
             * Activate the given win layer children component window.
             * @param  {zebkit.ui.Panel} c a component to be activated as window
             * @method activate
             */
            this.activate = function(c) {
                if (c !== null && (this.kids.indexOf(c) < 0 ||
                                   c.winType === "info"))
                {
                    throw new Error("Window cannot be activated");
                }

                if (c !== this.activeWin) {
                    var old = this.activeWin;

                    if (c === null) {
                        var type = this.activeWin.winType;
                        if (type === "modal") {
                            throw new Error("Modal window cannot be de-activated");
                        }

                        this.activeWin = null;
                        pkg.events.fire("winActivated", WIN_EVENT.$fillWith(old, this, false, false));

                        // TODO: special flag $dontGrabFocus is not very elegant solution
                        if (type === "mdi" && old.$dontGrabFocus !== true) {
                            pkg.focusManager.requestFocus(null);
                        }
                    } else {
                        if (this.kids.indexOf(c) < this.topModalIndex) {
                            throw new Error();
                        }

                        this.activeWin = c;
                        this.activeWin.toFront();

                        if (old !== null) {
                            pkg.events.fire("winActivated", WIN_EVENT.$fillWith(old, this, false, false));
                        }

                        pkg.events.fire("winActivated", WIN_EVENT.$fillWith(c, this, true, false));
                        this.activeWin.validate();

                        // TODO: special flag $dontGrabFocus is not very elegant
                        if (this.activeWin.winType === "mdi" && this.activeWin.$dontGrabFocus !== true) {
                            var newFocusable = pkg.focusManager.findFocusable(this.activeWin);
                            pkg.focusManager.requestFocus(newFocusable);
                        }
                    }
                }
            };

            /**
             * Add the given window with the given type and the listener to the layer.
             * @param {String} [type]   a type of the window: "modal",
             * "mdi" or "info"
             * @param {zebkit.ui.Panel} win an UI component to be shown as window
             * @method addWin
             */
            this.addWin = function(type, win) {
                // check if window type argument has been passed
                if (arguments.length > 1) {
                    win.winType = type;
                }
                this.add(win);
            };

            this.getComponentAt = function(x, y) {
                return (this.activeWin === null) ? null
                                                 : this.activeWin.getComponentAt(x - this.activeWin.x,
                                                                                 y - this.activeWin.y);
            };
        },

        function kidAdded(index, constr, lw){
            this.$super(index, constr, lw);

            if (typeof lw.winType === 'undefined') {
                lw.winType = "mdi";
            } else {
                zebkit.util.$validateValue(lw.winType, "mdi", "modal", "info");
            }

            if (lw.winType === "modal") {
                this.topModalIndex = this.kids.length - 1;
                pkg.events.fire("winOpened", WIN_EVENT.$fillWith(lw, this, false, true));
                this.activate(lw);
            } else {
                pkg.events.fire("winOpened", WIN_EVENT.$fillWith(lw, this, false, true));
            }
        },

        function kidRemoved(index, lw){
            this.$getSuper("kidRemoved").call(this, index, lw);

            if (this.activeWin === lw) {
                this.activeWin = null;
                // TODO:  deactivated event can be used as a trigger of a window closing so
                // it is better don't fire it here this.fire("winActivated", lw, l);
                if (lw.winType === "mdi" && lw.$dontGrabFocus !== true) {
                    pkg.focusManager.requestFocus(null);
                }
            }

            var ci = this.kids.indexOf(lw);
            if (ci < this.topModalIndex) { // correct top modal window index
                this.topModalIndex--;
            } else if (this.topModalIndex === ci) {
                // looking for a new modal window
                for (this.topModalIndex = this.kids.length - 1; this.topModalIndex >= 0; this.topModalIndex--){
                    if (this.kids[this.topModalIndex].winType === "modal") {
                        break;
                    }
                }
            }

            pkg.events.fire("winOpened", WIN_EVENT.$fillWith(lw, this, false, false));

            if (this.topModalIndex >= 0) {
                var aindex = this.kids.length - 1;
                while (this.kids[aindex].winType === "info") {
                    aindex--;
                }
                this.activate(this.kids[aindex]);
            }
        }
    ]);

    pkg.WinLayer = Class(pkg.Panel, pkg.WinLayerMix, []);

    /**
     * Window UI component class. Implements window like UI component. The window component has a header,
     * status bar and content areas. The header component is usually placed at the top of window, the
     * status bar component is placed at the bottom and the content component at places the central part
     * of the window. Also the window defines corner UI component that is supposed to be used to resize
     * the window. The window implementation provides the following possibilities:

        - Move window by dragging the window on its header
        - Resize window by dragging the window corner element
        - Place buttons in the header to maximize, minimize, close, etc the window
        - Indicates state of window (active or inactive) by changing
        the widow header style
        - Define a window icon component
        - Define a window status bar component

     * @class zebkit.ui.Window
     *
     * @param {String} [s] a window title
     * @param {zebkit.ui.Panel} [c] a window content
     * @constructor
     * @extends {zebkit.ui.Panel}
     */
    pkg.Window = Class(pkg.StatePan, [
        function (s, c) {
            //!!! for some reason state has to be set beforehand
            this.state = "inactive";

            this.prevH = this.prevX = this.prevY = 0;
            this.px = this.py = this.dx = this.dy = 0;
            this.prevW = this.action = -1;

            /**
             * Root window panel. The root panel has to be used to
             * add any UI components
             * @attribute root
             * @type {zebkit.ui.Panel}
             * @readOnly
             */
            this.root = (c === null || arguments.length < 2 ? this.createContentPan() : c);

            /**
             * Window caption panel. The panel contains window
             * icons, button and title label
             * @attribute caption
             * @type {zebkit.ui.Panel}
             * @readOnly
             */
            this.caption = this.createCaptionPan();

            /**
             * Window title component
             * @type {zebkit.ui.Panel}
             * @attribute title
             * @readOnly
             */
            this.title = this.createTitle();
            this.title.setValue((s === null || arguments.length === 0 ? "" : s));

            /**
             * Icons panel. The panel can contain number of icons.
             * @type {zebkit.ui.Panel}
             * @attribute icons
             * @readOnly
             */
            this.icons = new pkg.Panel(new zebkit.layout.FlowLayout("left", "center", "horizontal", 2));
            this.icons.add(new this.clazz.Icon());

            /**
             * Window buttons panel. The panel can contain number of window buttons
             * @type {zebkit.ui.Panel}
             * @attribute buttons
             * @readOnly
             */
            this.buttons = new pkg.Panel(new zebkit.layout.FlowLayout("center", "center"));

            this.caption.add("center", this.title);
            this.caption.add("left", this.icons);
            this.caption.add("right", this.buttons);

            /**
             * Window status panel.
             * @attribute status
             * @readOnly
             * @type {zebkit.ui.Panel}
             */
            this.status = new this.clazz.StatusPan();
            this.sizer  = new this.clazz.SizerPan();
            this.status.add(this.sizer);

            this.setSizeable(true);

            this.$super();
            this.setLayout(new zebkit.layout.BorderLayout(2,2));

            this.add("center", this.root);
            this.add("top", this.caption);
            this.add("bottom", this.status);
        },

        function $clazz() {
            this.CaptionPan = Class(pkg.StatePan, [
                function $prototype() {
                    this.state = "inactive";
                }
            ]);

            this.TitleLab   = Class(pkg.Label, []);
            this.StatusPan  = Class(pkg.Panel, []);
            this.ContentPan = Class(pkg.Panel, []);
            this.SizerPan   = Class(pkg.ViewPan, []);
            this.Icon       = Class(pkg.ImagePan, []);
            this.Button     = Class(pkg.Button, []);
        },

        function $prototype() {
            var MOVE_ACTION = 1, SIZE_ACTION = 2;

            this.sizer = this.caption = null;

            this.isPopupEditor = true;

            /**
             * Minimal possible size of the window
             * @default 40
             * @attribute minSize
             * @type {Integer}
             */
            this.minSize = 40;

            /**
             * Indicate if the window can be resized by dragging its by corner
             * @attribute isSizeable
             * @type {Boolean}
             * @default true
             * @readOnly
             */
            this.isSizeable = true;

            /**
             * Test if the window is shown as a window and activated
             * @return {Boolean} true is the window is shown as internal window and
             * is active.
             * @method isActive
             */
            this.isActive = function() {
                var c = this.getCanvas();
                return c !== null && c.getLayer("win").activeWin === this.getWinContainer();
            };

            this.pointerDragStarted = function(e){
                this.px = e.absX;
                this.py = e.absY;
                this.action = this.insideCorner(e.x, e.y) ? (this.isSizeable ? SIZE_ACTION : -1)
                                                          : MOVE_ACTION;
                if (this.action > 0) {
                    this.dy = this.dx = 0;
                }
            };

            this.pointerDragged = function(e){
                if (this.action > 0) {
                    var container = null;

                    if (this.action !== MOVE_ACTION){
                        container = this.getWinContainer();

                        var nw = this.dx + container.width,
                            nh = this.dy + container.height;

                        if (nw > this.minSize && nh > this.minSize) {
                            container.setSize(nw, nh);
                        }
                    }

                    this.dx = (e.absX - this.px);
                    this.dy = (e.absY - this.py);
                    this.px = e.absX;
                    this.py = e.absY;
                    if (this.action === MOVE_ACTION){
                        container = this.getWinContainer();
                        container.setLocation(this.dx + container.x, this.dy + container.y);
                    }
                }
            };

            this.pointerDragEnded = function(e){
                if (this.action > 0){
                    if (this.action === MOVE_ACTION){
                        var container = this.getWinContainer();
                        container.setLocation(this.dx + container.x, this.dy + container.y);
                    }
                    this.action = -1;
                }
            };

            this.getWinContainer = function() {
                return this;
            };

            /**
             * Test if the pointer cursor is inside the window corner component
             * @protected
             * @param  {Integer} px a x coordinate of the pointer cursor
             * @param  {Integer} py a y coordinate of the pointer cursor
             * @return {Boolean}  true if the pointer cursor is inside window
             * corner component
             * @method insideCorner
             */
            this.insideCorner = function(px,py){
                return this.getComponentAt(px, py) === this.sizer;
            };

            this.getCursorType = function(target,x,y){
                return (this.isSizeable && this.insideCorner(x, y)) ? pkg.Cursor.SE_RESIZE
                                                                    : null;
            };

            this.catchInput = function(c){
                var tp = this.caption;
                return c === tp ||
                      (zebkit.layout.isAncestorOf(tp, c) && zebkit.instanceOf(c, pkg.Button) === false) ||
                       this.sizer === c;
            };

            this.winOpened = function(e) {
                var state = this.isActive() ? "active" : "inactive";
                if (this.caption !== null && typeof this.caption.setState !== 'undefined') {
                    this.caption.setState(state);
                }
                this.setState(state);
            };

            this.winActivated = function(e) {
                this.winOpened(e);
            };

            this.pointerDoubleClicked = function (e){
                var x = e.x, y = e.y, cc = this.caption;
                if (this.isSizeable === true &&
                    x > cc.x &&
                    x < cc.y + cc.width &&
                    y > cc.y &&
                    y < cc.y + cc.height)
                {
                    if (this.prevW < 0) this.maximize();
                    else this.restore();
                }
            };

            /**
             * Test if the window has been maximized to occupy the whole
             * window layer space.
             * @return {Boolean} true if the window has been maximized
             * @method isMaximized
             */
            this.isMaximized = function() {
                return this.prevW !== -1;
            };

            /**
             * Create a caption component
             * @return {zebkit.ui.Panel} a zebkit caption component
             * @method createCaptionPan
             * @protected
             */
            this.createCaptionPan = function() {
                return new this.clazz.CaptionPan();
            };

            /**
             * Create a content component
             * @return {zebkit.ui.Panel} a content component
             * @method createContentPan
             * @protected
             */
            this.createContentPan = function() {
                return new this.clazz.ContentPan();
            };

            /**
             * Create a caption title label
             * @return {zebkit.ui.Label} a caption title label
             * @method createTitle
             * @protected
             */
            this.createTitle = function() {
                return new this.clazz.TitleLab();
            };

            this.setIcon = function(i, icon) {
                if (zebkit.isString(icon) || zebkit.instanceOf(icon, pkg.Picture)) {
                    icon = new pkg.ImagePan(icon);
                }
                this.icons.setAt(i, icon);
                return this;
            };

            /**
             * Make the window sizable or not sizeable
             * @param {Boolean} b a sizeable state of the window
             * @chainable
             * @method setSizeable
             */
            this.setSizeable = function(b){
                if (this.isSizeable !== b){
                    this.isSizeable = b;
                    if (this.sizer !== null) {
                        this.sizer.setVisible(b);
                    }
                }
                return this;
            };

            /**
             * Maximize the window
             * @method maximize
             * @chainable
             */
            this.maximize = function(){
                if (this.prevW < 0){
                    var d    = this.getCanvas(),
                        cont = this.getWinContainer(),
                        left = d.getLeft(),
                        top  = d.getTop();

                    this.prevX = cont.x;
                    this.prevY = cont.y;
                    this.prevW = cont.width;
                    this.prevH = cont.height;

                    cont.setBounds(left, top,
                                   d.width  - left - d.getRight(),
                                   d.height - top - d.getBottom());
                }
                return this;
            };

            /**
             * Restore the window size
             * @method restore
             * @chainable
             */
            this.restore = function(){
                if (this.prevW >= 0){
                    this.getWinContainer().setBounds(this.prevX, this.prevY,
                                                     this.prevW, this.prevH);
                    this.prevW = -1;
                }
                return this;
            };

            /**
             * Close the window
             * @method close
             * @chainable
             */
            this.close = function() {
                this.getWinContainer().removeMe();
                return this;
            };

            /**
             * Set the window buttons set.
             * @param {Object} buttons dictionary of buttons icons for window buttons.
             * The dictionary key defines a method of the window component to be called
             * when the given button has been pressed. So the method has to be defined
             * in the window component.
             * @method setButtons
             */
            this.setButtons = function(buttons) {
                // remove previously added buttons
                for(var i = 0; i < this.buttons.length; i++) {
                    var kid = this.buttons.kids[i];
                    if (zebkit.instanceOf(kid, zebkit.util.Fireable)) {
                        kid.off();
                    }
                }
                this.buttons.removeAll();

                // add new buttons set
                for(var k in buttons) {
                    if (buttons.hasOwnProperty(k)) {
                        var b = new this.clazz.Button();
                        b.properties(buttons[k]);
                        this.buttons.add(b);

                        (function(t, f) {
                            b.on(function() { f.call(t); });
                        })(this, this[k]);
                    }
                }
                return this;
            };

        },

        function focused(){
            this.$super();
            if (this.caption !== null) {
                this.caption.repaint();
            }
        }
    ]);


    /**
     * Tooltip UI component. The component can be used as a tooltip that shows specified content in
     * figured border.
     * @class  zebkit.ui.Tooltip
     * @param  {zebkit.util.Panel|String} a content component or test label to be shown in tooltip
     * @constructor
     * @extends {zebkit.ui.Panel}
     */
    pkg.Tooltip = Class(pkg.Panel, [
        function(content) {
            this.$super();
            if (arguments.length > 0) {
                this.add(pkg.$component(content, this));
                this.toPreferredSize();
            }
        },

        function $clazz() {
            this.Label = Class(pkg.Label, []);

            this.ImageLabel = Class(pkg.ImageLabel, []);

            this.TooltipBorder = Class(pkg.View, [
                function(col, size) {
                    if (arguments.length > 0) this.color = col;
                    if (arguments.length > 1) this.size  = size;
                    this.gap = 2 * this.size;
                },

                function $prototype() {
                    this.color = "black";
                    this.size  = 2;

                    this.paint = function (g,x,y,w,h,d) {
                        if (this.color !== null) {
                            this.outline(g,x,y,w,h,d);
                            g.setColor(this.color);
                            g.lineWidth = this.size;
                            g.stroke();
                        }
                    };

                    this.outline = function(g,x,y,w,h,d) {
                        g.beginPath();
                        h -= 2 * this.size;
                        w -= 2 * this.size;
                        x += this.size;
                        y += this.size;

                        var w2   = (w/2 + 0.5) | 0,
                            w3_8 = ((3 * w)/8 + 0.5) | 0,
                            h2_3 = ((2 * h)/3 + 0.5) | 0,
                            h3   = (h/3 + 0.5) | 0,
                            w4   = (w/4 + 0.5) | 0;

                        g.moveTo(x + w2, y);
                        g.quadraticCurveTo(x, y, x, y + h3);
                        g.quadraticCurveTo(x, y + h2_3, x + w4,  y + h2_3);
                        g.quadraticCurveTo(x + w4, y + h, x, y + h);
                        g.quadraticCurveTo(x + w3_8, y + h, x + w2, y + h2_3);
                        g.quadraticCurveTo(x + w, y + h2_3, x + w, y + h3);
                        g.quadraticCurveTo(x + w, y, x + w2, y);
                        g.closePath();
                        return true;
                    };
                }
            ]);
        },

        function recalc() {
            this.$contentPs = (this.kids.length === 0 ? this.$super()
                                                      : this.kids[0].getPreferredSize());
        },

        function getBottom() {
            return this.$super() + this.$contentPs.height;
        },

        function getTop() {
            return this.$super() + ((this.$contentPs.height/6 + 0.5) | 0);
        },

        function getLeft() {
            return this.$super() + ((this.$contentPs.height/6 + 0.5) | 0);
        },

        function getRight() {
            return this.$super() + ((this.$contentPs.height/6 + 0.5) | 0);
        }
    ]);

    /**
     * Popup window manager class. The manager registering and triggers showing context popup menu
     * and tooltips. Menu appearing is triggered by right pointer click or double fingers touch event.
     * To bind a popup menu to an UI component you can either set "tooltip" property of the component
     * with a popup menu instance:

            // create canvas
            var canvas = new zebkit.ui.zCanvas();

            // create menu with three items
            var m = new zebkit.ui.Menu();
            m.add("Menu Item 1");
            m.add("Menu Item 2");
            m.add("Menu Item 3");

            // bind the menu to root panel
            canvas.root.popup = m;

     * Or implement "getPopup(target,x,y)" method that can rule showing popup menu depending on
     * the current cursor location:

            // create canvas
            var canvas = new zebkit.ui.zCanvas();

            // visualize 50x50 pixels hot component spot
            // to which the context menu is bound
            canvas.root.paint = function(g) {
                g.setColor("red");
                g.fillRect(50,50,50,50);
            }

            // create menu with three items
            var m = new zebkit.ui.Menu();
            m.add("Menu Item 1");
            m.add("Menu Item 2");
            m.add("Menu Item 3");

            // implement "getPopup" method that shows popup menu only
            // if pointer cursor located at red rectangular area of the
            // component
            canvas.root.getPopup = function(target, x, y) {
                // test if pointer cursor position is in red spot area
                // and return context menu if it is true
                if (x > 50 && y > 50 && x < 100 && y <  100)  {
                    return m;
                }
                return null;
            }

     *  Defining a tooltip for an UI component follows the same approach. Other you
     *  define set "tooltip" property of your component with a component that has to
     *  be shown as the tooltip:

             // create canvas
             var canvas = new zebkit.ui.zCanvas();

             // create tooltip
             var t = new zebkit.ui.Label("Tooltip");
             t.setBorder("plain");
             t.setBackground("yellow");
             t.setPadding(6);

             // bind the tooltip to root panel
             canvas.root.popup = t;

    *  Or you can implement "getTooltip(target,x,y)" method if the tooltip showing depends on
    *  the pointer cursor location:


            // create canvas
            var canvas = new zebkit.ui.zCanvas();

            // create tooltip
            var t = new zebkit.ui.Label("Tooltip");
            t.setBorder("plain");
            t.setBackground("yellow");
            t.setPadding(6);

            // bind the tooltip to root panel
            canvas.root.getPopup = function(target, x, y) {
                return x < 10 && y < 10 ? t : null;
            };

     * @class zebkit.ui.TooltipManager
     * @extends zebkit.ui.Manager
     * @constructor
     */

     /**
      * Fired when a menu item has been selected

             zebkit.ui.events.on("menuItemSelected", function(menu, index, item) {
                 ...
             });

      *
      * @event menuItemSelected
      * @param {zebkit.ui.Menu} menu a menu component that triggers the event
      * @param {Integer}  index a menu item index that has been selected
      * @param {zebkit.ui.Panel} item a menu item component that has been selected
      */
    pkg.TooltipManager = Class(pkg.Manager, [
        function $prototype() {
            this.$tooltipX = this.$tooltipY = 0;
            this.$toolTask = this.$targetTooltipLayer = this.$tooltip = this.$target = null;

            /**
             * Indicates if a shown tooltip has to disappear by pointer pressed event
             * @attribute hideTooltipByPress
             * @type {Boolean}
             * @default true
             */
            this.hideTooltipByPress = true;

            /**
             * Define interval (in milliseconds) between entering a component and showing
             * a tooltip for the entered component
             * @attribute showTooltipIn
             * @type {Integer}
             * @default 400
             */
            this.showTooltipIn = 400;

            /**
             * Indicates if tool tip position has to be synchronized with pointer position
             * @attribute syncTooltipPosition
             * @type {Boolean}
             * @default true
             */
            this.syncTooltipPosition = true;

            /**
             * Define pointer clicked event handler
             * @param  {zebkit.ui.PointerEvent} e a pointer event
             * @method pointerClicked
             */
            // this.pointerClicked = function (e){

            //     // Right button
            //     // TODO: check if it is ok and compatible with touch
            //     if (this.isTriggeredWith(e)) {
            //         var popup = null;

            //         if (e.source.popup != null) {
            //             popup = e.source.popup;
            //         } else {
            //             if (e.source.getPopup != null) {
            //                 popup = e.source.getPopup(e.source, e.x, e.y);
            //             }
            //         }

            //         if (popup != null) {
            //             popup.setLocation(e.absX, e.absY);
            //             e.source.getCanvas().getLayer(pkg.PopupLayer.id).add(popup);
            //             popup.requestFocus();
            //         }
            //     }
            // };

            /**
             * Define pointer entered event handler
             * @param  {zebkit.ui.PointerEvent} e a pointer event
             * @method pointerEntered
             */
            this.pointerEntered = function(e) {
                if (this.$target === null &&
                    ((typeof e.source.tooltip !== 'undefined' && e.source.tooltip !== null) || typeof e.source.getTooltip !== 'undefined'))
                {
                    var $this = this;
                    this.$target = e.source;
                    this.$targetTooltipLayer = e.source.getCanvas().getLayer("win");
                    this.$tooltipX = e.x;
                    this.$tooltipY = e.y;
                    this.$toolTask = zebkit.util.tasksSet.run(
                        this,
                        this.showTooltipIn,
                        this.showTooltipIn
                    );
                }
            };

            /**
             * Define pointer exited event handler
             * @param  {zebkit.ui.PointerEvent} e a pointer event
             * @method pointerExited
             */
            this.pointerExited = function(e) {
                // exited triggers tooltip hiding only for "info" tooltips
                if (this.$target !== null && (this.$tooltip === null || this.$tooltip.winType === "info")) {
                    this.stopShowingTooltip();
                }
            };

            /**
             * Define pointer moved event handler
             * @param  {zebkit.ui.PointerEvent} e a pointer event
             * @method pointerMoved
             */
            this.pointerMoved = function(e) {
                // to prevent handling pointer moved from component of mdi
                // tooltip we have to check if target equals to source
                // instead of just checking if target is not a null
                if (this.$target === e.source) {
                    // store a new location for a tooltip
                    this.$tooltipX = e.x;
                    this.$tooltipY = e.y;

                    // wake up task try showing a tooltip
                    // at the new location
                    if (this.$toolTask !== null) {
                        this.$toolTask.resume(this.showTooltipIn);
                    }
                }
            };

            /**
             * Task body method
             * @private
             * @param  {Task} t a task context
             * @method run
             */
            this.run = function(t) {
                if (this.$target !== null) {
                    var ntooltip = (typeof this.$target.tooltip !== 'undefined' &&
                                   this.$target.tooltip !== null) ? this.$target.tooltip
                                                                  : this.$target.getTooltip(this.$target,
                                                                                            this.$tooltipX,
                                                                                            this.$tooltipY),
                        p = null,
                        tx = 0,
                        ty = 0;

                    if (this.$tooltip !== ntooltip) {

                        // hide previously shown tooltip
                        if (this.$tooltip !== null) {
                            this.hideTooltip();
                        }

                        // set new tooltip
                        this.$tooltip = ntooltip;

                        // if new tooltip exists than show it
                        if (ntooltip !== null) {
                            p = zebkit.layout.toParentOrigin(this.$tooltipX, this.$tooltipY, this.$target);

                            this.$tooltip.toPreferredSize();
                            tx = p.x;
                            ty = p.y - this.$tooltip.height;

                            var dw = this.$targetTooltipLayer.width;

                            if (tx + this.$tooltip.width > dw) {
                                tx = dw - this.$tooltip.width - 1;
                            }

                            this.$tooltip.setLocation(tx < 0 ? 0 : tx, ty < 0 ? 0 : ty);

                            if (typeof this.$tooltip.winType === 'undefined') {
                                this.$tooltip.winType = "info";
                            }

                            this.$targetTooltipLayer.add(this.$tooltip);
                            if (this.$tooltip.winType !== "info") {
                                pkg.activateWindow(this.$tooltip);
                            }
                        }
                    } else {
                        if (this.$tooltip !== null && this.syncTooltipPosition === true) {
                            p  = zebkit.layout.toParentOrigin(this.$tooltipX,
                                                              this.$tooltipY,
                                                              this.$target);
                            tx = p.x;
                            ty = p.y - this.$tooltip.height;

                            this.$tooltip.setLocation(tx < 0 ? 0 : tx, ty < 0 ? 0 : ty);
                        }
                    }
                }
                t.pause();
            };

            this.winActivated = function(e) {
                // this method is called only for mdi window
                // consider every deactivation of a mdi window as
                // a signal to stop showing tooltip
                if (e.isActive === false && this.$tooltip !== null)  {
                    this.$tooltip.removeMe();
                }
            };

            this.winOpened = function(e) {
                if (e.isShown === false) {
                    // cleanup tooltip reference
                    this.$tooltip = null;

                    if (e.source.winType !== "info") {
                        this.stopShowingTooltip();
                    }
                }
            };

            /**
             * Stop showing tooltip
             * @private
             * @method stopShowingTooltip
             */
            this.stopShowingTooltip = function() {
                if (this.$target !== null) {
                    this.$target = null;
                }

                if (this.$toolTask !== null) {
                    this.$toolTask.shutdown();
                }

                this.hideTooltip();
            };

            /**
             * Hide tooltip if it has been shown
             * @method hideTooltip
             */
            this.hideTooltip = function(){
                if (this.$tooltip !== null) {
                    this.$tooltip.removeMe();
                    this.$tooltip = null;
                }
            };

            /**
             * Define pointer pressed event handler
             * @param  {zebkit.ui.PointerEvent} e a pointer event
             * @method pointerPressed
             */
            this.pointerPressed = function(e) {
                if (this.hideTooltipByPress === true &&
                    e.pointerType === "mouse" &&
                    this.$target !== null &&
                    (this.$tooltip === null || this.$tooltip.winType === "info"))
                {
                    this.stopShowingTooltip();
                }
            };

            /**
             * Define pointer released event handler
             * @param  {zebkit.ui.PointerEvent} e a pointer event
             * @method pointerReleased
             */
            this.pointerReleased = function(e) {
                if ((this.hideTooltipByPress === false || e.pointerType !== "mouse") &&
                    this.$target !== null &&
                    (this.$tooltip === null || this.$tooltip.winType === "info"))
                {
                    this.stopShowingTooltip();
                }
            };
        }
    ]);


    pkg.$configWith(pkg);
});
zebkit.package("ui.tree", function(pkg, Class) {
    'use strict';
    var ui = pkg.cd("..");

    /**
     * Tree UI components and all related to the component classes and interfaces.
     * Tree components are graphical representation of a tree model that allows a user
     * to navigate over the model item, customize the items rendering and
     * organize customizable editing of the items.

            // create tree component instance to visualize the given tree model
            var tree = new zebkit.ui.tree.Tree({
                value: "Root",
                kids : [
                    "Item 1",
                    "Item 2",
                    "Item 3"
                ]
            });

            // make all tree items editable with text field component
            tree.setEditorProvider(new zebkit.ui.tree.DefEditors());

     * One more tree  component implementation - "CompTree" - allows developers
     * to create tree whose nodes are  other UI components

            // create tree component instance to visualize the given tree model
            var tree = new zebkit.ui.tree.CompTree({
                value: new zebkit.ui.Label("Root label item"),
                kids : [
                    new zebkit.ui.Checkbox("Checkbox Item"),
                    new zebkit.ui.Button("Button Item"),
                    new zebkit.ui.TextField("Text field item")
                ]
            });

     * @class zebkit.ui.tree
     * @access package
     */

    //  tree node metrics:
    //   |
    //   |-- <-gapx-> {icon} -- <-gapx-> {view}
    //

    /**
     * Simple private structure to keep a tree model item metrical characteristics
     * @constructor
     * @param {Boolean} b a state of an appropriate tree component node of the given
     * tree model item. The state is sensible for item that has children items and
     * the state indicates if the given tree node is collapsed (false) or expanded
     * (true)
     * @private
     * @class zebkit.ui.tree.$IM
     */
    pkg.$IM = function(b) {
        /**
         *  The whole width of tree node that includes a rendered item preferred
         *  width, all icons and gaps widths
         *  @attribute width
         *  @type {Integer}
         *  @readOnly
         */

        /**
         *  The whole height of tree node that includes a rendered item preferred
         *  height, all icons and gaps heights
         *  @attribute height
         *  @type {Integer}
         *  @readOnly
         */

        /**
         *  Width of an area of rendered tree model item. It excludes icons, toggle
         *  and gaps widths
         *  @attribute viewWidth
         *  @type {Integer}
         *  @readOnly
         */

        /**
         *  Height of an area of rendered tree model item. It excludes icons, toggle
         *  and gaps heights
         *  @attribute viewHeight
         *  @type {Integer}
         *  @readOnly
         */

        /**
         *  Indicates whether a node is in expanded or collapsed state
         *  @attribute isOpen
         *  @type {Boolean}
         *  @readOnly
         */

        this.width = this.height = this.x = this.y = this.viewHeight = 0;
        this.viewWidth = -1;
        this.isOpen = b;
    };

    /**
     * Default tree editor provider
     * @constructor
     * @class zebkit.ui.tree.DefEditors
     */
    pkg.DefEditors = Class([
        function() {
            /**
             * Internal component that are designed as default editor component
             * @private
             * @readOnly
             * @attribute tf
             * @type {zebkit.ui.TextField}
             */
            this.tf = new this.clazz.TextField(new zebkit.data.SingleLineTxt(""));
        },

        function $clazz() {
            this.TextField = Class(ui.TextField, []);
        },

        function $prototype() {
            /**
             * Get an UI component to edit the given tree model element
             * @param  {zebkit.ui.tree.Tree} src a tree component
             * @param  {zebkit.data.Item} item an data model item
             * @return {zebkit.ui.Panel} an editor UI component
             * @method getEditor
             */
            this.getEditor = function(src, item){
                var o = item.value;
                this.tf.setValue(o === null ? "" : o.toString());
                return this.tf;
            };

            /**
             * Fetch a model item from the given UI editor component
             * @param  {zebkit.ui.tree.Tree} src a tree UI component
             * @param  {zebkit.ui.Panel} editor an editor that has been used to edit the tree model element
             * @return {Object} an new tree model element value fetched from the given UI editor component
             * @method fetchEditedValue
             */
            this.fetchEditedValue = function(src, editor){
                return editor.view.target.getValue();
            };

            /**
             * The method is called to ask if the given input event should trigger an tree component item
             * @param  {zebkit.ui.tree.Tree} src a tree UI component
             * @param  {zebkit.ui.PointerEvent|zebkit.ui.KeyEvent} e   an input event: pointer or key event
             * @return {Boolean} true if the event should trigger edition of a tree component item
             * @method @shouldStartEdit
             */
            this.shouldStartEdit = function(src,e){
                return  e.id === "pointerDoubleClicked" ||
                       (e.id === "keyPressed" && e.code === "Enter");
            };
        }
    ]);

    /**
     * Default tree editor view provider
     * @class zebkit.ui.tree.DefViews
     * @constructor
     * @param {String} [color] the tree item text color
     * @param {String} [font] the tree item text font
     */
    pkg.DefViews = Class([
        function(color, font) {
            /**
             * Default tree item render
             * @attribute render
             * @readOnly
             * @type {zebkit.ui.StringRender}
             */
            this.render = new ui.StringRender("");

            zebkit.properties(this, this.clazz);

            if (arguments.length > 0 && color !== null) {
                this.setColor(color);
            }

            if (arguments.length > 1 && font !== null) {
                this.setFont(font);
            }
        },

        function $prototype() {
            /**
             * Get a view for the given model item of the UI tree component
             * @param  {zebkit.ui.tree.Tree} tree  a tree component
             * @param  {zebkit.data.Item} item a tree model element
             * @return {zebkit.ui.View}  a view to visualize the given tree data model element
             * @method  getView
             */
            this.getView = function (tree, item){
                if (item.value && typeof item.value.paint !== 'undefined') {
                    return item.value;
                }
                this.render.setValue(item.value === null ? "<null>" : item.value);
                return this.render;
            };

            /**
             * Set the default view provider text render font
             * @param {zebkit.ui.Font} f a font
             * @method setFont
             * @chainable
             */
            this.setFont = function(f) {
                this.render.setFont(f);
                return this;
            };

            /**
             * Set the default view provider text render color
             * @param {String} c a color
             * @method setColor
             * @chainable
             */
            this.setColor = function(c) {
                this.render.setColor(c);
                return this;
            };
        }
    ]);


    /**
     * Abstract tree component that can used as basement for building own tree components.
     * The component is responsible for rendering tree, calculating tree nodes metrics,
     * computing visible area, organizing basic user interaction. Classes that inherit it
     * has to provide the following important things:

        * **A tree model item metric** Developers have to implement "getItemPreferredSize(item)"
          method to say which size the given tree item wants to have.
        * **Tree node item rendering** If necessary developers have to implement the way
          a tree item has to be visualized by implementing "this.paintItem(...)" method

     *
     * @class zebkit.ui.tree.BaseTree
     * @constructor
     * @param {zebkit.data.TreeModel|Object} a tree model. It can be an instance of tree model
     * class or an object that described tree model. An example of such object is shown below:

            {
                value : "Root",
                kids  : [
                    {
                        value: "Child 1",
                        kids :[
                            "Sub child 1"
                        ]
                    },
                    "Child 2",
                    "Child 3"
                ]
            }

     * @param {Boolean} [nodeState] a default tree nodes state (expanded or collapsed)
     * @extends {zebkit.ui.Panel}
     */

     /**
      * Fired when a tree item has been toggled

            tree.on("toggled", function(src, item) {
               ...
            });

      * @event toggled
      * @param  {zebkit.ui.tree.BaseTree} src a tree component that triggers the event
      * @param  {zebkit.data.Item} item an tree item that has been toggled
      */

     /**
      * Fired when a tree item has been selected

          tree.on("selected", function(src, prevItem) {
             ...
          });

      * @event selected
      * @param  {zebkit.ui.tree.BaseTree} src a tree component that triggers the event
      * @param  {zebkit.data.Item} prevItem a previously selected tree item
      */


    /**
      * Fired when a tree item editing has been started

          tree.on("editingStarted", function(src, item, editor) {
             ...
          });

      * @event editingStarted
      * @param  {zebkit.ui.tree.BaseTree} src an tree component that triggers the event
      * @param  {zebkit.data.Item} item a tree item to be edited
      * @param  {zebkit.ui.Panel} editor an editor to be used to edit the given item
      */

    /**
      * Fired when a tree item editing has been stopped

          tree.on("editingStopped", function(src, item, oldValue, editor, isApplied) {
             ...
          });

      * @event editingStopped
      * @param  {zebkit.ui.tree.BaseTree} src a tree component that triggers the event
      * @param  {zebkit.data.Item} item a tree item that has been edited
      * @param  {Object} oldValue an old value of the edited tree item
      * @param  {zebkit.ui.Panel} editor an editor to be used to edit the given item
      * @param  {Boolean} isApplied flag that indicates if the edited value has been
      * applied to the given tree item
      */
    pkg.BaseTree = Class(ui.Panel, [
        function (d, b){
            if (arguments.length < 2) {
                b = true;
            }

            this.maxw = this.maxh = 0;

            this.views     = {};
            this.viewSizes = {};

            this._isVal = false;
            this.nodes = {};
            this._ = new this.clazz.Listeners();
            this.setLineColor("gray");

            this.isOpenVal = b;

            this.setSelectable(true);
            this.$super();
            this.setModel(d);
            this.scrollManager = new ui.ScrollManager(this);
        },

        function  $clazz() {
            this.Listeners = zebkit.util.ListenersClass("toggled",
                                                        "selected",
                                                        "editingStarted",
                                                        "editingStopped");
        },

        function $prototype() {
             /**
              * Tree component line color
              * @attribute lnColor
              * @type {String}
              * @readOnly
              */
            this.visibleArea = this.lnColor = null;

             /**
              * Selected tree model item
              * @attribute selected
              * @type {zebkit.data.Item}
              * @default null
              * @readOnly
              */
            this.model = this.selected = this.firstVisible = null;

            /**
             * Horizontal gap between a node elements: toggle, icons and tree item view
             * @attribute gapx
             * @readOnly
             * @default 2
             * @type {Integer}
             */

            /**
             * Vertical gap between a node elements: toggle, icons and tree item view
             * @attribute gapy
             * @readOnly
             * @default 2
             * @type {Integer}
             */

            this.gapx = this.gapy = 2;
            this.canHaveFocus = true;

            /**
             * Test if the given tree component item is opened
             * @param  {zebkit.data.Item}  i a tree model item
             * @return {Boolean} true if the given tree component item is opened
             * @method isOpen
             */
            this.isOpen = function(i){
                this.validate();
                return this.$isOpen(i);
            };

            /**
             * Get calculated for the given tree model item metrics
             * @param  {zebkit.data.Item} i a tree item
             * @return {Object}   an tree model item metrics. Th
             * @method getItemMetrics
             */
            this.getItemMetrics = function(i){
                this.validate();
                return this.getIM(i);
            };

            this.togglePressed = function(root) {
                this.toggle(root);
            };

            this.itemPressed = function(root, e) {
                this.select(root);
            };

            this.pointerPressed = function(e){
                if (this.firstVisible !== null && e.isAction()) {
                    var x = e.x,
                        y = e.y,
                        root = this.getItemAt(this.firstVisible, x, y);

                    if (root !== null) {
                        x -= this.scrollManager.getSX();
                        y -= this.scrollManager.getSY();
                        var r = this.getToggleBounds(root);

                        if (x >= r.x && x < r.x + r.width && y >= r.y && y < r.y + r.height){
                            this.togglePressed(root);
                        } else {
                            if (x > r.x + r.width) this.itemPressed(root, e);
                        }
                    }
                }
            };

            this.vVisibility = function (){
                if (this.model === null) {
                    this.firstVisible = null;
                }
                else {
                    var nva = ui.$cvp(this, {});
                    if (nva === null) {
                        this.firstVisible = null;
                    } else {
                        if (this._isVal === false ||
                            (this.visibleArea === null              ||
                             this.visibleArea.x !== nva.x           ||
                             this.visibleArea.y !== nva.y           ||
                             this.visibleArea.width !== nva.width   ||
                             this.visibleArea.height !== nva.height   ))
                        {
                            this.visibleArea = nva;
                            if (this.firstVisible !== null) {
                                this.firstVisible = this.findOpened(this.firstVisible);
                                this.firstVisible = this.isOverVisibleArea(this.firstVisible) ? this.nextVisible(this.firstVisible)
                                                                                              : this.prevVisible(this.firstVisible);
                            } else {
                                this.firstVisible = (-this.scrollManager.getSY() > Math.floor(this.maxh / 2)) ? this.prevVisible(this.findLast(this.model.root))
                                                                                                              : this.nextVisible(this.model.root);
                            }
                        }
                    }
                }
                this._isVal = true;
            };

            this.recalc = function() {
                this.maxh = this.maxw = 0;
                if (this.model !== null && this.model.root !== null) {
                    this.$recalc(this.getLeft(), this.getTop(), null, this.model.root, true);
                    this.maxw -= this.getLeft();
                    this.maxh -= this.gapy;
                }
            };

            /**
             * Get tree model item  metrical bounds (location and size).
             * @param  {zebkit.data.Item} root an tree model item
             * @return {Object} a structure that keeps an item view location
             * and size:

                    {
                        x: {Integer},
                        y: {Integer},
                        width: {Integer},
                        height: {Integer}
                    }

             * @method getItemBounds
             * @protected
             */
            this.getItemBounds = function(root){
                var metrics = this.getIM(root),
                    toggle  = this.getToggleBounds(root),
                    image   = this.getIconBounds(root);

                toggle.x = image.x + image.width + (image.width > 0 || toggle.width > 0 ? this.gapx : 0);
                toggle.y = metrics.y + Math.floor((metrics.height - metrics.viewHeight) / 2);
                toggle.width = metrics.viewWidth;
                toggle.height = metrics.viewHeight;
                return toggle;
            };

            /**
             * Get toggle element bounds for the given tree model item.
             * @param  {zebkit.data.Item} root an tree model item
             * @return {Object} a structure that keeps an item toggle location
             * and size:
             *
             *     {
             *         x: {Integer},
             *         y: {Integer},
             *         width: {Integer},
             *         height: {Integer}
             *     }
             *
             * @method getToggleBounds
             * @protected
             */
            this.getToggleBounds = function(root){
                var node = this.getIM(root), d = this.getToggleSize(root);
                return { x     : node.x,
                         y     : node.y + Math.floor((node.height - d.height) / 2),
                         width : d.width,
                         height: d.height };
            };

            /**
             * Get current toggle element view. The view depends on the state of tree item.
             * @param  {zebkit.data.Item} i a tree model item
             * @protected
             * @return {zebkit.ui.View}  a toggle element view
             * @method getToogleView
             */
            this.getToggleView = function(i){
                var v = i.kids.length > 0 ? (this.getIM(i).isOpen ? this.views.on
                                                                  : this.views.off) : null;

                return (typeof v === 'undefined' ? null : v);
            };

            /**
             * An abstract method that a concrete tree component implementations have to
             * override. The method has to return a preferred size the given tree model
             * item wants to have.
             * @param  {zebkit.data.Item} root an tree model item
             * @return {Object} a structure that keeps an item preferred size:
             *
             *     {
             *          width: {Integer},
             *          height: {Integer}
             *     }
             *
             * @method getItemPreferredSize
             * @protected
             */
            this.getItemPreferredSize = function(root) {
                throw new Error("Not implemented");
            };

            /**
             * An abstract method that a concrete tree component implementations should
             * override. The method has to render the given tree node of the specified
             * tree model item at the given location
             * @param  {CanvasRenderingContext2D} g a graphical context
             * @param  {zebkit.data.Item} root a tree model item to be rendered
             * @param  {zebkit.ui.tree.$IM} node a tree node metrics
             * @param  {Ineteger} x a x location where the tree node has to be rendered
             * @param  {Ineteger} y a y location where the tree node has to be rendered
             * @method paintItem
             * @protected
             */
            this.$recalc = function (x,y,parent,root,isVis){
                var node = this.getIM(root);
                if (isVis === true) {
                    if (node.viewWidth < 0) {
                        var viewSize = this.getItemPreferredSize(root);
                        node.viewWidth  = viewSize.width;
                        node.viewHeight = viewSize.height;
                    }

                    var imageSize = this.getIconSize(root),
                        toggleSize = this.getToggleSize(root);

                    if (parent !== null){
                        var pImg = this.getIconBounds(parent);
                        x = pImg.x + Math.floor((pImg.width - toggleSize.width) / 2);
                    }

                    node.x = x;
                    node.y = y;
                    node.width = toggleSize.width + imageSize.width +
                                 node.viewWidth + (toggleSize.width > 0 ? this.gapx : 0) + 10 +
                                                  (imageSize.width  > 0 ? this.gapx : 0);

                    node.height = Math.max(((toggleSize.height > imageSize.height) ? toggleSize.height
                                                                                   : imageSize.height),
                                            node.viewHeight);

                    if (node.x + node.width > this.maxw) {
                        this.maxw = node.x + node.width;
                    }

                    this.maxh += (node.height + this.gapy);
                    x = node.x + toggleSize.width + (toggleSize.width > 0 ? this.gapx : 0);
                    y += (node.height + this.gapy);
                }

                var b = node.isOpen && isVis === true;
                if (b) {
                    var count = root.kids.length;
                    for(var i = 0; i < count; i++) {
                        y = this.$recalc(x, y, root, root.kids[i], b);
                    }
                }
                return y;
            };

            this.$isOpen = function(i) {
                return i === null || (i.kids.length > 0 && this.getIM(i).isOpen && this.$isOpen(i.parent));
            };

            /**
             * Get a tree node metrics by the given tree model item.
             * @param  {zebkit.data.Item} item a tree model item
             * @return {zebkit.ui.tree.$IM} a tree node metrics
             * @protected
             * @method getIM
             */
            this.getIM = function (item) {
                if (this.nodes.hasOwnProperty(item.$hash$) === false){
                    var node = new pkg.$IM(this.isOpenVal);
                    this.nodes[item.$hash$] = node;
                    return node;
                }
                return this.nodes[item.$hash$];
            };

            /**
             * Get a tree item that is located at the given location.
             * @param  {zebkit.data.Item} [root] a starting tree node
             * @param  {Integer} x a x coordinate
             * @param  {Integer} y a y coordinate
             * @return {zebkit.data.Item} a tree model item
             * @method getItemAt
             */
            this.getItemAt = function(root, x, y){
                this.validate();

                if (arguments.length < 3) {
                    x = arguments[0];
                    y = arguments[1];
                    root = this.model.root;
                }

                if (this.firstVisible !== null && y >= this.visibleArea.y && y < this.visibleArea.y + this.visibleArea.height){
                    var dx    = this.scrollManager.getSX(),
                        dy    = this.scrollManager.getSY(),
                        found = this.getItemAtInBranch(root, x - dx, y - dy);

                    if (found !== null) return found;

                    var parent = root.parent;
                    while (parent !== null) {
                        var count = parent.kids.length;
                        for(var i = parent.kids.indexOf(root) + 1;i < count; i ++ ){
                            found = this.getItemAtInBranch(parent.kids[i], x - dx, y - dy);
                            if (found !== null) return found;
                        }
                        root = parent;
                        parent = root.parent;
                    }
                }
                return null;
            };

            this.getItemAtInBranch = function(root,x,y){
                if (root !== null) {
                    var node = this.getIM(root);
                    if (x >= node.x && y >= node.y && x < node.x + node.width && y < node.y + node.height + this.gapy) {
                        return root;
                    }

                    if (this.$isOpen(root)) {
                        for(var i = 0;i < root.kids.length; i++) {
                            var res = this.getItemAtInBranch(root.kids[i], x, y);
                            if (res !== null) return res;
                        }
                    }
                }
                return null;
            };

            this.getIconView = function (i){
                return i.kids.length > 0 ? (this.getIM(i).isOpen ? this.views.open
                                                                 : this.views.close)
                                         : this.views.leaf;
            };

            this.getIconSize = function (i) {
                return i.kids.length > 0 ? (this.getIM(i).isOpen ? this.viewSizes.open
                                                                 : this.viewSizes.close)
                                          : this.viewSizes.leaf;
            };

            /**
             * Get icon element bounds for the given tree model item.
             * @param  {zebkit.data.Item} root an tree model item
             * @return {Object} a structure that keeps an item icon location
             * and size:
             *
             *     {
             *         x: {Integer},
             *         y: {Integer},
             *         width: {Integer},
             *         height: {Integer}
             *     }
             *
             * @method getToggleBounds
             * @protected
             */
            this.getIconBounds = function(root) {
                var node = this.getIM(root),
                    id   = this.getIconSize(root),
                    td   = this.getToggleSize(root);
                return { x:node.x + td.width + (td.width > 0 ? this.gapx : 0),
                         y:node.y + Math.floor((node.height - id.height) / 2),
                         width:id.width, height:id.height };
            };

            this.getToggleSize = function(i) {
                return this.$isOpen(i) ? this.viewSizes.on : this.viewSizes.off;
            };

            this.isOverVisibleArea = function (i) {
                var node = this.getIM(i);
                return node.y + node.height + this.scrollManager.getSY() < this.visibleArea.y;
            };

            this.findOpened = function(item) {
                var parent = item.parent;
                return (parent === null || this.$isOpen(parent)) ? item : this.findOpened(parent);
            };

            this.findNext = function(item) {
                if (item !== null){
                    if (item.kids.length > 0 && this.$isOpen(item)){
                        return item.kids[0];
                    }
                    var parent = null;
                    while ((parent = item.parent) !== null){
                        var index = parent.kids.indexOf(item);
                        if (index + 1 < parent.kids.length) return parent.kids[index + 1];
                        item = parent;
                    }
                }
                return null;
            };

            this.findPrev = function (item){
                if (item !== null) {
                    var parent = item.parent;
                    if (parent !== null) {
                        var index = parent.kids.indexOf(item);
                        return (index - 1 >= 0) ? this.findLast(parent.kids[index - 1]) : parent;
                    }
                }
                return null;
            };

            this.findLast = function (item){
                return this.$isOpen(item) && item.kids.length > 0 ? this.findLast(item.kids[item.kids.length - 1])
                                                                  : item;
            };

            this.prevVisible = function (item){
                if (item === null || this.isOverVisibleArea(item)) {
                    return this.nextVisible(item);
                }

                var parent = null;
                while((parent = item.parent) !== null){
                    for(var i = parent.kids.indexOf(item) - 1;i >= 0; i-- ){
                        var child = parent.kids[i];
                        if (this.isOverVisibleArea(child)) return this.nextVisible(child);
                    }
                    item = parent;
                }
                return item;
            };

            this.isVerVisible = function (item){
                if (this.visibleArea === null) {
                    return false;
                }

                var node = this.getIM(item),
                    yy1  = node.y + this.scrollManager.getSY(),
                    yy2  = yy1 + node.height - 1,
                    by   = this.visibleArea.y + this.visibleArea.height;

                return ((this.visibleArea.y <= yy1 && yy1 < by) ||
                        (this.visibleArea.y <= yy2 && yy2 < by) ||
                        (this.visibleArea.y > yy1 && yy2 >= by)    );
            };

            this.nextVisible = function(item){
                if (item === null || this.isVerVisible(item) === true) {
                    return item;
                }

                var res = this.nextVisibleInBranch(item), parent = null;
                if (res !== null) {
                    return res;
                }

                while ((parent = item.parent) !== null){
                    var count = parent.kids.length;
                    for(var i = parent.kids.indexOf(item) + 1;i < count; i++){
                        res = this.nextVisibleInBranch(parent.kids[i]);
                        if (res !== null) return res;
                    }
                    item = parent;
                }
                return null;
            };

            this.nextVisibleInBranch = function (item){
                if (this.isVerVisible(item)) return item;
                if (this.$isOpen(item)){
                    for(var i = 0;i < item.kids.length; i++){
                        var res = this.nextVisibleInBranch(item.kids[i]);
                        if (res !== null) return res;
                    }
                }
                return null;
            };

            this.paintSelectedItem = function(g, root, node, x, y) {
                var v = this.hasFocus() ? this.views.aselect : this.views.iselect;
                if (v !== null && typeof v !== 'undefined') {
                    v.paint(g, x, y, node.viewWidth, node.viewHeight, this);
                }
            };

            this.paintTree = function (g,item){
                this.paintBranch(g, item);
                var parent = null;
                while( (parent = item.parent) !== null){
                    this.paintChild(g, parent, parent.kids.indexOf(item) + 1);
                    item = parent;
                }
            };

            this.paintBranch = function (g, root){
                if (root === null) return false;

                var node = this.getIM(root),
                    dx   = this.scrollManager.getSX(),
                    dy   = this.scrollManager.getSY();

                if (zebkit.util.isIntersect(node.x + dx, node.y + dy,
                                           node.width, node.height,
                                           this.visibleArea.x, this.visibleArea.y,
                                           this.visibleArea.width, this.visibleArea.height))
                {
                    var toggle     = this.getToggleBounds(root),
                        toggleView = this.getToggleView(root),
                        image      = this.getIconBounds(root),
                        vx         = image.x + image.width + this.gapx,
                        vy         = node.y + Math.floor((node.height - node.viewHeight) / 2);

                    if (toggleView !== null) {
                        toggleView.paint(g, toggle.x, toggle.y, toggle.width, toggle.height, this);
                    }

                    if (image.width > 0) {
                        this.getIconView(root).paint(g, image.x, image.y,
                                                     image.width, image.height, this);
                    }

                    if (this.selected === root){
                        this.paintSelectedItem(g, root, node, vx, vy);
                    }

                    if (typeof this.paintItem !== 'undefined') {
                        this.paintItem(g, root, node, vx, vy);
                    }

                    if (this.lnColor !== null){
                        g.setColor(this.lnColor);
                        var yy = toggle.y + Math.floor(toggle.height / 2) + 0.5;

                        g.beginPath();
                        g.moveTo(toggle.x + (toggleView === null ? Math.floor(toggle.width / 2)
                                                                 : toggle.width - 1), yy);
                        g.lineTo(image.x, yy);
                        g.stroke();
                    }
                } else {
                    if (node.y + dy > this.visibleArea.y + this.visibleArea.height ||
                        node.x + dx > this.visibleArea.x + this.visibleArea.width    )
                    {
                        return false;
                    }
                }
                return this.paintChild(g, root, 0);
            };

            this.$y = function (item, isStart){
                var node = this.getIM(item),
                    th = this.getToggleSize(item).height,
                    ty = node.y + Math.floor((node.height - th) / 2),
                    dy = this.scrollManager.getSY(),
                    y  = (item.kids.length > 0) ? (isStart ? ty + th : ty - 1)
                                                : ty + Math.floor(th / 2);

                return (y + dy < 0) ?  -dy - 1
                                    : ((y + dy > this.height) ? this.height - dy : y);
            };

            /**
             * Paint children items of the given root tree item.
             * @param  {CanvasRenderingContext2D} g a graphical context
             * @param  {zebkit.data.Item} root a root tree item
             * @param  {Integer} index an index
             * @return {Boolean}
             * @protected
             * @method paintChild
             */
            this.paintChild = function (g, root, index){
                var b = this.$isOpen(root);
                if (root === this.firstVisible && this.lnColor !== null) {
                    g.setColor(this.lnColor);
                    var xx = this.getIM(root).x + Math.floor((b ? this.viewSizes.on.width
                                                                : this.viewSizes.off.width) / 2);
                    g.beginPath();
                    g.moveTo(xx + 0.5, this.getTop());
                    g.lineTo(xx + 0.5, this.$y(root, false));
                    g.stroke();
                }
                if (b === true && root.kids.length > 0){
                    var firstChild = root.kids.length > 0 ?root.kids[0] : null;
                    if (firstChild === null) {
                        return true;
                    }

                    var x = this.getIM(firstChild).x + Math.floor((this.$isOpen(firstChild) ? this.viewSizes.on.width
                                                                                            : this.viewSizes.off.width) / 2),
                    count = root.kids.length;
                    if (index < count) {
                        var  node = this.getIM(root),
                             y    = (index > 0) ? this.$y(root.kids[index - 1], true)
                                                : node.y + Math.floor((node.height + this.getIconSize(root).height) / 2);

                        for(var i = index;i < count; i++ ) {
                            var child = root.kids[i];
                            if (this.lnColor !== null){
                                g.setColor(this.lnColor);
                                g.beginPath();
                                g.moveTo(x + 0.5, y);
                                g.lineTo(x + 0.5, this.$y(child, false));
                                g.stroke();
                                y = this.$y(child, true);
                            }
                            if (this.paintBranch(g, child) === false){
                                if (this.lnColor !== null && i + 1 !== count){
                                    g.setColor(this.lnColor);
                                    g.beginPath();
                                    g.moveTo(x + 0.5, y);
                                    g.lineTo(x + 0.5, this.height - this.scrollManager.getSY());
                                    g.stroke();
                                }
                                return false;
                            }
                        }
                    }
                }
                return true;
            };

            this.nextPage = function (item,dir){
                var sum = 0, prev = item;
                while (item !== null && sum < this.visibleArea.height){
                    sum += (this.getIM(item).height + this.gapy);
                    prev = item;
                    item = dir < 0 ? this.findPrev(item) : this.findNext(item);
                }
                return prev;
            };

            this.paint = function(g){
                if (this.model !== null){
                    this.vVisibility();
                    if (this.firstVisible !== null){
                        var sx = this.scrollManager.getSX(), sy = this.scrollManager.getSY();
                        try {
                            g.translate(sx, sy);
                            this.paintTree(g, this.firstVisible);
                            g.translate(-sx,  -sy);
                        } catch(e) {
                            g.translate(-sx,  -sy);
                            throw e;
                        }
                    }
                }
            };

            /**
             * Select the given item.
             * @param  {zebkit.data.Item} an item to be selected. Use null value to clear any selection
             * @method  select
             */
            this.select = function(item){
                if (this.isSelectable === true){
                    var old = this.selected, m = null;

                    this.selected = item;
                    if (this.selected !== null) {
                        this.makeVisible(this.selected);
                    }

                    this._.selected(this, old);

                    if (old !== null && this.isVerVisible(old)) {
                        m = this.getItemMetrics(old);
                        this.repaint(m.x + this.scrollManager.getSX(),
                                     m.y + this.scrollManager.getSY(),
                                     m.width, m.height);
                    }

                    if (this.selected !== null && this.isVerVisible(this.selected)) {
                        m = this.getItemMetrics(this.selected);
                        this.repaint(m.x + this.scrollManager.getSX(),
                                     m.y + this.scrollManager.getSY(),
                                     m.width, m.height);
                    }
                }
            };

            /**
             * Make the given tree item visible. Tree component rendered content can takes more space than
             * the UI component size is. In this case the content can be scrolled to make visible required
             * tree item.
             * @param  {zebkit.data.Item} item an item to be visible
             * @method makeVisible
             */
            this.makeVisible = function(item){
                this.validate();
                var r = this.getItemBounds(item);
                this.scrollManager.makeVisible(r.x, r.y, r.width, r.height);
            };

            /**
             * Toggle off or on recursively all items of the given item
             * @param  {zebkit.data.Item} root a starting item to toggle
             * @param  {Boolean} b  true if all items have to be in opened
             * state and false otherwise
             * @method toggleAll
             * @chainable
             */
            this.toggleAll = function (root,b){
                var model = this.model;
                if (root.kids.length > 0){
                    if (this.getItemMetrics(root).isOpen !== b) this.toggle(root);
                    for(var i = 0; i < root.kids.length; i++ ){
                        this.toggleAll(root.kids[i], b);
                    }
                }
                return this;
            };

            /**
             * Toggle the given tree item
             * @param  {zebkit.data.Item} item an item to be toggled
             * @method toggle
             * @chainable
             */
            this.toggle = function(item){
                if (item.kids.length > 0){
                    this.validate();
                    var node = this.getIM(item);
                    node.isOpen = (node.isOpen ? false : true);
                    this.invalidate();
                    this._.toggled(this, item);

                    if (!node.isOpen && this.selected !== null){
                        var parent = this.selected;
                        do {
                            parent = parent.parent;
                        } while (parent !== item && parent !== null);
                        if (parent === item) this.select(item);
                    }

                    this.repaint();
                }
                return this;
            };

            this.itemInserted = function (model,item){
                this.vrp();
            };

            this.itemRemoved = function (model,item){
                if (item === this.firstVisible) {
                    this.firstVisible = null;
                }

                if (item === this.selected) {
                    this.select(null);
                }

                delete this.nodes[item];
                this.vrp();
            };

            this.itemModified = function (model, item, prevValue){
                var node = this.getIM(item);
                // invalidate an item metrics
                if (node !== null) {
                    node.viewWidth = -1;
                }
                this.vrp();
            };

            this.calcPreferredSize = function (target){
                return this.model === null ? { width:0, height:0 }
                                           : { width:this.maxw, height:this.maxh };
            };
        },

        function focused(){
            this.$super();
            if (this.selected !== null) {
                var m = this.getItemMetrics(this.selected);
                this.repaint(m.x + this.scrollManager.getSX(),
                             m.y + this.scrollManager.getSY(), m.width, m.height);
            }
        },
        /**
         * Say if items of the tree component should be selectable
         * @param {Boolean} b true is tree component items can be selected
         * @method setSelectable
         */
        function setSelectable(b){
            if (this.isSelectable !== b){
                if (b === false && this.selected !== null) this.select(null);
                this.isSelectable = b;
                this.repaint();
            }
            return this;
        },

        /**
         * Set tree component connector lines color
         * @param {String} c a color
         * @method setLineColor
         * @chainable
         */
        function setLineColor(c){
            this.lnColor = c;
            this.repaint();
            return this;
        },

        /**
         * Set the given horizontal gaps between tree node graphical elements:
         * toggle, icon, item view
         * @param {Integer} gx horizontal gap
         * @param {Integer} gy vertical gap
         * @method setGaps
         * @chainable
         */
        function setGaps(gx, gy){
            if (gx !== this.gapx || gy !== this.gapy){
                this.gapx = gx;
                this.gapy = gy;
                this.vrp();
            }
            return this;
        },

        /**
         * Set the number of views to customize rendering of different visual elements of the tree
         * UI component. The following decorative elements can be customized:
         *
         *   - **"close"** - closed tree item icon view
         *   - **"open"**  - opened tree item icon view
         *   - **"leaf"**  - leaf tree item icon view
         *   - **"on"**    - toggle on view
         *   - **"off"**   - toggle off view
         *   - **"iselect"**   - a view to express an item selection when tree component doesn't hold focus
         *   - **"aselect"**   - a view to express an item selection when tree component holds focus
         *
         * For instance:

            // build tree UI component
            var tree = new zebkit.ui.tree.Tree({
                value: "Root",
                kids: [
                    "Item 1",
                    "Item 2"
                ]
            });

            // set " [x] " text render for toggle on and
            // " [o] " text render for toggle off tree elements
            tree.setViews({
                "on": new zebkit.ui.TextRender(" [x] "),
                "off": new zebkit.ui.TextRender(" [o] ")
            });

         * @param {Object} v dictionary of tree component decorative elements views
         * @method setViews
         * @chainable
         */
        function setViews(v) {
            // setting to 0 prevents exception when on/off view is not defined
            this.viewSizes.on    = { width: 0, height : 0};
            this.viewSizes.off   = { width: 0, height : 0};
            this.viewSizes.open  = { width: 0, height : 0};
            this.viewSizes.close = { width: 0, height : 0};
            this.viewSizes.leaf  = { width: 0, height : 0};
            for(var k in v) {
                if (v.hasOwnProperty(k)) {
                    var vv = ui.$view(v[k]);

                    this.views[k] = vv;
                    if (k !== "aselect" && k !== "iselect"){
                        this.viewSizes[k] = vv ? vv.getPreferredSize() : { width: 0, height : 0};
                        this.vrp();
                    }
                }
            }
            return this;
        },

        /**
         * Set the given tree model to be visualized with the UI component.
         * @param {zebkit.data.TreeModel|Object} d a tree model
         * @method setModel
         * @chainable
         */
        function setModel(d){
            if (this.model !== d) {
                if (zebkit.instanceOf(d, zebkit.data.TreeModel) === false) {
                    d = new zebkit.data.TreeModel(d);
                }

                this.select(null);
                if (this.model !== null && this.model._) this.model.off(this);
                this.model = d;
                if (this.model !== null && this.model._) this.model.on(this);
                this.firstVisible = null;
                delete this.nodes;
                this.nodes = {};
                this.vrp();
            }
            return this;
        },

        function invalidate(){
            if (this.isValid === true){
                this._isVal = false;
            }
            this.$super();
        }
    ]);


    var ui = pkg.cd("..");

    /**
     * Tree UI component that visualizes a tree data model. The model itself can be passed as JavaScript
     * structure or as a instance of zebkit.data.TreeModel. Internally tree component keeps the model always
     * as zebkit.data.TreeModel class instance:

         var tree = new zebkit.ui.tree.Tree({
              value: "Root",
              kids : [  "Item 1", "Item 2"]
         });

     * or

         var model = new zebkit.data.TreeModel("Root");
         model.add(model.root, "Item 1");
         model.add(model.root, "Item 2");

         var tree = new zebkit.ui.tree.Tree(model);

     * Tree model rendering is fully customizable by defining an own views provider. Default views
     * provider renders tree model item as text. The tree node can be made editable by defining an
     * editor provider. By default tree modes are not editable.
     * @class  zebkit.ui.tree.Tree
     * @constructor
     * @extends zebkit.ui.tree.BaseTree
     * @param {Object|zebkit.data.TreeModel} [model] a tree data model passed as JavaScript
     * structure or as an instance
     * @param {Boolean} [b] the tree component items toggle state. true to have all items
     * in opened state.
     */
    pkg.Tree = Class(pkg.BaseTree, [
        function (d, b){
            if (arguments.length < 2) {
                b  = true;
            }

            this.setViewProvider(new pkg.DefViews());
            this.$super(d, b);
        },

        function $prototype() {
            this.itemGapY = 2;
            this.itemGapX = 4;

            /**
             * A tree model editor provider
             * @readOnly
             * @attribute editors
             * @default null
             * @type {zebkit.ui.tree.DefEditors}
             */
            this.editors = null;

            /**
             * A tree model items view provider
             * @readOnly
             * @attribute provider
             * @default an instance of zebkit.ui.tree.DefsViews
             * @type {zebkit.ui.tree.DefsViews}
             */
            this.provider = this.editedItem = this.pressedItem = null;

            this.setFont = function(f) {
                this.provider.setFont(f);
                this.vrp();
                return this;
            };

            this.childKeyPressed = function(e){
                if (e.code === "Escape") {
                    this.stopEditing(false);
                } else {
                    if (e.code === "Enter" &&
                           ((zebkit.instanceOf(e.source, ui.TextField) === false) ||
                            (zebkit.instanceOf(e.source.view.target, zebkit.data.SingleLineTxt))))
                    {
                        this.stopEditing(true);
                    }
                }
            };

            this.catchScrolled = function (psx, psy){
                if (this.kids.length > 0) this.stopEditing(false);

                if (this.firstVisible === null) {
                    this.firstVisible = this.model.root;
                }
                this.firstVisible = (this.y < psy) ? this.nextVisible(this.firstVisible)
                                                   : this.prevVisible(this.firstVisible);
                this.repaint();
            };

            this.laidout = function() {
                this.vVisibility();
            };

            this.getItemPreferredSize = function(root) {
                var ps = this.provider.getView(this, root).getPreferredSize();
                ps.width  += this.itemGapX * 2;
                ps.height += this.itemGapY * 2;
                return ps;
            };

            this.paintItem = function(g, root, node, x, y) {
                if (root !== this.editedItem){
                    var v = this.provider.getView(this, root);
                    v.paint(g, x + this.itemGapX, y + this.itemGapY,
                            node.viewWidth, node.viewHeight, this);
                }
            };

            /**
             * Initiate the given item editing if the specified event matches condition
             * @param  {zebkit.data.Item} item an item to be edited
             * @param  {zebkit.util.Event} e an even that may trigger the item editing
             * @return {Boolean}  return true if an item editing process has been started,
             * false otherwise
             * @method  se
             * @private
             */
            this.se = function (item, e){
                if (item !== null){
                    this.stopEditing(true);
                    if (this.editors !== null && this.editors.shouldStartEdit(item, e)) {
                        this.startEditing(item);
                        return true;
                    }
                }
                return false;
            };

            this.pointerClicked = function(e){
                if (this.se(this.pressedItem, e)) {
                    this.pressedItem = null;
                }
            };

            this.pointerDoubleClicked = function(e) {
                if (this.se(this.pressedItem, e)) {
                    this.pressedItem = null;
                } else {
                    if (this.selected !== null &&
                        this.getItemAt(this.firstVisible, e.x, e.y) === this.selected)
                    {
                        this.toggle(this.selected);
                    }
                }
            };

            this.pointerReleased = function(e){
                if (this.se(this.pressedItem, e)) this.pressedItem = null;
            };

            this.keyTyped = function(e){
                if (this.selected !== null){
                    switch(e.key) {
                        case '+': if (this.isOpen(this.selected) === false) {
                            this.toggle(this.selected);
                        } break;
                        case '-': if (this.isOpen(this.selected)) {
                            this.toggle(this.selected);
                        } break;
                    }
                }
            };

            this.keyPressed = function(e){
                var newSelection = null;
                switch(e.code) {
                    case "ArrowDown" :
                    case "ArrowRight": newSelection = this.findNext(this.selected);break;
                    case "ArrowUp"   :
                    case "ArrowLeft" : newSelection = this.findPrev(this.selected);break;
                    case "Home"      : if (e.ctrlKey) this.select(this.model.root);break;
                    case "End"       : if (e.ctrlKey) this.select(this.findLast(this.model.root));break;
                    case "PageDown"  : if (this.selected !== null) this.select(this.nextPage(this.selected, 1));break;
                    case "PageUp"    : if (this.selected !== null) this.select(this.nextPage(this.selected,  -1));break;
                    //!!!!case "Enter": if(this.selected !== null) this.toggle(this.selected);break;
                }
                if (newSelection !== null) this.select(newSelection);
                this.se(this.selected, e);
            };

            /**
             * Start editing the given if an editor for the item has been defined.
             * @param  {zebkit.data.Item} item an item whose content has to be edited
             * @method startEditing
             * @protected
             */
            this.startEditing = function (item){
                this.stopEditing(true);
                if (this.editors !== null){
                    var editor = this.editors.getEditor(this, item);
                    if (editor !== null) {
                        this.editedItem = item;
                        var b  = this.getItemBounds(this.editedItem),
                            ps = editor.getPreferredSize();

                        editor.setBounds(b.x + this.scrollManager.getSX() + this.itemGapX,
                                         b.y - Math.floor((ps.height - b.height + 2 * this.itemGapY) / 2) +
                                         this.scrollManager.getSY() + this.itemGapY,
                                         ps.width, ps.height);

                        this.add(editor);
                        editor.requestFocus();
                        this._.editingStarted(this, item, editor);
                    }
                }
            };

            /**
             * Stop editing currently edited tree item and apply or discard the result of the
             * editing to tree data model.
             * @param  {Boolean} true if the editing result has to be applied to tree data model
             * @method stopEditing
             * @protected
             */
            this.stopEditing = function(applyData){
                if (this.editors !== null && this.editedItem !== null) {
                    var item     = this.editedItem,
                        oldValue = item.value,
                        editor   = this.kids[0];

                    try {
                        if (applyData)  {
                            this.model.setValue(this.editedItem,
                                                this.editors.fetchEditedValue(this.editedItem, this.kids[0]));
                        }
                    } finally {
                        this.editedItem = null;
                        this.removeAt(0);
                        this.requestFocus();
                        this._.editingStopped(this, item, oldValue, editor, applyData);
                    }
                }
            };
        },

        function toggle(item) {
            this.stopEditing(false);
            this.$super(item);
            return this;
        },

        function itemInserted(target,item){
            this.stopEditing(false);
            this.$super(target,item);
        },

        function itemRemoved(target,item){
            this.stopEditing(false);
            this.$super(target,item);
        },

        /**
         * Set the given editor provider. The editor provider is a class that is used to decide which UI
         * component has to be used as an item editor, how the editing should be triggered and how the
         * edited value has to be fetched from an UI editor.
         * @param {zebkit.ui.tree.DefEditors} p an editor provider
         * @method setEditorProvider
         */
        function setEditorProvider(p){
            if (p != this.editors){
                this.stopEditing(false);
                this.editors = p;
            }
            return this;
        },

        /**
         * Set tree component items view provider. Provider says how tree model items
         * have to be visualized.
         * @param {zebkit.ui.tree.DefViews} p a view provider
         * @method setViewProvider
         * @chainable
         */
        function setViewProvider(p){
            if (this.provider != p) {
                this.stopEditing(false);
                this.provider = p;
                delete this.nodes;
                this.nodes = {};
                this.vrp();
            }
            return this;
        },

        /**
         * Set the given tree model to be visualized with the UI component.
         * @param {zebkit.data.TreeModel|Object} d a tree model
         * @method setModel
         * @chainable
         */
        function setModel(d){
            this.stopEditing(false);
            this.$super(d);
            return this;
        },

        function paintSelectedItem(g, root, node, x, y) {
            if (root !== this.editedItem) {
                this.$super(g, root, node, x, y);
            }
        },

        function itemPressed(root, e) {
            this.$super(root, e);
            if (this.se(root, e) === false) this.pressedItem = root;
        },

        function pointerPressed(e){
            this.pressedItem = null;
            this.stopEditing(true);
            this.$super(e);
        }
    ]);


    var ui = pkg.cd("..");

    /**
     * Component tree component that expects other UI components to be a tree model values.
     * In general the implementation lays out passed via tree model UI components as tree
     * component nodes. For instance:

         var tree = new zebkit.ui.tree.Tree({
              value: new zebkit.ui.Label("Label root item"),
              kids : [
                    new zebkit.ui.Checkbox("Checkbox Item"),
                    new zebkit.ui.Button("Button item"),
                    new zebkit.ui.Combo(["Combo item 1", "Combo item 2"])
             ]
         });

     * But to prevent unexpected navigation it is better to use number of predefined
     * with component tree UI components:

       - zebkit.ui.tree.CompTree.Label
       - zebkit.ui.tree.CompTree.Checkbox
       - zebkit.ui.tree.CompTree.Combo

     * You can describe tree model keeping in mind special notation

         var tree = new zebkit.ui.tree.Tree({
              value: "Label root item",  // zebkit.ui.tree.CompTree.Label
              kids : [
                    "[ ] Checkbox Item 1", // unchecked zebkit.ui.tree.CompTree.Checkbox
                    "[x] Checkbox Item 2", // checked zebkit.ui.tree.CompTree.Checkbox
                    ["Combo item 1", "Combo item 2"] // zebkit.ui.tree.CompTree.Combo
             ]
         });

     *
     * @class  zebkit.ui.tree.CompTree
     * @constructor
     * @extends zebkit.ui.tree.BaseTree
     * @param {Object|zebkit.data.TreeModel} [model] a tree data model passed as JavaScript
     * structure or as an instance
     * @param {Boolean} [b] the tree component items toggle state. true to have all items
     * in opened state.
     */
    pkg.CompTree = Class(pkg.BaseTree, [
        function $clazz() {
            this.Label = Class(ui.Label, [
                function $prototype() {
                    this.canHaveFocus = true;
                }
            ]);

            this.Checkbox = Class(ui.Checkbox, []);

            this.Combo = Class(ui.Combo, [
                function keyPressed(e) {
                    if (e.code !== "ArrowUp" && e.code !== "ArrowDown") {
                        this.$super(e);
                    }
                }
            ]);

            this.createModel = function(item, root, tree) {
                var mi = new zebkit.data.Item();

                if (typeof item.value !== "undefined") {
                    mi.value = item.value !== null ? item.value : "";
                } else {
                    mi.value = item;
                }

                mi.value = ui.$component(mi.value, tree);
                mi.parent = root;
                if (typeof item.kids !== 'undefined' && item.kids.length > 0 && zebkit.instanceOf(item, ui.Panel) === false) {
                    for (var i = 0; i < item.kids.length; i++) {
                        mi.kids[i] = this.createModel(item.kids[i], mi, tree);
                    }
                }

                return mi;
            };
        },

        function $prototype() {
            this.$blockCIE = false;
            this.canHaveFocus = false;

            this.getItemPreferredSize = function(root) {
                return root.value.getPreferredSize();
            };

            this.childKeyTyped = function(e) {
                if (this.selected !== null){
                    switch(e.key) {
                        case '+': if (this.isOpen(this.selected) === false) {
                            this.toggle(this.selected);
                        } break;
                        case '-': if (this.isOpen(this.selected)) {
                            this.toggle(this.selected);
                        } break;
                    }
                }
            };

            this.setFont = function(f) {
                this.font = zebkit.isString(f) ? new zebkit.ui.Font(f) : f;
                return this;
            };

            this.childKeyPressed = function(e) {
                if (this.isSelectable === true){
                    var newSelection = (e.code === "ArrowDown") ? this.findNext(this.selected)
                                                                : (e.code === "ArrowUp") ? this.findPrev(this.selected)
                                                                                         : null;
                    if (newSelection !== null) {
                        this.select(newSelection);
                    }
                }
            };

            this.childPointerPressed = this.childFocusGained = function(e) {
                if (this.isSelectable === true && this.$blockCIE !== true) {
                    this.$blockCIE = true;
                    try {
                        var item = zebkit.data.TreeModel.findOne(this.model.root,
                                                                zebkit.layout.getDirectChild(this,
                                                                                            e.source));
                        if (item !== null) this.select(item);
                    } finally {
                        this.$blockCIE = false;
                    }
                }
            };

            this.childFocusLost = function(e) {
                if (this.isSelectable === true) {
                    this.select(null);
                }
            };

            this.catchScrolled = function(psx, psy){
                this.vrp();
            };

            this.doLayout = function() {
                this.vVisibility();

                // hide all components
                for(var i = 0; i < this.kids.length; i++) {
                    this.kids[i].setVisible(false);
                }

                if (this.firstVisible !== null) {
                    var $this = this,
                        fvNode = this.getIM(this.firstVisible),
                        started = 0;

                    this.model.iterate(this.model.root, function(item) {
                        var node = $this.nodes[item];  // slightly improve performance
                                                       // (instead of calling $this.getIM(...))

                        if (started === 0 && item === $this.firstVisible) {
                            started = 1;
                        }

                        if (started === 1) {
                            var sy = $this.scrollManager.getSY();

                            if (node.y + sy < $this.height) {
                                var image = $this.getIconBounds(item),
                                    x = image.x + image.width +
                                               (image.width > 0 || $this.getToggleSize(item).width > 0 ? $this.gapx : 0) +
                                               $this.scrollManager.getSX(),
                                    y = node.y + Math.floor((node.height - node.viewHeight) / 2) + sy;

                                item.value.setVisible(true);
                                item.value.setLocation(x, y);
                                item.value.width  = node.viewWidth;
                                item.value.height = node.viewHeight;
                            } else {
                                started = 2;
                            }
                        }

                        return (started === 2) ? 2 : (node.isOpen === false ? 1 : 0);
                    });
                }
            };

            this.itemInserted = function(target, item) {
                this.add(item.value);
            };
        },

        function itemRemoved(target,item){
            this.$super(target,item);
            this.remove(item.value);
        },

        function setModel(model) {
            var old = this.model;

            if (model !== null && zebkit.instanceOf(model, zebkit.data.TreeModel) === false) {
                model = new zebkit.data.TreeModel(this.clazz.createModel(model, null, this));
            }

            this.$super(model);

            if (old !== this.model) {
                this.removeAll();
                if (this.model !== null) {
                    var $this = this;
                    this.model.iterate(this.model.root, function(item) {
                        $this.add(item.value);
                    });
                }
            }
            return this;
        },

        function recalc() {
            // track with the flag a node metrics has been updated
            this.$isMetricUpdated  = false;
            this.$super();

            // if a node size has been changed we have to force calling
            // repaint method for the whole tree component to render
            // tree lines properly
            if (this.$isMetricUpdated === true) {
                this.repaint();
            }
        },

        function recalc_(x,y,parent,root,isVis) {
            // in a case of component tree node view size has to be synced with
            // component
            var node = this.getIM(root);
            if (isVis === true) {
                var viewSize = this.getItemPreferredSize(root);
                if (this.$isMetricUpdated === false && (node.viewWidth  !== viewSize.width  ||
                                                        node.viewHeight !== viewSize.height  ))
                {
                    this.$isMetricUpdated = true;
                }

                node.viewWidth  = viewSize.width;
                node.viewHeight = viewSize.height;
            }
            return this.$super(x,y,parent,root,isVis);
        },

        function select(item) {
            if (this.isSelectable === true) {
                var old = this.selected;

                if (old !== null && old.value.hasFocus()) {
                    ui.focusManager.requestFocus(null);
                }

                this.$super(item);

                if (item !== null) {
                    item.value.requestFocus();
                }
            }
        },

        function makeVisible(item) {
           item.value.setVisible(true);
           this.$super(item);
        }
    ]);


    zebkit.ui.$configWith(pkg);
});
zebkit.package("ui.grid", function(pkg, Class) {
    'use strict';
    var ui = pkg.cd("..");

    //      ---------------------------------------------------
    //      | x |    col0 width     | x |   col2 width    | x |
    //      .   .
    //    Line width
    //   -->.   .<--

    /**
     * The package contains number of classes and interfaces to implement
     * UI Grid component. The grid allows developers to visualize matrix
     * model, customize the model data editing and rendering.
     * @class zebkit.ui.grid
     * @access package
     */

    pkg.CellsVisibility = function() {
        this.hasVisibleCells = function(){
            return this.fr !== null && this.fc !== null &&
                   this.lr !== null && this.lc !== null   ;
        };

        // first visible row (row and y), first visible
        // col, last visible col and row
        this.fr = this.fc = this.lr = this.lc = null;
    };

    /**
     *  Interface that describes a grid component metrics
     *  @class zebkit.ui.grid.Metrics
     *  @interface zebkit.ui.grid.Metrics
     */
    pkg.Metrics = zebkit.Interface([
        "abstract",
            function getCellsVisibility() {},
            function getColWidth(col) {},
            function getRowHeight(row) {},
            function setRowHeight(row, height) {},
            function setColWidth(col, width) {}
    ]);

    /**
     * Get the given column width of a grid component
     * @param {Integer} col a column index
     * @method getColWidth
     * @return {Integer} a column width
     */

    /**
     * Get the given row height of a grid component
     * @param {Integer} row a row index
     * @method getRowHeight
     * @return {Integer} a row height
     */

    /**
     * Get the given row preferred height of a grid component
     * @param {Integer} row a row index
     * @method getPSRowHeight
     * @return {Integer} a row preferred height
     */

    /**
     * Get the given column preferred width of a grid component
     * @param {Integer} col a column index
     * @method getPSColWidth
     * @return {Integer} a column preferred width
     */

     /**
      * Get a x origin of a grid component. Origin indicates how
      * the grid component content has been scrolled
      * @method getXOrigin
      * @return {Integer} a x origin
      */

    /**
      * Get a y origin of a grid component. Origin indicates how
      * the grid component content has been scrolled
      * @method getYOrigin
      * @return {Integer} a y origin
      */

      /**
       * Set the given column width of a grid component
       * @param {Integer} col a column index
       * @param {Integer} w a column width
       * @method setColWidth
       */

      /**
       * Set the given row height of a grid component
       * @param {Integer} row a row index
       * @param {Integer} h a row height
       * @method setRowHeight
       */

      /**
       * Get number of columns in a grid component
       * @return {Integer} a number of columns
       * @method getGridCols
       */

      /**
       * Get number of rows in a grid component
       * @return {Integer} a number of rows
       * @method getGridRows
       */

       /**
        * Get a structure that describes a grid component
        * columns and rows visibility
        * @return {zebkit.ui.grid.CellsVisibility} a grid cells visibility
        * @method getCellsVisibility
        */

      /**
       * Grid line size
       * @attribute lineSize
       * @type {Integer}
       * @readOnly
       */

      /**
       * Indicate if a grid sizes its rows and cols basing on its preferred sizes
       * @attribute isUsePsMetric
       * @type {Boolean}
       * @readOnly
       */

    /**
     * Default grid cell views provider. The class rules how a grid cell content,
     * background has to be rendered and aligned. Developers can implement an own
     * views providers and than setup it for a grid by calling "setViewProvider(...)"
     * method.
     * @param {zebkit.ui.TextRender|zebkit.ui.StringText} [render] a string render
     * @class zebkit.ui.grid.DefViews
     * @constructor
     */
    pkg.DefViews = Class([
        function(render) {
            /**
             * Default render that is used to paint grid content.
             * @type {zebkit.ui.StringRender}
             * @attribute render
             * @readOnly
             * @protected
             */
            this.render = (arguments.length === 0 || typeof render === 'undefined' ? new ui.StringRender("")
                                                                                   : render);
            zebkit.properties(this, this.clazz);
        },

        function $prototype() {
            /**
             * Set the default view provider text render font
             * @param {zebkit.ui.Font} f a font
             * @method setFont
             */
            this.setFont = function(f) {
                this.render.setFont(f);
                return this;
            };

            /**
             * Set the default view provider text render color
             * @param {String} c a color
             * @method setColor
             */
            this.setColor = function(c) {
                this.render.setColor(c);
                return this;
            };

            /**
             * Get a renderer to draw the specified grid model value.
             * @param  {zebkit.ui.grid.Grid} target a target Grid component
             * @param  {Integer} row  a grid cell row
             * @param  {Integer} col  a grid cell column
             * @param  {Object} obj   a model value for the given grid cell
             * @return {zebkit.ui.View}  an instance of  view to be used to
             * paint the given cell model value
             * @method  getView
             */
            this.getView = function(target, row, col, obj){
                if (obj !== null && typeof obj !== 'undefined') {
                    if (typeof obj.toView !== 'undefined') return obj.toView();
                    if (typeof obj.paint  !== 'undefined') return obj;
                    this.render.setValue(obj.toString());
                    return this.render;
                } else {
                    return null;
                }
            };

            /**
             * Get an horizontal alignment a content in the given grid cell
             * has to be adjusted. The method is optional.
             * @param  {zebkit.ui.grid.Grid} target a target grid component
             * @param  {Integer} row   a grid cell row
             * @param  {Integer} col   a grid cell column
             * @return {String}  a horizontal alignment ("left", "center", "right")
             * @method  getXAlignment
             */

             /**
              * Get a vertical alignment a content in the given grid cell
              * has to be adjusted. The method is optional.
              * @param  {zebkit.ui.grid.Grid} target a target grid component
              * @param  {Integer} row   a grid cell row
              * @param  {Integer} col   a grid cell column
              * @return {String}  a vertical alignment ("top", "center", "bottom")
              * @method  getYAlignment
              */

             /**
              * Get the given grid cell color
              * @param  {zebkit.ui.grid.Grid} target a target grid component
              * @param  {Integer} row   a grid cell row
              * @param  {Integer} col   a grid cell column
              * @return {String}  a cell color to be applied to the given grid cell
              * @method  getCellColor
              */
        }
    ]);

    /**
     * Simple grid cells editors provider implementation. By default the editors provider
     * uses a text field component or check box component as a cell content editor. Check
     * box component is used if a cell data type is boolean, otherwise text filed is applied
     * as the cell editor.

            // grid with tree columns and three rows
            // first and last column will be editable with text field component
            // second column will be editable with check box component
            var grid = new zebkit.ui.grid.Grid([
                ["Text Cell", true, "Text cell"],
                ["Text Cell", false, "Text cell"],
                ["Text Cell", true, "Text cell"]
            ]);

            // make grid cell editable
            grid.setEditorProvider(new zebkit.ui.grid.DefEditors());


     * It is possible to customize a grid column editor by specifying setting "editors[col]" property
     * value. You can define an UI component that has to be applied as an editor for the given column
     * Also you can disable editing by setting appropriate column editor class to null:

            // grid with tree columns and three rows
            // first and last column will be editable with text field component
            // second column will be editable with check box component
            var grid = new zebkit.ui.grid.Grid([
                ["Text Cell", true, "Text cell"],
                ["Text Cell", false, "Text cell"],
                ["Text Cell", true, "Text cell"]
            ]);

            // grid cell editors provider
            var editorsProvider = new zebkit.ui.grid.DefEditors();

            // disable the first column editing
            editorsProvider.editors[0] = null;

            // make grid cell editable
            grid.setEditorProvider(editorsProvider);

     * @constructor
     * @class zebkit.ui.grid.DefEditors
     */
    pkg.DefEditors = Class([
        function() {
            this.textEditor     = new this.clazz.TextField("", 150);
            this.boolEditor     = new this.clazz.Checkbox(null);
            this.selectorEditor = new this.clazz.Combo();

            this.editors = {};
        },

        function $clazz() {
            this.TextField = Class(ui.TextField, []);
            this.Checkbox  = Class(ui.Checkbox,  []);
            this.Combo     = Class(ui.Combo,     [
                function padShown(src, b) {
                    if (b === false) {
                        this.parent.stopEditing(true);
                        this.setSize(0,0);
                    }
                },

                function resized(pw, ph) {
                    this.$super(pw, ph);
                    if (this.width > 0 && this.height > 0 && this.hasFocus()) {
                        this.showPad();
                    }
                }
            ]);

            this.Items = Class([
                function $prototype() {
                    this.toString = function() {
                        return this.selectedIndex < 0 ? ""
                                                      : this.items[this.selectedIndex];
                    };
                },

                function(items, selectedIndex) {
                    if (arguments.length < 2) {
                        selectedIndex = -1;
                    }

                    this.items = items;
                    this.selectedIndex = selectedIndex;
                }
            ]);
        },

        function $prototype() {
            /**
             * Fetch an edited value from the given UI editor component.
             * @param  {zebkit.ui.grid.Grid} grid a target grid component
             * @param  {Integer} row a grid cell row that has been edited
             * @param  {Integer} col a grid cell column that has been edited
             * @param  {Object} data an original cell content
             * @param  {zebkit.ui.Panel} editor an editor that has been used to
             * edit the given cell
             * @return {Object} a value that can be applied as a new content of
             * the edited cell content
             * @method  fetchEditedValue
             */
            this.fetchEditedValue = function(grid, row, col, data, editor) {
                if (editor === this.selectorEditor) {
                    data.selectedIndex = editor.list.selectedIndex;
                    return data;
                }
                return editor.getValue();
            };

            /**
             * Get an editor UI component to be used for the given cell of the specified grid
             * @param  {zebkit.ui.grid.Grid} grid a grid whose cell is going to be edited
             * @param  {Integer} row  a grid cell row
             * @param  {Integer} col  a grid cell column
             * @param  {Object}  v    a grid cell model data
             * @return {zebkit.ui.Panel} an editor UI component to be used to edit the given cell
             * @method  getEditor
             */
            this.getEditor = function(grid, row, col, v) {
                var editor = null;
                if (this.editors.hasOwnProperty(col)) {
                    editor = this.editors[col];
                    if (editor !== null) {
                        editor.setValue(v);
                    }
                    return editor;
                }

                editor = zebkit.isBoolean(v) ? this.boolEditor
                                            : (zebkit.instanceOf(v, this.clazz.Items) ? this.selectorEditor : this.textEditor);

                if (editor === this.selectorEditor) {
                    editor.list.setModel(v.items);
                    editor.list.select(v.selectedIndex);
                } else {
                    editor.setValue(v);
                }

                editor.setPadding(0);
                var ah = Math.floor((grid.getRowHeight(row) - editor.getPreferredSize().height)/2);
                editor.setPadding(ah, grid.cellInsetsLeft, ah, grid.cellInsetsRight);
                return editor;
            };

            /**
             * Test if the specified input event has to trigger the given grid cell editing
             * @param  {zebkit.ui.grid.Grid} grid a grid
             * @param  {Integer} row  a grid cell row
             * @param  {Integer} col  a grid cell column
             * @param  {zebkit.util.Event} e  an event to be evaluated
             * @return {Boolean} true if the given input event triggers the given cell editing
             * @method shouldStart
             */
            this.shouldStart = function(grid,row,col,e){
                return e.id === "pointerClicked";
            };

            /**
             * Test if the specified input event has to canceling the given grid cell editing
             * @param  {zebkit.ui.grid.Grid} grid a grid
             * @param  {Integer} row  a grid cell row
             * @param  {Integer} col  a grid cell column
             * @param  {zebkit.util.Event} e  an event to be evaluated
             * @return {Boolean} true if the given input event triggers the given cell editing
             * cancellation
             * @method shouldCancel
             */
            this.shouldCancel = function(grid,row,col,e){
                return e.id === "keyPressed" && "Escape" === e.code;
            };

            /**
             * Test if the specified input event has to trigger finishing the given grid cell editing
             * @param  {zebkit.ui.grid.Grid} grid [description]
             * @param  {Integer} row  a grid cell row
             * @param  {Integer} col  a grid cell column
             * @param  {zebkit.util.Event} e  an event to be evaluated
             * @return {Boolean} true if the given input event triggers finishing the given cell editing
             * @method shouldFinish
             */
            this.shouldFinish = function(grid,row,col,e){
                return e.id === "keyPressed" && "Enter" === e.code;
            };
        }
    ]);

    /**
     * Grid caption base UI component class. This class has to be used
     * as base to implement grid caption components
     * @class  zebkit.ui.grid.BaseCaption
     * @extends {zebkit.ui.Panel}
     * @constructor
     * @param {Array} [titles] a caption component titles
     */

    /**
     * Fire when a grid row selection state has been changed

            caption.on("captionResized", function(caption, rowcol, phw) {
                ...
            });

     * @event captionResized
     * @param  {zebkit.ui.grid.BaseCaption} caption a caption
     * @param  {Integer} rowcol a row or column that has been resized
     * @param  {Integer} pwh a previous row or column size
     */

    pkg.BaseCaption = Class(ui.Panel, [
        function(titles) {
            this._ = new this.clazz.Listeners();

            this.$super();

            if (arguments.length > 0) {
                for(var i = 0; i < titles.length; i++) {
                    this.putTitle(i, titles[i]);
                }
            }
        },

        function $clazz() {
            this.Listeners = new zebkit.util.ListenersClass("captionResized");
        },

        function $prototype() {
            this.selectedColRow = -1;

            this.orient = this.metrics = this.pxy = null;

            /**
             * Minimal possible grid cell size
             * @type {Number}
             * @default 10
             * @attribute minSize
             */
            this.minSize = 10;

            /**
             * Size of the active area where cells size can be changed by pointer dragging event
             * @attribute activeAreaSize
             * @type {Number}
             * @default 5
             */
            this.activeAreaSize = 5;

            /**
             * Caption line color
             * @attribute lineColor
             * @type {String}
             * @default "gray"
             */
            this.lineColor = "gray";

            /**
             * Indicate if the grid cell size has to be adjusted according
             * to the cell preferred size by pointer double click event.
             * @attribute isAutoFit
             * @default true
             * @type {Boolean}
             */

            /**
             * Indicate if the grid cells are resize-able.
             * to the cell preferred size by pointer double click event.
             * @attribute isResizable
             * @default true
             * @type {Boolean}
             */
            this.isAutoFit = this.isResizable = true;

            this.getCursorType = function (target,x,y){
                return this.metrics !== null    &&
                       this.selectedColRow >= 0 &&
                       this.isResizable         &&
                       this.metrics.isUsePsMetric === false ? ((this.orient === "horizontal") ? ui.Cursor.W_RESIZE
                                                                                              : ui.Cursor.S_RESIZE)
                                                            : null;
            };

            /**
             * Define pointer dragged events handler.
             * @param  {zebkit.ui.PointerEvent} e a pointer event
             * @method pointerDragged
             */
            this.pointerDragged = function(e){
                if (this.pxy !== null) {
                    var b  = (this.orient === "horizontal"),
                        rc = this.selectedColRow,
                        ns = (b ? this.metrics.getColWidth(rc) + e.x
                                : this.metrics.getRowHeight(rc) + e.y) - this.pxy;

                    this.captionResized(rc, ns);

                    if (ns > this.minSize) {
                        this.pxy = b ? e.x : e.y;
                    }
                }
            };

            /**
             * Define pointer drag started events handler.
             * @param  {zebkit.ui.PointerEvent} e a pointer event
             * @method pointerDragStarted
             */
            this.pointerDragStarted = function(e){
                if (this.metrics !== null &&
                    this.isResizable     &&
                    this.metrics.isUsePsMetric === false)
                {
                    this.calcRowColAt(e.x, e.y);

                    if (this.selectedColRow >= 0) {
                        this.pxy = (this.orient === "horizontal") ? e.x
                                                                  : e.y;
                    }
                }
            };

            /**
             * Define pointer drag ended events handler.
             * @param  {zebkit.ui.PointerEvent} e a pointer event
             * @method pointerDragEnded
             */
            this.pointerDragEnded = function (e){
                if (this.pxy !== null) {
                    this.pxy = null;
                }

                if (this.metrics !== null) {
                    this.calcRowColAt(e.x, e.y);
                }
            };

            /**
             * Define pointer moved events handler.
             * @param  {zebkit.ui.PointerEvent} e a pointer event
             * @method pointerMoved
             */
            this.pointerMoved = function(e) {
                if (this.metrics !== null) {
                    this.calcRowColAt(e.x, e.y);
                }
            };

            /**
             * Define pointer clicked events handler.
             * @param  {zebkit.ui.PointerEvent} e a pointer event
             * @method pointerClicked
             */
            this.pointerDoubleClicked = function (e){
                if (this.pxy     === null     &&
                    this.metrics !== null     &&
                    this.selectedColRow >= 0 &&
                    this.isAutoFit === true     )
                {
                    var size = this.getCaptionPS(this.selectedColRow);
                    if (this.orient === "horizontal") {
                        this.metrics.setColWidth (this.selectedColRow, size);
                    } else {
                        this.metrics.setRowHeight(this.selectedColRow, size);
                    }
                    this.captionResized(this.selectedColRow, size);
                }
            };

            /**
             * Get the given row or column caption preferred size
             * @param  {Integer} rowcol a row or column of a caption
             * @return {Integer}  a size of row or column caption
             * @method getCaptionPS
             */
            this.getCaptionPS = function(rowcol) {
                return 0;
            };

            this.captionResized = function(rowcol, ns) {
                if (ns > this.minSize) {
                    if (this.orient === "horizontal") {
                        var pw = this.metrics.getColWidth(rowcol);
                        this.metrics.setColWidth(rowcol, ns);
                        this._.captionResized(this, rowcol, pw);
                    } else  {
                        var ph = this.metrics.getRowHeight(rowcol);
                        this.metrics.setRowHeight(rowcol, ns);
                        this._.captionResized(this, rowcol, ph);
                    }
                }
            };

            this.calcRowColAt = function(x, y){
                var $this = this;
                this.selectedColRow = this.getCaptionAt(x, y, function(m, xy, xxyy, wh, i) {
                    xxyy += (wh + m.lineSize);
                    return (xy < xxyy + $this.activeAreaSize &&
                            xy > xxyy - $this.activeAreaSize   );

                });
            };

            /**
             * Compute a column (for horizontal caption component) or row (for
             * vertically aligned caption component) at the given location
             * @param  {Integer} x a x coordinate
             * @param  {Integer} y an y coordinate
             * @param  {Function} [f] an optional match function. The method can be passed
             * if you need to detect a particular area of row or column. The method gets
             * a grid metrics as the first argument, a x or y location to be detected,
             * a row or column y or x coordinate, a row or column height or width and
             * row or column index. The method has to return true if the given location
             * is in.
             * @return {Integer}  a row or column
             * @method calcRowColAt
             */
            this.getCaptionAt = function (x,y,f){
                if (this.metrics !== null &&
                    x >= 0                &&
                    y >= 0                &&
                    x < this.width        &&
                    y < this.height         )
                {
                    var m     = this.metrics,
                        cv    = m.getCellsVisibility(),
                        isHor = (this.orient === "horizontal");

                    if ((isHor && cv.fc !== null) ||
                        (isHor === false && cv.fr !== null))
                    {
                        var gap  = m.lineSize,
                            xy   = isHor ? x : y,
                            xxyy = isHor ? cv.fc[1] - this.x - gap + m.getXOrigin()
                                         : cv.fr[1] - this.y - gap + m.getYOrigin();

                        for (var i = (isHor ? cv.fc[0] : cv.fr[0]);i <= (isHor ? cv.lc[0] : cv.lr[0]); i ++ ) {
                            var wh = isHor ? m.getColWidth(i) : m.getRowHeight(i);
                            if ((arguments.length > 2 && f(m, xy, xxyy, wh, i)) ||
                                (arguments.length < 3 && xy > xxyy && xy < xxyy + wh))
                            {
                                return i;
                            }
                            xxyy += wh + gap;
                        }
                    }
                }
                return -1;
            };

            this.paintOnTop = function(g) {
                if (this.lineColor !== null && this.metrics !== null) {
                    var v = this.metrics.getCellsVisibility();
                    if (v !== null) {
                        var m       = this.metrics,
                            b       = this.orient === "horizontal",
                            startRC = b ? v.fc[0] : v.fr[0],
                            endRC   = b ? v.lc[0] : v.lr[0],
                            xy      = b ? v.fc[1] - this.x - m.lineSize + m.getXOrigin()
                                        : v.fr[1] - this.y - m.lineSize + m.getYOrigin();

                        g.setColor(this.lineColor);
                        for(var i = startRC; i <= endRC; i++) {
                            if (i !== 0) {
                                if (b) g.drawLine(xy, 0, xy, this.height, m.lineSize);
                                else   g.drawLine(0, xy, this.width, xy, m.lineSize);
                            }
                            xy += (b ? m.getColWidth(i): m.getRowHeight(i)) + m.lineSize;
                        }
                    }
                }
            };

            /**
             * Implement the method to be aware when number of rows or columns in
             * a grid model has been updated
             * @param  {zebkit.ui.grid.Grid} target a target grid
             * @param  {Integer} prevRows a previous number of rows
             * @param  {Integer} prevCols a previous number of columns
             * @method matrixResized
             */

            /**
             * Implement the method to be aware when a grid model data has been
             * re-ordered.
             * @param  {zebkit.ui.grid.Grid} target a target grid
             * @param  {Object} sortInfo an order information
             * @method matrixSorted
             */
        },

        function setParent(p) {
            this.$super(p);

            this.metrics = this.orient = null;
            if (p === null || zebkit.instanceOf(p, pkg.Metrics)) {
                this.metrics = p;
                if (this.constraints !== null) {
                    this.orient = (this.constraints === "top"   ||
                                   this.constraints === "bottom"  ) ? "horizontal"
                                                                    : "vertical";
                }
            }
        }
    ]);


    var ui = pkg.cd("..");

    pkg.CaptionViewProvider = Class([
        function(render) {
            if (arguments.length === 0 || typeof render === 'undefined') {
                render = new ui.StringRender("");
            }

            this.render = render;
            this.render.setFont(pkg.GridCaption.font);
            this.render.setColor(pkg.GridCaption.fontColor);
        },

        function $prototype() {
            this.render = null;
            this.meta = null;

            /**
             * Set the default view provider text render font
             * @param {zebkit.ui.Font} f a font
             * @method setFont
             */
            this.setFont = function(f) {
                this.render.setFont(f);
                return this;
            };

            /**
             * Set the default view provider text render color
             * @param {String} c a color
             * @method setColor
             */
            this.setColor = function(c) {
                this.render.setColor(c);
                return this;
            };

            this.getView = function(target, rowcol, value){
                if (value !== null) {
                    if (typeof value.toView !== 'undefined') return value.toView();
                    if (typeof value.paint  !== 'undefined') return value;
                    this.render.setValue(value.toString());
                    return this.render;
                } else {
                    return null;
                }
            };

            this.$getCellMeta = function(rowcol) {
                if (this.meta === null) {
                    this.meta = {};
                }

                if (this.meta.hasOwnProperty(rowcol)) {
                    return this.meta[rowcol];
                } else {
                    this.meta[rowcol] = {
                        ax : null,
                        ay : null,
                        bg : null
                    };
                    return this.meta[rowcol];
                }
            };

            this.getXAlignment = function(target, rowcol) {
                return this.meta === null || this.meta.hasOwnProperty(rowcol) === false ? null
                                                                                        : this.meta[rowcol].ax;
            };

            this.getYAlignment = function(target, rowcol) {
                return this.meta === null || this.meta.hasOwnProperty(rowcol) === false ? null
                                                                                        : this.meta[rowcol].ay;
            };

            this.getCellBackground = function(target, rowcol) {
                return this.meta === null || this.meta.hasOwnProperty(rowcol) === false ? null
                                                                                        : this.meta[rowcol].bg;
            };

            this.setTitleAlignments = function(rowcol, ax, ay) {
                var m = this.$getCellMeta(rowcol);
                if (m.ax !== ax || m.ay !== ay) {
                    m.ax = ax;
                    m.ay = ay;
                    return true;
                } else {
                    return false;
                }
            };

            this.setCellBackground = function(rowcol, bg) {
                var m = this.$getCellMeta(rowcol);
                if (m.bg !== bg) {
                    m.bg = ui.$view(bg);
                    return true;
                } else {
                    return false;
                }
            };
        }
    ]);

    /**
     * Grid caption class that implements rendered caption.
     * Rendered means all caption titles, border are painted
     * as a number of views.
     * @param  {Array} [titles] a caption titles. Title can be a string or
     * a zebkit.ui.View class instance
     * @param  {zebkit.ui.StringRender|zebkit.ui.TextRender} [render] a text render to be used
     * to paint grid titles
     * @constructor
     * @class zebkit.ui.grid.GridCaption
     * @extends zebkit.ui.grid.BaseCaption
     */
    pkg.GridCaption = Class(pkg.BaseCaption, [
        function(titles, render) {
            this.titles = {};

            this.psW = this.psH = 0;
            this.setViewProvider(new pkg.CaptionViewProvider(render));

            if (arguments.length === 0) {
                this.$super();
            } else {
                this.$super(titles);
            }
        },

        function $prototype() {
            this.provider = null;

            this.defYAlignment = this.defXAlignment = "center";

            this.defCellBg = null;

            this.setViewProvider = function(p) {
                if (p !== this.provider) {
                    this.provider = p;
                    this.vrp();
                }
                return this;
            };

            this.getTitle = function(rowcol) {
                return this.titles.hasOwnProperty(rowcol) ? this.titles[rowcol]
                                                          : null;
            };

            this.calcPreferredSize = function (l) {
                return { width:this.psW, height:this.psH };
            };

            this.setFont = function(f) {
                this.provider.setFont(f);
                this.vrp();
                return this;
            };

            this.setColor = function(c) {
                this.provider.setColor(c);
                this.repaint();
                return this;
            };

            this.recalc = function(){
                this.psW = this.psH = 0;
                if (this.metrics !== null){
                    var m     = this.metrics,
                        isHor = (this.orient === "horizontal"),
                        size  = isHor ? m.getGridCols() : m.getGridRows();

                    for(var i = 0;i < size; i++) {
                        var v = this.provider.getView(this, i, this.getTitle(i));
                        if (v !== null) {
                            var ps = v.getPreferredSize();
                            if (isHor === true) {
                                if (ps.height > this.psH) this.psH = ps.height;
                                this.psW += ps.width;
                            } else {
                                if (ps.width > this.psW) this.psW = ps.width;
                                this.psH += ps.height;
                            }
                        }
                    }

                    if (this.psH === 0) this.psH = pkg.Grid.DEF_ROWHEIGHT;
                    if (this.psW === 0) this.psW = pkg.Grid.DEF_COLWIDTH;
                }
            };

            /**
             * Put the given title for the given caption cell.
             * @param  {Integer} rowcol a grid caption cell index
             * @param  {String|zebkit.ui.View|zebkit.ui.Panel} title a title of the given grid caption cell.
             * Can be a string or zebkit.ui.View or zebkit.ui.Panel class instance
             * @method putTitle
             * @chainable
             */
            this.putTitle = function(rowcol, value) {
                if (value === null) {
                    if (title !== null) {
                        delete this.titles[rowcol];
                    }
                } else {
                    this.titles[rowcol] = value;
                }

                this.vrp();
                return this;
            };

            this.setTitleAlignments = function(rowcol, xa, ya){
                if (this.provider.setTitleAlignments(rowcol, xa, ya)) {
                    this.repaint();
                }
                return this;
            };

            this.setCellBackground = function(rowcol, bg) {
                if (this.provider.setCellBackground(rowcol, bg)) {
                    this.repaint();
                }
                return this;
            };

            this.getCaptionPS = function(rowcol) {
                var v = this.provider.getView(this, rowcol, this.getTitle(rowcol));
                return (v !== null) ? (this.orient === "horizontal" ? v.getPreferredSize().width
                                                                    : v.getPreferredSize().height)
                                    : 0;
            };
        },

        function paintOnTop(g) {
            if (this.metrics !== null){
                var cv = this.metrics.getCellsVisibility();

                if ((cv.fc !== null && cv.lc !== null && this.orient === "horizontal")||
                    (cv.fr !== null && cv.lr !== null && this.orient === "vertical"  )   )
                {
                    var isHor  = (this.orient === "horizontal"),
                        gap    = this.metrics.lineSize,
                        top    = this.getTop(),
                        left   = this.getLeft(),
                        bottom = this.getBottom(),
                        right  = this.getRight(),
                        x      = isHor ? cv.fc[1] - this.x + this.metrics.getXOrigin() - gap
                                       : left,
                        y      = isHor ? top
                                       : cv.fr[1] - this.y + this.metrics.getYOrigin() - gap,
                        size   = isHor ? this.metrics.getGridCols()
                                       : this.metrics.getGridRows();

                    //           top
                    //           >|<
                    //  +=========|===========================
                    //  ||        |
                    //  ||   +====|============+     +========
                    //  ||   ||   |            ||   ||
                    //  ||--------> left       ||   ||
                    //  ||   ||<-------------->||   ||
                    //  ||   ||       ww       ||   ||
                    //  ||   ||                ||   ||
                    // >-------< lineSize      ||   ||
                    //  ||   ||                ||   ||
                    //  x   first
                    //      visible

                    for(var i = (isHor ? cv.fc[0] : cv.fr[0]); i <= (isHor ? cv.lc[0] : cv.lr[0]); i++) {
                        var ww = isHor ? this.metrics.getColWidth(i)
                                       : this.width - left - right,
                            hh = isHor ? this.height - top - bottom
                                       : this.metrics.getRowHeight(i),
                            v = this.provider.getView(this, i, this.getTitle(i));

                        if (v !== null) {
                            var xa = this.provider.getXAlignment(this, i, v),
                                ya = this.provider.getYAlignment(this, i, v),
                                bg = this.provider.getCellBackground(this, i, v);

                            if (xa === null) {
                                xa = this.defXAlignment;
                            }

                            if (ya === null) {
                                ya = this.defYAlignment;
                            }

                            if (bg === null) {
                                bg = this.defCellBg;
                            }

                            var ps = v.getPreferredSize(),
                                vx = xa === "center" ? Math.floor((ww - ps.width)/2)
                                                     : (xa === "right" ? ww - ps.width - ((i === size - 1) ? right : 0)
                                                                       : (i === 0 ? left: 0)),
                                vy = ya === "center" ? Math.floor((hh - ps.height)/2)
                                                     : (ya === "bottom" ? hh - ps.height - ((i === size - 1) ? bottom : 0)
                                                                        : (i === 0 ? top: 0));


                            if (bg !== null) {
                                if (isHor) bg.paint(g, x, 0, ww + gap , this.height, this);
                                else       bg.paint(g, 0, y, this.width, hh + gap, this);
                            }

                            g.save();
                            g.clipRect(x + gap, y + gap, ww, hh);
                            v.paint(g, x + vx + gap, y + vy + gap, ps.width, ps.height, this);
                            g.restore();
                        }

                        if (isHor) x += ww + gap;
                        else       y += hh + gap;
                    }
                }

                this.$super(g);
            }
        }
    ]);


    var ui = pkg.cd("..");

    /**
     * Grid caption class that implements component based caption.
     * Component based caption uses other UI component as the
     * caption titles.
     * @param  {Array} a caption titles. Title can be a string or
     * a zebkit.ui.Panel class instance
     * @constructor
     * @class zebkit.ui.grid.CompGridCaption
     * @extends zebkit.ui.grid.BaseCaption
     */
    pkg.CompGridCaption = Class(pkg.BaseCaption, [
        function(titles) {
            if (arguments.length === 0) {
                this.$super();
            } else {
                this.$super(titles);
            }

            this.setLayout(new this.clazz.Layout());
        },

        function $clazz() {
            this.Layout = Class(zebkit.layout.Layout, [
                function $prototype() {
                    this.doLayout = function (target) {
                        var m    = target.metrics,
                            b    = target.orient === "horizontal",
                            top  = target.getTop(),
                            left = target.getLeft(),
                            wh   = (b ? target.height - top  - target.getBottom()
                                      : target.width  - left - target.getRight()),
                            xy   = (b ? left + m.getXOrigin()
                                      : top  + m.getYOrigin());

                        for (var i = 0; i < target.kids.length; i++) {
                            var kid = target.kids[i],
                                cwh = (b ? m.getColWidth(i)
                                         : m.getRowHeight(i));

                            if (i === 0) {
                                cwh -= (b ? (left - m.lineSize) : top);
                            }

                            if (kid.isVisible === true) {
                                if (b) {
                                    kid.setBounds(xy, top, cwh, wh);
                                } else {
                                    kid.setBounds(left, xy, wh, cwh);
                                }
                            }

                            xy += (cwh + m.lineSize);
                        }
                    };

                    this.calcPreferredSize = function (target) {
                        return zebkit.layout.getMaxPreferredSize(target);
                    };
                }
            ]);

            this.Link = Class(ui.Link, []);

            this.StatusPan = Class(ui.StatePan, []);

            /**
             * Title panel that is designed to be used as CompGridCaption UI component title element.
             * The panel keeps a grid column or row title, a column or row sort indicator. Using the
             * component you can have sortable grid columns.
             * @constructor
             * @param {String} a grid column or row title
             * @class zebkit.ui.grid.CompGridCaption.TitlePan
             */
            var clazz = this;
            this.TitlePan = Class(ui.Panel, [
                function(title) {
                    this.$super();

                    /**
                     * Image panel to keep grtid caption title
                     * @attribute iconPan
                     * @type {zebkit.ui.ImagePan}
                     * @readOnly
                     */
                    this.iconPan = new ui.ImagePan(null);

                    /**
                     * Title link
                     * @attribute link
                     * @type {zebkit.ui.Link}
                     * @readOnly
                     */
                    this.link = new clazz.Link(title);
                    this.statusPan = new clazz.StatusPan();
                    this.statusPan.setVisible(this.isSortable);

                    this.add(this.iconPan);
                    this.add(this.link);
                    this.add(this.statusPan);
                },

                function $clazz() {
                    this.layout = new zebkit.layout.FlowLayout("center", "center", "horizontal", 8);
                },

                function $prototype() {
                    this.sortState = 0;

                    /**
                     * Indicates if the title panel has to initiate a column sorting
                     * @default false
                     * @attribute isSortable
                     * @readOnly
                     * @type {Boolean}
                     */
                    this.isSortable = false;
                },

                function getGridCaption() {
                    var c = this.parent;
                    while(c !== null && zebkit.instanceOf(c, pkg.BaseCaption) === false) {
                        c = c.parent;
                    }
                    return c;
                },

                function matrixSorted(target, info) {
                    if (this.isSortable) {
                        var col = this.parent.indexOf(this);
                        if (info.col === col) {
                            this.sortState = info.name === 'descent' ? 1 : -1;
                            this.statusPan.setState(info.name);
                        } else {
                            this.sortState = 0;
                            this.statusPan.setState("*");
                        }
                    }
                },

                /**
                 * Set the caption icon
                 * @param {String|Image} path a path to an image or image object
                 * @method setIcon
                 * @chainable
                 */
                function setIcon(path) {
                    this.iconPan.setImage(path);
                    return this;
                },

                function matrixResized(target,prevRows,prevCols){
                    if (this.isSortable) {
                        this.sortState = 0;
                        this.statusPan.setState("*");
                    }
                },

                function fired(target) {
                    if (this.isSortable === true) {
                        var f = this.sortState === 1 ? zebkit.data.ascent
                                                     : zebkit.data.descent,
                            model = this.getGridCaption().metrics.model,
                            col   = this.parent.indexOf(this);
                        model.sortCol(col, f);
                    }
                },

                function kidRemoved(index, kid) {
                    if (zebkit.instanceOf(kid, zebkit.util.Fireable)) {
                        kid.off(this);
                    }
                    this.$super(index, kid);
                },

                function kidAdded(index, constr, kid) {
                    // TODO: not very prefect check
                    if (zebkit.instanceOf(kid, zebkit.util.Fireable)) {
                        kid.on(this);
                    }
                    this.$super(index, constr, kid);
                }
            ]);
        },

        /**
         * @for zebkit.ui.grid.CompGridCaption
         */
        function $prototype() {
            this.catchInput = function(t) {
                return zebkit.instanceOf(t, zebkit.util.Fireable) === false;
            };

            this.scrolled = function() {
                this.vrp();
            };

            /**
             * Put the given title component for the given caption cell.
             * @param  {Integer} rowcol a grid caption cell index
             * @param  {String|zebkit.ui.Panel|zebkit.ui.View} title a title of the given grid caption cell.
             * Can be a string or zebkit.ui.View or zebkit.ui.Panel class instance
             * @method putTitle
             * @chainable
             */
            this.putTitle = function(rowcol, t) {
                // add empty titles
                for(var i = this.kids.length - 1;  i >= 0 && i < rowcol; i++) {
                    this.add(new this.clazz.TitlePan(""));
                }

                if (zebkit.isString(t)) {
                    t = new this.clazz.TitlePan(t);
                } else {
                    if (zebkit.instanceOf(t, ui.View)) {
                        var p = new ui.ViewPan();
                        p.setView(t);
                        t = p;
                    }
                }

                if (rowcol < this.kids.length) {
                    this.setAt(rowcol, t);
                } else {
                    this.add(t);
                }

                return this;
            };

            /**
             * Set the given column sortable state
             * @param {Integer} col a column
             * @param {Boolean} b true if the column has to be sortable
             * @method setSortable
             * @chainable
             */
            this.setSortable = function(col, b) {
                var c = this.kids[col];
                if (c.isSortable !== b) {
                    c.isSortable = b;
                    c.statusPan.setVisible(b);
                }
                return this;
            };

            this.matrixSorted = function(target, info) {
                for(var i = 0; i < this.kids.length; i++) {
                    if (this.kids[i].matrixSorted) {
                        this.kids[i].matrixSorted(target, info);
                    }
                }
            };

            this.matrixResized = function(target,prevRows,prevCols){
                for(var i = 0; i < this.kids.length; i++) {
                    if (this.kids[i].matrixResized) {
                        this.kids[i].matrixResized(target,prevRows,prevCols);
                    }
                }
            };

            this.getCaptionPS = function(rowcol) {
                return rowcol < this.kids.length ? (this.orient === "horizontal" ? this.kids[rowcol].getPreferredSize().width
                                                                                 : this.kids[rowcol].getPreferredSize().height)
                                                 : 0;
            };
        },

        function captionResized(rowcol, ns) {
            this.$super(rowcol, ns);
            this.vrp();
        },

        function setParent(p) {
            if (this.parent !== null && typeof this.parent.scrollManager !== "undefined" && this.parent.scrollManager !== null) {
                this.parent.scrollManager.off(this);
            }

            if (p !== null && typeof p.scrollManager !== 'undefined' && p.scrollManager !== null) {
                p.scrollManager.on(this);
            }

            this.$super(p);
        },

        function insert(i,constr, c) {
            if (zebkit.isString(c)) {
                c = new this.clazz.TitlePan(c);
            }
            this.$super(i,constr, c);
        }
    ]);

    pkg.LeftCompGridCaption = Class(pkg.CompGridCaption, [
        function $prototype() {
            this.constraints = "left";
        }
    ]);

    pkg.LeftGridCaption = Class(pkg.GridCaption, [
        function $prototype() {
            this.constraints = "left";
        }
    ]);


    var ui = pkg.cd("..");

    // TODO: this is the future thoughts regarding
    // grid cell selection customization
    pkg.RowSelMode = Class([
        function $prototype() {
            this.selectedIndex = 0;
            this.$blocked = false;

            this.isSelected = function(row, col) {
                return row >= 0 && this.selectedIndex === row;
            };

            this.select = function(row, col, b) {
                if (arguments.length === 1 || (arguments.length === 2 && zebkit.isNumber(col))) {
                    b = true;
                }

                if (this.isSelected(row, col) !== b){
                    if (this.selectedIndex >= 0) this.clearSelect();
                    if (b === true) {
                        this.selectedIndex = row;
                        this.target._.rowSelected();
                    }
                }
            };

            this.clearSelect = function() {
                if (this.selectedIndex >= 0) {
                    this.selectedIndex = -1;
                    this.target._.rowSelected();
                }
            };

            this.posChanged = function(src) {
                if ($blocked === false) {
                    $blocked = true;
                    try {

                    }
                    finally {
                        $blocked = false;
                    }
                }
            };
        }
    ]);

    /**
     * Grid UI component class. The grid component visualizes "zebkit.data.Matrix" data model.
     * Grid cell visualization can be customized by defining and setting an own view provider.
     * Grid component supports cell editing. Every existent UI component can be configured
     * as a cell editor by defining an own editor provider.
     *

            // create a grid that contains three rows and tree columns
            var grid  = new zebkit.ui.grid.Grid([
                [ "Cell 1.1", "Cell 1.2", "Cell 1.3"],
                [ "Cell 2.1", "Cell 2.2", "Cell 2.3"],
                [ "Cell 3.1", "Cell 3.2", "Cell 3.3"]
            ]);

            // add the top caption
            grid.add("top", new zebkit.ui.grid.GridCaption([
                "Caption title 1", "Caption title 2", "Caption title 3"
            ]));

            // set rows size
            grid.setRowsHeight(45);

     *
     * Grid can have top and left captions.
     * @class  zebkit.ui.grid.Grid
     * @constructor
     * @param {zebkit.data.Matrix|Array} [model] a matrix model to be visualized with the grid
     * component. It can be an instance of zebkit.data.Matrix class or an array that contains
     * embedded arrays. Every embedded array is a grid row.
     * @param {Integer} [rows]  a number of rows
     * @param {Integer} [columns] a number of columns
     * @extends {zebkit.ui.Panel}
     * @uses zebkit.ui.grid.Metrics
     */

    /**
     * Fire when a grid row selection state has been changed

            grid.on(function(grid, row, count, status) {
                ...
            });

     * @event rowSelected
     * @param  {zebkit.ui.grid.Grid} grid a grid that triggers the event
     * @param  {Integer} row a first row whose selection state has been updated. The row is
     * -1 if all selected rows have been unselected
     * @param  {Integer} count a number of rows whose selection state has been updated
     * @param {Boolean} status a status. true means rows have been selected
     */
    pkg.Grid = Class(ui.Panel, zebkit.util.Position.Metric, pkg.Metrics, ui.$ViewsSetterMix, [
            function(model) {
                /**
                 * Default cell background color
                 * @type {String}
                 * @attribute defCellColor
                 * @default pkg.DefViews.cellBackground
                 */
                this.defCellColor = pkg.DefViews.cellBackground;

                if (arguments.length === 0) {
                    model = new this.clazz.Matrix(5, 5);
                } else if (arguments.length === 2) {
                    model = new this.clazz.Matrix(arguments[0], arguments[1]);
                }

                this._ = new this.clazz.Listeners();
                this.views = {};

                this.visibility = new pkg.CellsVisibility();

                this.$super();

                this.add("corner", new this.clazz.CornerPan());
                this.setModel(model);
                this.setViewProvider(new pkg.DefViews());
                this.setPosition(new zebkit.util.Position(this));
                this.scrollManager = new ui.ScrollManager(this);
            },

            function $clazz() {
                this.Listeners = zebkit.util.ListenersClass("rowSelected");
                this.Matrix    = Class(zebkit.data.Matrix, []);

                this.DEF_COLWIDTH  = 80;
                this.DEF_ROWHEIGHT = 25;
                this.CornerPan = Class(ui.Panel, []);
            },

            function $prototype() {
                this.psWidth_    = this.psHeight_  = this.colOffset = 0;
                this.rowOffset   = this.pressedCol = this.selectedIndex = 0;
                this.scrollManager = this.model = this.visibleArea = null;

                /**
                 * Reference to top caption component
                 * @attribute topCaption
                 * @type {zebkit.ui.grid.GridCaption|zebkit.ui.grid.CompGridCaption}
                 * @default null
                 * @readOnly
                 */

                /**
                 * Reference to left caption component
                 * @attribute leftCaption
                 * @type {zebkit.ui.grid.GridCaption|zebkit.ui.grid.CompGridCaption}
                 * @default null
                 * @readOnly
                 */
                this.editor = this.editors = this.leftCaption = this.topCaption = this.colWidths = null;
                this.rowHeights = this.position = this.stub = null;

                /**
                 * Currently editing row. -1 if no row is editing
                 * @attribute editingRow
                 * @type {Integer}
                 * @default -1
                 * @readOnly
                 */

                /**
                 * Currently editing column. -1 if no column is editing
                 * @attribute editingCol
                 * @type {Integer}
                 * @default -1
                 * @readOnly
                 */
                this.editingRow = this.editingCol = this.pressedRow = -1;

                /**
                 * Grid navigation mode
                 * @attribute navigationMode
                 * @default "row"
                 * @type {String}
                 */
                this.navigationMode = "row";

                /**
                 * Grid line size
                 * @attribute lineSize
                 * @default 1
                 * @type {Integer}
                 */

                /**
                 * Grid cell top padding
                 * @attribute cellInsetsTop
                 * @default 1
                 * @type {Integer}
                 * @readOnly
                 */

                /**
                 * Grid cell left padding
                 * @attribute cellInsetsLeft
                 * @default 2
                 * @type {Integer}
                 * @readOnly
                 */

                /**
                 * Grid cell bottom padding
                 * @attribute cellInsetsBottom
                 * @default 1
                 * @type {Integer}
                 * @readOnly
                 */

                /**
                 * Grid cell right padding
                 * @attribute cellInsetsRight
                 * @default 2
                 * @type {Integer}
                 * @readOnly
                 */
                this.lineSize = this.cellInsetsTop = this.cellInsetsBottom = 1;
                this.cellInsetsLeft = this.cellInsetsRight = 2;

                /**
                 * Default cell content horizontal alignment
                 * @type {String}
                 * @attribute defXAlignment
                 * @default "left"
                 */
                this.defXAlignment = "left";

                /**
                 * Default cell content vertical alignment
                 * @type {String}
                 * @attribute defYAlignment
                 * @default "center"
                 */
                this.defYAlignment = "center";

                /**
                 * Indicate if vertical lines have to be rendered
                 * @attribute drawVerLines
                 * @type {Boolean}
                 * @readOnly
                 * @default true
                 */

                /**
                 * Indicate if horizontal lines have to be rendered
                 * @attribute drawHorLines
                 * @type {Boolean}
                 * @readOnly
                 * @default true
                 */
                this.drawVerLines = this.drawHorLines = true;

                /**
                 * Indicates if left and right grid net vertical lines
                 * have to be rendered or not.
                 * @attribute drawSideLines
                 * @type {Boolean}
                 * @readOnly
                 * @default true
                 */
                this.drawSideLines = true;

                /**
                 * Line color
                 * @attribute lineColor
                 * @type {String}
                 * @default gray
                 * @readOnly
                 */
                this.lineColor = "gray";

                /**
                 * Indicate if size of grid cells have to be calculated
                 * automatically basing on its preferred heights and widths
                 * @attribute isUsePsMetric
                 * @type {Boolean}
                 * @default false
                 * @readOnly
                 */
                this.isUsePsMetric = false;

                /**
                 * Defines if the pos narker has to be renederd over rendered data
                 * @attribute paintPosMarkerOver
                 * @type {Boolean}
                 * @default true
                 */
                this.paintPosMarkerOver = true;

                this.$topY = function() {
                    // grid without top caption renders line at the top, so we have to take in account
                    // the place for the line
                    return this.getTop() +
                          (this.topCaption === null || this.topCaption.isVisible === false ? this.lineSize
                                                                                           : this.getTopCaptionHeight());
                };

                this.$leftX = function() {
                    // grid without left caption renders line at the left, so we have to take in account
                    // the place for the line
                    return this.getLeft() +
                          (this.leftCaption === null || this.leftCaption.isVisible === false ? this.lineSize
                                                                                             : this.getLeftCaptionWidth());
                };

                this.setDefCellXAlignment = function(ax) {
                    this.setDefCellAlignments(ax, this.defYAlignment);
                };

                this.setDefCellYAlignment = function(ay) {
                    this.setDefCellAlignments(this.defXAlignment, ay);
                };

                this.setDefCellAlignments = function(ax, ay) {
                    if (this.defXAlignment !== ax || this.defYAlignment !== ay) {
                        this.defXAlignment = ax;
                        this.defYAlignment = ay;
                        this.repaint();
                    }
                };

                this.colVisibility = function(col,x,d,b){
                    var cols = this.getGridCols();
                    if (cols === 0) return null;

                    var left = this.getLeft(),
                        dx   = this.scrollManager.getSX(),
                        xx1  = Math.min(this.visibleArea.x + this.visibleArea.width,
                                        this.width - this.getRight()),
                        xx2  = Math.max(left, this.visibleArea.x +
                                        this.getLeftCaptionWidth());

                    for(; col < cols && col >= 0; col += d) {
                        if (x + dx < xx1 && (x + this.colWidths[col] + dx) > xx2) {
                            if (b) return [col, x];
                        } else {
                            if (b === false) return this.colVisibility(col, x, (d > 0 ?  -1 : 1), true);
                        }

                        if (d < 0) {
                            if (col > 0) x -= (this.colWidths[col - 1] + this.lineSize);
                        } else {
                            if (col < cols - 1) x += (this.colWidths[col] + this.lineSize);
                        }
                    }
                    return b ? null : ((d > 0) ? [col -1, x]
                                               : [0, this.$leftX() ]);
                };

                this.rowVisibility = function(row,y,d,b) {
                    var rows = this.getGridRows();
                    if (rows === 0) return null;

                    var top = this.getTop(),
                        dy  = this.scrollManager.getSY(),
                        yy1 = Math.min(this.visibleArea.y + this.visibleArea.height,
                                       this.height - this.getBottom()),
                        yy2 = Math.max(this.visibleArea.y,
                                       top + this.getTopCaptionHeight());

                    for(; row < rows && row >= 0; row += d){
                        if (y + dy < yy1 && (y + this.rowHeights[row] + dy) > yy2){
                            if (b) return [row, y];
                        } else {
                            if (b === false) return this.rowVisibility(row, y, (d > 0 ?  -1 : 1), true);
                        }

                        if (d < 0){
                            if (row > 0) y -= (this.rowHeights[row - 1] + this.lineSize);
                        } else {
                            if (row < rows - 1) y += (this.rowHeights[row] + this.lineSize);
                        }
                    }
                    return b ? null : ((d > 0) ? [row - 1, y]
                                               : [0, this.$topY()]);
                };

                this.vVisibility = function(){
                    var va = ui.$cvp(this, {});
                    if (va === null) {
                        this.visibleArea = null;
                        this.visibility.fr = null; // say no visible cells are available
                        return;
                    }

                    // visible area has not been calculated or
                    // visible area has been changed
                    if (this.visibleArea === null            ||
                        va.x !== this.visibleArea.x          ||
                        va.y !== this.visibleArea.y          ||
                        va.width  !== this.visibleArea.width ||
                        va.height !== this.visibleArea.height  )
                    {
                        this.iColVisibility(0);
                        this.iRowVisibility(0);
                        this.visibleArea = va;
                    }

                    var v = this.visibility,
                        b = v.hasVisibleCells();

                    if (this.colOffset !== 100) {
                        if (this.colOffset > 0 && b){
                            v.lc = this.colVisibility(v.lc[0], v.lc[1],  -1, true);
                            v.fc = this.colVisibility(v.lc[0], v.lc[1],  -1, false);
                        } else {
                            if (this.colOffset < 0 && b) {
                                v.fc = this.colVisibility(v.fc[0], v.fc[1], 1, true);
                                v.lc = this.colVisibility(v.fc[0], v.fc[1], 1, false);
                            } else {
                                v.fc = this.colVisibility(0, this.$leftX(), 1, true);
                                v.lc = (v.fc !== null) ? this.colVisibility(v.fc[0], v.fc[1], 1, false)
                                                       : null;
                            }
                        }
                        this.colOffset = 100;
                    }

                    if (this.rowOffset !== 100) {
                        if (this.rowOffset > 0 && b) {
                            v.lr = this.rowVisibility(v.lr[0], v.lr[1],  -1, true);
                            v.fr = this.rowVisibility(v.lr[0], v.lr[1],  -1, false);
                        } else {
                            if(this.rowOffset < 0 && b){
                                v.fr = this.rowVisibility(v.fr[0], v.fr[1], 1, true);
                                v.lr = (v.fr !== null) ? this.rowVisibility(v.fr[0], v.fr[1], 1, false) : null;
                            } else {
                                v.fr = this.rowVisibility(0, this.$topY(), 1, true);
                                v.lr = (v.fr !== null) ? this.rowVisibility(v.fr[0], v.fr[1], 1, false) : null;
                            }
                        }
                        this.rowOffset = 100;
                    }
                };

                this.makeVisible = function(row, col) {
                    var top  = this.getTop()  + this.getTopCaptionHeight(),
                        left = this.getLeft() + this.getLeftCaptionWidth(),
                        o    = ui.calcOrigin(this.getColX(col) ,
                                             this.getRowY(row) ,

                                             // width depends on marker mode: cell or row
                                             this.getLineSize(row) > 1 ? this.colWidths[col] + this.lineSize
                                                                     : this.psWidth_,
                                             this.rowHeights[row] + this.lineSize,
                                             this.scrollManager.getSX(),
                                             this.scrollManager.getSY(),
                                             this, top, left,
                                             this.getBottom(),
                                             this.getRight());

                    this.scrollManager.scrollTo(o[0], o[1]);
                };

                this.$se = function(row, col, e) {
                    if (row >= 0) {
                        this.stopEditing(true);

                        if (this.editors !== null &&
                            this.editors.shouldStart(this, row, col, e))
                        {
                            return this.startEditing(row, col);
                        }
                    }
                    return false;
                };

                this.getXOrigin = function() {
                    return this.scrollManager.getSX();
                };

                this.getYOrigin = function () {
                    return this.scrollManager.getSY();
                };

                /**
                 * Get a preferred width the given column wants to have
                 * @param  {Integer} col a column
                 * @return {Integer} a preferred width of the given column
                 * @method getColPSWidth
                 */
                this.getColPSWidth = function(col){
                    return this.getPSSize(col, false);
                };

                /**
                 * Get a preferred height the given row wants to have
                 * @param  {Integer} col a row
                 * @return {Integer} a preferred height of the given row
                 * @method getRowPSHeight
                 */
                this.getRowPSHeight = function(row) {
                    return this.getPSSize(row, true);
                };

                this.recalc = function(){
                    if (this.isUsePsMetric) {
                        this.rPsMetric();
                    } else {
                        this.rCustomMetric();
                    }

                    var cols = this.getGridCols(),
                        rows = this.getGridRows();

                    this.psWidth_  = this.lineSize * (cols + ((this.leftCaption === null || this.leftCaption.isVisible === false) ? 1 : 0));
                    this.psHeight_ = this.lineSize * (rows + ((this.topCaption === null || this.topCaption.isVisible === false) ? 1 : 0));

                    var i = 0;
                    for(;i < cols; i++) this.psWidth_  += this.colWidths[i];
                    for(i = 0;i < rows; i++) this.psHeight_ += this.rowHeights[i];
                };

                /**
                 * Get number of rows in the given grid
                 * @return {Integer} a number of rows
                 * @method getGridRows
                 */
                this.getGridRows = function() {
                    return this.model !== null ? this.model.rows : 0;
                };

                /**
                 * Get number of columns in the given grid
                 * @return {Integer} a number of columns
                 * @method getGridColumns
                 */
                this.getGridCols = function(){
                    return this.model !== null ? this.model.cols : 0;
                };

                /**
                 * Get the  given grid row height
                 * @param  {Integer} row a grid row
                 * @return {Integer} a height of the given row
                 * @method getRowHeight
                 */
                this.getRowHeight = function(row){
                    this.validateMetric();
                    return this.rowHeights[row];
                };

                /**
                 * Get the given grid column width
                 * @param  {Integer} col a grid column
                 * @return {Integer} a width of the given column
                 * @method getColWidth
                 */
                this.getColWidth = function(col){
                    this.validateMetric();
                    return this.colWidths[col];
                };

                this.getCellsVisibility = function(){
                    this.validateMetric();
                    return this.visibility;
                };

                /**
                 * Get the given column top-left corner x coordinate
                 * @param  {Integer} col a column
                 * @return {Integer} a top-left corner x coordinate of the given column
                 * @method getColX
                 */
                this.getColX = function (col){
                    // speed up a little bit by avoiding calling validateMetric method
                    if (this.isValid === false) this.validateMetric();

                    var start = 0,
                        d     = 1,
                        x     = this.getLeft() +
                                (this.leftCaption === null || this.leftCaption.isVisible === false ? this.lineSize : 0) +
                                this.getLeftCaptionWidth();

                    if (this.visibility.hasVisibleCells()) {
                        start = this.visibility.fc[0];
                        x     = this.visibility.fc[1];
                        d     = (col > this.visibility.fc[0]) ? 1 : -1;
                    }

                    for(var i = start;i !== col; x += ((this.colWidths[i] + this.lineSize) * d),i += d);
                    return x;
                };

                /**
                 * Get the given row top-left corner y coordinate
                 * @param  {Integer} row a row
                 * @return {Integer} a top-left corner y coordinate
                 * of the given column
                 * @method getColX
                 */
                this.getRowY = function (row){
                    // speed up a little bit by avoiding calling validateMetric method
                    if (this.isValid === false) {
                        this.validateMetric();
                    }

                    var start = 0,
                        d     = 1,
                        y     = this.getTop() +
                                (this.topCaption === null || this.topCaption.isVisible === false ? this.lineSize : 0) +
                                this.getTopCaptionHeight();

                    if (this.visibility.hasVisibleCells()){
                        start = this.visibility.fr[0];
                        y     = this.visibility.fr[1];
                        d     = (row > this.visibility.fr[0]) ? 1 : -1;
                    }

                    for(var i = start;i !== row; y += ((this.rowHeights[i] + this.lineSize) * d),i += d);
                    return y;
                };

                this.childPointerEntered  =
                this.childPointerExited   =
                this.childPointerReleased =
                this.childPointerReleased =
                this.childPointerPressed  =
                this.childKeyReleased     =
                this.childKeyTyped        =
                this.childKeyPressed      = function(e){
                    if (this.editingRow >= 0) {
                        if (this.editors.shouldCancel(this,
                                                      this.editingRow,
                                                      this.editingCol, e))
                        {
                            this.stopEditing(false);
                        } else {
                            if (this.editors.shouldFinish(this,
                                                          this.editingRow,
                                                          this.editingCol, e))
                            {
                                this.stopEditing(true);
                            }
                        }
                    }
                };

                this.iColVisibility = function(off) {
                    this.colOffset = (this.colOffset === 100) ? this.colOffset = off
                                                              : ((off !== this.colOffset) ? 0 : this.colOffset);
                };

                this.iRowVisibility = function(off) {
                    this.rowOffset = (this.rowOffset === 100) ? off
                                                              : (((off + this.rowOffset) === 0) ? 0 : this.rowOffset);
                };

                /**
                 * Get top grid caption height. Return zero if no top caption element has been defined
                 * @return {Integer} a top caption height
                 * @protected
                 * @method  getTopCaptionHeight
                 */
                this.getTopCaptionHeight = function(){
                    return (this.topCaption !== null && this.topCaption.isVisible === true) ? this.topCaption.height : 0;
                };

                /**
                 * Get left grid caption width. Return zero if no left caption element has been defined
                 * @return {Integer} a left caption width
                 * @protected
                 * @method  getLeftCaptionWidth
                 */
                this.getLeftCaptionWidth = function(){
                    return (this.leftCaption !== null && this.leftCaption.isVisible === true) ? this.leftCaption.width : 0;
                };

                this.paint = function(g){
                    this.vVisibility();

                    if (this.visibility.hasVisibleCells()) {
                        var dx = this.scrollManager.getSX(),
                            dy = this.scrollManager.getSY(),
                            th = this.getTopCaptionHeight(),
                            tw = this.getLeftCaptionWidth();

                        try {
                            g.save();
                            g.translate(dx, dy);

                            if (th > 0 || tw > 0) {
                                g.clipRect(tw - dx, th - dy, this.width  - tw, this.height - th);
                            }

                            if (this.paintPosMarkerOver !== true) {
                                this.paintPosMarker(g);
                            }

                            this.paintData(g);
                            if (this.paintNetOnCaption !== true && (this.drawHorLines === true || this.drawVerLines === true)) {
                                this.paintNet(g);
                            }

                            if (this.paintPosMarkerOver === true) {
                                this.paintPosMarker(g);
                            }

                            g.restore();
                        } catch(e) {
                            g.restore();
                            throw e;
                        }
                    }
                };

                this.paintOnTop = function(g) {
                    if (this.paintNetOnCaption === true && (this.drawHorLines === true || this.drawVerLines === true)) {
                        this.paintNet(g);
                    }
                };

                this.catchScrolled = function (psx, psy){
                    var offx = this.scrollManager.getSX() - psx,
                        offy = this.scrollManager.getSY() - psy;

                    if (offx !== 0) {
                        this.iColVisibility(offx > 0 ? 1 :  - 1);
                    }

                    if (offy !== 0) {
                        this.iRowVisibility(offy > 0 ? 1 :  - 1);
                    }

                    this.stopEditing(false);
                    this.repaint();
                };

                //TODO: zebkit doesn't support yet the method
                this.isInvalidatedByChild = function (c){
                    return c !== this.editor || this.isUsePsMetric;
                };

                /**
                 * Stop editing a grid cell.
                 * @param  {Boolean} applyData true if the edited data has to be applied as a new
                 * grid cell content
                 * @protected
                 * @method stopEditing
                 */
                this.stopEditing = function(applyData){
                    if (this.editors !== null &&
                        this.editingRow >= 0  &&
                        this.editingCol >= 0    )
                    {
                        try {
                            if (zebkit.instanceOf(this.editor, pkg.Grid)) {
                                this.editor.stopEditing(applyData);
                            }

                            var data = this.getDataToEdit(this.editingRow, this.editingCol);
                            if (applyData){
                                this.setEditedData(this.editingRow,
                                                   this.editingCol,
                                                   this.editors.fetchEditedValue( this,
                                                                                  this.editingRow,
                                                                                  this.editingCol,
                                                                                  data, this.editor));
                            }
                            this.repaintRows(this.editingRow, this.editingRow);
                        } finally {
                            this.editingCol = this.editingRow = -1;
                            if (this.indexOf(this.editor) >= 0) {
                                this.remove(this.editor);
                            }
                            this.editor = null;
                            this.requestFocus();
                        }
                    }
                };

                /**
                 * Set if horizontal and vertical lines have to be painted
                 * @param {Boolean} hor true if horizontal lines have to be painted
                 * @param {Boolean} ver true if vertical lines have to be painted
                 * @method setDrawLines
                 * @chainable
                 */
                this.setDrawLines = function(hor, ver){
                    if (this.drawVerLines !== hor || this.drawHorLines !== ver) {
                        this.drawHorLines = hor;
                        this.drawVerLines = ver;
                        this.repaint();
                    }
                    return this;
                };

                /**
                 * Set navigation mode. It is possible to use "row" or "cell" navigation mode.
                 * In first case navigation happens over row, in the second
                 * case navigation happens over cell.
                 * @param {String} mode a navigation mode ("row" pr "cell")
                 * @method setNavigationMode
                 * @chainable
                 */
                this.setNavigationMode = function(mode) {
                    if (mode.toLowerCase() === "row") {
                        this.navigationMode = "row";

                        this.getLineSize = function(row) {
                            return 1;
                        };

                        this.getMaxOffset = function() {
                            return this.getGridRows()-1;
                        };
                    } else {
                        this.navigationMode = "cell";

                        if (mode.toLowerCase() === "cell") {
                            this.getLineSize = function(row) {
                                return this.getGridCols();
                            };

                            this.getMaxOffset = function() {
                                return this.getGridRows()* this.getGridCols() - 1;
                            };
                        } else {
                            throw new Error("Unsupported position marker mode");
                        }
                    }
                    return this;
                };

                this.getLines = function() {
                    return this.getGridRows();
                };

                this.getLineSize = function(line) {
                    return 1;
                };

                this.getMaxOffset = function() {
                    return this.getGridRows() - 1;
                };

                this.posChanged = function(target, prevOffset, prevLine, prevCol) {
                    var row = this.position.currentLine;
                    if (row >= 0) {
                        this.makeVisible(row, this.position.currentCol);
                        this.select(row, true);
                        this.repaintRows(prevLine, row);
                    } else {
                        this.repaintRows(prevLine, prevLine);
                    }
                };

                this.keyReleased = function(e) {
                    if (this.position !== null) {
                        this.$se(this.position.currentLine,
                                 this.position.currentCol, e);
                    }
                };

                this.keyTyped = function(e){
                    if (this.position !== null) {
                        this.$se(this.position.currentLine, this.position.currentCol, e);
                    }
                };

                this.keyPressed = function(e){
                    if (this.position !== null) {
                        switch(e.code) {
                            case "ArrowLeft"   : this.position.seek(-1); break;
                            case "ArrowUp"     : this.position.seekLineTo("up"); break;
                            case "ArrowRight"  : this.position.seek(1); break;
                            case "ArrowDown"   : this.position.seekLineTo("down");break;
                            case "PageUp"      : this.position.seekLineTo("up", this.pageSize(-1));break;
                            case "PageDown"    : this.position.seekLineTo("down", this.pageSize(1));break;
                            case "End"         : if (e.ctrlKey) this.position.setOffset(this.getLines() - 1);break;
                            case "Home"        : if (e.ctrlKey) this.position.setOffset(0);break;
                        }

                        this.$se(this.position.currentLine, this.position.currentCol, e);
                    }
                };

                /**
                 * Checks if the given grid cell is selected
                 * @param  {Integer}  row a grid row
                 * @param  {Integer}  col a grid col
                 * @return {Boolean}  true if the given row is selected
                 * @method isSelected
                 */
                this.isSelected = function(row, col) {
                    return row === this.selectedIndex;
                };

                /**
                 * Repaint range of grid rows
                 * @param  {Integer} r1 the first row to be repainted
                 * @param  {Integer} r2 the last row to be repainted
                 * @method repaintRows
                 * @chainable
                 */
                this.repaintRows = function (r1,r2){
                    if (r1 < 0) r1 = r2;
                    if (r2 < 0) r2 = r1;
                    if (r1 > r2) {
                        var i = r2;
                        r2 = r1;
                        r1 = i;
                    }

                    var rows = this.getGridRows();
                    if (r1 < rows) {
                        if (r2 >= rows) r2 = rows - 1;
                        var y1 = this.getRowY(r1),
                            y2 = ((r1 === r2) ? y1 + 1 : this.getRowY(r2)) + this.rowHeights[r2];

                        this.repaint(0, y1 + this.scrollManager.getSY(), this.width, y2 - y1);
                    }

                    return this;
                };

                /**
                 * Detect a cell by the given location
                 * @param  {Integer} x a x coordinate relatively the grid component
                 * @param  {Integer} y a y coordinate relatively the grid component
                 * @return {Object} an object that contains detected grid cell row as
                 * "row" field and a grid column as "col" field. null is returned if
                 * no cell can be detected.
                 * @method cellByLocation
                 */
                this.cellByLocation = function(x,y){
                    this.validate();

                    var dx  = this.scrollManager.getSX(),
                        dy  = this.scrollManager.getSY(),
                        v   = this.visibility,
                        ry1 = v.fr[1] + dy,
                        rx1 = v.fc[1] + dx,
                        row = -1,
                        col = -1,
                        i   = 0,
                        ry2 = v.lr[1] + this.rowHeights[v.lr[0]] + dy,
                        rx2 = v.lc[1] + this.colWidths[v.lc[0]] + dx;

                    if (y > ry1 && y < ry2) {
                        for(i = v.fr[0];i <= v.lr[0]; ry1 += this.rowHeights[i] + this.lineSize, i++) {
                            if (y > ry1 && y < ry1 + this.rowHeights[i]) {
                                row = i;
                                break;
                            }
                        }
                    }
                    if (x > rx1 && x < rx2) {
                        for (i = v.fc[0];i <= v.lc[0]; rx1 += this.colWidths[i] + this.lineSize, i++ ) {
                            if (x > rx1 && x < rx1 + this.colWidths[i]) {
                                col = i;
                                break;
                            }
                        }
                    }
                    return (col >= 0 && row >= 0) ? { row:row, col:col } : null;
                };

                this.doLayout = function(target) {
                    var topHeight = (this.topCaption !== null &&
                                     this.topCaption.isVisible === true) ? this.topCaption.getPreferredSize().height : 0,
                        leftWidth = (this.leftCaption !== null &&
                                     this.leftCaption.isVisible === true) ? this.leftCaption.getPreferredSize().width : 0;

                    if (this.topCaption !== null){
                        this.topCaption.setBounds(this.getLeft() + leftWidth, this.getTop(),
                                                  Math.min(target.width - this.getLeft() - this.getRight() - leftWidth,
                                                           this.psWidth_),
                                                  topHeight);
                    }

                    if (this.leftCaption !== null){
                        this.leftCaption.setBounds(this.getLeft(),
                                                   this.getTop() + topHeight,
                                                   leftWidth,
                                                   Math.min(target.height - this.getTop() - this.getBottom() - topHeight,
                                                            this.psHeight_));
                    }

                    if (this.stub !== null && this.stub.isVisible === true)
                    {
                        if (this.topCaption  !== null && this.topCaption.isVisible === true &&
                            this.leftCaption !== null && this.leftCaption.isVisible === true  )
                        {
                            this.stub.setBounds(this.getLeft(), this.getTop(),
                                                this.topCaption.x - this.stub.x,
                                                this.leftCaption.y - this.stub.y);
                        } else {
                            this.stub.setSize(0, 0);
                        }
                    }

                    if (this.editors !== null &&
                        this.editor  !== null &&
                        this.editor.parent === this &&
                        this.editor.isVisible === true)
                    {
                        var w = this.colWidths[this.editingCol],
                            h = this.rowHeights[this.editingRow],
                            x = this.getColX(this.editingCol),
                            y = this.getRowY(this.editingRow);

                        if (this.isUsePsMetric){
                            x += this.cellInsetsLeft;
                            y += this.cellInsetsTop;
                            w -= (this.cellInsetsLeft + this.cellInsetsRight);
                            h -= (this.cellInsetsTop + this.cellInsetsBottom);
                        }

                        this.editor.setBounds(x + this.scrollManager.getSX(),
                                              y + this.scrollManager.getSY(), w, h);
                    }
                };

                this.canHaveFocus = function (){
                    return this.editor === null;
                };

                /**
                 * Clear grid row or rows selection
                 * @method clearSelect
                 * @chainable
                 */
                this.clearSelect = function (){
                    if (this.selectedIndex >= 0) {
                        var prev = this.selectedIndex;
                        this.selectedIndex = -1;
                        this._.rowSelected(this, -1, 0, false);
                        this.repaintRows(-1, prev);
                    }
                    return this;
                };

                /**
                 * Mark as selected or unselected the given grid cell
                 * @param  {Integer} row a grid row
                 * @param  {Integer} col a grid row,
                 * @param  {boolean} [b] a selection status. true if the parameter
                 * has not been specified
                 * @method select
                 * @chainable
                 */
                this.select = function (row, b){
                    if (arguments.length < 2) b = true;

                    if (this.isSelected(row) !== b){
                        if (this.selectedIndex >= 0) this.clearSelect();
                        if (b) {
                            this.selectedIndex = row;
                            this._.rowSelected(this, row, 1, b);
                        }
                    }

                    return this;
                };

                this.laidout = function () {
                    this.vVisibility();
                };

                this.pointerClicked = function(e) {
                    if (e.isAction() && this.visibility.hasVisibleCells()){
                        this.stopEditing(true);

                        if (e.isAction()){
                            var p = this.cellByLocation(e.x, e.y);
                            if (p !== null) {
                                if (this.position !== null){
                                    var row = this.position.currentLine,
                                        col = this.position.currentCol,
                                        ls  = this.getLineSize(p.row);

                                    // normalize column depending on marker mode: row or cell
                                    // in row mode marker can select only the whole row, so
                                    // column can be only 1  (this.getLineSize returns 1)
                                    if (row === p.row && col === p.col % ls) {
                                        this.makeVisible(row, col);
                                    } else {
                                        this.clearSelect();
                                        this.position.setRowCol(p.row, p.col % ls);
                                    }
                                }

                                if (this.$se(p.row, p.col, e)) {
                                    // TODO: initiated editor has get pointer clicked event
                                }
                            }
                        }
                    }
                };

                this.calcPreferredSize = function(target) {
                    return {
                        width : this.psWidth_  +
                               ((this.leftCaption !== null  &&
                                 this.leftCaption.isVisible === true) ? this.leftCaption.getPreferredSize().width : 0),
                        height: this.psHeight_ +
                               ((this.topCaption !== null  &&
                                 this.topCaption.isVisible === true) ? this.topCaption.getPreferredSize().height : 0)
                    };
                };

                /**
                 * Paint vertical and horizontal grid component lines
                 * @param  {CanvasRenderingContext2D} g a HTML5 canvas 2D context
                 * @method paintNet
                 * @protected
                 */
                this.paintNet = function(g) {
                    var v    = this.visibility,
                        i    = 0,
                        topX = v.fc[1] - this.lineSize,
                        topY = v.fr[1] - this.lineSize,
                        botX = v.lc[1] + this.colWidths[v.lc[0]],
                        botY = v.lr[1] + this.rowHeights[v.lr[0]],
                        prevWidth = g.lineWidth;

                    g.setColor(this.lineColor);
                    g.lineWidth = this.lineSize;
                    g.beginPath();

                    if (this.drawHorLines === true) {
                        i = v.fr[0];

                        var y  = topY + this.lineSize/2,
                            tx = (this.paintNetOnCaption === true) ? this.getLeft() : topX;

                        for(;i <= v.lr[0]; i++){
                            g.moveTo(tx, y);
                            g.lineTo(botX, y);
                            y += this.rowHeights[i] + this.lineSize;
                        }
                        g.moveTo(tx, y);
                        g.lineTo(botX, y);
                    }

                    if (this.drawVerLines === true) {
                        i = v.fc[0];

                        if (this.drawSideLines !== true && v.fc[0] === 0) {
                            i++;
                            topX = v.fc[1] + this.colWidths[0];
                        }

                        var x    = topX + this.lineSize/2,
                            cols = this.getGridCols() - 1,
                            ty   = (this.paintNetOnCaption === true) ? this.getTop() : topY;

                        for(;i <= v.lc[0] &&  (this.drawSideLines === true || i < cols); i++){
                            g.moveTo(x , ty);
                            g.lineTo(x, botY);
                            x += this.colWidths[i] + this.lineSize;
                        }
                        g.moveTo(x, ty);
                        g.lineTo(x, botY);
                    }
                    g.stroke();
                    g.lineWidth = prevWidth;
                };

                /**
                 * Paint grid data
                 * @param  {CanvasRenderingContext2D} g a HTML5 canvas 2d context
                 * @method paintData
                 * @protected
                 */
                this.paintData = function(g) {
                    var y    = this.visibility.fr[1] + this.cellInsetsTop,
                        addW = this.cellInsetsLeft   + this.cellInsetsRight,
                        addH = this.cellInsetsTop    + this.cellInsetsBottom,
                        ts   = g.$states[g.$curState],
                        cx   = ts.x,
                        cy   = ts.y,
                        cw   = ts.width,
                        ch   = ts.height,
                        res  = {};

                    for(var i = this.visibility.fr[0];i <= this.visibility.lr[0] && y < cy + ch; i++){
                        if (y + this.rowHeights[i] > cy) {
                            var x = this.visibility.fc[1] + this.cellInsetsLeft;

                            for(var j = this.visibility.fc[0];j <= this.visibility.lc[0]; j++) {
                                if (this.isSelected(i, j) === true) {
                                    this.paintCellSelection(g, i, j, x - this.cellInsetsLeft, y - this.cellInsetsTop);
                                } else {
                                    var bg = typeof this.provider.getCellColor !== 'undefined' ? this.provider.getCellColor(this, i, j)
                                                                                               : this.defCellColor;
                                    if (bg !== null) {
                                        g.setColor(bg);
                                        g.fillRect(x - this.cellInsetsLeft,
                                                   y - this.cellInsetsTop,
                                                   this.colWidths[j], this.rowHeights[i]);
                                    }
                                }

                                var v = (i === this.editingRow &&
                                         j === this.editingCol   ) ? null
                                                                   : this.provider.getView(this, i, j,
                                                                                           this.model.get(i, j));
                                if (v !== null) {
                                    var w = this.colWidths[j]  - addW,
                                        h = this.rowHeights[i] - addH;

                                    res.x = x > cx ? x : cx;
                                    res.width = Math.min(x + w, cx + cw) - res.x;
                                    res.y = y > cy ? y : cy;
                                    res.height = Math.min(y + h, cy + ch) - res.y;

                                    if (res.width > 0 && res.height > 0) {
                                        // TODO: most likely the commented section should be removed
                                        // if (this.isUsePsMetric !== true) {
                                        //     v.paint(g, x, y, w, h, this);
                                        // }
                                        //else {
                                            var ax = typeof this.provider.getXAlignment !== 'undefined' ? this.provider.getXAlignment(this, i, j)
                                                                                                        : this.defXAlignment,
                                                ay = typeof this.provider.getYAlignment !== 'undefined' ? this.provider.getYAlignment(this, i, j)
                                                                                                        : this.defYAlignment,
                                                vw = w, // cell width
                                                vh = h, // cell height
                                                xx = x,
                                                yy = y,
                                                id = -1,
                                                ps = (ax !== null || ay !== null) ? v.getPreferredSize(vw, vh)
                                                                                  : null;

                                            if (ax !== null) {
                                                xx = x + ((ax === "center") ? ~~((w - ps.width) / 2)
                                                                            : ((ax === "right") ? w - ps.width : 0));
                                                vw = ps.width;
                                            }

                                            if (ay !== null) {
                                                yy = y + ((ay === "center") ? ~~((h - ps.height) / 2)
                                                                            : ((ay === "bottom") ? h - ps.height : 0));
                                                vh = ps.height;
                                            }

                                            if (xx < res.x || yy < res.y || (xx + vw) > (x + w) || (yy + vh) > (y + h)) {
                                                id = g.save();
                                                g.clipRect(res.x, res.y, res.width, res.height);
                                            }

                                            v.paint(g, xx, yy, vw, vh, this);
                                            if (id >= 0) {
                                               g.restore();
                                            }
                                       // }
                                    }
                                }
                                x += (this.colWidths[j] + this.lineSize);
                            }
                        }
                        y += (this.rowHeights[i] + this.lineSize);
                    }
                };

                this.$getPosMarker = function() {
                    return this.hasFocus() ? (typeof this.views.marker === 'undefined' ? null : this.views.marker)
                                           : (typeof this.views.offmarker === 'undefined' ? null : this.views.offmarker);
                };

                this.paintPosMarker = function(g) {
                    if (this.position       !== null &&
                        this.position.offset >= 0       )
                    {
                        var view       = this.$getPosMarker(),
                            row        = this.position.currentLine,
                            col        = this.position.currentCol,
                            rowPosMode = this.navigationMode === "row",
                            v          = this.visibility;

                        // depending on position changing mode (cell or row) analyze
                        // whether the current position is in visible area
                        if (view !== null && row >= v.fr[0] && row <= v.lr[0] &&
                            (rowPosMode === true || (col >= v.fc[0] && col <= v.lc[0])))
                        {
                            // TODO: remove the clip, think it is redundant code
                            // g.clipRect(this.getLeftCaptionWidth() - this.scrollManager.getSX(),
                            //            this.getTopCaptionHeight() - this.scrollManager.getSY(),
                            //            this.width, this.height);

                            // detect if grid marker position works in row selection mode
                            if (rowPosMode === true) {
                                // row selection mode
                                view.paint(g,   v.fc[1],
                                                this.getRowY(row),
                                                v.lc[1] - v.fc[1] + this.colWidths[v.lc[0]],
                                                this.rowHeights[row], this);
                            } else {
                                // cell selection mode
                                view.paint(g,   this.getColX(col),
                                                this.getRowY(row),
                                                this.colWidths[col],
                                                this.rowHeights[row], this);
                            }
                        }
                    }
                };

                this.paintCellSelection = function(g, row, col, x, y) {
                    if (this.editingRow < 0) {
                        var v = ui.focusManager.focusOwner === this ? this.views.onselection
                                                                    : this.views.offselection;
                        if (v !== null && typeof v !== 'undefined')  {
                            v.paint(g, x, y, this.colWidths[col], this.rowHeights[row], this);
                        }
                    }
                };

                this.rPsMetric = function(){
                    var cols  = this.getGridCols(),
                        rows  = this.getGridRows(),
                        addW  = this.cellInsetsLeft + this.cellInsetsRight,
                        addH  = this.cellInsetsTop  + this.cellInsetsBottom,
                        capPS = null,
                        i     = 0;

                    if (this.colWidths === null || this.colWidths.length !== cols) {
                        this.colWidths = Array(cols);
                        for (;i < cols; i++) this.colWidths[i] = 0;
                    } else {
                        for (;i < cols; i++) this.colWidths[i] = 0;
                    }

                    if (this.rowHeights === null || this.rowHeights.length !== rows) {
                        this.rowHeights = Array(rows);
                        for(i = 0; i < rows; i++) this.rowHeights[i] = 0;
                    } else {
                        for(i = 0;i < rows; i++) this.rowHeights[i] = 0;
                    }

                    for(i = 0; i < cols; i++ ){
                        for(var j = 0; j < rows; j++ ){
                            var v = this.provider.getView(this, j, i, this.model.get(j, i));
                            if (v !== null){
                                var ps = v.getPreferredSize();
                                ps.width  += addW;
                                ps.height += addH;
                                if (ps.width  > this.colWidths[i] ) this.colWidths [i] = ps.width;
                                if (ps.height > this.rowHeights[j]) this.rowHeights[j] = ps.height;
                            } else {
                                if (pkg.Grid.DEF_COLWIDTH > this.colWidths [i]) {
                                    this.colWidths [i] = pkg.Grid.DEF_COLWIDTH;
                                }

                                if (pkg.Grid.DEF_ROWHEIGHT > this.rowHeights[j]) {
                                    this.rowHeights[j] = pkg.Grid.DEF_ROWHEIGHT;
                                }
                            }
                        }
                    }

                    if (this.topCaption !== null && this.topCaption.isVisible === true) {
                        for(i = 0;i < cols; i++ ) {
                            capPS = this.topCaption.getCaptionPS(i);
                            if (capPS  > this.colWidths[i]) this.colWidths[i] = capPS;
                        }
                    }

                    if (this.leftCaption !== null && this.leftCaption.isVisible === true) {
                        for(i = 0;i < rows; i++ ) {
                            capPS = this.leftCaption.getCaptionPS(i);
                            if (capPS  > this.rowHeights[i]) this.rowHeights[i] = capPS;
                        }
                    }
                };

                this.getPSSize = function (rowcol,b){
                    if (this.isUsePsMetric === true) {
                        return b ? this.getRowHeight(rowcol) : this.getColWidth(rowcol);
                    } else {
                        var max = 0, count = b ? this.getGridCols() : this.getGridRows();
                        for(var j = 0;j < count; j ++ ){
                            var r = b ? rowcol : j, c = b ? j : rowcol,
                                v = this.provider.getView(this, r, c, this.model.get(r, c));

                            if (v !== null){
                                var ps = v.getPreferredSize();
                                if (b) {
                                    if (ps.height > max) max = ps.height;
                                } else {
                                    if (ps.width > max) max = ps.width;
                                }
                            }
                        }
                        return max + this.lineSize * 2 +
                               (b ? this.cellInsetsTop + this.cellInsetsBottom
                                  : this.cellInsetsLeft + this.cellInsetsRight);
                    }
                };

                this.rCustomMetric = function(){
                    var start = 0;
                    if (this.colWidths !== null) {
                        start = this.colWidths.length;
                        if (this.colWidths.length !== this.getGridCols()) {
                            this.colWidths.length = this.getGridCols();
                        }
                    } else {
                        this.colWidths = Array(this.getGridCols());
                    }

                    for(; start < this.colWidths.length; start ++ ) {
                        this.colWidths[start] = pkg.Grid.DEF_COLWIDTH;
                    }

                    start = 0;
                    if (this.rowHeights !== null) {
                        start = this.rowHeights.length;
                        if (this.rowHeights.length !== this.getGridRows()) {
                            this.rowHeights.length = this.getGridRows();
                        }
                    } else {
                        this.rowHeights = Array(this.getGridRows());
                    }

                    for(; start < this.rowHeights.length; start++) {
                        this.rowHeights[start] = pkg.Grid.DEF_ROWHEIGHT;
                    }
                };

                /**
                 * Calculate number of rows to be scrolled up or down to scroll one page
                 * @param  {Integer} d a direction. 1 for scroll down and -1 for scroll up
                 * @return {Integer}  a page size in rows to be scrolled up or down
                 * @method pageSize
                 * @protected
                 */
                this.pageSize = function(d){
                    this.validate();
                    if (this.visibility.hasVisibleCells() && this.position !== null) {
                        var off = this.position.offset;
                        if (off >= 0){
                            var hh  = this.visibleArea.height - this.getTopCaptionHeight(),
                                sum = 0,
                                poff = off;

                            for(; off >= 0 && off < this.getGridRows() && sum < hh; sum += this.rowHeights[off] + this.lineSize,off += d);
                            return Math.abs(poff - off);
                        }
                    }
                    return 0;
                };

                /**
                 * Set the given height for the specified grid row. The method has no effect
                 * if the grid component is forced to use preferred size metric.
                 * @param {Integer} row a grid row
                 * @param {Integer} h   a height of the grid row
                 * @method setRowHeight
                 * @chainable
                 */
                this.setRowHeight = function(row,h){
                    this.setRowsHeight(row, 1, h);
                    return this;
                };

                /**
                 * Set the given height for all or the specified range of rows
                 * @param {Integer} [row] start row
                 * @param {Integer} [len] number of rows whose height has to be set
                 * @param {Integer} h  a height
                 * @method setRowsHeight
                 * @chainable
                 */
                this.setRowsHeight = function(row, len, h) {
                    if (this.isUsePsMetric === false){
                        if (arguments.length === 1) {
                            h   = arguments[0];
                            row = 0;
                            len = this.getGridRows();
                        }

                        if (len !== 0) {
                            this.validateMetric();
                            var b = false;
                            for(var i=row; i < row + len; i++) {
                                if (this.rowHeights[i] !== h) {
                                    this.psHeight_ += (h - this.rowHeights[i]);
                                    this.rowHeights[i] = h;
                                    b = true;
                                }
                            }

                            if (b === true) {
                                this.stopEditing(false);
                                this.cachedHeight = this.getTop() + this.getBottom() + this.psHeight_ +
                                                    ((this.topCaption !== null && this.topCaption.isVisible === true) ? this.topCaption.getPreferredSize().height : 0);

                                if (this.parent !== null) {
                                    this.parent.invalidate();
                                }

                                this.iRowVisibility(0);
                                this.invalidateLayout();
                                this.repaint();
                            }
                        }

                        return this;
                    }
                };

                /**
                 * Set the given width for the specified grid column. The method has no effect
                 * if the grid component is forced to use preferred size metric.
                 * @param {Integer} column a grid column
                 * @param {Integer} w   a width of the grid column
                 * @method setColWidth
                 * @chainable
                 */
                this.setColWidth = function (col,w){
                    this.setColsWidth(col, 1, w);
                    return this;
                };

                /**
                 * Set the given width for all or the specified range of columns
                 * @param {Integer} [col] start column
                 * @param {Integer} [len] number of columns whose height has to be set
                 * @param {Integer} w  a width
                 * @method setColsHeight
                 * @chainable
                 */
                this.setColsWidth = function(col, len, w){
                    if (this.isUsePsMetric === false){
                        if (arguments.length === 1) {
                            w   = arguments[0];
                            col = 0;
                            len = this.getGridCols();
                        }

                        if (len !== 0)  {
                            this.validateMetric();
                            var b = false;
                            for(var i = col; i < col + len; i++) {
                                if (this.colWidths[i] !== w){
                                    this.psWidth_ += (w - this.colWidths[i]);
                                    this.colWidths[i] = w;
                                    b = true;
                                }
                            }

                            if (b === true) {
                                this.stopEditing(false);
                                this.cachedWidth = this.getRight() + this.getLeft() +
                                                   this.psWidth_ + ((this.leftCaption !== null &&
                                                                     this.leftCaption.isVisible === true) ? this.leftCaption.getPreferredSize().width
                                                                                                          : 0);
                                if (this.parent !== null) {
                                    this.parent.invalidate();
                                }
                                this.iColVisibility(0);
                                this.invalidateLayout();
                                this.repaint();
                            }
                        }

                        return this;
                    }
                };

                this.matrixResized = function(target, prevRows, prevCols){
                    this.clearSelect();

                    this.vrp();
                    if (this.position !== null) {
                        this.position.setOffset(null);
                    }

                    for(var i = 0; i < this.kids.length; i++) {
                        if (typeof this.kids[i].matrixResized !== 'undefined') {
                            this.kids[i].matrixResized(target,prevRows,prevCols);
                        }
                    }
                };

                this.cellModified = function(target,row,col,prevValue) {
                    if (this.isUsePsMetric){
                        this.invalidate();
                    }

                    for(var i=0; i < this.kids.length; i++) {
                        if (typeof this.kids[i].cellModified !== 'undefined') {
                            this.kids[i].cellModified(target,row,col, prevValue);
                        }
                    }
                };

                this.matrixSorted = function(target, info) {
                    this.clearSelect();
                    this.vrp();

                    for(var i=0; i < this.kids.length; i++) {
                        if (typeof this.kids[i].matrixSorted !== 'undefined') {
                            this.kids[i].matrixSorted(target, info);
                        }
                    }
                };

                /**
                 * Set the given editor provider. Editor provider is a way to customize
                 * cell editing.
                 * @param {Object} p an editor provider
                 * @method setEditorProvider
                 * @chainable
                 */
                this.setEditorProvider = function(p){
                    if (p !== this.editors){
                        this.stopEditing(true);
                        this.editors = p;
                    }
                    return this;
                };

                /**
                 * Force to size grid columns and rows according to its preferred size
                 * @param {Boolean} b use true to use preferred size
                 * @method setUsePsMetric
                 * @chainable
                 */
                this.setUsePsMetric = function(b){
                    if (this.isUsePsMetric !== b){
                        this.isUsePsMetric = b;
                        this.vrp();
                    }
                    return this;
                };

                this.setPosition = function(p){
                    if (this.position !== p){
                        if (this.position !== null) {
                            this.position.off(this);
                        }

                        /**
                         * Virtual cursor position controller
                         * @readOnly
                         * @attribute position
                         * @type {zebkit.util.Position}
                         */
                        this.position = p;
                        if (this.position !== null) {
                            this.position.on(this);
                            this.position.setMetric(this);
                        }
                        this.repaint();
                    }

                    return this;
                };

                /**
                 * Set the given cell view provider. Provider is a special
                 * class that says how grid cells content has to be rendered,
                 * aligned, colored
                 * @param {Object} p a view provider
                 * @method setViewProvider
                 * @chainable
                 */
                this.setViewProvider = function(p){
                    if (this.provider !== p){
                        this.provider = p;
                        this.vrp();
                    }
                    return this;
                };

                /**
                 * Set the given matrix model to be visualized and controlled
                 * with the grid component
                 * @param {zebkit.data.Matrix|Array} d a model passed as an
                 * instance of  matrix model or an array that contains
                 * model rows as embedded arrays.
                 * @method setModel
                 * @chainable
                 */
                this.setModel = function(d){
                    if (d !== this.model) {
                        this.clearSelect();
                        if (Array.isArray(d)) d = new this.clazz.Matrix(d);

                        if (this.model !== null && typeof this.model._ !== 'undefined') {
                            this.model.off(this);
                        }

                        this.model = d;
                        if (this.model !== null && typeof this.model._ !== 'undefined') {
                            this.model.on(this);
                        }

                        if (this.position !== null) {
                            this.position.setOffset(null);
                        }

                        this.vrp();
                    }

                    return this;
                };

                /**
                 * Set the given top, left, right, bottom cell paddings
                 * @param {Integer} p a top, left, right and bottom cell paddings
                 * @method setCellPadding
                 * @chainable
                 */
                this.setCellPadding = function (p){
                    this.setCellPaddings(p,p,p,p);
                    return this;
                };

                /**
                 * Set the given top, left, right, bottom cell paddings
                 * @param {Integer} t a top cell padding
                 * @param {Integer} l a left cell padding
                 * @param {Integer} b a bottom cell padding
                 * @param {Integer} r a rightcell padding
                 * @method setCellPaddings
                 * @chainable
                 */
                this.setCellPaddings = function (t,l,b,r){
                    if (t !== this.cellInsetsTop    || l !== this.cellInsetsLeft ||
                        b !== this.cellInsetsBottom || r !== this.cellInsetsRight)
                    {
                        this.cellInsetsTop = t;
                        this.cellInsetsLeft = l;
                        this.cellInsetsBottom = b;
                        this.cellInsetsRight = r;
                        this.vrp();
                    }

                    return this;
                };

                /**
                 * Set the given color to render the grid vertical and horizontal lines
                 * @param {String} c a color
                 * @method setLineColor
                 * @chainable
                 */
                this.setLineColor = function (c){
                    if (c !== this.lineColor){
                        this.lineColor = c;
                        if (this.drawVerLines || this.drawHorLines) {
                            this.repaint();
                        }
                    }
                    return this;
                };

                /**
                 * Set the given grid lines size
                 * @param {Integer} s a size
                 * @method setLineSize
                 * @chainable
                 */
                this.setLineSize = function (s){
                    if (s !== this.lineSize){
                        this.lineSize = s;
                        this.vrp();
                    }
                    return this;
                };

                /**
                 * Start editing the given grid cell. Editing is initiated only if an editor
                 * provider has been set and the editor provider defines not-null UI component
                 * as an editor for the given cell.
                 * @param  {Integer} row a grid cell row
                 * @param  {Integer} col a grid cell column
                 * @method startEditing
                 */
                this.startEditing = function(row, col){
                    this.stopEditing(true);
                    if (this.editors !== null){
                        var editor = this.editors.getEditor(this, row, col,
                                                            this.getDataToEdit(row, col));

                        if (editor !== null){
                            this.editingRow = row;
                            this.editingCol = col;
                            if (editor.isPopupEditor === true) {
                                var p = zebkit.layout.toParentOrigin(this.getColX(col) + this.scrollManager.getSX(),
                                                                     this.getRowY(row) + this.scrollManager.getSY(),
                                                                     this);

                                editor.setLocation(p.x, p.y);
                                ui.makeFullyVisible(this.getCanvas(), editor);
                                this.editor = editor;

                                var $this = this;
                                this.editor.winOpened = function(e) {
                                    if (e.isShown === false){
                                        $this.stopEditing(typeof e.source.isAccepted !== 'undefined' ? e.source.isAccepted() : false);
                                    }
                                };
                                ui.showModalWindow(this, editor, this);
                            } else {
                                this.add("editor", editor);
                                this.repaintRows(this.editingRow, this.editingRow);
                            }
                            ui.focusManager.requestFocus(editor);

                            return true;
                        }
                    }
                    return false;
                };

                /**
                 * Fetch a data from matrix model that has to be edited
                 * @param  {Integer} row a row
                 * @param  {Integer} col a column
                 * @return {Object} a matrix model data to be edited
                 * @method getDataToEdit
                 * @protected
                 */
                this.getDataToEdit = function (row, col){
                    return this.model.get(row, col);
                };

                /**
                 * Apply the given edited data to grid matrix model
                 * @param  {Integer} row a row
                 * @param  {Integer} col a column
                 * @param  {Object}  an edited matrix model data to be applied
                 * @method setEditedData
                 * @protected
                 */
                this.setEditedData = function (row,col,value){
                    this.model.put(row, col, value);
                };

                this.setLeftCaption = function() {
                    if (this.leftCaption !== null) {
                        this.leftCaption.removeMe();
                    }
                    this.add("left", new pkg.GridCaption(Array.prototype.slice.call(arguments)));
                    return this;
                };

                this.setTopCaption = function() {
                    if (this.topCaption !== null) {
                        this.topCaption.removeMe();
                    }
                    this.add("top", new pkg.GridCaption(Array.prototype.slice.call(arguments)));
                    return this;
                };
            },

            function focused() {
                this.$super();
                this.repaint();
            },

            function invalidate(){
                this.$super();
                this.iColVisibility(0);
                this.iRowVisibility(0);
            },

            function kidAdded(index, ctr, c){
                this.$super(index, ctr, c);

                if ((ctr === null && this.topCaption === null) || "top" === ctr){
                    this.topCaption = c;
                } else {
                    if ("editor" === ctr) this.editor = c;
                    else {
                        if ((ctr === null && this.leftCaption === null) || "left" === ctr) {
                            this.leftCaption = c;
                        } else {
                            if ((ctr === null && this.stub === null) || "corner" === ctr) {
                                this.stub = c;
                            }
                        }
                    }
                }
            },

            function kidRemoved(index,c) {
                this.$super(index, c);
                if (c === this.editor) this.editor = null;
                else {
                    if (c === this.topCaption){
                        this.topCaption = null;
                    } else {
                        if (c === this.leftCaption){
                            this.leftCaption = null;
                        } else {
                            if (c === this.stub) this.stub = null;
                        }
                    }
                }
            }

            /**
             *  Set number of views to render different grid component elements
             *  @param {Object} a set of views as dictionary where key is a view
             *  name and the value is a view instance, string (for color, border),
             *  or render function. The following view elements can be passed:
             *
             *
             *      {
             *         "onselection" : <view to render selected row for the grid that holds focus>,
             *         "offselection": <view to render selected row for the grid that doesn't hold focus>
             *      }
             *
             *
             *  @method  setViews
             */
    ]);


    var ui = pkg.cd("..");

    /**
     * Special UI panel that manages to stretch grid columns to occupy the whole panel space.
     *

            ...

            var canvas = new zebkit.ui.zCanvas();
            var grid = new zebkit.ui.grid.Grid(100,10);
            var pan  = new zebkit.ui.grid.GridStretchPan(grid);

            canvas.root.setLayout(new zebkit.layout.BorderLayout());
            canvas.root.add("center", pan);

            ...

     * @constructor
     * @param {zebkit.ui.grid.Grid} grid a grid component that has to be added in the panel
     * @class zebkit.ui.grid.GridStretchPan
     * @extends {zebkit.ui.Panel}
     */
    pkg.GridStretchPan = Class(ui.Panel, [
        function (grid){
            this.$super(this);

            /**
             * Target grid component
             * @type {zebkit.ui.Grid}
             * @readOnly
             * @attribute grid
             */
            this.grid = grid;

            this.$widths = [];
            this.$prevWidth = 0;
            this.$propW = -1;
            this.add(grid);
        },

        function $prototype() {
            this.$props = this.$strPs = null;

            this.grid = null;

            this.calcPreferredSize = function(target) {
                this.recalcPS();
                return (target.kids.length === 0 ||
                        target.grid.isVisible === false) ? { width:0, height:0 }
                                                         : { width:this.$strPs.width,
                                                             height:this.$strPs.height };
            };

            this.doLayout = function(target){
                this.recalcPS();
                if (target.kids.length > 0){
                    var grid = this.grid,
                        left = target.getLeft(),
                        top = target.getTop();

                    if (grid.isVisible === true) {
                        grid.setBounds(left, top,
                                       target.width  - left - target.getRight(),
                                       target.height - top  - target.getBottom());

                        for(var i = 0; i < this.$widths.length; i++) {
                            grid.setColWidth(i, this.$widths[i]);
                        }
                    }
                }
            };

            this.captionResized = function(src, col, pw){
                if (col < this.$widths.length - 1) {
                    var grid = this.grid,
                        w    = grid.getColWidth(col),
                        dt   = w - pw;

                    if (dt < 0) {
                        grid.setColWidth(col + 1, grid.getColWidth(col + 1) - dt);
                    } else {
                        var ww = grid.getColWidth(col + 1) - dt,
                            mw = this.getMinWidth();

                        if (ww < mw) {
                            grid.setColWidth(col, w - (mw - ww));
                            grid.setColWidth(col + 1, mw);
                        } else {
                            grid.setColWidth(col + 1, ww);
                        }
                    }

                    this.$propW = -1;
                }
            };

            this.getMinWidth = function () {
                return zebkit.instanceOf(this.grid.topCaption, pkg.BaseCaption) ? this.grid.topCaption.minSize
                                                                               : 10;
            };

            this.calcColWidths = function(targetAreaW){
                var grid = this.grid,
                    cols = grid.getGridCols(),
                    ew   = targetAreaW - (this.$props.length + 1) * grid.lineSize,
                    sw   = 0;

                if (this.$widths.length !== cols) {
                    this.$widths = Array(cols);
                }

                for(var i = 0; i < cols; i++){
                    if (this.$props.length - 1 === i) {
                        this.$widths[i] = ew - sw;
                    } else {
                        this.$widths[i] = Math.round(ew * this.$props[i]);
                        sw += this.$widths[i];
                    }
                }
            };

            this.recalcPS = function (){
                var grid = this.grid;
                if (grid !== null && grid.isVisible === true) {
                    // calculate size excluding padding where
                    // the target grid columns have to be stretched
                    var p        = this.parent,
                        isScr    = zebkit.instanceOf(p, ui.ScrollPan),
                        taWidth  = (isScr ? p.width - p.getLeft() - p.getRight() - this.getRight() - this.getLeft()
                                          : this.width - this.getRight() - this.getLeft()),
                        taHeight = (isScr ? p.height - p.getTop() - p.getBottom() - this.getBottom() - this.getTop()
                                          : this.height - this.getBottom() - this.getTop());

                    // exclude left caption
                    if (this.grid.leftCaption !== null &&
                        this.grid.leftCaption.isVisible === true)
                    {
                        taWidth -= this.grid.leftCaption.getPreferredSize().width;
                    }

                    if (this.$strPs === null || this.$prevWidth !== taWidth) {
                        var cols = grid.getGridCols();
                        if (this.$propW < 0 || this.$props === null || this.$props.length !== cols) {
                            // calculate col proportions
                            if (this.$props === null || this.$props.length !== cols) {
                                this.$props = Array(cols);
                            }
                            this.$propW = 0;

                            var i = 0, w = 0;

                            for(i = 0; i < cols; i++){
                                w = grid.getColWidth(i);
                                if (w === 0) w = grid.getColPSWidth(i);
                                this.$propW += w;
                            }

                            for(i = 0; i < cols; i++){
                                w = grid.getColWidth(i);
                                if (w === 0) w = grid.getColPSWidth(i);
                                this.$props[i] = w / this.$propW;
                            }
                        }

                        this.$prevWidth  = taWidth;
                        this.calcColWidths(taWidth);
                        this.$strPs   = {
                            width : taWidth,
                            height: grid.getPreferredSize().height
                        };

                        // check if the calculated height is greater than
                        // height of the parent component and re-calculate
                        // the metrics if vertical scroll bar is required
                        // taking in account horizontal reduction because of
                        // the scroll bar visibility
                        if (isScr === true &&
                            p.height > 0 &&
                            (typeof p.vBar !== 'undefined' || p.vBar === null) &&
                            p.autoHide === false &&
                            taHeight < this.$strPs.height)
                        {
                            taWidth -= p.vBar.getPreferredSize().width;
                            this.calcColWidths(taWidth);
                            this.$strPs.width = taWidth;
                        }
                    }
                }
            };
        },

        function kidAdded(index,constr,l){
            this.$propsW = -1;
            if (l.topCaption !== null) {
                l.topCaption.on(this);
            }
            this.scrollManager = l.scrollManager;
            this.$super(index, constr, l);
        },

        function kidRemoved(i,l){
            this.$propsW = -1;
            if (l.topCaption !== null) {
                l.topCaption.off(this);
            }
            this.scrollManager = null;
            this.$super(i, l);
        },

        function invalidate(){
            this.$strPs = null;
            this.$super();
        }
    ]);


    zebkit.ui.$configWith(pkg);
});
zebkit.package("ui.design", function(pkg, Class) {
    var ui = pkg.cd("..");

    /**
     * The package contains number of UI components that can be helpful to
     * perform visual control of an UI component. You can control an UI component
     * size and location.
     *
     *     var root = (new zebkit.ui.zCanvas(400, 300)).root;
     *     root.setLayout(new zebkit.layout.RasterLayout());
     *     root.setPadding(8);
     *
     *     // Add check box component wrapped with shaper panel
     *     // to control the component size and location
     *     var ch = new zebkit.ui.Checkbox("Check-box")
     *                           .setBounds(10, 10, 100, 30);
     *
     *     root.add(new zebkit.ui.design.ShaperPan(ch));
     *
     * @class  zebkit.ui.design
     * @access package
     */
    var CURSORS = {
        left        : ui.Cursor.W_RESIZE,
        right       : ui.Cursor.E_RESIZE,
        top         : ui.Cursor.N_RESIZE,
        bottom      : ui.Cursor.S_RESIZE,
        topLeft     : ui.Cursor.NW_RESIZE,
        topRight    : ui.Cursor.NE_RESIZE,
        bottomLeft  : ui.Cursor.SW_RESIZE,
        bottomRight : ui.Cursor.SE_RESIZE,
        center      : ui.Cursor.MOVE,
        none        : ui.Cursor.DEFAULT
    };

    /**
     * A designer border view. The border view visually indicates areas
     * of border with different size possibilities.
     * @constructor
     * @class zebkit.ui.design.ShaperBorder
     * @extends {zebkit.ui.View}
     */
    pkg.ShaperBorder = Class(ui.View, [
        function $prototype() {
            this.color = "blue";
            this.gap   = 7;

            function contains(x, y, gx, gy, ww, hh) {
                return gx <= x && (gx + ww) > x && gy <= y && (gy + hh) > y;
            }

            this.paint = function(g,x,y,w,h,d){
                var cx = Math.floor((w - this.gap)/2),
                    cy = Math.floor((h - this.gap)/2);

                g.setColor(this.color);
                g.beginPath();
                g.rect(x, y, this.gap, this.gap);
                g.rect(x + cx, y, this.gap, this.gap);
                g.rect(x, y + cy, this.gap, this.gap);
                g.rect(x + w - this.gap, y, this.gap, this.gap);
                g.rect(x, y + h - this.gap, this.gap, this.gap);
                g.rect(x + cx, y + h - this.gap, this.gap, this.gap);
                g.rect(x + w - this.gap, y + cy, this.gap, this.gap);
                g.rect(x + w - this.gap, y + h - this.gap, this.gap, this.gap);
                g.fill();

                g.beginPath();

                // very strange thing with rect() method if it called with w or h
                // without decreasing with gap it is ok, otherwise moving   a
                // component with the border outside parent component area leaves
                // traces !
                //
                // adding 0.5 (to center line) solves the problem with traces
                g.rect(x + Math.floor(this.gap / 2) + 0.5,
                       y + Math.floor(this.gap / 2) + 0.5,
                       w - this.gap,
                       h - this.gap );

                g.stroke();
            };

            this.detectAt = function(target,x,y) {
                if (contains(x, y, this.gap, this.gap, target.width - 2 * this.gap, target.height - 2 * this.gap)) {
                    return "center";
                }

                if (contains(x, y, 0, 0, this.gap, this.gap)) {
                    return "topLeft";
                }

                if (contains(x, y, 0, target.height - this.gap, this.gap, this.gap)) {
                    return "bottomLeft";
                }

                if (contains(x, y, target.width - this.gap, 0, this.gap, this.gap)) {
                    return "topRight";
                }

                if (contains(x, y, target.width - this.gap, target.height - this.gap, this.gap, this.gap)) {
                    return "bottomRight";
                }

                var mx = Math.floor((target.width - this.gap) / 2);
                if (contains(x, y, mx, 0, this.gap, this.gap)) {
                    return "top";
                }

                if (contains(x, y, mx, target.height - this.gap, this.gap, this.gap)) {
                    return "bottom";
                }

                var my = Math.floor((target.height - this.gap)/2);
                if (contains(x, y, 0, my, this.gap, this.gap)) {
                    return "left";
                }

                return contains(x, y, target.width - this.gap, my, this.gap, this.gap) ? "right"
                                                                                       : "none";
            };
        }
    ]);

    /**
     * This is UI component class that implements possibility to embeds another
     * UI components to control the component size and location visually.

            // create canvas
            var canvas = new zebkit.ui.zCanvas(300,300);

            // create two UI components
            var lab = new zebkit.ui.Label("Label");
            var but = new zebkit.ui.Button("Button");

            // add created before label component as target of the shaper
            // component and than add the shaper component into root panel
            canvas.root.add(new zebkit.ui.design.ShaperPan(lab).properties({
                bounds: [ 30,30,100,40]
            }));

            // add created before button component as target of the shaper
            // component and than add the shaper component into root panel
            canvas.root.add(new zebkit.ui.design.ShaperPan(but).properties({
                bounds: [ 130,130,100,50]
            }));

     * @class  zebkit.ui.design.ShaperPan
     * @constructor
     * @extends {zebkit.ui.Panel}
     * @param {zebkit.ui.Panel} target a target UI component whose size and location
     * has to be controlled
     */
    pkg.ShaperPan = Class(ui.Panel, [
        function $clazz() {
            this.colors = [ "lightGray", "blue" ];
        },

        function $prototype() {
            this.colors = null;

           /**
            * Indicates if controlled component can be moved
            * @attribute isMoveEnabled
            * @type {Boolean}
            * @default true
            */

           /**
            * Indicates if controlled component can be sized
            * @attribute isResizeEnabled
            * @type {Boolean}
            * @default true
            */

            /**
             * Minimal possible height or controlled component
             * @attribute minHeight
             * @type {Integer}
             * @default 12
             */

            /**
             * Minimal possible width or controlled component
             * @attribute minWidth
             * @type {Integer}
             * @default 12
             */
            this.minHeight = this.minWidth = 12;
            this.canHaveFocus = this.isResizeEnabled = this.isMoveEnabled = true;
            this.state = null;

            this.catchInput = true;

            this.getCursorType = function (t, x ,y) {
                return this.kids.length > 0 ? CURSORS[this.shaperBr.detectAt(t, x, y)]
                                            : null;
            };

            /**
             * Define key pressed events handler
             * @param  {zebkit.ui.KeyEvent} e a key event
             * @method keyPressed
             */
            this.keyPressed = function(e) {
                if (this.kids.length > 0){
                    var dx = (e.code === "ArrowLeft" ? -1 : (e.code === "ArrowRight" ? 1 : 0)),
                        dy = (e.code === "ArrowUp"   ? -1 : (e.code === "ArrowDown"  ? 1 : 0)),
                        w  = this.width  + dx,
                        h  = this.height + dy,
                        x  = this.x + dx,
                        y  = this.y + dy;

                    if (e.shiftKey) {
                        if (this.isResizeEnabled === true && w > this.shaperBr.gap * 2 && h > this.shaperBr.gap * 2) {
                            this.setSize(w, h);
                        }
                    } else {
                        if (this.isMoveEnabled) {
                            if (x + this.width/2  > 0 &&
                                y + this.height/2 > 0 &&
                                x < this.parent.width  - this.width/2  &&
                                y < this.parent.height - this.height/2    )
                            {
                                this.setLocation(x, y);
                            }
                        }
                    }
                }
            };

            /**
             * Define pointer drag started events handler
             * @param  {zebkit.ui.PointerEvent} e a pointer event
             * @method pointerDragStarted
             */
            this.pointerDragStarted = function(e) {
                this.state = null;
                if (this.isResizeEnabled || this.isMoveEnabled) {
                    var t = this.shaperBr.detectAt(this, e.x, e.y);
                    if ((this.isMoveEnabled   === true || t !== "center")||
                        (this.isResizeEnabled === true || t === "center")  )
                    {
                        this.state = { top    : (t === "top"    || t === "topLeft"     || t === "topRight"   ) ? 1 : 0,
                                       left   : (t === "left"   || t === "topLeft"     || t === "bottomLeft" ) ? 1 : 0,
                                       right  : (t === "right"  || t === "topRight"    || t === "bottomRight") ? 1 : 0,
                                       bottom : (t === "bottom" || t === "bottomRight" || t === "bottomLeft" ) ? 1 : 0 };

                        this.px = e.absX;
                        this.py = e.absY;
                    }
                }
            };

            /**
             * Define pointer dragged events handler
             * @param  {zebkit.ui.PointerEvent} e a pointer event
             * @method pointerDragged
             */
            this.pointerDragged = function(e){
                if (this.state !== null) {
                    var dy = (e.absY - this.py),
                        dx = (e.absX - this.px),
                        s  = this.state,
                        nw = this.width  - dx * s.left + dx * s.right,
                        nh = this.height - dy * s.top  + dy * s.bottom;

                    if (nw >= this.minWidth && nh >= this.minHeight) {
                        this.px = e.absX;
                        this.py = e.absY;
                        if ((s.top + s.right + s.bottom + s.left) === 0) {
                            this.setLocation(this.x + dx, this.y + dy);
                        } else {
                            this.setBounds(this.x + dx * s.left, this.y + dy * s.top, nw, nh);
                     //       this.invalidateLayout();
                        }
                    }
                }
            };

            this.setColor = function (b, color) {
                var rp = false;
                if (this.colors === null) {
                    this.colors = [ "lightGray", "blue"];
                    rp = true;
                }

                var oldCol = this.colors[b?1:0];
                if (oldCol !== color) {
                    this.colors[b?1:0] = color;
                    rp = true;
                }

                var hasFocus = this.hasFocus();
                if (this.shaperBr.color !== this.colors[hasFocus?1:0]) {
                    this.shaperBr.color = this.colors[hasFocus?1:0];
                    rp = true;
                }

                if (rp) {
                    this.repaint();
                }

                return this;
            };

            this.setColors = function(col1, col2) {
                this.setColor(false, col1);
                if (arguments.length > 1) {
                    this.setColor(true, col2);
                }
                return this;
            };
        },

        function insert(i, constr, d) {
            if (this.kids.length > 0) {
                this.removeAll();
            }

            var top  = this.getTop(),
                left = this.getLeft();

            if (d.width === 0 || d.height === 0) {
                d.toPreferredSize();
            }

            this.setBounds(d.x - left, d.y - top,
                           d.width + left + this.getRight(),
                           d.height + top + this.getBottom());
            this.$super(i, "center", d);
        },

        function focused(){
            this.$super();
            this.shaperBr.color = this.colors[this.hasFocus()? 1 : 0];
            this.repaint();
        },

        function(t) {
            this.shaperBr = new pkg.ShaperBorder();
            this.$super(new zebkit.layout.BorderLayout());
            this.px = this.py = 0;
            this.setBorder(this.shaperBr);
            if (arguments.length > 0) {
                this.add(t);
            }
        }
    ]);

    /**
     * Special tree model implementation that represent zebkit UI component
     * hierarchy as a simple tree model.
     * @param  {zebkit.ui.Panel} target a root UI component
     * @constructor
     * @class zebkit.ui.design.FormTreeModel
     * @extends {zebkit.data.TreeModel}
     */
    pkg.FormTreeModel = Class(zebkit.data.TreeModel, [
        function $prototype() {
            this.buildModel = function(comp, root){
                var b    = typeof this.exclude !== 'undefined' && this.exclude(comp),
                    item = b ? root : this.createItem(comp);

                for(var i = 0; i < comp.kids.length; i++) {
                    var r = this.buildModel(comp.kids[i], item);
                    if (r !== null) {
                        r.parent = item;
                        item.kids.push(r);
                    }
                }
                return b ? null : item;
            };

            this.itemByComponent = function (c, r) {
                if (arguments.length < 2) r = this.root;
                if (r.comp === c) return c;
                for(var i = 0;i < r.kids.length; i++) {
                    var item = this.itemByComponent(c, r.kids[i]);
                    if (item !== null) return item;
                }
                return null;
            };

            this.createItem = function(comp){
                var name = comp.clazz.$name;
                if (typeof name === 'undefined') name = comp.toString();
                var index = name.lastIndexOf('.'),
                    item = new zebkit.data.Item(index > 0 ? name.substring(index + 1) : name);
                item.comp = comp;
                return item;
            };
        },

        function (target){
            this.$super(this.buildModel(target, null));
        }
    ]);
});
zebkit.package("web", function(pkg, Class) {
    'use strict';
    /**
     * Web specific stuff to provide abstracted method to work in WEB context.
     * @class zebkit.web
     * @access package
     */

    /**
     * Device ratio.
     * @attribute $deviceRatio
     * @readOnly
     * @private
     * @type {Number}
     */
    pkg.$deviceRatio = typeof window.devicePixelRatio !== "undefined" ? window.devicePixelRatio
                                                                      : (typeof window.screen.deviceXDPI !== "undefined" ? window.screen.deviceXDPI / window.screen.logicalXDPI // IE
                                                                                                                         : 1);

    pkg.$windowSize = function() {
        // iOS retina devices can have a problem with performance
        // in landscape mode because of a bug (full page size is
        // just 1 pixels column more than video memory that can keep it)
        // So, just make width always one pixel less.
        return  {
            width : window.innerWidth, //   - 1,
            height: window.innerHeight
        };
    };

    /**
     * Calculates view port of a browser window
     * @return {Object} a browser window view port size.
     *
     *    ```json
     *    {
     *      width : {Integer},
     *      height: {Integer}
     *    }
     *    ```
     *
     * @method $viewPortSize
     * @for  zebkit.web
     * @private
     */
    pkg.$viewPortSize = function() {
        var ws   = pkg.$windowSize(),
            body = document.body,
            css  = [ "margin-left", "margin-right", "margin-top", "margin-bottom",
                     "padding-left", "padding-right", "padding-top", "padding-bottom",
                     "border-left-width", "border-right-width", "border-top-width", "border-bottom-width"];

        for(var i = 0; i < css.length;) {
            ws.width  -= (pkg.$measure(body, css[i++]) + pkg.$measure(body, css[i++]));
            ws.height -= (pkg.$measure(body, css[i++]) + pkg.$measure(body, css[i++]));
        }
        return ws;
    };

    pkg.$measure = function(e, cssprop) {
        var value = window.getComputedStyle(e, null).getPropertyValue(cssprop);
        return (value === null || value === '') ? 0
                                                : parseInt(/(^[0-9\.]+)([a-z]+)?/.exec(value)[1], 10);
    };


    /**
     * Tests if the given DOM element is in document
     * @private
     * @param  {Element} element a DOM element
     * @return {Boolean} true if the given DOM element is in document
     * @method $contains
     * @for  zebkit.web
     */
    pkg.$contains = function(element) {
        // TODO: not sure it is required, probably it can be replaced with document.body.contains(e);
        return (typeof document.contains !== 'undefined' && document.contains(element)) ||
               (typeof document.body.contains !== 'undefined' && document.body.contains(element)); // !!! use body for IE
    };

    /**
     * Test if the given page coordinates is inside the given element
     * @private
     * @param  {Element} element a DOM element
     * @param  {Number} pageX an x page coordinate
     * @param  {Number} pageY an y page coordinate
     * @return {Boolean} true if the given point is inside the specified DOM element
     * @method $isInsideElement
     */
    pkg.$isInsideElement = function(element, pageX, pageY) {
        var r = element.getBoundingClientRect();
        return r !== null            &&
               pageX >= r.left       &&
               pageY >= r.top        &&
               pageX <= r.right - 1  &&
               pageY <= r.bottom - 1   ;
    };

    var $focusInOutSupported = (function() {
        var support = false,
            parent  = document.lastChild,
            a       = document.createElement('a');

        a.href = '#';
        a.setAttribute("style", "position:fixed;left:-99em;top:-99em;");
        a.addEventListener('focusin', function() {
            support = true;
        });

        parent.appendChild(a).focus();
        parent.removeChild(a);
        return support;
    })();

    pkg.$focusin = function(element, f, b) {
        return element.addEventListener($focusInOutSupported ? "focusin" : "focus", f, b);
    };

    pkg.$focusout = function(element, f, b) {
        return element.addEventListener($focusInOutSupported ? "focusout" : "blur", f, b);
    };

    pkg.$eventsBlackHole = function(e) {
        e.preventDefault();
        e.stopPropagation();
    };

    /**
     * Creates HTML element that "eats" (doesn't propagate and prevents default) all input (touch, mouse, key)
     * events that it gets.
     * @return {HTMLElement} a created HTML element.
     * @method  $createBlockedElement
     * @protected
     * @for  zebkit.web
     */
    pkg.$createBlockedElement = function() {
        var be = document.createElement("div");
        be.style.height = be.style.width  = "100%";
        be.style.left = be.style.top = "0px";
        be.style.position = "absolute";
        be.style["z-index"] = "100000";
        be.setAttribute("zebkit", "blockedElement");

        be.onmouseup   = be.onmousedown = be.onmouseout =
        be.onmouseover = be.onmousemove = be.onkeydown  =
        be.onkeypress  = be.onkeyup = pkg.$eventsBlackHole;

        var events = [ "touchstart", "touchend", "touchmove",
                       "pointerdown", "pointerup", "pointermove",
                       "pointerenter", "pointerleave" ];

        for(var i = 0 ; i < events.length ; i++ ) {
           be.addEventListener(events[i], pkg.$eventsBlackHole, false);
        }

        return be;
    };

    /**
     * Dictionary of useful methods an HTML Canvas 2D context can be extended. The following methods are
     * included:
     *
     *   - **setFont(f)**   set font
     *   - **setColor(c)**  set background and foreground colors
     *   - **drawLine(x1, y1, x2, y2, [w])**  draw line of the given width
     *   - **ovalPath(x,y,w,h)**  build oval path
     *   - **polylinePath(xPoints, yPoints, nPoints)**  build path by the given points
     *   - **drawDottedRect(x,y,w,h)**  draw dotted rectangle
     *   - **drawDashLine(x,y,x2,y2)** draw dashed line
     *
     * @attribute $2DContextMethods
     * @type {Object}
     * @protected
     * @readOnly
     */
    pkg.$2DContextMethods = {
        setFont : function(f) {
            f = (typeof f.s !== 'undefined' ? f.s : f.toString());
            if (f !== this.font) {
                this.font = f;
            }
        },

        setColor : function (c) {
            c = (typeof c.s !== 'undefined' ? c.s : c.toString());
            if (c !== this.fillStyle) this.fillStyle = c;
            if (c !== this.strokeStyle) this.strokeStyle = c;
        },

        drawLine : function (x1, y1, x2, y2, w){
            if (arguments.length < 5) w = 1;
            var pw = this.lineWidth;
            this.beginPath();
            if (this.lineWidth !== w) this.lineWidth = w;

            if (x1 === x2) {
                x1 += w / 2;
                x2 = x1;
            } else if (y1 === y2) {
                y1 += w / 2;
                y2 = y1;
            }

            this.moveTo(x1, y1);
            this.lineTo(x2, y2);
            this.stroke();
            if (pw !== this.lineWidth) this.lineWidth = pw;
        },

        ovalPath: function (x,y,w,h){
            this.beginPath();
            x += this.lineWidth;
            y += this.lineWidth;
            w -= 2 * this.lineWidth;
            h -= 2 * this.lineWidth;

            var kappa = 0.5522848,
                ox = Math.floor((w / 2) * kappa),
                oy = Math.floor((h / 2) * kappa),
                xe = x + w,
                ye = y + h,
                xm = x + w / 2,
                ym = y + h / 2;
            this.moveTo(x, ym);
            this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
            this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
            this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
            this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
            this.closePath();
        },

        polylinePath : function(xPoints, yPoints, nPoints){
            this.beginPath();
            this.moveTo(xPoints[0], yPoints[0]);
            for(var i = 1; i < nPoints; i++) this.lineTo(xPoints[i], yPoints[i]);
        },

        drawDottedRect : function(x,y,w,h) {
            var ctx = this, m = ["moveTo", "lineTo", "moveTo"];
            function dv(x, y, s) { for(var i=0; i < s; i++) ctx[m[i%3]](x + 0.5, y + i); }
            function dh(x, y, s) { for(var i=0; i < s; i++) ctx[m[i%3]](x + i, y + 0.5); }
            ctx.beginPath();
            dh(x, y, w);
            dh(x, y + h - 1, w);
            ctx.stroke();
            ctx.beginPath();
            dv(x, y, h);
            dv(w + x - 1, y, h);
            ctx.stroke();
        },

        drawDashLine : function(x,y,x2,y2) {
            var pattern = [1,2],
                compute = null,
                dx      = (x2 - x), dy = (y2 - y),
                b       = (Math.abs(dx) > Math.abs(dy)),
                slope   = b ? dy / dx : dx / dy,
                sign    = b ? (dx < 0 ?-1:1) : (dy < 0?-1:1),
                dist    = Math.sqrt(dx * dx + dy * dy);

            if (b) {
                compute = function(step) {
                    x += step;
                    y += slope * step;
                };
            }
            else {
                compute = function(step) {
                    x += slope * step;
                    y += step;
                };
            }

            this.beginPath();
            this.moveTo(x, y);
            for (var i = 0; dist >= 0.1; i++) {
                var idx  = i % pattern.length,
                    dl   = dist < pattern[idx] ? dist : pattern[idx],
                    step = Math.sqrt(dl * dl / (1 + slope * slope)) * sign;

                compute(step);
                this[(i % 2 === 0) ? 'lineTo' : 'moveTo'](x + 0.5, y + 0.5);
                dist -= dl;
            }
            this.stroke();
        }
    };

    /**
     * Extend standard 2D HTML Canvas context instance with the given set of methods.
     * If new methods clash with already existent 2D context method the old one is overwritten
     * with new one and old method is saved using its name prefixed with "$" character
     * @param  {CanvasRenderingContext2D} ctx  a 2D HTML Canvas context instance
     * @param  {Array} methods list of methods to be added to the context
     * @method $extendContext
     * @private
     */
    pkg.$extendContext = function(ctx, methods) {
        for(var k in methods) {
            if (k === "$init") {
                methods[k].call(ctx);
            } else {
                var old = ctx[k];
                if (typeof old !== 'undefined') {
                    var kk = "$" + k;
                    if (typeof ctx[kk] === 'undefined') {
                        ctx[kk] = old;
                    }
                }
                ctx[k] = methods[k];
            }
        }
    };

    /**
     * Adjusts the given HTML Canvas element to the required size that takes in account device DPI.
     * Extend the canvas 2D context with extra methods and variables that are used with zebkit UI
     * engine.
     * @param  {HTMLCanvasElement} c a HTML canvas element
     * @param  {Integer} w  a required width of the given canvas
     * @param  {Integer} h  a required height of the given canvas
     * @param  {Boolean} [forceResize] flag to force canvas resizing even if the canvas has identical width and height.
     * It is required to re-create canvas 2D context to work properly.
     * @return {CanvasRenderingContext2D} a 2D context of the canvas element
     * @method $canvas
     * @protected
     * @for  zebkit.web
     */
    pkg.$canvas = function(c, w, h, forceResize) {
        // fetch current CSS size of canvas
        var cs = window.getComputedStyle(c, null),
            cw = parseInt(cs.getPropertyValue("width"),  10),
            ch = parseInt(cs.getPropertyValue("height"), 10),
            ctx = c.getContext("2d"),
            updateRatio = false;

        // if CSS width or height has not been set for the canvas
        // it has to be done, otherwise scaling on hi-DPI screen
        // will not work
        if (isNaN(parseInt(c.style.width ))||
            isNaN(parseInt(c.style.height))  )
        {
            c.style.width  = "" + cw + "px";
            c.style.height = "" + ch + "px";
            updateRatio = true;
        }

        // setup new canvas CSS size if appropriate width and height
        // parameters have been passed and they don't match current CSS
        // width and height
        if (arguments.length > 1) {
            if (cw !== w || ch !== h) {
                c.style.width  = "" + w + "px";
                c.style.height = "" + h + "px";
                updateRatio = true;
            }
            cw = w;
            ch = h;
        }

        // canvas 2D context is singleton so check if the
        // context has already been modified to prevent
        // redundancy
        if (typeof ctx.$ratio === "undefined") {
            ctx.$ratio = (ctx.webkitBackingStorePixelRatio ||   // backing store ratio
                          ctx.mozBackingStorePixelRatio    ||
                          ctx.msBackingStorePixelRatio     ||
                          ctx.backingStorePixelRatio       ||
                          ctx.backingStorePixelRatio       || 1);

            ctx.$getImageData = ctx.getImageData;
            ctx.$scale        = ctx.scale;          // save original method if at some stage
                                                    // it will be overridden (zebkit does it)
                                                    // only original method has to be used to
                                                    // adjust canvas to screen DPI
            if (pkg.$deviceRatio != ctx.$ratio) {
                var r = pkg.$deviceRatio / ctx.$ratio;
                ctx.getImageData= function(x, y, w, h) {
                    return this.$getImageData(x * r, y * r, w, h);
                };
            }

            // populate extra method to 2d context
            pkg.$extendContext(ctx, pkg.$2DContextMethods);
        }

        // take in account that canvas can be visualized on
        // Retina screen where the size of canvas (backstage)
        // can be less than it is real screen size. Let's
        // make it match each other
        if (ctx.$ratio != pkg.$deviceRatio) {
            var ratio = pkg.$deviceRatio / ctx.$ratio;

            // calculate canvas with and height taking in account
            // screen ratio
            cw = ~~(cw * ratio);
            ch = ~~(ch * ratio);

            // adjust canvas size if it is necessary
            if (c.width != cw || c.height != ch || updateRatio === true || forceResize === true) {
                c.width  = cw;
                c.height = ch;
                ctx.$scale(ratio, ratio);
            }
        } else {
            // adjust canvas size if it is necessary
            if (c.width != cw || c.height != ch || forceResize === true) {
                c.width  = cw;
                c.height = ch;
            }
        }

        // TODO: top works not good in FF and it is better don't use it
        // So, ascent has to be taking in account as it was implemented
        // before
        if (ctx.textBaseline !== "top" ) {
            ctx.textBaseline = "top";
        }

        return ctx;
    };


    //  zebkit dependencies:
    //      -- zebkit.ui.Clipboard
    //      -- zebkit.web.$fetchKeyCode
    //
    //

    // IE doesn't allow standard window.Event instantiation
    // this is a workaround to avoid the problem
    function CustomEvent(event, params ) {
        params = params || { bubbles: false, cancelable: false, detail: undefined };
        var evt = document.createEvent( 'CustomEvent' );
        evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );
        return evt;
    }
    CustomEvent.prototype = window.Event.prototype;

    function $dupKeyEvent(e, id, target)  {
        var k = new CustomEvent(id);
        k.keyCode   = e.keyCode;
        k.key       = e.key;
        k.code      = e.code;
// TODO: cannot be set in strict mode and most likely it is set with dispactEvent() function
// properly
//        k.target    = target;
        k.ctrlKey   = e.ctrlKey;
        k.altKey    = e.altKey;
        k.shiftKey  = e.shiftKey;
        k.metaKey   = e.metaKey;
        k.which     = e.which;

      // TODO: cannot be set in strict mode and most likely it is set with dispactEvent() function
      // properly
      //  k.timeStamp = e.timeStamp;
        return k;
    }

    /**
     * Clipboard support class. The class is light abstraction that helps to perform
     * textual data exchange via system (browser) clipboard. Browsers have different approaches
     * and features regarding clipboard implementation and clipboard API. This class
     * hides the native specific and provides simple way to exchange data via clipboard.
     * @param  {String} [triggerKeyCode] a key code that starts triggering clipboard copy
     * paste actions. It depends on platform. On Linux "Control" + <xxx> combination
     * should be used, but on Mac OSX "MetaLeft" + xxx.
     * To handle copy, paste and cut event override the following methods:
     *    - **copy**   "clipCopy(focusOwnerComponent, data)"
     *    - **paste**  "clipPaste(focusOwnerComponent, data)"
     *    - **cut**    "clipCut(focusOwnerComponent, data)"
     * @constructor
     * @class zebkit.web.Clipboard
     * @extends zebkit.ui.Clipboard
     */
    pkg.Clipboard = Class(zebkit.ui.Clipboard, [
        function(triggerKeyCode) {
            if (document.getElementById(this.clazz.id) !== null) {
                throw new Error("Duplicated clipboard element");
            }

            if (arguments.length > 0 && triggerKeyCode !== null) {
                this.triggerKeyCode = triggerKeyCode;
            } else {
                this.triggerKeyCode = zebkit.isMacOS ? "MetaLeft"
                                                     : "Control";
            }

            if (this.triggerKeyCode !== null) {
                this.$clipboard = document.createElement("textarea");
                this.$clipboard.setAttribute("style", "display:none;position:fixed;left:-99em;top:-99em;");
                this.$clipboard.setAttribute("id", this.clazz.id);

                this.$element   = null;

                var $this = this;

                window.addEventListener("keydown", function(e) {
                    var dest = $this.getDestination();
                    if (dest !== null) {
                        if (typeof dest.clipCopy !== 'undefined' || typeof dest.clipPaste !== 'undefined') {
                            if (zebkit.web.$fetchKeyCode(e) === $this.triggerKeyCode) {
                                // value has to be set, otherwise some browsers (Safari) do not generate
                                // "copy" event
                                $this.$on("1");
                            }
                        }
                    }
                }, true);

                this.$clipboard.onkeydown = function(ee) {
                    $this.$element.dispatchEvent($dupKeyEvent(ee, 'keydown', this.$element));
                    $this.$clipboard.value = "1";
                    $this.$clipboard.select();
                };

                this.$clipboard.onkeyup = function(ee) {
                    if (zebkit.web.$fetchKeyCode(ee) === $this.triggerKeyCode) {
                        $this.$clipboard.style.display = "none";
                        $this.$element.focus();
                    }

                    $this.$element.dispatchEvent($dupKeyEvent(ee,'keyup', $this.$element));
                };

                this.$clipboard.onfocus = function(e) {
                    if ($this.$element == null && e.relatedTarget != null) {
                        $this.$element = e.relatedTarget;
                    }
                };

                this.$clipboard.onblur = function() {
                    this.value = "";
                    this.style.display = "none";

                    //!!! pass focus back to canvas
                    //    it has to be done for the case when cmd+TAB (switch from browser to
                    //    another application)
                    $this.$element.focus();
                };

                this.$clipboard.oncopy = function(ee) {
                    var dest = $this.getDestination();
                    if (dest          !== null &&
                        typeof dest.clipCopy !== 'undefined')
                    {
                        var v = dest.clipCopy();
                        $this.$clipboard.value = (v === null || typeof v === 'undefined' ? "" : v);
                        $this.$clipboard.select();
                        if (typeof $this.clipCopy !== 'undefined') {
                            $this.clipCopy(v, $this.$clipboard.value);
                        }
                    }
                };

                this.$clipboard.oncut = function(ee) {
                    var dest = $this.getDestination();
                    if (dest !== null && typeof dest.cut !== 'undefined') {
                        $this.$clipboard.value = dest.cut();
                        $this.$clipboard.select();
                        if (typeof $this.clipCut !== 'undefined') {
                            $this.clipCut(dest, $this.$clipboard.value);
                        }
                    }
                };

                if (zebkit.isFF === true) {
                    this.$clipboard.addEventListener("input", function(ee) {
                        var dest = $this.getDestination();
                        if (dest !== null && typeof dest.clipPaste !== 'undefined') {
                            dest.clipPaste($this.$clipboard.value);
                            if (typeof $this.clipPaste !== 'undefined') {
                                $this.clipPaste(dest, $clipboard.value);
                            }
                        }

                    }, false);
                } else {
                    this.$clipboard.onpaste = function(ee) {
                        var dest = $this.getDestination();
                        if (dest !== null && typeof dest.clipPaste !== 'undefined') {
                            var txt = (typeof ee.clipboardData === "undefined") ? window.clipboardData.getData('Text')  // IE
                                                                                : ee.clipboardData.getData('text/plain');
                            dest.clipPaste(txt);
                            if (typeof $this.clipPaste !== 'undefined') {
                                $this.clipPaste(dest, txt);
                            }
                        }
                        $this.$clipboard.value = "";
                    };
                }

                document.body.appendChild(this.$clipboard);
            }
        },

        function $clazz() {
            this.id = "zebkitClipboardBuffer";
        },

        function $prototype() {
            /**
             * Clipboard trigger key code.
             * @private
             * @readOnly
             * @attribute triggerKeyCode
             * @type {String}
             */
            this.triggerKeyCode = null;

            /**
             * Write the given content into clipboard. This method not necessary work on
             * all browsers by default. Many browsers issue security restrictions regarding
             * clipboard data manipulation.
             * @param  {String} txt a content
             * @method  write
             */
            this.write = function(txt) {
                try {
                    this.$on(txt);
                    if (typeof document.execCommand !== 'undefined' && document.execCommand("copy") !== true) {
                        throw new Error("Unsupported 'copy' clipboard command");
                    }
                } finally {
                    this.$off();
                }
            };

            /**
             * Read clipboard content. This method not necessary work on
             * all browsers by default. Many browsers issue security restrictions regarding
             * clipboard data manipulation.
             * @return {String} a clipboard content.
             * @method  read
             */
            this.read = function() {
                try {
                    var clip = this.$on("");
                    if (typeof document.execCommand !== 'undefined' && document.execCommand("paste", null, null)) {
                        return clip.value;
                    } else {
                        throw new Error("Unsupported 'paste' clipboard command");
                    }
                } finally {
                    this.$off();
                }
            };

            /**
             * Return focus from a hidden element back to initial one.
             * @private
             * @method $off
             */
            this.$off = function() {
                if (this.$clipboard.style.display !== "none") {
                    this.$clipboard.value = "";
                    this.$clipboard.style.display = "none";

                    //!!! pass focus back to canvas
                    //    it has to be done for the case when cmd+TAB (switch from browser to
                    //    another application)
                    this.$element.focus();
                }
            };

            /**
             * Pass focus to hidden html element to catch input.
             * @private
             * @method $on
             */
            this.$on = function(txt) {
                this.$off();

                this.$element = document.activeElement;
                this.$clipboard.style.display = "block";

                // value has to be set, otherwise some browsers (Safari) do not generate
                // "copy" event
                this.$clipboard.value = arguments.length > 0 ? txt : "1";
                this.$clipboard.select();
                this.$clipboard.focus();
                return this.$clipboard;
            };
        }
    ]);

    new pkg.Clipboard();


    // TODO List:
    //    [+] add pressure level field to pointer events
    //    [-] group field
    //    [+] floor for pageX/pageY
    //    [+] double click
    //    [+] check if button field is required or can be removed from pointer event
    //    [+] support global status keeping and updating (ctrl/alt/shift)
    //    [+] "lmouse" and "rmouse" should be constants
    //    [-] list of active touches or pointers have to be available
    //    [-] meX/meY -> (x, y) ?

    if (typeof pkg.doubleClickDelta === 'undefined') {
        pkg.doubleClickDelta = 280;
    }

    var PI4                      = Math.PI/4,  // used to calculate touch event gamma (direction
        PI4_3                    = PI4 * 3,    // in polar coordinate)
        $enteredElement          = null,
        $tmpWinMouseMoveListener = null,
        $lastPointerReleased     = null,
        $pointerPressedEvents    = {},         // collect all pointer pressed events
        LMOUSE = "lmouse",
        RMOUSE = "rmouse";

    /**
     * Mouse and touch screen input event class. The input event is triggered by a mouse or
     * touch screen.
     * @class  zebkit.ui.PointerEvent
     * @constructor
     */
    pkg.PointerEvent = Class(zebkit.ui.PointerEvent, [
        function $prototype() {
            this.isAction = function() {
                return this.identifier !== RMOUSE && this.touchCounter === 1;
            };

            this.$fillWith = function(identifier, e) {
                this.pageX      = Math.floor(e.pageX);
                this.pageY      = Math.floor(e.pageY);
                this.target     = e.target;
                this.identifier = identifier;
                this.altKey     = typeof e.altKey   !== 'undefined' ? e.altKey   : false;
                this.shiftKey   = typeof e.shiftKey !== 'undefined' ? e.shiftKey : false;
                this.ctrlKey    = typeof e.ctrlKey  !== 'undefined' ? e.ctrlKey  : false;
                this.metaKey    = typeof e.metaKey  !== 'undefined' ? e.metaKey  : false;
                this.pressure   = typeof e.pressure !== 'undefined' ? e.pressure : 0.5;
            };

            this.getTouches = function() {
                var touches = [], i = 0;
                for(var k in pkg.$pointerPressedEvents) {
                    var pe = pkg.$pointerPressedEvents[k];
                    touches[i++] = {
                        pageX      : pe.pageX,
                        pageY      : pe.pageY,
                        identifier : pe.identifier,
                        target     : pe.target,
                        pressure   : pe.pressure,
                        pointerType: pe.stub.pointerType
                    };
                }
                return touches;
            };
        }
    ]);

    var ME_STUB      = new pkg.PointerEvent(), // instance of mouse event
        TOUCH_STUB   = new pkg.PointerEvent(), // instance of touch event
        POINTER_STUB = new pkg.PointerEvent(); // instance of pointer event

    ME_STUB.pointerType      = "mouse";
    TOUCH_STUB.pointerType   = "touch";
    POINTER_STUB.pointerType = "unknown"; // type of pointer events have to be copied from original WEB PointerEvent

    // !!!
    // global mouse move events handler (registered by drag out a canvas surface)
    // has to be removed every time a mouse button released with the given function
    function $cleanDragFix() {
        if ($tmpWinMouseMoveListener !== null      &&
            $pointerPressedEvents.hasOwnProperty(LMOUSE) === false &&
            $pointerPressedEvents.hasOwnProperty(RMOUSE) === false   )
        {
            window.removeEventListener("mousemove", $tmpWinMouseMoveListener, true);
            $tmpWinMouseMoveListener = null;
            return true;
        }
        return false;
    }

    function isIn(t, id) {
        for(var i = 0; i < t.length; i++) {
            if (t[i].identifier === id) return true;
        }
        return false;
    }

    pkg.PointerEventUnifier = Class([
        function $clazz() {
            // !!!!
            // TODO: this method works only for mouse (constant of mouse event ids is in)
            // not clear if it is ok
            //
            // the document mouse up happens when we drag outside a canvas.
            // in this case canvas doesn't catch mouse up, so we have to do it
            // by global mouseup handler
            document.addEventListener("mouseup", function(e) {
                // ignore any mouse buttons except left
                // and right buttons
                if (e.button === 0 || e.button === 2) {
                    var id = e.button === 0 ? LMOUSE : RMOUSE;

                    // !!!!
                    // Check if the event target is not the canvas itself
                    // On desktop  "mouseup" event is generated only if
                    // you drag mouse outside a canvas and than release a mouse button
                    // At the same time in Android native browser (and may be other mobile
                    // browsers) "mouseup" event is fired every time you touch
                    // canvas or any other element. So check if target is not a canvas
                    // before doing releasing, otherwise it brings to error on mobile
                    if ($pointerPressedEvents.hasOwnProperty(id)) {
                        var mp = $pointerPressedEvents[id];
                        if (mp.$adapter.element !== e.target && mp.$adapter.element.contains(e.target) === false) {
                            try {
                                if ($enteredElement !== null) {
                                    $enteredElement = null;
                                    mp.$adapter.destination.$pointerExited(ME_STUB);
                                }
                            } finally {
                                mp.$adapter.$UP(id, e, ME_STUB);
                            }
                        }
                    }
                }
            },  false); // false is important since if mouseUp  happens on
                        // canvas the canvas gets the event first and than stops
                        // propagating to prevent it
        },

        function $prototype() {
            this.$timer = null;
            this.$queue = [];

            this.$touchedAt = function(pageX, pageY, d) {
                var lx = pageX - d,
                    ty = pageY - d,
                    rx = pageX + d,
                    by = pageY + d;

                for(var k in $pointerPressedEvents) {
                    if (k !== LMOUSE && k !== RMOUSE) {
                        var e = $pointerPressedEvents[k];
                        if (e.pageX >= lx && e.pageY >= ty && e.pageX <= rx && e.pageY <= by) {
                            return true;
                        }
                    }
                }
                return false;
            };

            this.$DRAG = function(id, e, stub) {
                // a pointer touched has been pressed and pressed target zebkit component exists
                // emulate mouse dragging events if mouse has moved on the canvas where mouse
                // pressed event occurred
                if ($pointerPressedEvents.hasOwnProperty(id)) {
                    // get appropriate pointerPressed event that has occurred before
                    var mp = $pointerPressedEvents[id];

                    // ignore moved if there still start events that are waiting for to be fired
                    if (mp.$adapter.element === this.element) {
                        // target component exists and mouse cursor moved on the same
                        // canvas where mouse pressed occurred
                        if (this.$timer === null) {  // ignore drag for if the queue of touches is not empty
                            stub.$fillWith(id, e);

                            var dx = stub.pageX - mp.pageX,
                                dy = stub.pageY - mp.pageY,
                                d  = mp.direction;

                            // accumulate shifting of pointer
                            mp.$adx += dx;
                            mp.$ady += dy;

                            // update stored touch coordinates with a new one
                            mp.pageX  = stub.pageX;
                            mp.pageY  = stub.pageY;

                            // we can recognize direction only if move was not too small
                            if (Math.abs(mp.$adx) > 4 || Math.abs(mp.$ady) > 4) {
                                // compute gamma, this is corner in polar coordinate system
                                var gamma = Math.atan2(mp.$ady, mp.$adx);

                                // using gamma we can figure out direction
                                if (gamma > -PI4) {
                                    d = (gamma < PI4) ? "right" : (gamma < PI4_3 ? "bottom" : "left");
                                } else {
                                    d = (gamma > -PI4_3) ? "top" : "left";
                                }

                                mp.direction = d;

                                // clear accumulated shift
                                mp.$ady = mp.$adx = 0;

                                mp.gamma = gamma;
                            }

                            stub.direction = mp.direction;
                            stub.dx = dx;
                            stub.dy = dy;

                            try {
                                if (mp.isDragged === false) {
                                    this.destination.$pointerDragStarted(stub);
                                }

                                if (mp.isDragged === false || dx !== 0 || dy !== 0) {
                                    this.destination.$pointerDragged(stub);
                                }
                            } finally {
                                mp.isDragged = true;
                            }
                        }
                    } else {
                        mp.$adapter.$DRAG(id, e, stub);
                    }
                }
            };

            this.$fireUP = function(id, e, mp, stub, destination) {
                try {
                    // store coordinates and target
                    stub.$fillWith(id, e);

                    // TODO: uncomment it and replace with sub or so
                    //if (tt.group != null) tt.group.active = false;

                    // add press coordinates what can help to detect source
                    // of the event
                    stub.pressPageX = mp.pressPageX;
                    stub.pressPageY = mp.pressPageY;

                    // fire dragged or clicked
                    if (mp.isDragged === true) {
                        destination.$pointerDragEnded(stub);
                    } else {
                        // TODO: sometimes browser scrolls page during the click
                        // to detect it we have to check pageX / pageY coordinates with
                        // initial one to suppress not valid pointer clicked events
                        if (mp.pressPageY === stub.pageY && mp.pressPageX === stub.pageX) {
                            if ($lastPointerReleased !== null &&
                                $lastPointerReleased.identifier === id &&
                                (new Date().getTime() - $lastPointerReleased.time) <= pkg.doubleClickDelta)
                            {
                                destination.$pointerDoubleClicked(stub);
                            } else {
                                if (mp.group === stub.touchCounter) {  // TODO: temporary solution
                                    destination.$pointerClicked(stub);
                                }
                            }
                        }
                    }

                    // always complete pointer pressed with appropriate
                    // release event
                    destination.$pointerReleased(stub);
                } finally {
                    // clear handled pressed and dragged state
                    if (stub.touchCounter > 0) stub.touchCounter--;
                    $lastPointerReleased = $pointerPressedEvents.hasOwnProperty(id) ? $pointerPressedEvents[id] : null;
                    delete $pointerPressedEvents[id];

                    // remove global move listener if necessary
                    $cleanDragFix();
                }
            };

            //  Possible cases of mouse up events:
            //
            //   a) +-------------+        b) +----------------+       c) +---------------+
            //      |  E          |           | E +----+       |          | E       +-----|
            //      |      p--u   |          |    | p--|-u     |          |         |  p--|-u
            //      |             |           |   +----+       |          |         +-----|
            //      +-------------+           +----------------+          +---------------+
            // (out to document/body)      (out from kid to element)   (out from kid to document)
            //
            //   d) +--------+--------+    e) +----------+----------+    f) +---------+-------+
            //      | E      |        |       |  E +-----|-----+    |       | E +-----|       |
            //      |     p--|--u     |       |    | p---|--u  |    |       |   |  p--|-u     |
            //      |        |        |       |    +-----|-----+    |       |   +-----|       |
            //      +--------+--------+       +----------+----------+       +---------+-------+
            //     (out from element to       (out from kid of element     (out from kid element
            //      other element)            to kid of another element)    to another element)
            // Contract:
            //   -- handle only mouse events whose destination is the passed element
            //   -- does stop propagation if event has been handled
            //   -- clear drag  fix ?
            this.$UP = function(id, e, stub) {
                // remove timer if it has not been started yet since we already have
                // got UP event and have to fire pressed events from queue with the
                // UP handler
                if (this.$timer !== null) {
                    clearTimeout(this.$timer);
                    this.$timer = null;
                }

                // test if the pressed event for the given id has not been fired yet
                var isPressedInQ = false;
                for(var i = 0; i < this.$queue.length; i++) {
                    if (this.$queue[i].identifier === id) {
                        isPressedInQ = true;
                        break;
                    }
                }

                // fire collected in queue pressed events
                this.$firePressedFromQ();

                // check if a pointer state is in pressed state
                if ($pointerPressedEvents.hasOwnProperty(id)) {
                    // get pointer pressed state for the given id
                    var mp = $pointerPressedEvents[id];

                    // mouse up can happen in another element than
                    // mouse down occurred. let the original element
                    // (where mouse down is happened) to handle it
                    if (this.element !== mp.$adapter.element) {
                        $enteredElement = null;
                        // wrap with try-catch to prevent inconsistency
                        try {
                            stub.$fillWith(id, e);
                            mp.$adapter.destination.$pointerExited(stub);
                            $enteredElement = this.element;
                            this.destination.$pointerEntered(stub);
                        } catch(ee) {
                            // keep it for exceptional cases
                            $enteredElement = this.element;
                            throw ee;
                        } finally {
                            mp.$adapter.$UP(id, e, stub);
                        }
                    } else {
                        if (isPressedInQ) {  // the mouse pressed and mouse released has happened in different
                                             // point in a time to let UI show visual state, for instance mouse
                                             // down and up
                            var $this = this;
                            setTimeout(function() {
                                $this.$fireUP(id, e, mp, stub, $this.destination);
                            }, 50);
                        } else {
                            this.$fireUP(id, e, mp, stub, this.destination);
                        }
                    }
                }
            };

            this.$indexOfQ = function(id) {
                for(var i = 0; i < this.$queue.length; i++) {
                    if (id === this.$queue[i].identifier) return i;
                }
                return -1;
            };

            this.$firePressedFromQ = function() {
                // fire collected pointer pressed events
                if (this.$queue.length > 0) {
                    var l = this.$queue.length;
                    for(var i = 0; i < l; i++) {
                        var t = this.$queue[i];

                        try {
                            // reg the event
                            $pointerPressedEvents[t.identifier] = t;

                            t.stub.$fillWith(t.identifier, t);
                            t.group = l; // TODO: temporary solution

                            if (this.destination.$pointerPressed(t.stub) === true) {
                                if (t.stub.touchCounter > 0) {
                                    t.stub.touchCounter--;
                                }
                                delete $pointerPressedEvents[t.identifier];
                            }
                        } catch(ex) {
                            // don't forget to decrease counter
                            if (t.stub.touchCounter > 0) {
                                t.stub.touchCounter--;
                            }
                            delete $pointerPressedEvents[t.identifier];
                            zebkit.dumpError(ex);
                        }
                    }
                    this.$queue.length = 0;
                }
            };

            this.$DOWN = function(id, e, stub) {
                $cleanDragFix();


                // remove not fired pointer pressed from queue if necessary
                var i = this.$indexOfQ(id);
                if (i >= 0) {
                    this.$queue.splice(i, 1);
                }

                // release mouse pressed if it has not happened before
                if ($pointerPressedEvents.hasOwnProperty(id)) {
                    var mp = $pointerPressedEvents[id];
                    mp.$adapter.$UP(id, e, mp.stub);
                }

                // count pointer pressed
                stub.touchCounter++;

                try {
                    var q = {
                        target      : e.target,
                        direction   : null,
                        identifier  : id,
                        shiftKey    : e.shiftKey,
                        altKey      : e.altKey,
                        metaKey     : e.metaKey,
                        ctrlKey     : e.ctrlKey,
                        time        : (new Date()).getTime(),
                        $adapter    : this,
                        $adx        : 0,
                        $ady        : 0,
                        isDragged   : false,
                        stub        : stub
                    };

                    q.pageX = q.pressPageX = Math.floor(e.pageX);
                    q.pageY = q.pressPageY = Math.floor(e.pageY);

                    // put pointer pressed in queue
                    this.$queue.push(q);

                    // initiate timer to send collected new touch events
                    // if any new has appeared. the timer helps to collect
                    // events in one group
                    if (this.$queue.length > 0 && this.$timer === null) {
                        var $this = this;
                        this.$timer = setTimeout(function() {
                            $this.$timer = null;
                            $this.$firePressedFromQ(); // flush queue
                        }, 25);
                    }
                } catch(ee) {
                    // restore touch counter if an error has happened
                    if (stub.touchCounter > 0) stub.touchCounter--;
                    throw ee;
                }
            };

            this.$MMOVE = function(e) {
                var pageX = Math.floor(e.pageX),
                    pageY = Math.floor(e.pageY);

                // ignore extra mouse moved event that can appear in IE
                if (this.$mousePageY !== pageY ||
                    this.$mousePageX !== pageX   )
                {

                    this.$mousePageX = pageX;
                    this.$mousePageY = pageY;

                    if ($pointerPressedEvents.hasOwnProperty(LMOUSE) ||
                        $pointerPressedEvents.hasOwnProperty(RMOUSE)   )
                    {
                        if ($pointerPressedEvents.hasOwnProperty(LMOUSE)) {
                            this.$DRAG(LMOUSE, e, ME_STUB);
                        }

                        if ($pointerPressedEvents.hasOwnProperty(RMOUSE)) {
                            this.$DRAG(RMOUSE, e, ME_STUB);
                        }
                    } else {
                        // initialize native fields
                        ME_STUB.$fillWith("mouse", e);
                        this.destination.$pointerMoved(ME_STUB);
                    }
                }
            };
        },

        function (element, destination) {
            if (element === null || typeof element === 'undefined') {
                throw new Error("Invalid DOM element");
            }

            if (destination === null || typeof destination === 'undefined') {
                throw new Error("Invalid destination");
            }

            this.destination = destination;
            this.element     = element;

            var $this = this;

            element.onmousedown = function(e) {
                // ignore any mouse buttons except left
                // and right buttons or long touch emulates mouse event what causes generations of
                // mouse down event after touch start event. Let's suppress it
                if ((e.button !== 0 && e.button !== 2) ||
                     $this.$touchedAt(e.pageX, e.pageY, 0))
                {
                    e.preventDefault();
                } else {
                    $this.$DOWN(e.button === 0 ? LMOUSE : RMOUSE, e, ME_STUB);
                    e.stopPropagation();
                }
            };


            //  Possible cases of mouse up events:
            //
            //   a) +-------------+        b) +----------------+       c) +---------------+
            //      |  E          |           | E +----+       |          | E       +-----|
            //      |      p--u   |          |    | p--|-u     |          |         |  p--|-u
            //      |             |           |   +----+       |          |         +-----|
            //      +-------------+           +----------------+          +---------------+
            // (out to document/body)      (out from kid to element)   (out from kid to document)
            //
            //   d) +--------+--------+    e) +----------+----------+    f) +---------+-------+
            //      | E      |        |       |  E +-----|-----+    |       | E +-----|       |
            //      |     p--|--u     |       |    | p---|--u  |    |       |   |  p--|-u     |
            //      |        |        |       |    +-----|-----+    |       |   +-----|       |
            //      +--------+--------+       +----------+----------+       +---------+-------+
            //     (out from element to       (out from kid of element     (out from kid element
            //      other element)            to kid of another element)    to another element)
            // Contract:
            //   -- handle only mouse events whose destination is the passed element
            //   -- does stop propagation if event has been handled
            //   -- clear drag  fix ?
            element.onmouseup = function(e) {
                // ignore any mouse buttons except left
                // and right buttons
                if (e.button !== 0 && e.button !== 2) {
                    e.preventDefault();
                } else {
                    var id = e.button === 0 ? LMOUSE : RMOUSE;

                    $this.$UP(id, e, ME_STUB);

                    if (typeof e.stopPropagation !== 'undefined') {
                        e.stopPropagation();
                    }
                }
            };

            // mouse over has to setup if necessary current over element variable
            // it requires to detect repeat mouse over event that happens when
            // for instance we switch between browser and other application, but
            // mouse cursor stays at the same place
            element.onmouseover = function(e) {
                // this code prevent mouse over for first touch on iOS and Android
                if ($this.$touchedAt(e.pageX, e.pageY, 0)) {
                    e.preventDefault();
                } else {
                    var id = e.button === 0 ? LMOUSE : RMOUSE;

                    // if a button has not been pressed handle mouse entered to detect
                    // zebkit component the mouse pointer entered and send appropriate
                    // mouse entered event to it
                    if ($pointerPressedEvents.hasOwnProperty(id) === false) {
                        // just for the sake of error prevention
                        // clean global move listeners
                        $cleanDragFix();

                        // if entered element is null or the target element
                        // is not a children/element of the entered element than
                        // fires pointer entered event
                        if ($enteredElement === null || ($enteredElement.contains(e.target) === false && $enteredElement !== e.target)) {
                            ME_STUB.$fillWith("mouse", e);
                            $enteredElement = element;
                            destination.$pointerEntered(ME_STUB);
                        }
                    } else {
                        // remove any previously registered listener if
                        //  -- a mouse button has been pressed
                        //  -- a mouse button has been pressed on the canvas we have entered
                        if (element === e.target || element.contains(e.target)) {
                            $cleanDragFix();
                        }
                    }

                    e.stopPropagation();
                }
            };

            //  Possible cases of mouse out events:
            //
            //   a) +-------------+        b) +----------------+       c) +---------------+
            //      |  E          |           | E +----+       |          | E       +-----|
            //      |        *----|->         |   | *--|->     |          |         |  *--|->
            //      |             |           |   +----+       |          |         +-----|
            //      +-------------+           +----------------+          +---------------+
            // (out to document/body)      (out from kid to element)   (out from kid to document)
            //
            //   d) +--------+--------+    e) +----------+----------+    f) +---------+-------+
            //      | E      |        |       |  E +-----|-----+    |       | E +-----|       |
            //      |     *--|-->     |       |    | *---|-->  |    |       |   |  *--|->     |
            //      |        |        |       |    +-----|-----+    |       |   +-----|       |
            //      +--------+--------+       +----------+----------+       +---------+-------+
            //     (out from element to       (out from kid of element     (out from kid element
            //      other element)            to kid of another element)    to another element)
            //
            //   1) a mouse button doesn't have to be pressed on any element
            //   2) e.target always equals to element (E), just because we register event handler
            //      for element. This guarantees element will get mouse out event only from itself
            //      and its children elements
            //   3) mouse out should trigger pointerExited event only if the relatedTarget element
            //      is not the element (E) or kid of the element (E)
            //   4) if a mouse button has been pressed than mouse out registers mouse move listener
            //      to track drag events if the listener has nor been registered yet.
            //   5) mouse out set to null $enteredElement

            element.onmouseout = function(e) {
                var id = e.button === 0 ? LMOUSE : RMOUSE;

                // no pressed button exists
                if ($pointerPressedEvents.hasOwnProperty(id) === false) {
                    // the target element is the not a kid of the element
                    if ($enteredElement !== null && (e.relatedTarget != null     &&
                                                     e.relatedTarget !== element &&
                                                     element.contains(e.relatedTarget) === false))
                    {
                        $enteredElement = null;
                        ME_STUB.$fillWith("mouse", e);

                        if (zebkit.web.$isInsideElement(element, e.pageX, e.pageY) === false) {
                            destination.$pointerExited(ME_STUB);
                        }
                    }
                } else {
                    var mp = $pointerPressedEvents[id];

                    // if a button has been pressed but the mouse cursor is outside of
                    // the canvas, for a time being start listening mouse moved events
                    // of Window to emulate mouse moved events in canvas
                    if ($tmpWinMouseMoveListener === null &&
                        e.relatedTarget != null &&
                        element.contains(e.relatedTarget) === false)
                    {
                        // !!! ignore touchscreen devices
                        if (id === LMOUSE || id === RMOUSE) {
                            $tmpWinMouseMoveListener = function(ee) {
                                ee.stopPropagation();

                                if ($pointerPressedEvents.hasOwnProperty(LMOUSE)) {
                                    $this.$DRAG(LMOUSE, {
                                        pageX  : ee.pageX,
                                        pageY  : ee.pageY,
                                        target : mp.target,
                                    }, ME_STUB);
                                }

                                if ($pointerPressedEvents.hasOwnProperty(RMOUSE)) {
                                    $this.$DRAG(RMOUSE, {
                                        pageX  : ee.pageX,
                                        pageY  : ee.pageY,
                                        target : mp.target,
                                    }, ME_STUB);
                                }

                                ee.preventDefault();
                            };

                            window.addEventListener("mousemove", $tmpWinMouseMoveListener, true);
                        }
                    }
                }

                $this.$mousePageX = $this.$mousePageY = -1;
                e.stopPropagation();
            };

            if ("onpointerdown" in window || "onmspointerdown" in window) {
                var names = "onpointerdown" in window ? [ "pointerdown",
                                                          "pointerup",
                                                          "pointermove",
                                                          "pointerenter",
                                                          "pointerleave" ]
                                                      : [ "MSPointerDown",
                                                          "MSPointerUp",
                                                          "MSPointerMove",
                                                          "MSPointerEnter",
                                                          "MSPointerLeave" ];

                //
                // in windows 8 IE10  pointerType can be a number !!!
                // what is nit the case fo rinstanvce for Win 8.1
                //

                element.addEventListener(names[0], function(e) {
                    var pt = e.pointerType;
                    if (pt === 4) {
                        pt = "mouse";
                    } else if (pt === 2) {
                        pt = "touch";
                    } else if (pt === 3) {
                        pt = "pen";
                    }

                    if (pt !== "mouse")  {
                        POINTER_STUB.touch = e;
                        POINTER_STUB.pointerType = pt;
                        $this.$DOWN(e.pointerId, e, POINTER_STUB);
                    }
                }, false);

                element.addEventListener(names[1], function(e) {
                    var pt = e.pointerType;
                    if (pt === 4) {
                        pt = "mouse";
                    } else if (pt === 2) {
                        pt = "touch";
                    } else if (pt === 3) {
                        pt = "pen";
                    }

                    if (pt !== "mouse") {
                        POINTER_STUB.touch = e;
                        POINTER_STUB.pointerType = pt;
                        $this.$UP(e.pointerId, e, POINTER_STUB);
                    }
                }, false);

                element.addEventListener(names[2], function(e) {
                    var pt = e.pointerType;
                    if (pt === 4) {
                        pt = "mouse";
                    } else if (pt === 2) {
                        pt = "touch";
                    } else if (pt === 3) {
                        pt = "pen";
                    }

                    if (pt !== "mouse") {
                        POINTER_STUB.touch = e;
                        POINTER_STUB.pointerType = pt;
                        $this.$DRAG(e.pointerId, e, POINTER_STUB);
                    } else {
                        //e.pointerType = pt;
                        $this.$MMOVE(e);
                    }
                }, false);
            } else {
                element.addEventListener("touchstart", function(e) {
                    var allTouches = e.touches,
                        newTouches = e.changedTouches; // list of touch events that become
                                                       // active with the current touch start

                    // fix android bug: parasite event for multi touch
                    // or stop capturing new touches since it is already fixed
                    // TODO: have no idea what it is
                    // if (TOUCH_STUB.touchCounter > e.touches.length) {
                    //     return;
                    // }

                    // android devices fire mouse move if touched but not moved
                    // let save coordinates what should prevent mouse move event
                    // generation
                    //
                    // TODO: not clear if second tap will fire mouse move or if the
                    // second tap will have any influence to first tap mouse move
                    // initiation
                    $this.$mousePageX = Math.floor(e.pageX);
                    $this.$mousePageY = Math.floor(e.pageY);

                    // fire touches that has not been fired yet
                    for(var i = 0; i < newTouches.length; i++) {  // go through all touches
                        var newTouch = newTouches[i];
                        $this.$DOWN(newTouch.identifier, newTouch, TOUCH_STUB);
                    }

                    // clear touches that still is not in list of touches
                    for (var k in $pointerPressedEvents) {
                        if (isIn(allTouches, k) === false) {
                            var tt = $pointerPressedEvents[k];
                            if (tt.group != null) tt.group.active = false;
                            $this.$UP(tt.identifier, tt, TOUCH_STUB);
                        }
                    }

                    //!!!
                    //TODO: this calling prevents generation of phantom mouse move event
                    //but it is not clear if it will stop firing touch end/move events
                    //for some mobile browsers. Check it !
                    e.preventDefault();
                }, false);

                element.addEventListener("touchend", function(e) {
                    // update touches
                    var t = e.changedTouches;
                    for (var i = 0; i < t.length; i++) {
                        var tt = t[i];
                        $this.$UP(tt.identifier, tt, TOUCH_STUB);
                    }

                    e.preventDefault();
                }, false);

                element.addEventListener("touchmove", function(e) {
                    var mt = e.changedTouches;

                    // clear dx, dy for not updated touches
                    for(var k in $this.touches) {
                        $pointerPressedEvents[k].dx = $pointerPressedEvents[k].dy = 0;
                    }

                    for(var i = 0; i < mt.length; i++) {
                        var nmt = mt[i];
                        if ($pointerPressedEvents.hasOwnProperty(nmt.identifier)) {
                            var t = $pointerPressedEvents[nmt.identifier];
                            if (t.pageX !== Math.floor(nmt.pageX) ||
                                t.pageY !== Math.floor(nmt.pageY)   )
                            {
                                // TODO: analyzing time is not enough to generate click event since
                                // a user can put finger and wait for a long time. the best way is
                                // normalize time with movement (number of movement of dx/dy accumulation)
                                //if (t.isDragged) {// || (new Date().getTime() - t.time) > 200) {
                                if (t.isDragged || Math.abs(nmt.pageX - t.pageX) + Math.abs(nmt.pageY - t.pageY) > 4) {
                                    $this.$DRAG(nmt.identifier, nmt, TOUCH_STUB);
                                }
                            }
                        }
                    }

                    e.preventDefault();
                }, false);

                element.onmousemove = function(e) {
                    $this.$MMOVE(e);
                    e.stopPropagation();
                };
            }

            // TODO: not sure it has to be in pointer unifier
            element.oncontextmenu = function(e) {
                e.preventDefault();
            };
        }
    ]);


    /**
     *  Mouse wheel support class. Installs necessary mouse wheel listeners and handles mouse wheel
     *  events in zebkit UI. The mouse wheel support is plugging that is configured by a JSON
     *  configuration.
     *  @class zebkit.web.MouseWheelSupport
     *  @param  {DOMElement} element
     *  @param  {Object} destination
     *  @constructor
     */
    pkg.MouseWheelSupport = Class([
        function(element, destination) {
            var META = this.clazz.$META;
            for(var k in META) {
                if (META[k].test()) {
                    var $wheelMeta = META[k],
                        $clazz     = this.clazz;

                    element.addEventListener(k,
                        function(e) {
                            var dy = typeof e[$wheelMeta.dy] !== 'undefined' ? e[$wheelMeta.dy] * $wheelMeta.dir : 0,
                                dx = typeof e[$wheelMeta.dx] !== 'undefined' ? e[$wheelMeta.dx] * $wheelMeta.dir : 0;

                            // some version of FF can generates dx/dy  < 1
                            if (Math.abs(dy) < 1) {
                                dy *= $clazz.dyZoom;
                            }

                            if (Math.abs(dx) < 1) {
                                dx *= $clazz.dxZoom;
                            }

                            dy = Math.abs(dy) > $clazz.dyNorma ? dy % $clazz.dyNorma : dy;
                            dx = Math.abs(dx) > $clazz.dxNorma ? dx % $clazz.dxNorma : dx;

                            // do floor since some mouse devices can fire float as
                            if (destination.$doScroll(Math.floor(dx),
                                                      Math.floor(dy), "wheel"))
                            {
                                e.preventDefault();
                            }
                        },
                        false);
                    break;
                }
            }
        },

        function $clazz() {
            this.dxZoom = this.dyZoom = 20;
            this.dxNorma = this.dyNorma = 80;

            this.$META = {
                wheel: {
                    dy  : "deltaY",
                    dx  : "deltaX",
                    dir : 1,
                    test: function() {
                        return "WheelEvent" in window;
                    }
                },
                mousewheel: {
                    dy  : "wheelDelta",
                    dx  : "wheelDeltaX",
                    dir : -1,
                    test: function() {
                        return document.onmousewheel !== undefined;
                    }
                },
                DOMMouseScroll: {
                    dy  : "detail",
                    dir : 1,
                    test: function() {
                        return true;
                    }
                }
            };
        },

        function $prototype() {
            this.naturalDirection = true;
        }
    ]);


    // Key CODES meta
    // pr  - preventDefault, false if not defined
    // rp  - repeatable key, true if not defined
    // map  - map code to another code
    // ignore  - don't fire the given event, false by default
    var CODES = {
            "KeyA"  : { keyCode: 65 },
            "KeyB"  : { keyCode: 66 },
            "KeyC"  : { keyCode: 67 },
            "KeyD"  : { keyCode: 68 },
            "KeyE"  : { keyCode: 69 },
            "KeyF"  : { keyCode: 70 },
            "KeyG"  : { keyCode: 71 },
            "KeyH"  : { keyCode: 72 },
            "KeyI"  : { keyCode: 73 },
            "KeyJ"  : { keyCode: 74 },
            "KeyK"  : { keyCode: 75 },
            "KeyL"  : { keyCode: 76 },
            "KeyM"  : { keyCode: 77 },
            "KeyN"  : { keyCode: 78 },
            "KeyO"  : { keyCode: 79 },
            "KeyP"  : { keyCode: 80 },
            "KeyQ"  : { keyCode: 81 },
            "KeyR"  : { keyCode: 82 },
            "KeyS"  : { keyCode: 83 },
            "KeyT"  : { keyCode: 84 },
            "KeyU"  : { keyCode: 85 },
            "KeyV"  : { keyCode: 86 },
            "KeyW"  : { keyCode: 87 },
            "KeyX"  : { keyCode: 88 },
            "KeyY"  : { keyCode: 89 },
            "KeyZ"  : { keyCode: 90 },
            "Digit0": { keyCode: 48 },
            "Digit1": { keyCode: 49 },
            "Digit2": { keyCode: 50 },
            "Digit3": { keyCode: 51 },
            "Digit4": { keyCode: 52 },
            "Digit5": { keyCode: 53 },
            "Digit6": { keyCode: 54 },
            "Digit7": { keyCode: 55 },
            "Digit8": { keyCode: 56 },
            "Digit9": { keyCode: 57 },

            "F1":  { keyCode: 112, key: "F1",   rp: false  },
            "F2":  { keyCode: 113, key: "F2",   rp: false  },
            "F3":  { keyCode: 114, key: "F3",   rp: false  },
            "F4":  { keyCode: 115, key: "F4",   rp: false  },
            "F5":  { keyCode: 116, key: "F5",   rp: false  },
            "F6":  { keyCode: 117, key: "F6",   rp: false  },
            "F7":  { keyCode: 118, key: "F7",   rp: false  },
            "F8":  { keyCode: 119, key: "F8",   rp: false  },
            "F9":  { keyCode: 120, key: "F9",   rp: false  },
            "F10": { keyCode: 121, key: "F10",  rp: false  },
            "F11": { keyCode: 122, key: "F11",  rp: false  },
            "F12": { keyCode: 123, key: "F12",  rp: false  },
            "F13": { keyCode: 124, key: "F13",  rp: false  },
            "F14": { keyCode: 125, key: "F14",  rp: false  },
            "F15": { keyCode: 126, key: "F15",  rp: false  },

            "Numpad0"       : { keyCode: 96  },
            "Numpad1"       : { keyCode: 97  },
            "Numpad2"       : { keyCode: 98  },
            "Numpad3"       : { keyCode: 99  },
            "Numpad4"       : { keyCode: 100 },
            "Numpad5"       : { keyCode: 101 },
            "Numpad6"       : { keyCode: 102 },
            "Numpad7"       : { keyCode: 103 },
            "Numpad8"       : { keyCode: 104 },
            "Numpad9"       : { keyCode: 105 },
            "NumpadDecimal" : { keyCode: 110, key: "Decimal"  },
            "NumpadSubtract": { keyCode: 109, key: "Subtract" },
            "NumpadDivide"  : { keyCode: 111, key: "Divide"   },
            "NumpadMultiply": { keyCode: 106, key: "Multiply" },
            "NumpadAdd"     : { keyCode: 107, key: "Add"      },
            "NumLock"       : { keyCode: (zebkit.isFF ? 144 : 12) , key: "NumLock", rp: false, ignore : true },

            "Comma"        : { keyCode: 188 },
            "Period"       : { keyCode: 190 },
            "Semicolon"    : { keyCode: (zebkit.isFF ? 59  : 186) },
            "Quote"        : { keyCode: 222 },
            "BracketLeft"  : { keyCode: 219 },
            "BracketRight" : { keyCode: 221 },
            "Backquote"    : { keyCode: 192 },
            "Backslash"    : { keyCode: 220 },
            "Minus"        : { keyCode: (zebkit.isFF ? 173 : 189) },
            "Equal"        : { keyCode: (zebkit.isFF ? 61  : 187) },

            "NumpadEnter"  : { map: "Enter" },
            "Enter"        : { keyCode: 13, key: "\n" },

            "Slash"        : { keyCode: 191 },
            "Space"        : { keyCode: 32, pr: true, key: " " },
            "Delete"       : { keyCode: 46, key: "Delete" },

            "IntlRo"     : { keyCode: (zebkit.isFF ? 167 : 193), key: "IntlRo"},

            "Backspace"  :  { keyCode: 8, pr: true, key: "Backspace" },
            "Tab":          { keyCode: 9, pr: true, key: "\t" },
            "ContextMenu":  { keyCode: zebkit.isFF ? 93 : 0, pr: true, key: "ContextMenu" },

            "ArrowLeft"   : { keyCode: 37, pr: true,  key: "ArrowLeft"   },
            "ArrowRight"  : { keyCode: 39, pr: true,  key: "ArrowRight"  },
            "ArrowUp"     : { keyCode: 38, pr: true,  key: "ArrowUp"     },
            "ArrowDown"   : { keyCode: 40, pr: true,  key: "ArrowDown"   },
            "PageUp"      : { keyCode: 33, pr: true,  key: "PaheUp"      },
            "PageDown"    : { keyCode: 34, pr: true,  key: "PageDown"    },
            "Home"        : { keyCode: 36, pr: true,  key: "Home"        },
            "End"         : { keyCode: 35, pr: true,  key: "End"         },

            "Escape"      : { keyCode: 27,  pr: true,  key: "Escape",   rp: false },
            "CapsLock"    : { keyCode: 20,             key: "CapsLock", rp: false, ignore : true },

            "Shift"       : { keyCode: 16,  pr: true, key: "Shift", rp: false,},
            "ShiftLeft"   : { map: "Shift" },
            "ShiftRight"  : { map: "Shift" },

            "Alt"         : { keyCode: 18,  pr: true,  key: "Alt",  rp: false, },
            "AltLeft"     : { map: "Alt" },
            "AltRight"    : { map: "Alt" },

            "Control"     : { keyCode: 17,  pr: true,  key: "Control",  rp: false },
            "ControlRight": { map: "Control" },
            "ControlLeft" : { map: "Control" },

            "MetaLeft"    : { keyCode: 91,  pr: true,  key: "Meta", rp: false },
            "MetaRight"   : { keyCode: 93,  pr: true,  key: "Meta", rp: false },
            "OSLeft"      : { keyCode: 224,  map: "MetaLeft" },
            "OSRight"     : { keyCode: 224,  map: "MetaRight"  }
        },

        CODES_MAP = {};

    // codes to that are not the same for different browsers
    function $initializeCodesMap() {
        var k = null, code = null;

        // validate codes mapping
        for(k in CODES) {
            code = CODES[k];
            if (typeof code.map !== "undefined")  {
                if (typeof CODES[code.map] === "undefined") {
                    throw new Error("Invalid mapping for code = '" + k + "'");
                }
            } else if (typeof code.keyCode === "undefined") {
                throw new Error("unknown keyCode  for code = '" + k + "'");
            }
        }

        // build codes map table for the cases when "code" property
        CODES_MAP = {};
        for(k in CODES) {
            code = CODES[k];
            if (typeof code.map !== "undefined") {
                if (typeof code.keyCode !== "undefined") {
                    CODES_MAP[code.keyCode] = code.map;
                }
            } else {
                CODES_MAP[code.keyCode] = k;
            }
        }
    }

    pkg.$fetchKeyCode = function(e) {
        var code = e.code;
        if (typeof code !== "undefined") {
            if (CODES.hasOwnProperty(code) && CODES[code].hasOwnProperty("map")) {
                code = CODES[code].map;
            }
        } else {
            code = CODES_MAP[(e.which || e.keyCode || 0)];
            if (typeof code === "undefined") {
                code = null;
            }
        }
        return code;
    };

    $initializeCodesMap();

    /**
     * Input key event class.
     * @class  zebkit.ui.KeyEvent
     * @extends zebkit.util.Event
     * @constructor
     */
    pkg.KeyEvent = Class(zebkit.ui.KeyEvent, [
        function $prototype() {
            /**
             * Fulfills the given abstract event with fields from the specified native WEB key event
             * @param  {KeyboardEvent} e a native WEB event
             * @method $fillWith
             * @chainable
             * @protected
             */
            this.$fillWith = function(e) {
                // code defines integer that in a case of
                // key pressed/released is zero or equals to physical key layout integer identifier
                // but for keyTyped should depict Unicode character code
                var keyCode = (e.which || e.keyCode || 0);

                this.code = pkg.$fetchKeyCode(e);

                if (this.code === "Enter" || this.code === "Space" || this.code === "Tab") {
                    this.key = CODES[this.code].key;
                } else if (e.key != null) {
                    this.key = e.key;
                } else if (e.type === "keypress") {
                    this.key = e.charCode > 0 && keyCode >= 32 ? String.fromCharCode(e.charCode)
                                                               : null;
                } else {
                    if (e.keyIdentifier != null) {
                        if (e.keyIdentifier[0] === 'U' &&  e.keyIdentifier[1] === '+') {
                            this.key = String.fromCharCode(parseInt(e.keyIdentifier.substring(2), 16));
                        } else {
                            this.key = e.keyIdentifier;
                        }
                    } else {
                        if (this.code != null && CODES.hasOwnProperty(this.code) === true && CODES[this.code].key != null) {
                            this.key = CODES[this.code].key;
                        } else {
                            this.key = e.charCode > 0 && keyCode >= 32 ? String.fromCharCode(e.charCode)
                                                                       : null;
                        }
                    }
                }

                this.altKey   = e.altKey;
                this.shiftKey = e.shiftKey;
                this.ctrlKey  = e.ctrlKey;
                this.metaKey  = e.metaKey;
                return this;
            };
        }
    ]);


    var KEY_DOWN_EVENT  = new pkg.KeyEvent(),
        KEY_UP_EVENT    = new pkg.KeyEvent(),
        KEY_PRESS_EVENT = new pkg.KeyEvent(),
        wasMetaLeftPressed  = false,
        wasMetaRightPressed = false;

    /**
     * Class that is responsible for translating native DOM element key event into abstract event that further
     * can be transfered to zebkit UI engine (or any other destination). Browsers key events support can be
     * implemented with slight differences from the standards. The goal of the class is key events unification.
     * The class fires three types of key events to passed event destination code:
     *    - $keyPressed(e)
     *    - $keyReleased(e)
     *    - $keyTyped(e)
     *
     * For instance imagine we have a DOM Element and want to have identical sequence and parameters of key
     * events the DOM element triggers. It can be done as follow:
     *
     *      new KeyEventUnifier(domElement, {
     *          "$keyPressed" : function(e) {
     *              ...
     *          },
     *
     *          "$keyReleased" : function(e) {
     *              ...
     *          },
     *
     *          "$keyTyped" : function(e) {
     *              ...
     *          }
     *      });
     *
     * @param  {HTMLElement} element
     * @param  {Object} destination a destination listener that can listen
     * @constructor
     * @class  zebkit.web.KeyEventUninfier
     */
    pkg.KeyEventUnifier = Class([
        function(element, destination) {
            //   Alt + x  was pressed  (for IE11 consider sequence of execution of "alt" and "x" keys)
            //   Chrome/Safari/FF  keydown -> keydown -> keypressed
            // ----------------------------------------------------------------------------------------------------------------------
            //          |     which   |    keyCode   | charCode |      code        |     key        |   keyIdentifier   |  char
            // ----------------------------------------------------------------------------------------------------------------------
            //          |             |              |          |                  |                |                   |
            //  Chrome  |    unicode/ |    unicode/  |   0      |  undefined       |  undefined     | Mnemonic + Unistr |   No
            //          |     code    |     code     |          |                  |                |  "Alt" + "U-0058" |
            //          |   18 + 88   |    18 + 88   |          |                  |                |                   |
            //----------+-----------------------------------------------------------------------------------------------|------------
            //          |             |              |          |                  |                |                   |
            //  IE11    |  unicode/   |  unicode/    |          |                  |                |                   |  Alt => ""
            //          |   code      |    code      |    0     |   undefined      |   "Alt","x"    |   undefined       |  x => "x"
            //          |    18, 88   |   18, 88     |          |                  |                |                   |
            //          |             |              |          |                  |                |                   |
            //----------+-------------|--------------|----------|------------------|----------------|-------------------|------------
            //          |   unicode/  |   unicode/   |          |                  |                |                   |
            //          |   code      |     code     |    0     |  undefined       | undefined      | Mnemonic + Unistr |   No
            //  Safari  |   18 + 88   |   18 + 88    |          |                  |                |  "Alt" + "U-0058" |
            //          |             |              |          |                  |                |                   |
            //----------+-----------------------------------------------------------------------------------------------|------------
            //          |             |              |          |                  |                |                   |
            //  FF      |   unicode/  |   unicode/   |    0     |  Mnemonic        | Mnemonic/char  |                   |  No
            //          |    code     |     code     |          |("AltLeft"+"KeyX")|  "Alt"+"≈"     |   undefined       |
            //          |  18 + 88    |  18 + 88     |          |                  |                |                   |
            //
            element.onkeydown = function(e) {
                var code = KEY_DOWN_EVENT.code,
                    pts  = KEY_DOWN_EVENT.timeStamp,
                    ts   = new Date().getTime();

                // fix loosing meta left keyup event in some browsers
                var fc = pkg.$fetchKeyCode(e);

                // ignore some keys that cannot be handled properly
                if (CODES[fc] != null && CODES[fc].ignore === true) {
                    return;
                }

                if (wasMetaLeftPressed === true && (e.metaKey !== true ||  fc === "MetaLeft")) {
                    wasMetaLeftPressed = false;
                    try {
                        KEY_DOWN_EVENT.code      = "MetaLeft";
                        KEY_DOWN_EVENT.repeat    = 0;
                        KEY_DOWN_EVENT.metaKey   = true;
                        KEY_DOWN_EVENT.timeStamp = ts;
                        destination.$keyReleased(KEY_DOWN_EVENT);
                    } catch(ex) {
                        zebkit.dumpError(ex);
                    } finally {
                        KEY_DOWN_EVENT.code = null;
                        code = null;
                    }
                }

                // fix loosing meta right keyup event in some browsers
                if (wasMetaRightPressed === true && (e.metaKey !== true ||  fc === "MetaRight")) {
                    wasMetaRightPressed = false;
                    try {
                        KEY_DOWN_EVENT.code      = "MetaRight";
                        KEY_DOWN_EVENT.repeat    = 0;
                        KEY_DOWN_EVENT.metaKey   = true;
                        KEY_DOWN_EVENT.timeStamp = ts;
                        destination.$keyReleased(KEY_DOWN_EVENT);
                    } catch(ex) {
                        zebkit.dumpError(ex);
                    } finally {
                        KEY_DOWN_EVENT.code = null;
                        code = null;
                    }
                }

                // we suppose key down object is shared with key up that means it
                // holds state of key (we can understand whether a key has been
                // still held or was released by checking if the code equals)
                KEY_DOWN_EVENT.$fillWith(e);
                KEY_DOWN_EVENT.timeStamp = ts;

                // calculate repeat counter
                if (KEY_DOWN_EVENT.code === code && e.metaKey !== true && (ts - pts) < 1000) {
                    KEY_DOWN_EVENT.repeat++;
                } else {
                    KEY_DOWN_EVENT.repeat = 1;
                }

                //!!!!
                // Suppress some standard browser actions.
                // Since container of zCanvas catch all events from its children DOM
                // elements don't prevent the event for the children DOM element
                var key = CODES[KEY_DOWN_EVENT.code];
                if (key != null && key.pr === true && e.target === element) {
                    e.preventDefault();
                }
                e.stopPropagation();

                // fire key pressed event
                try {
                    destination.$keyPressed(KEY_DOWN_EVENT);
                } catch(ex) {
                    zebkit.dumpError(ex);
                }

                if (KEY_DOWN_EVENT.code === "MetaLeft") {
                    wasMetaLeftPressed = true;
                } else if (KEY_DOWN_EVENT.code === "MetaRight") {
                    wasMetaRightPressed = true;
                } else {
                    // if meta key is kept than generate key released event for
                    // all none-Meta keys. it is required since Meta + <a key>
                    // will never fire key released for <a key> (except state keys
                    // like shift, control etc)
                    if (e.metaKey === true) {
                        // only repeat
                        if (key == null || key.rp !== false) {
                            try {
                                KEY_UP_EVENT.$fillWith(e);
                                KEY_UP_EVENT.repeat = 0;
                                KEY_UP_EVENT.timeStamp = ts;
                                destination.$keyReleased(KEY_UP_EVENT);
                            } catch(ex) {
                                zebkit.dumpError(ex);
                            }
                        }
                    } else if (KEY_DOWN_EVENT.code === "Space" ||
                               KEY_DOWN_EVENT.code === "Enter" ||
                               KEY_DOWN_EVENT.code === "Tab"     )
                    {
                        // since space and enter key press event triggers preventDefault
                        // standard key press can never happen so let's emulate it here
                        KEY_PRESS_EVENT.$fillWith(e);
                        KEY_PRESS_EVENT.repeat = KEY_DOWN_EVENT.repeat;
                        KEY_PRESS_EVENT.timeStamp = ts;
                        destination.$keyTyped(KEY_PRESS_EVENT);
                    }
                }
            };

            element.onkeyup = function(e) {
                e.stopPropagation();

                KEY_UP_EVENT.$fillWith(e);

                // ignore some keys that cannot be handled properly
                if (CODES[KEY_UP_EVENT.code] != null && CODES[KEY_UP_EVENT.code].ignore === true) {
                    return;
                }

                if (wasMetaLeftPressed === true && KEY_UP_EVENT.code === "MetaLeft") {
                    wasMetaLeftPressed = false;
                }

                if (wasMetaRightPressed === true && KEY_UP_EVENT.code === "MetaRight") {
                    wasMetaRightPressed = false;
                }

                var key = CODES[KEY_UP_EVENT.code];
                if (e.metaKey !== true || (key != null && key.rp === false)) {
                    KEY_UP_EVENT.repeat    = 0;
                    KEY_UP_EVENT.timeStamp = new Date().getTime();
                    try {
                        destination.$keyReleased(KEY_UP_EVENT);
                    } finally {
                        // clean repeat counter
                        if (KEY_DOWN_EVENT.code === KEY_UP_EVENT.code) {
                            KEY_DOWN_EVENT.repeat = 0;
                        }
                    }
                }
            };

            //   Alt + x  was pressed  (for IE11 consider sequence of execution of "alt" and "x" keys)
            // ----------------------------------------------------------------------------------------------------------------------
            //          |     which   |    keyCode   | charCode |      code        |     key        |   keyIdentifier   |  char
            // ----------------------------------------------------------------------------------------------------------------------
            //          |             |              |          |                  |                |                   |
            //  Chrome  |    unicode/ |    unicode/  |   8776   |  undefined       |  undefined     | Mnemonic + Unistr |   No
            //          |     code    |     code     |   (≈)    |                  |                |     "U-0058"      |
            //          |   8776 (≈)  |    8776 (≈)  |          |                  |                |                   |
            //----------+-----------------------------------------------------------------------------------------------|------------
            //          |             |              |          |                  |                |                   |
            //  IE11    |  unicode/   |  unicode/    |          |                  |                |                   |
            //          |   code      |    code      |  88 (x)  |   undefined      |     "x"        |   undefined       |   "x"
            //          |    88 (x)   |   88 (x)     |          |                  |                |                   |
            //          |             |              |          |                  |                |                   |
            //----------+-------------|--------------|----------|------------------|----------------|-------------------|------------
            //          |   unicode/  |   unicode/   |          |                  |                |                   |
            //          |   code      |     code     | 8776 (≈) |  undefined       | undefined      |                   |   No
            //  Safari  |   8776 (≈)  |   8776 (≈)   |          |                  |                |        ""         |
            //          |             |              |          |                  |                |                   |
            //----------+-----------------------------------------------------------------------------------------------|------------
            //          |             |              |          |                  |                |                   |
            //  FF      |   unicode/  |    0         |   8776   |  Mnemonic        | Mnemonic/char  |                   |   No
            //          |    code     |              |   (≈)    |  ("KeyX")        |      "≈"       |   undefined       |
            //          |  8776 (≈)   |              |          |                  |                |                   |
            //
            element.onkeypress = function(e) {
                e.stopPropagation();

                // pressed meta key should bring to ignorance keypress event since the event
                // is emulated in keydown event handler.
                if (e.metaKey !== true) {
                    KEY_PRESS_EVENT.$fillWith(e);

                    KEY_PRESS_EVENT.code   = KEY_DOWN_EVENT.code;      // copy code of keydown key since key press can contain undefined code
                    KEY_PRESS_EVENT.repeat = KEY_DOWN_EVENT.repeat;

                    if (KEY_PRESS_EVENT.code !== "Space" &&
                        KEY_PRESS_EVENT.code !== "Enter" &&
                        KEY_PRESS_EVENT.code !== "Tab"   &&
                        KEY_PRESS_EVENT.code !== "ContextMenu")
                    {
                        // Since container of zCanvas catch all events from its children DOM
                        // elements don't prevent the event for the children DOM element
                        KEY_PRESS_EVENT.timeStamp = new Date().getTime();
                        destination.$keyTyped(KEY_PRESS_EVENT);
                    }
                }
            };
        }
    ]);
});
zebkit.package("ui.web", function(pkg, Class) {
    'use strict';
    /**
     * Cursor manager class. Allows developers to control pointer cursor type by implementing an own
     * getCursorType method or by specifying a cursor by cursorType field. Imagine an UI component
     * needs to change cursor type. It
     *  can be done by one of the following way:
     *
     *   - **Implement getCursorType method by the component itself if the cursor type depends on cursor location**

          var p = new zebkit.ui.Panel([
               // implement getCursorType method to set required
               // pointer cursor type
               function getCursorType(target, x, y) {
                   return zebkit.ui.Cursor.WAIT;
               }
          ]);

     *   - **Define "cursorType" property in component if the cursor type doesn't depend on cursor location**

          var myPanel = new zebkit.ui.Panel();
          ...
          myPanel.cursorType = zebkit.ui.Cursor.WAIT;


     *  @class zebkit.ui.web.CursorManager
     *  @constructor
     *  @extends {zebkit.ui.Manager}
     */
    pkg.CursorManager = Class(zebkit.ui.CursorManager, [
        function $prototype() {
            this.$isFunc = false;
            this.source = this.target = null;

            /**
             * Define pointer moved events handler.
             * @param  {zebkit.ui.PointerEvent} e a pointer event
             * @method pointerMoved
             */
            this.pointerMoved = function(e) {
                if (this.$isFunc === true) {
                    this.cursorType = this.source.getCursorType(this.source, e.x, e.y);
                    this.target.style.cursor = (this.cursorType === null) ? "default"
                                                                          : this.cursorType;
                }
            };

            /**
             * Define pointer entered events handler.
             * @param  {zebkit.ui.PointerEvent} e a pointer event
             * @method pointerEntered
             */
            this.pointerEntered = function(e) {
                if ((typeof e.source.cursorType !== 'undefined' && e.source.cursorType !== null) ||
                     typeof e.source.getCursorType !== 'undefined')
                {
                    this.$isFunc = (typeof e.source.getCursorType === 'function');
                    this.target = e.target;
                    this.source = e.source;

                    this.cursorType = this.$isFunc === true ? this.source.getCursorType(this.source, e.x, e.y)
                                                            : this.source.cursorType;

                    this.target.style.cursor = (this.cursorType === null) ? "default"
                                                                          : this.cursorType;
                }
            };

            /**
             * Define pointer exited events handler.
             * @param  {zebkit.ui.PointerEvent} e a pointer event
             * @method pointerExited
             */
            this.pointerExited  = function(e){
                if (this.source !== null) {
                    this.cursorType = "default";
                    if (this.target.style.cursor != this.cursorType) {
                        this.target.style.cursor = this.cursorType;
                    }
                    this.source = this.target = null;
                    this.$isFunc = false;
                }
            };

            /**
             * Define pointer dragged events handler.
             * @param  {zebkit.ui.PointerEvent} e a pointer event
             * @method pointerDragged
             */
            this.pointerDragged = function(e) {
                if (this.$isFunc === true) {
                    this.cursorType = this.source.getCursorType(this.source, e.x, e.y);
                    this.target.style.cursor = (this.cursorType === null) ? "default"
                                                                          : this.cursorType;
                }
            };
        }
    ]);

    // TODO: make sure it should be done here, instead of json config
    pkg.cd("..").cursorManager = new pkg.CursorManager();


    var ui = pkg.cd("..");

    /**
     *  WEB based zebkit UI components.
     *
     * @class zebkit.ui.web
     * @access package
     */


    /**
     * HTML element UI component wrapper class. The class represents an HTML element as if it is standard
     * UI component. It helps to use some standard HTML element as zebkit UI components and embeds it
     * in zebkit UI application layout.
     * @class zebkit.ui.web.HtmlElement
     * @constructor
     * @param {String|HTMLElement} [element] an HTML element to be represented as a standard zebkit UI
     * component. If the passed parameter is string it denotes a name of an HTML element. In this case
     * a new HTML element will be created.
     * @extends {zebkit.ui.Panel}
     */
    pkg.HtmlElement = Class(ui.Panel, [
        function(e) {
            if (arguments.length === 0) {
                e = "div";
            }

            if (zebkit.isString(e)) {
                e = document.createElement(e);
                e.style.border   = "0px solid transparent";   // clean up border
                e.style.fontSize = this.clazz.$bodyFontSize;  // DOM element is wrapped with a container that
                                                              // has zero sized font, so let's set body  font
                                                              // for the created element
            }

            // sync padding and margin of the DOM element with
            // what appropriate properties are set
            e.style.margin = e.style.padding = "0px";

            /**
             * Reference to HTML element the UI component wraps
             * @attribute element
             * @readOnly
             * @type {HTMLElement}
             */
            this.element = e;

            // this is set to make possible to use set z-index for HTML element
            this.element.style.position = "relative";

            if (e.parentNode !== null && e.parentNode.getAttribute("data-zebcont") !== null) {
                throw new Error("DOM element '" + e + "' already has container");
            }


            /**
             * Every zebkit HTML element is wrapped with a container (div) HTML element.
             * It is required since not all HTML elements are designed to be a container
             * (for instance HTMLCanvas element), where every zebkit has to be a container.
             * @attribute $container
             * @readOnly
             * @private
             * @type {HTMLElement}
             */

            // container is a DIV element that is used as a wrapper around original one
            // it is done to make HtmlElement implementation more universal making
            // all DOM elements capable to be a container for another one
            this.$container = document.createElement("div");

            // prevent stretching to a parent container element
            this.$container.style.display = "inline-block";

            // cut content
            this.$container.style.overflow = "hidden";

            // it fixes problem with adding, for instance, DOM element as window what can prevent
            // showing components added to popup layer
            this.$container.style["z-index"] = "0";

            // coordinates have to be set to initial zero value in CSS
            // otherwise the DOM layout can be wrong !
            this.$container.style.left = this.$container.style.top = "0px";

            this.$container.visibility = "hidden";  // before the component will be attached
                                                    // to parent hierarchy the component has to be hidden

            // container div will always few pixel higher than its content
            // to prevent the bloody effect set font to zero
            // border and margin also have to be zero
            this.$container.style.fontSize = this.$container.style.padding = this.$container.style.padding = "0px";

            // add id
            this.$container.setAttribute("id", "container-" + this.toString());

            // mark wrapper with a special attribute to recognize it exists later
            this.$container.setAttribute("data-zebcont", "true");

            // let html element interact
            this.$container.style["pointer-events"] = "auto";

            // if passed DOM element already has parent
            // attach it to container first and than
            // attach the container to the original parent element
            if (e.parentNode !== null) {
                // !!!
                // Pay attention container position cannot be set to absolute
                // since how the element has to be laid out is defined by its
                // original parent
                e.parentNode.replaceChild(this.$container, e);
                this.$container.appendChild(e);
            } else {
                // to force all children element be aligned
                // relatively to the wrapper we have to set
                // position CSS to absolute or absolute
                this.$container.style.position = "absolute";
                this.$container.appendChild(e);
            }

            // set ID if it has not been already defined
            if (e.getAttribute("id") === null) {
                e.setAttribute("id", this.toString());
            }

            this.$super();

            // attach listeners
            if (typeof this.$initListeners !== "undefined") {
                this.$initListeners();
            }

            var fe = this.$getElementRootFocus();

            // TODO: may be this code should be moved to web place
            //
            // reg native focus listeners for HTML element that can hold focus
            if (fe !== null) {
                var $this = this;

                zebkit.web.$focusin(fe, function(e) {
                    // sync native focus with zebkit focus if necessary
                    if ($this.hasFocus() === false) {
                        $this.requestFocus();
                    }
                }, false);

                zebkit.web.$focusout(fe, function(e) {
                    // sync native focus with zebkit focus if necessary
                    if ($this.hasFocus()) {
                        ui.focusManager.requestFocus(null);
                    }
                }, false);
            }
        },

        function $clazz() {
            this.CLASS_NAME = null;
            this.$bodyFontSize = window.getComputedStyle(document.body, null).getPropertyValue('font-size');
        },

        function $prototype() {
            this.$blockElement = this.$container = this.$canvas = null;
            this.ePsW = this.ePsH = 0;

            /**
             * Indicates that this component is a DOM element wrapper
             * @attribute isDOMElement
             * @type {Boolean}
             * @private
             * @readOnly
             */
            this.isDOMElement = true;   // indication of the DOM element that is used by DOM element manager to track
                                        // and manage its visibility

            this.$sizeAdjusted = false;


            this.wrap = function(c) {
                this.setLayout(new zebkit.layout.StackLayout());
                this.add(c);
                return this;
            };

            /**
             * Set the CSS font of the wrapped HTML element
             * @param {String|zebkit.ui.Font} f a font
             * @method setFont
             * @chainable
             */
            this.setFont = function(f) {
                this.setStyle("font", f.toString());
                this.vrp();
                return this;
            };

            /**
             * Set the CSS color of the wrapped HTML element
             * @param {String} c a color
             * @chainable
             * @method setColor
             */
            this.setColor = function(c) {
                this.setStyle("color", c.toString());
                return this;
            };

            /**
             * Apply the given set of CSS styles to the wrapped HTML element
             * @param {Object} styles a dictionary of CSS styles
             * @chainable
             * @method setStyles
             */
            this.setStyles = function(styles) {
                for(var k in styles) {
                    this.$setStyle(this.element, k, styles[k]);
                }
                this.vrp();
                return this;
            };

            /**
             * Apply the given CSS style to the wrapped HTML element
             * @param {String} a name of the CSS style
             * @param {String} a value the CSS style has to be set
             * @chainable
             * @method setStyle
             */
            this.setStyle = function(name, value) {
                this.$setStyle(this.element, name, value);
                this.vrp();
                return this;
            };

            this.$setStyle = function(element, name, value) {
                name = name.trim();
                var i = name.indexOf(':');
                if (i > 0) {
                    if (zebkit[name.substring(0, i)] !== true) {
                        return;
                    }
                    name = name.substring(i + 1);
                }
                element.style[name] = value;
                return this;
            };

            /**
             * Set the specified attribute to the wrapped HTML element
             * @param {String} name  a name of attribute
             * @param {String} value a value of the attribute
             * @chainable
             * @method setAttribute
             */
            this.setAttribute = function(name, value) {
                this.element.setAttribute(name, value);
                return this;
            };

            /**
             * Set the specified attributes set to the wrapped HTML element
             * @param {Object} attrs the dictionary of attributes where name of an attribute is a key
             * of the dictionary and
             * @method  setAttributes
             * @chainable
             */
            this.setAttributes = function(attrs) {
                for(var name in attrs) {
                    this.element.setAttribute(name, attrs[name]);
                }
                return this;
            };

            /**
             * Implements "paint" method to be aware when the component is visible.
             * It is used to adjust wrapped HTML element visibility and size.
             * @param  {CanvasRenderingContext2D} g a 2D canvas context
             * @method paint
             */
            this.paint = function(g) {
                // this method is used as an indication that the component
                // is visible and no one of his parent is invisible
                if (this.$container.style.visibility === "hidden") {
                    this.$container.style.visibility = "visible";
                }

                // calling paint says that the component in DOM tree
                // that is time to correct CSS size if necessary
                if (this.$sizeAdjusted !== true) {
                    this.setSize(this.width, this.height);
                }
            };

            this.calcPreferredSize = function(target) {
                return { width: this.ePsW, height: this.ePsH };
            };

            var $store = [
                "paddingTop","paddingLeft","paddingBottom","paddingRight",
                "border","borderStyle","borderWidth", "borderTopStyle",
                "borderTopWidth", "borderBottomStyle","borderBottomWidth",
                "borderLeftStyle","borderLeftWidth", "borderRightStyle",
                "visibility", "borderRightWidth", "width", "height", "position"
            ];

            // the method calculates the given HTML element preferred size
            this.recalc = function() {
                // if component has a layout set it is up to a layout manager to calculate
                // the component preferred size. In this case the HTML element is a container
                // whose preferred size is defined by its content
                if (this.layout === this) {
                    var e         = this.element,
                        vars      = {},
                        domParent = null,
                        k         = null,
                        b         = !zebkit.web.$contains(this.$container);

                    // element doesn't have preferred size if it is not a member of
                    // an html page, so add it if for a while
                    if (b) {
                        // save previous parent node since
                        // appendChild will overwrite it
                        domParent = this.$container.parentNode;
                        document.body.appendChild(this.$container);
                    }

                    // save element metrics
                    for(var i = 0; i < $store.length; i++) {
                        k = $store[i];
                        vars[k] = e.style[k];
                    }

                    // force metrics to be calculated automatically
                    this.$container.style.visibility = "hidden";
                    e.style.padding  = "0px";
                    e.style.border   = "none";
                    e.style.position = e.style.height = e.style.width = "auto";

                    // fetch preferred size
                    this.ePsW = e.offsetWidth;
                    this.ePsH = e.offsetHeight;

                    for(k in vars) {
                        var v = vars[k];
                        if (v !== null) e.style[k] = v;
                    }

                    if (b) {
                        document.body.removeChild(this.$container);
                        // restore previous parent node
                        if (domParent !== null) domParent.appendChild(this.$container);
                    }
                }
            };

            /**
             * Set the inner content of the wrapped HTML element
             * @param {String} an inner content
             * @method setContent
             * @chainable
             */
            this.setContent = function(content) {
                this.element.innerHTML = content;
                this.vrp();
                return this;
            };

            this.$getElementRootFocus = function() {
                return null;
            };

            this.canHaveFocus = function() {
                return this.$getElementRootFocus() !== null;
            };

            this.$focus = function() {
                if (this.canHaveFocus() && document.activeElement !== this.$getElementRootFocus()) {
                    this.$getElementRootFocus().focus();
                }
            };

            this.$blur = function() {
                if (this.canHaveFocus() && document.activeElement === this.$getElementRootFocus()) {
                    this.$getElementRootFocus().blur();
                }
            };
        },

        function toFront() {
            this.$super();
            var pnode = this.$container.parentNode;
            if (pnode !== null && pnode.lastChild !== this.$container) {
                pnode.removeChild(this.$container);
                pnode.appendChild(this.$container);
            }
        },

        function toBack() {
            this.$super();
            var pnode = this.$container.parentNode;
            if (pnode !== null && pnode.firstChild !== this.$container) {
                pnode.removeChild(this.$container);
                pnode.insertBefore(this.$container, pnode.firstChild);
            }
        },

        function setEnabled(b) {
            if (this.isEnabled !== b) {
                if (b) {
                    this.$container.removeChild(this.$blockElement);
                } else {
                    if (this.$blockElement === null) {
                        this.$blockElement = zebkit.web.$createBlockedElement();
                    }
                    this.$container.appendChild(this.$blockElement);
               }
            }
            return this.$super(b);
        },

        function setSize(w, h) {
            // by the moment the method setSize is called the DOM element can be not a part of
            // HTML layout. In this case offsetWidth/offsetHeihght are always zero what prevents
            // us from proper calculation of CSS width and height. Postpone
            if (zebkit.web.$contains(this.$container)) {
                var prevVisibility = this.$container.style.visibility;
                this.$container.style.visibility = "hidden"; // could make sizing smooth

                // HTML element size is calculated as sum of CSS "width"/"height", paddings, border
                // So the passed width and height has to be corrected (before it will be applied to
                // an HTML element) by reduction of extra HTML gaps. For this we firstly set the
                // width and size
                this.element.style.width  = "" + w + "px";
                this.element.style.height = "" + h + "px";

                var ww = 2 * w - this.element.offsetWidth,
                    hh = 2 * h - this.element.offsetHeight;

                if (ww !== w || hh !== h) {
                    // than we know the component metrics and can compute necessary reductions
                    this.element.style.width   = "" + ww + "px";
                    this.element.style.height  = "" + hh + "px";
                }

                this.$sizeAdjusted = true;

                // visibility correction is done by HTML elements manager
                this.$container.style.visibility = prevVisibility;
            } else {
                this.$sizeAdjusted = false;
            }

            return this.$super(w, h);
        },

        function setPadding(t,l,b,r) {
            if (arguments.length === 1) {
                l = b = r = t;
            }

            this.setStyles({
                paddingTop    : '' + t + "px",
                paddingLeft   : '' + l + "px",
                paddingRight  : '' + r + "px",
                paddingBottom : '' + b + "px"
            });

            if (this.top !== t || this.left !== l || this.right !== r || this.bottom !== b) {
                // changing padding has influence to CSS size the component has to have
                // so we have to request CSS size recalculation
                this.$sizeAdjusted = false;
            }

            this.$super.apply(this, arguments);
            return this;
        },

        function setBorder(b) {
            b = ui.$view(b);

            if (b === null) {
               this.setStyle("border", "none");
            } else {
                this.setStyles({
                    //!!!! bloody FF fix, the border can be made transparent
                    //!!!! only via "border" style
                    border : "0px solid transparent",

                    //!!! FF understands only decoupled border settings
                    borderTopStyle : "solid",
                    borderTopColor : "transparent",
                    borderTopWidth : "" + b.getTop() + "px",

                    borderLeftStyle : "solid",
                    borderLeftColor : "transparent",
                    borderLeftWidth : "" + b.getLeft() + "px",

                    borderBottomStyle : "solid",
                    borderBottomColor : "transparent",
                    borderBottomWidth : "" + b.getBottom() + "px",

                    borderRightStyle : "solid",
                    borderRightColor : "transparent",
                    borderRightWidth : "" + b.getRight() + "px"
                });
            }

            // changing border can have influence to
            // CSS size, so request recalculation of the CSS
            // size
            if (this.border != b) {
                this.$sizeAdjusted = false;
            }

            return this.$super(b);
        },

        function validate() {
            // lookup root canvas
            if (this.$canvas === null && this.parent !== null) {
                this.$canvas = this.getCanvas();
            }

            this.$super();
        },

        function focused() {
            this.$super();

            // sync state of zebkit focus with native focus of the HTML Element
            if (this.hasFocus()) {
                this.$focus();
            } else {
                this.$blur();
            }
        }
    ]).hashable();

    /**
     *  This special private manager that plays key role in integration of HTML ELement into zebkit UI hierarchy.
     *  Description to the class contains technical details of implementation that should not be interested for
     *  end users.
     *
     *  HTML element integrated into zebkit layout has to be tracked regarding:
     *    1) DOM hierarchy. A new added into zebkit layout DOM element has to be attached to the first found
     *       parent DOM element
     *    2) Visibility. If a zebkit UI component change its visibility state it has to have side effect to all
     *       children HTML elements on any subsequent hierarchy level
     *    3) Moving a zebkit UI component has to correct location of children HTML element on any subsequent
     *       hierarchy level.
     *
     *  The implementation of HTML element component has the following specific:
     *    1) Every original HTML is wrapped with "div" element. It is necessary since not all HTML element has been
     *       designed to be a container for another HTML element. By adding extra div we can consider the wrapper as
     *       container. The wrapper element is used to control visibility, location, enabled state
     *    2) HTML element has "isDOMElement" property set to true
     *    3) HTML element visibility depends on an ancestor component visibility. HTML element is visible if:
     *       - the element isVisible property is true
     *       - the element has a parent DOM element set
     *       - all his ancestors are visible
     *       - size of element is more than zero
     *       - getCanvas() != null
     *
     *  The visibility state is controlled with "e.style.visibility"
     *
     *  To support effective DOM hierarchy tracking a zebkit UI component defines "$domKid" property that contains
     *  direct DOM element the UI component hosts and other UI components that host DOM element. This is sort of tree:
     *
     *  <pre>
     *    +---------------------------------------------------------
     *    |  p1 (zebkit component)
     *    |   +--------------------------------------------------
     *    |   |  p2 (zebkit component)
     *    |   |    +---------+      +-----------------------+
     *    |   |    |   h1    |      | p3 zebkit component   |
     *    |   |    +---------+      |  +---------------+    |
     *    |   |                     |  |    h3         |    |
     *    |   |    +---------+      |  |  +---------+  |    |
     *    |   |    |   h2    |      |  |  |   p4    |  |    |
     *    |   |    +---------+      |  |  +---------+  |    |
     *    |   |                     |  +---------------+    |
     *    |   |                     +-----------------------+
     *
     *     p1.$domKids : {
     *         p2.$domKids : {
     *             h1,    * leaf elements are always DOM element
     *             h2,
     *             p3.$domKids : {
     *                h3
     *             }
     *         }
     *     }
     *   </pre>
     *
     *  @constructor
     *  @private
     *  @class zebkit.ui.web.HtmlElementMan
     */
    pkg.HtmlElementMan = Class(ui.Manager, [
        function $prototype() {
            /**
             * Evaluates if the given zebkit HTML UI component is invisible state.
             * @param  {zebkit.ui.HtmlElement}  c  an UI HTML element wrapper
             * @private
             * @method $isInInvisibleState
             * @return {Boolean} true if the HTML element wrapped with zebkit UI is in invisible state
             */
            function $isInInvisibleState(c) {
                if (c.isVisible === false            ||
                    c.$container.parentNode === null ||
                    c.width       <= 0               ||
                    c.height      <= 0               ||
                    c.parent      === null           ||
                    zebkit.web.$contains(c.$container) === false)
                {
                    return true;
                }

                var p = c.parent;
                while (p !== null && p.isVisible === true && p.width > 0 && p.height > 0) {
                    p = p.parent;
                }

                return p !== null || ui.$cvp(c) === null;
            }

            // attach to appropriate DOM parent if necessary
            // c parameter has to be DOM element
            function $resolveDOMParent(c) {
                // try to find an HTML element in zebkit (pay attention, in zebkit hierarchy !)
                // hierarchy that has to be a DOM parent for the given component
                var parentElement = null;
                for(var p = c.parent; p !== null; p = p.parent) {
                    if (p.isDOMElement === true) {
                        parentElement = p.$container;
                        break;
                    }
                }

                // parentElement is null means the component has
                // not been inserted into DOM hierarchy
                if (parentElement !== null && c.$container.parentNode === null) {
                    // parent DOM element of the component is null, but a DOM container
                    // for the element has been detected. We need to add it to DOM
                    // than we have to add the DOM to the found DOM parent element
                    parentElement.appendChild(c.$container);

                    // adjust location of just attached DOM component
                    $adjustLocation(c);
                } else {
                    // test consistency whether the DOM element already has
                    // parent node that doesn't match the discovered
                    if (parentElement           !== null &&
                        c.$container.parentNode !== null &&
                        c.$container.parentNode !== parentElement)
                    {
                        throw new Error("DOM parent inconsistent state ");
                    }
                }
            }

            //    +----------------------------------------
            //    |             ^      DOM1
            //    |             .
            //    |             .  (x,y) -> (xx,yy) than correct left
            //                  .  and top of DOM2 relatively to DOM1
            //    |    +--------.--------------------------
            //    |    |        .       zebkit1
            //    |    |        .
            //    |    |  (left, top)
            //    |<............+-------------------------
            //    |    |        |           DOM2
            //    |    |        |
            //
            //  Convert DOM (x, y) zebkit coordinates into appropriate CSS top and left
            //  locations relatively to its immediate DOM element. For instance if a
            //  zebkit component contains DOM component every movement of zebkit component
            //  has to bring to correction of the embedded DOM elements
            function $adjustLocation(c) {
                if (c.$container.parentNode !== null) {
                    // hide DOM component before move
                    // makes moving more smooth
                    var prevVisibility = null;
                    if (c.$container.style.visibility !== "hidden") {
                        prevVisibility = c.$container.style.visibility;
                        c.$container.style.visibility = "hidden";
                    }

                    // find a location relatively to the first parent HTML element
                    var p = c, xx = c.x, yy = c.y;
                    while (((p = p.parent) !== null) && p.isDOMElement !== true) {
                        xx += p.x;
                        yy += p.y;
                    }

                    c.$container.style.left = "" + xx + "px";
                    c.$container.style.top  = "" + yy + "px";
                    if (prevVisibility !== null) {
                        c.$container.style.visibility = prevVisibility;
                    }
                }
            }

            // iterate over all found children HTML elements
            // !!! pay attention you have to check existence
            // of "$domKids" field before the method calling
            function $domElements(c, callback) {
                for (var k in c.$domKids) {
                    var e = c.$domKids[k];
                    if (e.isDOMElement === true) {
                        callback.call(this, e);
                    } else if (typeof e.$domKids !== 'undefined') { // prevent unnecessary method call by condition
                        $domElements(e, callback);
                    }
                }
            }

            this.compShown = function(e) {
                // 1) if c is DOM element than we have make it is visible if
                //      -- c.isVisible == true : the component visible  AND
                //      -- all elements in parent chain is visible      AND
                //      -- the component is in visible area
                //
                // 2) if c is not a DOM component his visibility state can have
                //    side effect to his children HTML elements (on any level)
                //    In this case we have to do the following:
                //      -- go through all children HTML elements
                //      -- if c.isVisible == false: make invisible every children element
                //      -- if c.isVisible != false: make visible every children element whose
                //         visibility state satisfies the following conditions:
                //          -- kid.isVisible == true
                //          -- all parent to c are in visible state
                //          -- the kid component is in visible area
                var c = e.source;
                if (c.isDOMElement === true) {
                    c.$container.style.visibility = c.isVisible === false || $isInInvisibleState(c) ? "hidden"
                                                                                                    : "visible";
                } else if (typeof c.$domKids !== 'undefined') {
                    $domElements(c, function(e) {
                        e.$container.style.visibility = e.isVisible === false || $isInInvisibleState(e) ? "hidden" : "visible";
                    });
                }
            };

            this.compMoved = function(e) {
                var c = e.source;

                // if we move a zebkit component that contains
                // DOM element(s) we have to correct the DOM elements
                // locations relatively to its parent DOM
                if (c.isDOMElement === true) {
                    // root canvas location cannot be adjusted since it is up to DOM tree to do it
                    if (c.$isRootCanvas !== true) {
                        var dx   = e.prevX - c.x,
                            dy   = e.prevY - c.y,
                            cont = c.$container;

                        cont.style.left = ((parseInt(cont.style.left, 10) || 0) - dx) + "px";
                        cont.style.top  = ((parseInt(cont.style.top,  10) || 0) - dy) + "px";
                    }
                } else if (typeof c.$domKids !== 'undefined') {
                    $domElements(c, function(e) {
                        $adjustLocation(e);
                    });
                }
            };

            function detachFromParent(p, c) {
                // DOM parent means the detached element doesn't
                // have upper parents since it is relative to the
                // DOM element
                if (p.isDOMElement !== true && typeof p.$domKids !== 'undefined') {
                    // delete from parent
                    delete p.$domKids[c.$hash$];

                    // parent is not DOM and doesn't have kids anymore
                    // what means the parent has to be also detached
                    if (isLeaf(p)) {
                        // parent of parent is not null and is not a DOM element
                        if (p.parent !== null && p.parent.isDOMElement !== true) {
                            detachFromParent(p.parent, p);
                        }

                        // remove $domKids from parent since the parent is leaf
                        delete p.$domKids;
                    }
                }
            }

            function isLeaf(c) {
                if (typeof c.$domKids !== 'undefined') {
                    for(var k in c.$domKids) {
                        if (c.$domKids.hasOwnProperty(k)) return false;
                    }
                }
                return true;
            }

            function removeDOMChildren(c) {
                // DOM element cannot have children dependency tree
                if (c.isDOMElement !== true && typeof c.$domKids !== 'undefined') {
                    for(var k in c.$domKids) {
                        if (c.$domKids.hasOwnProperty(k)) {
                            var kid = c.$domKids[k];

                            // DOM element
                            if (kid.isDOMElement === true) {
                                kid.$container.parentNode.removeChild(kid.$container);
                                kid.$container.parentNode = null;
                            } else {
                                removeDOMChildren(kid);
                            }
                        }
                    }
                    delete c.$domKids;
                }
            }

            this.compRemoved = function(e) {
                var c = e.kid;

                // if detached element is DOM element we have to
                // remove it from DOM tree
                if (c.isDOMElement === true) {
                    c.$container.parentNode.removeChild(c.$container);
                    c.$container.parentNode = null;
                } else {
                    removeDOMChildren(c);
                }

                detachFromParent(e.source, c);
            };

            this.compAdded = function(e) {
                var p = e.source,  c = e.kid;
                if (c.isDOMElement === true) {
                    $resolveDOMParent(c);
                } else {
                    if (typeof c.$domKids !== 'undefined') {
                        $domElements(c, function(e) {
                            $resolveDOMParent(e);
                        });
                    } else {
                        return;
                    }
                }

                if (p.isDOMElement !== true) {
                    // we come here if parent is not a DOM element and
                    // inserted children is DOM element or an element that
                    // embeds DOM elements
                    while (p !== null && p.isDOMElement !== true) {
                        if (typeof p.$domKids === 'undefined') {
                            // if reference to kid DOM element or kid DOM elements holder
                            // has bot been created we have to continue go up to parent of
                            // the parent to register the whole chain of DOM and DOM holders
                            p.$domKids = {};
                            p.$domKids[c.$genHash()] = c;
                            c = p;
                            p = p.parent;
                        } else {
                            var id = c.$genHash();
                            if (p.$domKids.hasOwnProperty(id)) {
                                throw new Error("Inconsistent state for " + c + ", " + c.clazz.$name);
                            }
                            p.$domKids[id] = c;
                            break;
                        }
                    }
                }
            };
        }
    ]);

    // instantiate manager
    pkg.$htmlElementMan = new pkg.HtmlElementMan();

    if (typeof zebkit.ui.FocusManager !== 'undefined') {
        zebkit.ui.FocusManager.extend([
            function requestFocus(c) {
                this.$super(c);

                var canvas = null;

                // if the requested for the focus UI componet doesn't belong to a canvas that holds a native
                // focus then let's give native focus to the canvas
                if (c !== null && c !== this.focusOwner && (c.isDOMElement !== true || c.$getElementRootFocus() === null)) {
                    canvas = c.getCanvas();
                    if (canvas !== null && document.activeElement !== canvas.element) {
                        canvas.element.focus();
                    }

                    // if old focus onwer sits on canvas that doesn't hold the native focus
                    // let's clear it
                    if (this.focusOwner !== null && this.focusOwner.getCanvas() !== canvas) {
                        this.requestFocus(null);
                    }
                } else if (this.focusOwner !== null && this.focusOwner.isDOMElement !== true) {
                    // here we check if focus owner belongs to a canvas that has native focus
                    // and if it is not true we give native focus to the canvas
                    canvas = this.focusOwner.getCanvas();
                    if (canvas !== null && document.activeElement !== canvas.element) {
                        canvas.element.focus();
                    }
                }
            },

            function pointerPressed(e){
                if (e.isAction()) {
                    // the problem is a target canvas element get mouse pressed
                    // event earlier than it gets focus what is inconsistent behavior
                    // to fix it a timer is used
                    if (document.activeElement !== e.source.getCanvas().element) {
                        var $this = this;
                        setTimeout(function() {
                            $this.requestFocus(e.source);
                        });
                    } else {
                        this.$$super(e);
                    }
                }
            }
        ]);
    }


    var ui = pkg.cd("..");

    /**
     * HTML Canvas native DOM element wrapper.
     * @constructor
     * @param  {HTMLCanvas} [e] HTML canvas element to be wrapped as a zebkit UI
     * component or nothing to create a new canvas element
     * @class zebkit.ui.web.HtmlCanvas
     * @extends {zebkit.ui.web.HtmlElement}
     */
    pkg.HtmlCanvas = Class(pkg.HtmlElement,  [
        function(e) {
            if (arguments.length > 0 && e !== null && e.tagName !== "CANVAS") {
                throw new Error("Invalid element '" + e + "'");
            }

            /**
             * Keeps rectangular "dirty" area of the canvas component
             * @private
             * @attribute $da
             * @type {Object}
             *       { x:Integer, y:Integer, width:Integer, height:Integer }
             */
            this.$da = { x: 0, y: 0, width: -1, height: 0 };

            this.$super(arguments.length === 0  || e === null ? "canvas" : e);

            // let HTML Canvas be WEB event transparent
            this.$container.style["pointer-events"] = "none";

            // check if this element has been created
            if (arguments.length === 0 || e === null) {
                // prevent canvas selection
                this.element.onselectstart = function() { return false; };
            }
        },

        function $clazz() {
            this.$ContextMethods = {
                reset : function(w, h) {
                    this.$curState = 0;
                    var s = this.$states[0];
                    s.srot = s.rotateVal = s.x = s.y = s.width = s.height = s.dx = s.dy = 0;
                    s.crot = s.sx = s.sy = 1;
                    s.width = w;
                    s.height = h;
                    this.setFont(ui.font);
                    this.setColor("white");
                },

                $init : function() {
                    // pre-allocate canvas save $states stack
                    this.$states = Array(70);
                    for(var i=0; i < this.$states.length; i++) {
                        var s = {};
                        s.srot = s.rotateVal = s.x = s.y = s.width = s.height = s.dx = s.dy = 0;
                        s.crot = s.sx = s.sy = 1;
                        this.$states[i] = s;
                    }
                },

                translate : function(dx, dy) {
                    if (dx !== 0 || dy !== 0) {
                        var c = this.$states[this.$curState];
                        c.x  -= dx;
                        c.y  -= dy;
                        c.dx += dx;
                        c.dy += dy;
                        this.$translate(dx, dy);
                    }
                },

                rotate : function(v) {
                    var c = this.$states[this.$curState];
                    c.rotateVal += v;
                    c.srot = Math.sin(c.rotateVal);
                    c.crot = Math.cos(c.rotateVal);
                    this.$rotate(v);
                },

                scale : function(sx, sy) {
                    var c = this.$states[this.$curState];
                    c.sx = c.sx * sx;
                    c.sy = c.sy * sy;
                    this.$scale(sx, sy);
                },

                save : function() {
                    this.$curState++;
                    var c = this.$states[this.$curState], cc = this.$states[this.$curState - 1];
                    c.x = cc.x;
                    c.y = cc.y;
                    c.width = cc.width;
                    c.height = cc.height;

                    c.dx = cc.dx;
                    c.dy = cc.dy;
                    c.sx = cc.sx;
                    c.sy = cc.sy;
                    c.srot = cc.srot;
                    c.crot = cc.crot;
                    c.rotateVal = cc.rotateVal;

                    this.$save();
                    return this.$curState - 1;
                },

                restoreAll : function() {
                    while(this.$curState > 0) {
                        this.restore();
                    }
                },

                restore : function() {
                    if (this.$curState === 0) {
                        throw new Error("Context restore history is empty");
                    }

                    this.$curState--;
                    this.$restore();
                    return this.$curState;
                },

                clipRect : function(x,y,w,h){
                    var c = this.$states[this.$curState];
                    if (c.x !== x || y !== c.y || w !== c.width || h !== c.height) {
                        var xx = c.x, yy = c.y,
                            ww = c.width,
                            hh = c.height,
                            xw = x + w,
                            xxww = xx + ww,
                            yh = y + h,
                            yyhh = yy + hh;

                        c.x      = x > xx ? x : xx;
                        c.width  = (xw < xxww ? xw : xxww) - c.x;
                        c.y      = y > yy ? y : yy;
                        c.height = (yh < yyhh ? yh : yyhh) - c.y;

                        if (c.x !== xx || yy !== c.y || ww !== c.width || hh !== c.height) {
                            // begin path is very important to have proper clip area
                            this.beginPath();
                            this.rect(x, y, w, h);
                            this.closePath();
                            this.clip();
                        }
                    }
                }
            };
        },

        function $prototype(clazz) {
            this.$rotateValue = 0;
            this.$scaleX = 1;
            this.$scaleY = 1;

            /**
             *  Canvas context
             *  @attribute $context
             *  @private
             *  @type {CanvasRenderingContext2D}
             */
            this.$context = null;


            // set border for canvas has to be set as zebkit border, since canvas
            // is DOM component designed for rendering, so setting DOM border
            // doesn't allow us to render zebkit border
            this.setBorder = function(b) {
                return ui.Panel.prototype.setBorder.call(this, b);
            };

            this.rotate = function(r) {
                this.$rotateValue += r;
                if (this.$context !== null) {
                    this.$context.rotate(r);
                }

                this.vrp();
                return this;
            };

            this.scale = function(sx, sy) {
                if (this.$context !== null) this.$context.scale(sx, sy);
                this.$scaleX = this.$scaleX * sx;
                this.$scaleY = this.$scaleY * sy;
                this.vrp();
                return this;
            };

            this.clearTransformations = function() {
                this.$scaleX = 1;
                this.$scaleY = 1;
                this.$rotateValue = 0;
                if (this.$context !== null) {
                    this.$context = zebkit.web.$canvas(this.element, this.width, this.height, true);
                    this.$context.reset(this.width, this.height);
                }
                this.vrp();
                return this;
            };

            // set passing for canvas has to be set as zebkit padding, since canvas
            // is DOM component designed for rendering, so setting DOM padding
            // doesn't allow us to hold painting area proper
            this.setPadding = function() {
                return ui.Panel.prototype.setPadding.apply(this, arguments);
            };

            this.setSize = function(w, h) {
                if (this.width !== w || h !== this.height) {
                    var pw  = this.width,
                        ph  = this.height;

                    this.$context = zebkit.web.$canvas(this.element, w, h);

                    // canvas has one instance of context, the code below
                    // test if the context has been already full filled
                    // with necessary methods and if it is not true
                    // fill it
                    if (typeof this.$context.$states === "undefined") {
                        zebkit.web.$extendContext(this.$context, clazz.$ContextMethods);
                    }

                    this.$context.reset(w, h);

                    // if canvas has been rotated apply the rotation to the context
                    if (this.$rotateValue !== 0) {
                        this.$context.rotate(this.$rotateValue);
                    }

                    // if canvas has been scaled apply it to it
                    if (this.$scaleX !== 1 || this.$scaleY !== 1) {
                        this.$context.scale(this.$scaleX, this.$scaleY);
                    }

                    this.width  = w;
                    this.height = h;

                    // sync state of visibility
                    // TODO: probably it should e in html element manager, manager has
                    // to catch resize event and if size is not 0 correct visibility
                    // now manager doesn't set style visibility to "visible" state
                    // if component size is zero
                    if (this.$container.style.visibility === "hidden") {
                        if (this.isVisible) {
                            this.$container.style.visibility = "visible";
                        }
                    }

                    this.invalidate();

                    // TODO: think to replace it with vrp()
                    this.validate();
                    this.repaint();

                    if (w !== pw || h !== ph) {
                        this.resized(pw, ph);
                    }
                }
                return this;
            };
        }
    ]);

    /**
     * Class that wrapped window component with own HTML Canvas.
     * @param  {zebkit.ui.Window} [target] a window component. If target is not defined
     * it will be instantiated automatically. If the component is not passed the new
     * window component (zebkit.ui.Window) will be created.
     * @constructor
     * @extends {zebkit.ui.web.HtmlCanvas}
     * @class zebkit.ui.web.HtmlWinCanvas
     */
    pkg.HtmlWinCanvas = Class(pkg.HtmlCanvas, [
        function $prototype() {
            this.winOpened = function(e) {
                this.target.winOpened(e);
            };

            this.winActivated = function(e){
                this.target.winActivated(e);
            };
        },

        function(target) {
            this.$super();

            /**
             * Target window
             * @attribute target
             * @type {zebkit.ui.Window}
             * @readOnly
             */
            this.target = (arguments.length === 0 ? new ui.Window() : target);

            var $this = this;
            target.getWinContainer = function() {
                return $this;
            };

            this.setLayout(new zebkit.layout.BorderLayout());
            this.add("center", target);
        }
    ]);

    /**
     * WEB based HTML components wrapped with as zebkit components.
     * @class zebkit.ui.web.HtmlFocusableElement
     * @constructor
     * @extends {zebkit.ui.web.HtmlElement}
     */
    pkg.HtmlFocusableElement = Class(pkg.HtmlElement, [
        function $prototype() {
            this.$getElementRootFocus = function() {
                return this.element;
            };
        }
    ]);

    /**
     * HTML input element wrapper class. The class can be used as basis class
     * to wrap HTML elements that can be used to enter a textual information.
     * @constructor
     * @param {String} text a text the text input component has to be filled with
     * @param {String} element an input element name
     * @class zebkit.ui.web.HtmlTextInput
     * @extends zebkit.ui.web.HtmlElement
     */
    pkg.HtmlTextInput = Class(pkg.HtmlFocusableElement, [
        function(text, e) {
            if (text === null) text = "";
            this.$super(e);
            this.setAttribute("tabindex", 0);
            this.setValue(text);
        },

        function $prototype() {
            this.cursorType = ui.Cursor.TEXT;

            /**
             * Get a text of the text input element
             * @return {String} a text of the  text input element
             * @method getValue
             */
            this.getValue = function() {
                return this.element.value.toString();
            };

            /**
             * Set the text
             * @param {String} t a text
             * @method setValue
             * @chainable
             */
            this.setValue = function(t) {
                if (this.element.value !== t) {
                    this.element.value = t;
                    this.vrp();
                }
                return this;
            };
        }
    ]);

    /**
     * HTML input text element wrapper class. The class wraps standard HTML text field
     * and represents it as zebkit UI component.
     * @constructor
     * @class zebkit.ui.web.HtmlTextField
     * @param {String} [text] a text the text field component has to be filled with
     * @extends zebkit.ui.web.HtmlTextInput
     */
    pkg.HtmlTextField = Class(pkg.HtmlTextInput, [
        function(text) {
            this.$super(text, "input");
            this.element.setAttribute("type",  "text");
        }
    ]);

    /**
     * HTML input text area element wrapper class. The class wraps standard HTML text area
     * element and represents it as zebkit UI component.
     * @constructor
     * @param {String} [text] a text the text area component has to be filled with
     * @class zebkit.ui.web.HtmlTextArea
     * @extends zebkit.ui.web.HtmlTextInput
     */
    pkg.HtmlTextArea = Class(pkg.HtmlTextInput, [
        function(text) {
            this.$super(text, "textarea");
            this.element.setAttribute("rows", 10);
        },

        /**
         * Set the text area resizeable or not resizeable.
         * @param {Boolean} b true to make the text area component resizeable
         * @method setResizeable
         * @chainable
         */
        function setResizeable(b) {
            this.setStyle("resize", b === false ? "none" : "both");
            return this;
        }
    ]);

    /**
     * HTML Link component.
     * @param  {String} text  a text of link
     * @param  {String} [href] an href of the link
     * @extends zebkit.ui.web.HtmlElement
     * @class zebkit.ui.web.HtmlLink
     * @event fired
     * @param {zebkit.ui.web.Link} src a link that has been pressed
     */
    pkg.HtmlLink = Class(pkg.HtmlElement, [
        function(text, href) {
            this.$super("a");
            this.setContent(text);
            this.setAttribute("href", arguments.length < 2 ? "#": href);
            this._ = new zebkit.util.Listeners();
            var $this = this;
            this.element.onclick = function(e) {
                $this._.fired($this);
            };
        }
    ]);


    var ui = pkg.cd("..");

    /**
     * The base class for HTML developing HTML layers.
     * @class zebkit.ui.web.HtmlLayer
     * @constructor
     * @extends {zebkit.ui.web.HtmlCanvas}
     */
    pkg.HtmlLayer = Class(pkg.HtmlCanvas, []);

    /**
     *  Root layer implementation. This is the simplest UI layer implementation
     *  where the layer always try grabbing all input event
     *  @class zebkit.ui.web.RootLayer
     *  @constructor
     *  @extends {zebkit.ui.web.HtmlLayer}
     *  @uses {zebkit.ui.RootLayerMix}
     */
    pkg.RootLayer = Class(pkg.HtmlLayer, ui.RootLayerMix, [
        function $clazz() {
            this.layout = new zebkit.layout.RasterLayout();
        }
    ]);

    /**
     *  Window layer implementation.
     *  @class zebkit.ui.web.WinLayer
     *  @constructor
     *  @extends {zebkit.ui.web.HtmlLayer}
     *  @uses {zebkit.ui.WinLayerMix}
     */
    pkg.WinLayer = Class(pkg.HtmlLayer, ui.WinLayerMix, [
        function() {
            this.$super();

            // TODO: why 1000 and how to avoid z-index manipulation
            // the layer has to be placed above other elements that are virtually
            // inserted in the layer
            this.element.style["z-index"] = 10000;
        },

        function $clazz() {
            this.layout = new zebkit.layout.RasterLayout();
        }
    ]);

    /**
     *  Ppopup layer implementation.
     *  @class zebkit.ui.web.PopupLayer
     *  @constructor
     *  @extends {zebkit.ui.web.HtmlLayer}
     *  @uses {zebkit.ui.PopupLayerMix}
     */
    pkg.PopupLayer = Class(pkg.HtmlLayer, ui.PopupLayerMix, [
        function $clazz() {
            this.layout = new ui.PopupLayerLayout([
                function doLayout(target){
                    // TODO:
                    // prove of concept. if layer is active don't allow WEB events comes to upper layer
                    // since there can be another HtmlElement that should not be part of interaction
                    if (target.kids.length > 0) {
                        if (target.$container.style["pointer-events"] !== "auto") {
                            target.$container.style["pointer-events"] = "auto";
                        }
                    } else if (target.$container.style["pointer-events"] !== "none") {
                        target.$container.style["pointer-events"] = "none";  // make the layer transparent for pointer events
                    }

                    this.$super(target);
                }
            ]);
        }
    ]);


    // TODO: dependencies to remove
    //     -- taskSets (util.js)

    pkg.CanvasEvent = Class(zebkit.util.Event, []);

    var ui = pkg.cd(".."),
        COMP_EVENT = new ui.CompEvent();

    // keep pointer owners (the component where cursor/finger placed in)
    pkg.$pointerOwner        = {};
    pkg.$pointerPressedOwner = {};

    /**
     *  zCanvas zebkit UI component class. This is starting point for building zebkit UI. The class is a wrapper
     *  for HTML5 Canvas element. The main goals of the class is catching all native HTML5 Canvas element  events
     *  and translating its into Zebkit UI events.
     *
     *  zCanvas instantiation can trigger a new HTML Canvas will be created and added to HTML DOM tree.
     *  It happens if developer doesn't pass an HTML Canvas element reference or an ID of existing HTML
     *  Canvas element. To re-use an existent in DOM tree HTML5 canvas element pass an id of the canvas
     *  element:

            // a new HTML canvas element is created and added into HTML DOM tree
            var canvas = zebkit.ui.zCanvas();

            // a new HTML canvas element is created into HTML DOM tree
            var canvas = zebkit.ui.zCanvas(400,500);  // pass canvas size

            // stick to existent HTML canvas element
            var canvas = zebkit.ui.zCanvas("ExistentCanvasID");

     *  zCanvas has layered structure. Every layer is responsible for showing and controlling a dedicated
     *  type of UI elements like windows pop-up menus, tool tips and so on. To start building UI use root layer.
     *  The layer is standard zebkit UI panel that is accessible via "root" zCanvas field:

            // create canvas
            var canvas = zebkit.ui.zCanvas(400,500);

            // save reference to canvas root layer where
            // hierarchy of UI components have to be hosted
            var root = canvas.root;

            // fill root with UI components
            var label = new zebkit.ui.Label("Label");
            label.setBounds(10,10,100,50);
            root.add(label);

     *  @class zebkit.ui.zCanvas
     *  @extends {zebkit.ui.web.HtmlCanvas}
     *  @constructor
     *  @param {String|Canvas} [element] an ID of a HTML canvas element or reference to an HTML Canvas element.
     *  @param {Integer} [width] a width of an HTML canvas element
     *  @param {Integer} [height] a height of an HTML canvas element
     */

    /**
     * Implement the event handler method  to catch canvas initialized event. The event is triggered once the
     * canvas has been initiated and all properties listeners of the canvas are set upped. The event can be
     * used to load saved data.

         var p = new zebkit.ui.zCanvas(300, 300, [
              function canvasInitialized() {
                  // do something
              }
         ]);

     * @event  canvasInitialized
     */
    ui.zCanvas = pkg.zCanvas = Class(pkg.HtmlCanvas, [
        function(element, w, h) {
            // no arguments
            if (arguments.length === 0) {
                w = 400;
                h = 400;
                element = null;
            } else if (arguments.length === 1) {
                w = -1;
                h = -1;
            } else if (arguments.length === 2) {
                h = w;
                w = element;
                element = null;
            }

            // if passed element is string than consider it as
            // an ID of an element that is already in DOM tree
            if (element !== null && zebkit.isString(element)) {
                var id = element;
                element = document.getElementById(id);

                // no canvas can be detected
                if (element === null) {
                    throw new Error("Canvas id='" + id + "' element cannot be found");
                }
            }

            /**
             * Dictionary to track layers by its ids.
             * @attribute $layers
             * @private
             * @type {Object}
             */
            this.$layers = {};

            this.$super(element);


            // since zCanvas is top level element it doesn't have to have
            // absolute position
            this.$container.style.position = "relative";

            // let canvas zCanvas listen WEB event
            this.$container.style["pointer-events"] = "auto";

            // if canvas is not yet part of HTML let's attach it to
            // body.
            if (this.$container.parentNode === null) {
                document.body.appendChild(this.$container);
            }

            // force canvas to have a focus
            if (this.element.getAttribute("tabindex") === null) {
                this.element.setAttribute("tabindex", "1");
            }

            if (w < 0) w = this.element.offsetWidth;
            if (h < 0) h = this.element.offsetHeight;

            // !!!
            // save canvas in list of created Zebkit canvases
            // do it before calling setSize(w,h) method
            this.clazz.$canvases.push(this);

            this.setSize(w, h);

            // sync canvas visibility with what canvas style says
            var cvis = (this.element.style.visibility === "hidden" ? false : true);
            if (this.isVisible !== cvis) {
                this.setVisible(cvis);
            }

            // call event method if it is defined
            if (typeof this.canvasInitialized !== 'undefined') {
                this.canvasInitialized();
            }

            var $this = this;

            // this method should clean focus if
            // one of of a child DOM element gets focus
            zebkit.web.$focusin(this.$container, function(e) {
                // TODO: fix and uncomment
                // if (e.target !== $this.$container &&
                //     e.target.parentNode !== null &&
                //     e.target.parentNode.getAttribute("data-zebcont") === null) // TODO: BUG, data-zebcont is not set anymore, use $canvases instead
                // {
                //     ui.focusManager.requestFocus(null);
                // } else {
                //     // clear focus if a focus owner component is hosted with another zCanvas
                //     if (e.target === $this.$container &&
                //         ui.focusManager.focusOwner !== null &&
                //         ui.focusManager.focusOwner.getCanvas() !== $this)
                //     {
                //         ui.focusManager.requestFocus(null);
                //     }
                // }
            }, true);
        },

        function $clazz () {
            this.CLASS_NAME = "zebcanvas";
            this.$canvases  = [];

            this.$getCanvasByElement = function(e) {
                for (var i = 0; i < this.$canvases.length; i++) {
                    if (this.$canvases[i] === e) {
                        return this.$canvases[i];
                    }
                }
                return null;
            };
        },

        function $prototype() {
            /**
             * Indicates this the root canvas element
             * @attribute $isRootCanvas
             * @type {Boolean}
             * @private
             * @default true
             * @readOnly
             */
            this.$isRootCanvas = true;

            /**
             * Indicate if the canvas has to be stretched to fill the whole view port area.
             * @type {Boolean}
             * @attribute isSizeFull
             * @readOnly
             */
            this.isSizeFull = false;


            this.offx = this.offy = 0;

            /**
             * Transforms the pageX coordinate into relatively to the canvas origin
             * coordinate taking in account the canvas transformation
             * @param  {Number} pageX a pageX coordinate
             * @param  {Number} pageY a pageY coordinate
             * @return {Integer} an x coordinate that is relative to the canvas origin
             * @method $toElementX
             * @protected
             */
            this.$toElementX = function(pageX, pageY) {
                // offset has to be added here since "calcOffset" can called (for instance page reloading)
                // to early
                pageX -= (this.offx);
                pageY -= (this.offy);

                var c = this.$context.$states[this.$context.$curState];
                return ((c.sx !== 1 || c.sy !== 1 || c.rotateVal !== 0) ? Math.round((c.crot * pageX + pageY * c.srot)/c.sx)
                                                                        : pageX) - c.dx;
            };

            /**
             * Transforms the pageY coordinate into relatively to the canvas origin
             * coordinate taking in account the canvas transformation
             * @param  {Number} pageX a pageX coordinate
             * @param  {Number} pageY a pageY coordinate
             * @return {Integer} an y coordinate that is relative to the canvas origin
             * @method $toElementY
             * @protected
             */
            this.$toElementY = function(pageX, pageY) {
                // offset has to be added here since "calcOffset" can called (for instance page reloading)
                // to early
                pageX -= (this.offx);
                pageY -= (this.offy);

                var c = this.$context.$states[this.$context.$curState];
                return ((c.sx !== 1 || c.sy !== 1 || c.rotateVal !== 0) ? Math.round((pageY * c.crot - c.srot * pageX)/c.sy)
                                                                        : pageY) - c.dy;
            };

            this.load = function(jsonPath){
                return this.root.load(jsonPath);
            };

            // TODO: may be rename to dedicated method $doWheelScroll
            this.$doScroll = function(dx, dy, src) {
                if (src === "wheel" && pkg.$pointerOwner.mouse != null) {
                    var owner = pkg.$pointerOwner.mouse;
                    while (owner !== null && typeof owner.doScroll === 'undefined') {
                        owner = owner.parent;
                    }

                    if (owner !== null) {
                        return owner.doScroll(dx, dy, src);
                    }
                }
                return false;
            };

            /**
             * Catches key typed events, adjusts and distributes it to UI hierarchy
             * @param  {zebkit.ui.KeyEvent} e an event
             * @private
             * @method $keyTyped
             * @return {Boolean}  true if the event has been processed
             */
            this.$keyTyped = function(e) {
                if (ui.focusManager.focusOwner !== null) {
                    e.source = ui.focusManager.focusOwner;
                    return ui.events.fire("keyTyped", e);
                } else {
                    return false;
                }
            };

            /**
             * Catches key pressed events, adjusts and distributes it to UI hierarchy
             * @param  {zebkit.ui.KeyEvent} e an event
             * @private
             * @method $keyPressed
             * @return {Boolean}  true if the event has been processed
             */
            this.$keyPressed = function(e) {
                for(var i = this.kids.length - 1;i >= 0; i--){
                    var l = this.kids[i];
                    if (typeof l.layerKeyPressed !== 'undefined' && l.layerKeyPressed(e) === true) {
                        return true;
                    }
                }

                if (ui.focusManager.focusOwner !== null) {
                    e.source = ui.focusManager.focusOwner;
                    return ui.events.fire("keyPressed", e);
                } else {
                    e.source = this;
                    return ui.events.fire("keyPressed", e);
                }
            };

            /**
             * Catches key released events, adjusts and distributes it to UI hierarchy
             * @param  {zebkit.ui.KeyEvent} e an event
             * @private
             * @method $keyReleased
             * @return {Boolean}  true if the event has been processed
             */
            this.$keyReleased = function(e){
                if (ui.focusManager.focusOwner !== null) {
                    e.source = ui.focusManager.focusOwner;
                    return ui.events.fire("keyReleased", e);
                } else {
                    return false;
                }
            };

            /**
             * Catches pointer entered events, adjusts and distributes it to UI hierarchy
             * @param  {zebkit.ui.PointerEvent} e an event
             * @private
             * @method $pointerEntered
             */
            this.$pointerEntered = function(e) {
                // TODO: review it quick and dirty fix try to track a situation
                //       when the canvas has been moved
                this.recalcOffset();

                var x = this.$toElementX(e.pageX, e.pageY),
                    y = this.$toElementY(e.pageX, e.pageY),
                    d = this.getComponentAt(x, y),
                    o = pkg.$pointerOwner[e.identifier];

                // also correct current component on that  pointer is located
                if (d !== o) {
                    // if pointer owner is not null but doesn't match new owner
                    // generate pointer exit and clean pointer owner
                    if (o != null) {
                        pkg.$pointerOwner[e.identifier] = null;
                        ui.events.fire("pointerExited", e.update(o, x, y));
                    }

                    // if new pointer owner is not null and enabled
                    // generate pointer entered event ans set new pointer owner
                    if (d !== null && d.isEnabled === true){
                        pkg.$pointerOwner[e.identifier] = d;
                        ui.events.fire("pointerEntered", e.update(d, x, y));
                    }
                }
            };

            /**
             * Catches pointer exited events, adjusts and distributes it to UI hierarchy
             * @param  {zebkit.ui.PointerEvent} e an event
             * @private
             * @method $pointerExited
             */
            this.$pointerExited = function(e) {
                var o = pkg.$pointerOwner[e.identifier];
                if (o != null) {
                    pkg.$pointerOwner[e.identifier] = null;
                    return ui.events.fire("pointerExited", e.update(o,
                                                                          this.$toElementX(e.pageX, e.pageY),
                                                                          this.$toElementY(e.pageX, e.pageY)));
                }
            };

            /**
             * Catches pointer moved events, adjusts and distributes it to UI hierarchy.
             * @param  {zebkit.ui.PointerEvent} e an event
             * @private
             * @method $pointerMoved
             */
            this.$pointerMoved = function(e){
                // if a pointer button has not been pressed handle the normal pointer moved event
                var x = this.$toElementX(e.pageX, e.pageY),
                    y = this.$toElementY(e.pageX, e.pageY),
                    d = this.getComponentAt(x, y),
                    o = pkg.$pointerOwner[e.identifier],
                    b = false;

                // check if pointer already inside a component
                if (o != null) {
                    if (d !== o) {
                        pkg.$pointerOwner[e.identifier] = null;
                        b = ui.events.fire("pointerExited", e.update(o, x, y));

                        if (d != null && d.isEnabled === true) {
                            pkg.$pointerOwner[e.identifier] = d;
                            b = ui.events.fire("pointerEntered", e.update(d, x, y)) || b;
                        }
                    } else {
                        if (d !== null && d.isEnabled === true) {
                            b = ui.events.fire("pointerMoved", e.update(d, x, y));
                        }
                    }
                } else {
                    if (d !== null && d.isEnabled === true) {
                        pkg.$pointerOwner[e.identifier] = d;
                        b = ui.events.fire("pointerEntered", e.update(d, x, y));
                    }
                }

                return b;
            };

            /**
             * Catches pointer drag started events, adjusts and distributes it to UI hierarchy.
             * @param  {zebkit.ui.PointerEvent} e an event
             * @private
             * @method $pointerDragStarted
             */
            this.$pointerDragStarted = function(e) {
                var x = this.$toElementX(e.pageX, e.pageY),
                    y = this.$toElementY(e.pageX, e.pageY),
                    d = this.getComponentAt(x, y);

                // if target component can be detected fire pointer start dragging and
                // pointer dragged events to the component
                if (d !== null && d.isEnabled === true) {
                    return ui.events.fire("pointerDragStarted", e.update(d, x, y));
                }

                return false;
            };

            /**
             * Catches pointer dragged events, adjusts and distributes it to UI hierarchy.
             * @param  {zebkit.ui.PointerEvent} e an event
             * @private
             * @method $pointerDragged
             */
            this.$pointerDragged = function(e){
                if (pkg.$pointerOwner[e.identifier] != null) {
                    return ui.events.fire("pointerDragged", e.update(pkg.$pointerOwner[e.identifier],
                                                                           this.$toElementX(e.pageX, e.pageY),
                                                                           this.$toElementY(e.pageX, e.pageY)));
                }

                return false;
            };

            /**
             * Catches pointer drag ended events, adjusts and distributes it to UI hierarchy.
             * @param  {zebkit.ui.PointerEvent} e an event
             * @private
             * @method $pointerDragEnded
             */
            this.$pointerDragEnded = function(e) {
                if (pkg.$pointerOwner[e.identifier] != null) {
                    return ui.events.fire("pointerDragEnded", e.update(pkg.$pointerOwner[e.identifier],
                                                                             this.$toElementX(e.pageX, e.pageY),
                                                                             this.$toElementY(e.pageX, e.pageY)));
                }
                return false;
            };

            this.$isBlockedByLayer = function(id, method, e) {
                // adjust event for passing it to layers
                // e.x = x;
                // e.y = y;

                for(var i = this.kids.length - 1; i >= 0; i--){
                    var layer = this.kids[i];
                    if (typeof layer[method] !== 'undefined') {
                        e.id = id;
                        if (layer[method](e) === true) {
                            return true;
                        }
                    }
                }
                return false;
            };

            /**
             * Catches pointer clicked events, adjusts and distributes it to UI hierarchy.
             * @param  {zebkit.ui.PointerEvent} e an event
             * @private
             * @method $pointerClicked
             */
            this.$pointerClicked = function(e) {
                var x = this.$toElementX(e.pageX, e.pageY),
                    y = this.$toElementY(e.pageX, e.pageY),
                    d = this.getComponentAt(x, y);

                // zoom inn zoom out can bring to a situation
                // d is null, in this case offset should be recalculated
                // TODO: the cause of the issue has to be investigated deeper
                if (d === null) {
                    this.recalcOffset();
                    x = this.$toElementX(e.pageX, e.pageY);
                    y = this.$toElementY(e.pageX, e.pageY);
                    d = this.getComponentAt(x, y);
                }

                if (d !== null) {
                    e = e.update(d, x, y);
                    if (this.$isBlockedByLayer("pointerClicked", "layerPointerClicked", e)) {
                        return true;
                    } else {
                        return ui.events.fire("pointerClicked", e);
                    }
                } else {
                    return false;
                }
            };

            this.$pointerDoubleClicked = function(e) {
                var x = this.$toElementX(e.pageX, e.pageY),
                    y = this.$toElementY(e.pageX, e.pageY),
                    d = this.getComponentAt(x, y);

                return d !== null ? ui.events.fire("pointerDoubleClicked", e.update(d, x, y))
                                  : false;
            };

            /**
             * Catches pointer released events, adjusts and distributes it to UI hierarchy.
             * @param  {zebkit.ui.PointerEvent} e an event
             * @private
             * @method $pointerReleased
             */
            this.$pointerReleased = function(e) {
                var x  = this.$toElementX(e.pageX, e.pageY),
                    y  = this.$toElementY(e.pageX, e.pageY),
                    pp = pkg.$pointerPressedOwner[e.identifier];

                // release pressed state
                if (pp != null) {
                    try {
                        e = e.update(pp, x, y);
                        if (this.$isBlockedByLayer("pointerReleased", "layerPointerReleased", e) !== true) {
                            ui.events.fire("pointerReleased", e);
                        }
                    } finally {
                        delete pkg.$pointerPressedOwner[e.identifier];
                    }
                }

                // mouse released can happen at new location, so move owner has to be corrected
                // and mouse exited entered event has to be generated.
                // the correction takes effect if we have just completed dragging or mouse pressed
                // event target doesn't match pkg.$pointerOwner
                if (e.pointerType === "mouse" && (e.pressPageX !== e.pageX || e.pressPageY !== e.pageY)) {
                    var nd = this.getComponentAt(x, y),
                        po = this.getComponentAt(this.$toElementX(e.pressPageX, e.pressPageY),
                                                 this.$toElementY(e.pressPageX, e.pressPageY));

                    if (nd !== po) {
                        if (po !== null) {
                            pkg.$pointerOwner[e.identifier] = null;
                            ui.events.fire("pointerExited", e.update(po, x, y));
                        }

                        if (nd !== null && nd.isEnabled === true){
                            pkg.$pointerOwner[e.identifier] = nd;
                            ui.events.fire("pointerEntered", e.update(nd, x, y));
                        }
                    }
                }
            };

            /**
             * Catches pointer pressed events, adjusts and distributes it to UI hierarchy.
             * @param  {zebkit.ui.PointerEvent} e an event
             * @private
             * @method $pointerPressed
             */
            this.$pointerPressed = function(e) {
                var x  = this.$toElementX(e.pageX, e.pageY),
                    y  = this.$toElementY(e.pageX, e.pageY),
                    pp = pkg.$pointerPressedOwner[e.identifier];

                // free pointer prev pressed if any
                if (pp != null) {
                    try {
                        ui.events.fire("pointerReleased", e.update(pp, x, y));
                    } finally {
                        delete pkg.$pointerPressedOwner[e.identifier];
                    }
                }

                e.source = null;
                e.x = x;
                e.y = y;
                if (this.$isBlockedByLayer("pointerPressed", "layerPointerPressed", e)) {
                    return true;
                }

                var d = this.getComponentAt(x, y);
                if (d !== null && d.isEnabled === true) {
                    if (pkg.$pointerOwner[e.identifier] !== d) {
                        pkg.$pointerOwner[e.identifier] = d;
                        ui.events.fire("pointerEntered",  e.update(d, x, y));
                    }

                    pkg.$pointerPressedOwner[e.identifier] = d;

                    // TODO: prove the solution (return true) !?
                    if (ui.events.fire("pointerPressed", e.update(d, x, y)) === true) {
                        delete pkg.$pointerPressedOwner[e.identifier];
                        return true;
                    }
                }

                return false;
            };

            this.getComponentAt = function(x, y) {
                for(var i = this.kids.length; --i >= 0; ){
                    var c = this.kids[i].getComponentAt(x, y);
                    if (c !== null) {
                        var p = c;
                        while ((p = p.parent) !== null) {
                            if (typeof p.catchInput !== 'undefined' && (p.catchInput === true || (p.catchInput !== false && p.catchInput(c)))) {
                                c = p;
                            }
                        }
                        return c;
                    }
                }
                return null;
            };

            this.recalcOffset = function() {
                // calculate the DOM element offset relative to window taking in account scrolling
                var poffx = this.offx,
                    poffy = this.offy,
                    ba    = this.$container.getBoundingClientRect();

                this.offx = Math.round(ba.left) + zebkit.web.$measure(this.$container, "border-left-width") +
                                                  zebkit.web.$measure(this.$container, "padding-left") + window.pageXOffset;
                this.offy = Math.round(ba.top) +  zebkit.web.$measure(this.$container, "padding-top" ) +
                                                  zebkit.web.$measure(this.$container, "border-top-width") + window.pageYOffset;

                if (this.offx !== poffx || this.offy !== poffy) {
                    // force to fire component re-located event
                    this.relocated(this, poffx, poffy);
                }
            };

            /**
             * Get the canvas layer by the specified layer ID. Layer is a children component
             * of the canvas UI component. Every layer has an ID assigned to it the method
             * actually allows developers to get the canvas children component by its ID
             * @param  {String} id a layer ID
             * @return {zebkit.ui.Panel} a layer (children) component
             * @method getLayer
             */
            this.getLayer = function(id) {
                return this.$layers[id];
            };

            // override relocated and resized
            // to prevent unnecessary repainting
            this.relocated = function(px,py) {
                COMP_EVENT.source = this;
                COMP_EVENT.px     = px;
                COMP_EVENT.py     = py;
                ui.events.fire("compMoved", COMP_EVENT);
            };

            this.resized = function(pw,ph) {
                COMP_EVENT.source = this;
                COMP_EVENT.prevWidth  = pw;
                COMP_EVENT.prevHeight = ph;
                ui.events.fire("compSized", COMP_EVENT);
                // don't forget repaint it
                this.repaint();
            };

            this.$initListeners = function() {
                // TODO: hard-coded
                new zebkit.web.PointerEventUnifier(this.$container, this);
                new zebkit.web.KeyEventUnifier(this.element, this); // element has to be used since canvas is
                                                             // styled to have focus and get key events
                new zebkit.web.MouseWheelSupport(this.$container, this);
            };

            /**
             * Force the canvas to occupy the all available view port area
             * @param {Boolean} b true to force the canvas be stretched over all available view port area
             * @chainable
             * @method setSizeFull
             */
            this.setSizeFull = function(b) {
                /**
                 * Indicate if the canvas has to be stretched to
                 * fill the whole screen area.
                 * @type {Boolean}
                 * @attribute isSizeFull
                 * @readOnly
                 */
                if (this.isSizeFull !== true) {
                    if (zebkit.web.$contains(this.$container) !== true) {
                        throw new Error("zCanvas is not a part of DOM tree");
                    }

                    this.isSizeFull = true;
                    this.setLocation(0, 0);

                    // adjust body to kill unnecessary gap for inline-block zCanvas element
                    // otherwise body size will be slightly horizontally bigger than visual
                    // viewport height what causes scroller appears
                    document.body.style["font-size"] = "0px";

                    var ws = zebkit.web.$viewPortSize();
                    this.setSize(ws.width, ws.height);
                }
            };
        },

        function setSize(w, h) {
            if (this.width !== w || h !== this.height) {
                this.$super(w, h);

                // let know to other zebkit canvases that
                // the size of an element on the page has
                // been updated and they have to correct
                // its anchor.
                pkg.$elBoundsUpdated();
            }
            return this;
        },

        function setVisible(b) {
            var prev = this.isVisible;
            this.$super(b);

            // Since zCanvas has no parent component calling the super
            // method above doesn't trigger repainting. So, do it here.
            if (b !== prev) {
                this.repaint();
            }
            return this;
        },

        function vrp() {
            this.$super();
            if (zebkit.web.$contains(this.element) && this.element.style.visibility === "visible") {
                this.repaint();
            }
        },

        function kidAdded(i,constr,c){
            if (this.$layers.hasOwnProperty(c.id)) {
                throw new Error("Layer '" + c.id + "' already exist");
            }

            this.$layers[c.id] = c;
            if (c.id === "root") this.root = c;
            this.$super(i, constr, c);
        },

        function kidRemoved(i, c){
            delete this.$layers[c.id];
            if (c.id === "root") this.root = null;
            this.$super(i, c);
        }
    ]);

    // canvases location has to be corrected if document layout is invalid
    pkg.$elBoundsUpdated = function() {
        for(var i = pkg.zCanvas.$canvases.length - 1; i >= 0; i--) {
            var c = pkg.zCanvas.$canvases[i];
            if (c.isFullSize === true) {
                //c.setLocation(window.pageXOffset, -window.pageYOffset);

                var ws = zebkit.web.$viewPortSize();

                // browser (mobile) can reduce size of browser window by
                // the area a virtual keyboard occupies. Usually the
                // content scrolls up to the size the VK occupies, so
                // to leave zebkit full screen content in the window
                // with the real size (not reduced) size take in account
                // scrolled metrics
                c.setSize(ws.width  + window.pageXOffset,
                          ws.height + window.pageYOffset);
            }
            c.recalcOffset();
        }
    };

    var $wrt = null, $winSizeUpdated = false, $wpw = -1, $wph = -1;
    window.addEventListener("resize", function(e) {
        var ws = zebkit.web.$viewPortSize();
        if ($wpw !== window.innerWidth || $wph !== window.innerHeight) {
            $wpw = window.innerWidth;
            $wph = window.innerHeight;

            if ($wrt !== null) {
                $winSizeUpdated = true;
            } else {
                $wrt = zebkit.util.tasksSet.run(
                    function() {
                        if ($winSizeUpdated === false) {
                            pkg.$elBoundsUpdated();
                            this.shutdown();
                            $wrt = null;
                        }
                        $winSizeUpdated = false;
                    }, 200, 150
                );
            }
        }
    }, false);

    window.onbeforeunload = function(e) {
        var msgs = [];
        for(var i = pkg.zCanvas.$canvases.length - 1; i >= 0; i--) {
            if (typeof pkg.zCanvas.$canvases[i].saveBeforeLeave !== 'undefined') {
                var m = pkg.zCanvas.$canvases[i].saveBeforeLeave();
                if (m != null) {
                    msgs.push(m);
                }
            }
        }

        if (msgs.length > 0) {
            var message = msgs.join("  ");
            if (typeof e === 'undefined') {
                e = window.event;
            }

            if (e) {
                e.returnValue = message;
            }

            return message;
        }
    };

    // TODO: this is depricated events that can have significant impact to
    // page performance. That means it has to be removed and replace with soemting
    // else
    //
    // bunch of handlers to track HTML page metrics update
    // it is necessary since to correct zebkit canvases anchor
    // and track when a canvas has been removed
    document.addEventListener("DOMNodeInserted", function(e) {
        pkg.$elBoundsUpdated();
    }, false);

    document.addEventListener("DOMNodeRemoved", function(e) {
        // remove canvas from list
        for(var i = pkg.zCanvas.$canvases.length - 1; i >= 0; i--) {
            var canvas = pkg.zCanvas.$canvases[i];
            if (zebkit.web.$contains(canvas.element) !== true) {
                pkg.zCanvas.$canvases.splice(i, 1);
                if (typeof canvas.saveBeforeLeave !== 'undefined') {
                    canvas.saveBeforeLeave();
                }
            }
        }

        pkg.$elBoundsUpdated();
    }, false);


    var ui = pkg.cd("..");

    /**
     * Simple video panel that can be used to play a video:
     *

            // create canvas, add video panel to the center and
            // play video
            var canvas = zebkit.ui.zCanvas(500,500).root.properties({
                layout: new zebkit.layout.BorderLayout(),
                center: new zebkit.ui.web.VideoPan("trailer.mpg")
            });

     *
     * @param {String} url an URL to a video
     * @class zebkit.ui.web.VideoPan
     * @extends {zebkit.ui.Panel}
     * @constructor
     */
    pkg.VideoPan = Class(ui.Panel,  [
        function(src) {
            var $this = this;

            /**
             * Original video DOM element that is created
             * to play video
             * @type {Video}
             * @readOnly
             * @attribute video
             */
            this.video  = document.createElement("video");
            this.source = document.createElement("source");
            this.source.setAttribute("src", src);
            this.video.appendChild(this.source);

            this.$super();

            // canplaythrough is video event
            this.video.addEventListener("canplaythrough", function() {
                $this._.playbackStateUpdated($this, "ready");
                $this.repaint();
                $this.$continuePlayback();
            }, false);

            this.video.addEventListener("ended", function() {
                $this._.playbackStateUpdated($this, "end");
                $this.$interruptCancelTask();
            }, false);

            this.video.addEventListener("pause", function() {
                $this._.playbackStateUpdated($this, "pause");
                $this.$interruptCancelTask();
            }, false);

            this.video.addEventListener("play", function() {
                $this.$continuePlayback();
                $this._.playbackStateUpdated($this, "play");
            }, false);

            // progress event indicates a loading progress
            // the event is useful to detect recovering from network
            // error
            this.video.addEventListener("progress", function() {
                // if playback has been postponed due to an error
                // let's say that problem seems fixed and delete
                // the cancel task
                if ($this.$cancelTask !== null) {
                    $this.$interruptCancelTask();

                    // detect if progress event has to try to start animation that has not been
                    // started yet or has been canceled for a some reason
                    if ($this.video.paused === false) {
                        $this.$continuePlayback();
                        $this._.playbackStateUpdated($this, "continue");
                    }
                }
            }, false);

            this.source.addEventListener("error", function(e) {
                $this.$interruptCancelTask();
                $this.$lastError = e.toString();
                $this._.playbackStateUpdated($this, "error");
                $this.repaint();
                $this.pause();
            }, false);

            this.video.addEventListener("stalled", function() {
                $this.$cancelPlayback();
            }, false);

            this.video.addEventListener("loadedmetadata", function (e) {
                $this.videoWidth   = this.videoWidth;
                $this.videoHeight  = this.videoHeight;
                $this.$aspectRatio = $this.videoHeight > 0 ? $this.videoWidth / $this.videoHeight : 0;
                $this.vrp();
            }, false);
        },

        function $clazz() {
            this.Listeners = zebkit.util.ListenersClass("playbackStateUpdated");

            this.SignLabel = Class(ui.Panel, [
                function $clazz() {
                    this.font = new ui.Font("bold", 18);
                },

                function setColor(c) {
                    this.kids[0].setColor(c);
                    return this;
                },

                function(title) {
                    this.$super(new zebkit.layout.FlowLayout("center", "center"));
                    this.add(new ui.Label(title).setFont(this.clazz.font));
                    this.setBorder(new ui.Border("gray", 1, 8));
                    this.setPadding(6);
                    this.setBackground("white");
                    this.setColor("black");
                }
            ]);
        },

        function $prototype(clazz) {
            this.videoWidth = this.videoHeight = 0;

            this.cancelationTimeout = 20000; // 20 seconds

            this.showSign = true;

            this.$animStallCounter = this.$aspectRatio = 0;
            this.$adjustProportions = true;
            this.$lastError = this.$videoBound = this.$cancelTask = null;
            this.$animCurrentTime = -1;

            this._ = new this.clazz.Listeners();

            this.views = {
                pause  : new clazz.SignLabel("Pause, press to continue").toView(),
                replay : new clazz.SignLabel("Press to re-play").toView(),
                play   : new clazz.SignLabel("Press to play").toView(),
                error  : new clazz.SignLabel("Failed, press to re-try").setColor("red").toView(),
                waiting: new clazz.SignLabel("Waiting ...").setColor("orange").toView()
            };

            this.paint = function(g) {
                if (this.video.paused === false &&
                    this.video.ended  === false &&
                    this.$cancelTask  === null    )
                {
                    if (this.video.currentTime !== this.$animCurrentTime) {
                        this.$animStallCounter = 0;
                        this.repaint();
                    } else {
                        if (this.$animStallCounter > 180) {
                            this.$cancelPlayback();
                        } else {
                            this.$animStallCounter++;
                            this.repaint();
                        }
                    }
                }

                this.$animCurrentTime = this.video.currentTime;

                if (this.$videoBound === null) {
                    this.calcVideoBound();
                }

                g.drawImage(this.video, this.$videoBound.x,
                                        this.$videoBound.y,
                                        this.$videoBound.width,
                                        this.$videoBound.height);

                // draw status sign
                if (this.showSign) {
                    var sign = null;

                    if (this.$lastError !== null) {
                        sign = this.views.error;
                    } else {
                        if (this.$cancelTask !== null) {
                            sign =  this.views.waiting;
                        } else if (this.video.ended) {
                            sign = this.views.replay;
                        } else if (this.video.paused) {
                            if (this.video.currentTime === 0) {
                                sign = this.views.play;
                            } else {
                                sign = this.views.pause;
                            }
                        }
                    }

                    if (sign !== null) {
                        this.paintViewAt(g, "center", "center",  sign);
                    }
                }
            };

            /**
             * Set autoplay for video
             * @param  {Boolean} b an autoplay flag
             * @method autoplay
             * @chainable
             */
            this.autoplay = function(b) {
                this.video.autoplay = b;
                return this;
            };

            /**
             * Pause video
             * @method pause
             * @chainable
             */
            this.pause = function() {
                if (this.video.paused === false) {
                    this.video.pause();
                    this.repaint();
                }
                return this;
            };

            /**
             * Mute sound
             * @param  {Boolean} b true to mute the video sound
             * @method mute
             * @chainable
             */
            this.mute = function(b) {
                this.video.muted = b;
                return this;
            };

            /**
             * Start or continue playing video
             * @method play
             * @chainable
             */
            this.play = function() {
                if (this.video.paused === true) {
                    if (this.$lastError !== null) {
                        this.$lastError = null;
                        this.video.load();
                    }

                    this.video.play();
                    this.repaint();
                }
                return this;
            };

            /**
             * Adjust video proportion to fill maximal space with correct ratio
             * @param  {Boolean} b true if the video proportion has to be adjusted
             * @method adjustProportions
             * @chainable
             */
            this.adjustProportions = function(b) {
                if (this.$adjustProportions !== b) {
                    this.$adjustProportions = b;
                    this.vrp();
                }
                return this;
            };

            this.calcPreferredSize = function(target) {
                return {
                    width  : this.videoWidth,
                    height : this.videoHeight
                };
            };

            this.pointerClicked = function(e) {
                if (this.isPaused()) {
                    this.play();
                } else {
                    this.pause();
                }
            };

            /**
             * Check if the video is paused
             * @method isPaused
             * @return {Boolean} true if the video has been paused
             */
            this.isPaused = function() {
                return this.video.paused;
            };

            /**
             * Check if the video is ended
             * @method isEnded
             * @return {Boolean} true if the video has been ended
             */
            this.isEnded = function() {
                return this.video.ended;
            };

            this.getDuration = function() {
                return this.video.duration;
            };

            this.compSized = function(e) {
                this.$calcVideoBound();
            };

            this.recalc = function() {
                this.$calcVideoBound();
            };

            this.$calcVideoBound = function() {
                this.$videoBound = {
                    x      : this.getLeft(),
                    y      : this.getTop(),
                    width  : this.width  - this.getLeft() - this.getBottom(),
                    height : this.height - this.getTop()  - this.getBottom()
                };

                if (this.$adjustProportions === true && this.$aspectRatio !== 0) {
                    var ar = this.$videoBound.width / this.$videoBound.height;

                    //    ar = 3:1       ar' = 10:3      ar' > ar
                    //   +-------+   +--------------+
                    //   | video |   |    canvas    |   =>  decrease canvas width proportionally ar/ar'
                    //   +-------+   +--------------+
                    //
                    //    ar = 3:1       ar' = 2:1       ar' < ar
                    //   +-----------+   +------+
                    //   |  video    |   |canvas|   =>  decrease canvas height proportionally ar'/ar
                    //   +-----------+   +------+
                    if (ar < this.$aspectRatio) {
                        this.$videoBound.height = Math.floor((this.$videoBound.height * ar) / this.$aspectRatio);
                    } else {
                        this.$videoBound.width = Math.floor((this.$videoBound.width * this.$aspectRatio)/ ar);
                    }

                    this.$videoBound.x = Math.floor((this.width  - this.$videoBound.width )/2);
                    this.$videoBound.y = Math.floor((this.height - this.$videoBound.height)/2);
                }
            };

            this.$continuePlayback = function() {
                this.$interruptCancelTask();
                if (this.video.paused === false && this.video.ended === false) {
                    this.$animCurrentTime  = this.video.currentTime;
                    this.$animStallCounter = 0;
                    this.repaint();
                }
            };

            this.$cancelPlayback = function() {
                if (this.video.paused === true || this.video.ended === true) {
                    this.$interruptCancelTask();
                } else {
                    if (this.$cancelTask === null) {
                        var $this = this;
                        this.$postponedTime = new Date().getTime();

                        this.$cancelTask = zebkit.environment.setInterval(function() {
                            var dt = new Date().getTime() - $this.$postponedTime;
                            if (dt > $this.cancelationTimeout) {
                                try {
                                    if ($this.video.paused === false) {
                                        $this.$lastError = "Playback failed";
                                        $this.pause();
                                        $this.repaint();
                                        $this._.playbackStateUpdated($this, "error");
                                    }
                                } finally {
                                    $this.$interruptCancelTask();
                                }
                            } else {
                                $this._.playbackStateUpdated($this, "wait");
                            }
                        }, 200);
                    }
                }
            };

            this.$interruptCancelTask = function() {
                if (this.$cancelTask !== null) {
                    zebkit.environment.clearInterval(this.$cancelTask);
                    this.$postponedTime = this.$cancelTask = null;
                }
            };
        }
    ]);


    zebkit.ui.$configWith(pkg);

    //!!!
    // IE9 has an error: first mouse press formally pass focus to
    // canvas, but actually it doesn't get key events. To fix it
    // it is necessary to pass focus explicitly to window
    if (zebkit.isIE) {
        window.focus();
    }
});
