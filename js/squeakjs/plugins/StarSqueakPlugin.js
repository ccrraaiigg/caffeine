/* Smalltalk from Squeak4.5 with VMMaker 4.13.6 translated as JS source on 3 November 2014 1:52:26 pm */
/* Automatically generated by
	JSPluginCodeGenerator VMMakerJS-bf.15 uuid: fd4e10f2-3773-4e80-8bb5-c4b471a014e5
   from
	StarSqueakPlugin VMMaker-bf.353 uuid: 8ae25e7e-8d2c-451e-8277-598b30e9c002
 */

module("users.bert.SqueakJS.plugins.StarSqueakPlugin").requires("users.bert.SqueakJS.vm").toRun(function() {
"use strict";

var VM_PROXY_MAJOR = 1;
var VM_PROXY_MINOR = 11;

/*** Functions ***/
function CLASSOF(obj) { return typeof obj === "number" ? interpreterProxy.classSmallInteger() : obj.sqClass }
function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : 0 }
function BYTESIZEOF(obj) { return obj.bytes ? obj.bytes.length : obj.words ? obj.words.length * 4 : 0 }
function DIV(a, b) { return Math.floor(a / b) | 0; }   // integer division
function MOD(a, b) { return a - DIV(a, b) * b | 0; }   // signed modulus
function SHL(a, b) { return b > 31 ? 0 : a << b; }     // fix JS shift
function SHR(a, b) { return b > 31 ? 0 : a >>> b; }    // fix JS shift
function SHIFT(a, b) { return b < 0 ? (b < -31 ? 0 : a >>> (0-b) ) : (b > 31 ? 0 : a << b); }

/*** Variables ***/
var interpreterProxy = null;
var moduleName = "StarSqueakPlugin 3 November 2014 (e)";



/*	Return an unsigned int pointer to the first indexable word of oop, which must be a words object. */

function checkedUnsignedIntPtrOf(oop) {
	interpreterProxy.success(interpreterProxy.isWords(oop));
	if (interpreterProxy.failed()) {
		return 0;
	}
	return oop.words;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

function getModuleName() {
	return moduleName;
}

function halt() {
	;
}


/*	Diffuse the integer values of the source patch variable Bitmap into the output Bitmap. Each cell of the output is the average of the NxN area around it in the source, where N = (2 * delta) + 1. */

function primitiveDiffuseFromToWidthHeightDelta() {
	var area;
	var delta;
	var dst;
	var dstOop;
	var endX;
	var endY;
	var height;
	var rowStart;
	var src;
	var srcOop;
	var startX;
	var startY;
	var sum;
	var width;
	var x;
	var x2;
	var y;
	var y2;

	srcOop = interpreterProxy.stackValue(4);
	dstOop = interpreterProxy.stackValue(3);
	width = interpreterProxy.stackIntegerValue(2);
	height = interpreterProxy.stackIntegerValue(1);
	delta = interpreterProxy.stackIntegerValue(0);
	src = checkedUnsignedIntPtrOf(srcOop);
	dst = checkedUnsignedIntPtrOf(dstOop);
	interpreterProxy.success(SIZEOF(srcOop) === SIZEOF(dstOop));
	interpreterProxy.success(SIZEOF(srcOop) === (width * height));
	if (interpreterProxy.failed()) {
		return null;
	}
	area = ((2 * delta) + 1) * ((2 * delta) + 1);
	for (y = 0; y <= (height - 1); y++) {
		startY = y - delta;
		if (startY < 0) {
			startY = 0;
		}
		endY = y + delta;
		if (endY >= height) {
			endY = height - 1;
		}
		for (x = 0; x <= (width - 1); x++) {
			startX = x - delta;
			if (startX < 0) {
				startX = 0;
			}
			endX = x + delta;
			if (endX >= width) {
				endX = width - 1;
			}
			sum = 0;
			for (y2 = startY; y2 <= endY; y2++) {
				rowStart = y2 * width;
				for (x2 = startX; x2 <= endX; x2++) {
					sum += src[rowStart + x2];
				}
			}
			dst[(y * width) + x] = (DIV(sum, area));
		}
	}
	interpreterProxy.pop(5);
}


/*	Evaporate the integer values of the source Bitmap at the given rate. The rate is an integer between 0 and 1024, where 1024 is a scale factor of 1.0 (i.e., no evaporation). */

function primitiveEvaporateRate() {
	var i;
	var patchVar;
	var patchVarOop;
	var rate;
	var sz;

	patchVarOop = interpreterProxy.stackValue(1);
	rate = interpreterProxy.stackIntegerValue(0);
	patchVar = checkedUnsignedIntPtrOf(patchVarOop);
	sz = SIZEOF(patchVarOop);
	if (interpreterProxy.failed()) {
		return null;
	}
	for (i = 0; i <= (sz - 1); i++) {
		patchVar[i] = ((patchVar[i] * rate) >>> 10);
	}
	interpreterProxy.pop(2);
}

function primitiveMapFromToWidthHeightPatchSizeRgbFlagsShift() {
	var dst;
	var dstIndex;
	var dstOop;
	var h;
	var level;
	var offset;
	var patchSize;
	var pixel;
	var rgbFlags;
	var rgbMult;
	var rowStart;
	var shiftAmount;
	var src;
	var srcIndex;
	var srcOop;
	var w;
	var x;
	var y;

	srcOop = interpreterProxy.stackValue(6);
	dstOop = interpreterProxy.stackValue(5);
	w = interpreterProxy.stackIntegerValue(4);
	h = interpreterProxy.stackIntegerValue(3);
	patchSize = interpreterProxy.stackIntegerValue(2);
	rgbFlags = interpreterProxy.stackIntegerValue(1);
	shiftAmount = interpreterProxy.stackIntegerValue(0);
	src = checkedUnsignedIntPtrOf(srcOop);
	dst = checkedUnsignedIntPtrOf(dstOop);
	interpreterProxy.success(SIZEOF(dstOop) === (w * h));
	interpreterProxy.success(SIZEOF(dstOop) === ((SIZEOF(srcOop) * patchSize) * patchSize));
	if (interpreterProxy.failed()) {
		return null;
	}
	rgbMult = 0;
	if ((rgbFlags & 4) > 0) {
		rgbMult += 65536;
	}
	if ((rgbFlags & 2) > 0) {
		rgbMult += 256;
	}
	if ((rgbFlags & 1) > 0) {
		++rgbMult;
	}
	srcIndex = -1;
	for (y = 0; y <= ((DIV(h, patchSize)) - 1); y++) {
		for (x = 0; x <= ((DIV(w, patchSize)) - 1); x++) {
			level = SHIFT(src[(++srcIndex)], shiftAmount);
			if (level > 255) {
				level = 255;
			}
			if (level <= 0) {

				/* non-transparent black */

				pixel = 1;
			} else {
				pixel = level * rgbMult;
			}
			offset = ((y * w) + x) * patchSize;
			for (rowStart = offset; rowStart <= (offset + ((patchSize - 1) * w)); rowStart += w) {
				for (dstIndex = rowStart; dstIndex <= ((rowStart + patchSize) - 1); dstIndex++) {
					dst[dstIndex] = pixel;
				}
			}
		}
	}
	interpreterProxy.pop(7);
}


/*	Note: This is coded so that is can be run from Squeak. */

function setInterpreter(anInterpreter) {
	var ok;

	interpreterProxy = anInterpreter;
	ok = interpreterProxy.majorVersion() == VM_PROXY_MAJOR;
	if (ok === false) {
		return false;
	}
	ok = interpreterProxy.minorVersion() >= VM_PROXY_MINOR;
	return ok;
}


Squeak.registerExternalModule("StarSqueakPlugin", {
	primitiveDiffuseFromToWidthHeightDelta: primitiveDiffuseFromToWidthHeightDelta,
	primitiveEvaporateRate: primitiveEvaporateRate,
	setInterpreter: setInterpreter,
	primitiveMapFromToWidthHeightPatchSizeRgbFlagsShift: primitiveMapFromToWidthHeightPatchSizeRgbFlagsShift,
	getModuleName: getModuleName,
});

}); // end of module
