<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: meyda-wa.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: meyda-wa.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import * as utilities from './utilities';
import * as featureExtractors from './featureExtractors';

/**
  * MeydaAnalyzer
  * @classdesc
  * Meyda's interface to the Web Audio API. MeydaAnalyzer abstracts an API on
  * top of the Web Audio API's ScriptProcessorNode, running the Meyda audio
  * feature extractors inside that context.
  *
  * MeydaAnalyzer's constructor should not be called directly - MeydaAnalyzer
  * objects should be generated using the {@link Meyda.createMeydaAnalyzer}
  * factory function in the main Meyda class.
  *
  * @example
  * const analyzer = Meyda.createMeydaAnalyzer({
  *   "audioContext": audioContext,
  *   "source": source,
  *   "bufferSize": 512,
  *   "featureExtractors": ["rms"],
  *   "inputs": 2,
  *   "callback": features => {
  *     levelRangeElement.value = features.rms;
  *   }
  * });
  * @hideconstructor
  */
export class MeydaAnalyzer {
  constructor(options, _this) {
    this._m = _this;
    if (!options.audioContext) {
      throw this._m.errors.noAC;
    }
    else if (options.bufferSize &amp;&amp;
      !utilities.isPowerOfTwo(options.bufferSize)) {
      throw this._m._errors.notPow2;
    }
    else if (!options.source) {
      throw this._m._errors.noSource;
    }

    this._m.audioContext = options.audioContext;

    // TODO: validate options
    this._m.bufferSize = options.bufferSize || this._m.bufferSize || 256;
    this._m.hopSize = options.hopSize || this._m.hopSize || this._m.bufferSize;
    this._m.sampleRate = options.sampleRate
      || this._m.audioContext.sampleRate || 44100;
    this._m.callback = options.callback;
    this._m.windowingFunction = options.windowingFunction || 'hanning';
    this._m.featureExtractors = featureExtractors;
    this._m.EXTRACTION_STARTED = options.startImmediately || false;

    //create nodes
    this._m.spn = this._m.audioContext.createScriptProcessor(
      this._m.bufferSize, 1, 1);
    this._m.spn.connect(this._m.audioContext.destination);

    this._m._featuresToExtract = options.featureExtractors || [];

    //always recalculate BS and MFB when a new Meyda analyzer is created.
    this._m.barkScale = utilities.createBarkScale(
      this._m.bufferSize,
      this._m.sampleRate,
      this._m.bufferSize);
    this._m.melFilterBank = utilities.createMelFilterBank(
      this._m.melBands,
      this._m.sampleRate,
      this._m.bufferSize);

    this._m.inputData = null;
    this._m.previousInputData = null;

    this._m.frame = null;
    this._m.previousFrame = null;

    this.setSource(options.source);

    this._m.spn.onaudioprocess = (e)=> {
      if (this._m.inputData !== null) {
        this._m.previousInputData = this._m.inputData;
      }

      this._m.inputData = e.inputBuffer.getChannelData(0);

      if (!this._m.previousInputData) {
        var buffer = this._m.inputData;
      } else  {
        var buffer = new Float32Array(this._m.previousInputData.length + this._m.inputData.length - this._m.hopSize);
        buffer.set(this._m.previousInputData.slice(this._m.hopSize));
        buffer.set(this._m.inputData, this._m.previousInputData.length - this._m.hopSize);
      };

      var frames = utilities.frame(buffer, this._m.bufferSize, this._m.hopSize);

      frames.forEach(f => {
        this._m.frame = f;

        var features = this._m.extract(
          this._m._featuresToExtract,
          this._m.frame,
          this._m.previousFrame);

        // call callback if applicable
        if (typeof this._m.callback === 'function' &amp;&amp; this._m.EXTRACTION_STARTED) {
          this._m.callback(features);
        }

        this._m.previousFrame = this._m.frame;
      });
    };
  }

  /**
   * Start feature extraction
   * The audio features will be passed to the callback function that was defined
   * in the MeydaOptions that were passed to the factory when constructing the
   * MeydaAnalyzer.
   * @param {(string|Array.&lt;string>)} [features]
   * Change the features that Meyda is extracting. Defaults to the features that
   * were set upon construction in the options parameter.
   * @example
   * analyzer.start('chroma');
   */
  start(features) {
    this._m._featuresToExtract = features || this._m._featuresToExtract;
    this._m.EXTRACTION_STARTED = true;
  }

  /**
   * Stop feature extraction.
   * @example
   * analyzer.stop();
   */
  stop() {
    this._m.EXTRACTION_STARTED = false;
  }

  /**
   * Set the Audio Node for Meyda to listen to.
   * @param {AudioNode} source - The Audio Node for Meyda to listen to
   * @example
   * analyzer.setSource(audioSourceNode);
   */
  setSource(source) {
    source.connect(this._m.spn);
  }

  /**
   * Get a set of features from the current frame.
   * @param {(string|Array.&lt;string>)} [features]
   * Change the features that Meyda is extracting
   * @example
   * analyzer.get('spectralFlatness');
   */
  get(features) {
    if (this._m.inputData) {
      return this._m.extract(
              (features || this._m._featuresToExtract),
              this._m.inputData,
              this._m.previousInputData);
    } else {
      return null;
    }
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-meyda.html">meyda</a></li></ul><h3>Classes</h3><ul><li><a href="MeydaAnalyzer.html">MeydaAnalyzer</a></li><li><a href="module-meyda-Meyda.html">Meyda</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Sat Sep 22 2018 11:09:40 GMT+0200 (CEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
