/*! osc.js 2.2.2, Copyright 2018 Colin Clark | github.com/colinbdclark/osc.js */


!function(e, t) {
    "object" == typeof exports ? (e.osc = exports, t(exports, require("slip"), require("EventEmitter"), require("long"))) : "function" == typeof define && define.amd ? define([ "exports", "slip", "EventEmitter", "long" ], function(r, n, i, a) {
        return e.osc = r, e.osc, t(r, n, i, a);
    }) : (e.osc = {}, t(e.osc, slip, EventEmitter));
}(this, function(e, t, r, n) {
    var i = i || {};
    !function() {
        "use strict";
        i.SECS_70YRS = 2208988800, i.TWO_32 = 4294967296, i.defaults = {
            metadata: !1,
            unpackSingleArgs: !0
        }, i.isCommonJS = !("undefined" == typeof module || !module.exports), i.isNode = i.isCommonJS && "undefined" == typeof window, 
        i.isElectron = !("undefined" == typeof process || !process.versions || !process.versions.electron), 
        i.isBufferEnv = i.isNode || i.isElectron, i.isArray = function(e) {
            return e && "[object Array]" === Object.prototype.toString.call(e);
        }, i.isTypedArrayView = function(e) {
            return e.buffer && e.buffer instanceof ArrayBuffer;
        }, i.isBuffer = function(e) {
            return i.isBufferEnv && e instanceof Buffer;
        }, i.Long = void 0 !== n ? n : i.isNode ? require("long") : void 0, i.dataView = function(e, t, r) {
            return e.buffer ? new DataView(e.buffer, t, r) : e instanceof ArrayBuffer ? new DataView(e, t, r) : new DataView(new Uint8Array(e), t, r);
        }, i.byteArray = function(e) {
            if (e instanceof Uint8Array) return e;
            var t = e.buffer ? e.buffer : e;
            if (!(t instanceof ArrayBuffer || void 0 !== t.length && "string" != typeof t)) throw new Error("Can't wrap a non-array-like object as Uint8Array. Object was: " + JSON.stringify(e, null, 2));
            return new Uint8Array(t);
        }, i.nativeBuffer = function(e) {
            return i.isBufferEnv ? i.isBuffer(e) ? e : new Buffer(e.buffer ? e : new Uint8Array(e)) : i.isTypedArrayView(e) ? e : new Uint8Array(e);
        }, i.copyByteArray = function(e, t, r) {
            if (i.isTypedArrayView(e) && i.isTypedArrayView(t)) t.set(e, r); else for (var n = void 0 === r ? 0 : r, a = Math.min(t.length - r, e.length), o = 0, s = n; o < a; o++, 
            s++) t[s] = e[o];
            return t;
        }, i.readString = function(e, t) {
            for (var r = [], n = t.idx; n < e.byteLength; n++) {
                var i = e.getUint8(n);
                if (0 === i) {
                    n++;
                    break;
                }
                r.push(i);
            }
            return n = n + 3 & -4, t.idx = n, String.fromCharCode.apply(null, r);
        }, i.writeString = function(e) {
            for (var t = e + "\0", r = t.length, n = new Uint8Array(r + 3 & -4), i = 0; i < t.length; i++) {
                var a = t.charCodeAt(i);
                n[i] = a;
            }
            return n;
        }, i.readPrimitive = function(e, t, r, n) {
            var i = e[t](n.idx, !1);
            return n.idx += r, i;
        }, i.writePrimitive = function(e, t, r, n, i) {
            var a;
            return i = void 0 === i ? 0 : i, t ? a = new Uint8Array(t.buffer) : (a = new Uint8Array(n), 
            t = new DataView(a.buffer)), t[r](i, e, !1), a;
        }, i.readInt32 = function(e, t) {
            return i.readPrimitive(e, "getInt32", 4, t);
        }, i.writeInt32 = function(e, t, r) {
            return i.writePrimitive(e, t, "setInt32", 4, r);
        }, i.readInt64 = function(e, t) {
            var r = i.readPrimitive(e, "getInt32", 4, t), n = i.readPrimitive(e, "getInt32", 4, t);
            return i.Long ? new i.Long(n, r) : {
                high: r,
                low: n,
                unsigned: !1
            };
        }, i.writeInt64 = function(e, t, r) {
            var n = new Uint8Array(8);
            return n.set(i.writePrimitive(e.high, t, "setInt32", 4, r), 0), n.set(i.writePrimitive(e.low, t, "setInt32", 4, r + 4), 4), 
            n;
        }, i.readFloat32 = function(e, t) {
            return i.readPrimitive(e, "getFloat32", 4, t);
        }, i.writeFloat32 = function(e, t, r) {
            return i.writePrimitive(e, t, "setFloat32", 4, r);
        }, i.readFloat64 = function(e, t) {
            return i.readPrimitive(e, "getFloat64", 8, t);
        }, i.writeFloat64 = function(e, t, r) {
            return i.writePrimitive(e, t, "setFloat64", 8, r);
        }, i.readChar32 = function(e, t) {
            var r = i.readPrimitive(e, "getUint32", 4, t);
            return String.fromCharCode(r);
        }, i.writeChar32 = function(e, t, r) {
            var n = e.charCodeAt(0);
            if (!(void 0 === n || n < -1)) return i.writePrimitive(n, t, "setUint32", 4, r);
        }, i.readBlob = function(e, t) {
            var r = i.readInt32(e, t), n = r + 3 & -4, a = new Uint8Array(e.buffer, t.idx, r);
            return t.idx += n, a;
        }, i.writeBlob = function(e) {
            var t = (e = i.byteArray(e)).byteLength, r = new Uint8Array((t + 3 & -4) + 4), n = new DataView(r.buffer);
            return i.writeInt32(t, n), r.set(e, 4), r;
        }, i.readMIDIBytes = function(e, t) {
            var r = new Uint8Array(e.buffer, t.idx, 4);
            return t.idx += 4, r;
        }, i.writeMIDIBytes = function(e) {
            e = i.byteArray(e);
            var t = new Uint8Array(4);
            return t.set(e), t;
        }, i.readColor = function(e, t) {
            var r = new Uint8Array(e.buffer, t.idx, 4), n = r[3] / 255;
            return t.idx += 4, {
                r: r[0],
                g: r[1],
                b: r[2],
                a: n
            };
        }, i.writeColor = function(e) {
            var t = Math.round(255 * e.a);
            return new Uint8Array([ e.r, e.g, e.b, t ]);
        }, i.readTrue = function() {
            return !0;
        }, i.readFalse = function() {
            return !1;
        }, i.readNull = function() {
            return null;
        }, i.readImpulse = function() {
            return 1;
        }, i.readTimeTag = function(e, t) {
            var r = i.readPrimitive(e, "getUint32", 4, t), n = i.readPrimitive(e, "getUint32", 4, t);
            return {
                raw: [ r, n ],
                native: 0 === r && 1 === n ? Date.now() : i.ntpToJSTime(r, n)
            };
        }, i.writeTimeTag = function(e) {
            var t = e.raw ? e.raw : i.jsToNTPTime(e.native), r = new Uint8Array(8), n = new DataView(r.buffer);
            return i.writeInt32(t[0], n, 0), i.writeInt32(t[1], n, 4), r;
        }, i.timeTag = function(e, t) {
            e = e || 0;
            var r = (t = t || Date.now()) / 1e3, n = Math.floor(r), a = r - n, o = Math.floor(e), s = a + (e - o);
            if (s > 1) {
                var u = Math.floor(s);
                o += u, s = s - u;
            }
            return {
                raw: [ n + o + i.SECS_70YRS, Math.round(i.TWO_32 * s) ]
            };
        }, i.ntpToJSTime = function(e, t) {
            return 1e3 * (e - i.SECS_70YRS + t / i.TWO_32);
        }, i.jsToNTPTime = function(e) {
            var t = e / 1e3, r = Math.floor(t), n = t - r;
            return [ r + i.SECS_70YRS, Math.round(i.TWO_32 * n) ];
        }, i.readArguments = function(e, t, r) {
            var n = i.readString(e, r);
            if (0 !== n.indexOf(",")) throw new Error("A malformed type tag string was found while reading the arguments of an OSC message. String was: " + n, " at offset: " + r.idx);
            var a = n.substring(1).split(""), o = [];
            return i.readArgumentsIntoArray(o, a, n, e, t, r), o;
        }, i.readArgument = function(e, t, r, n, a) {
            var o = i.argumentTypes[e];
            if (!o) throw new Error("'" + e + "' is not a valid OSC type tag. Type tag string was: " + t);
            var s = o.reader, u = i[s](r, a);
            return n.metadata && (u = {
                type: e,
                value: u
            }), u;
        }, i.readArgumentsIntoArray = function(e, t, r, n, a, o) {
            for (var s = 0; s < t.length; ) {
                var u, c = t[s];
                if ("[" === c) {
                    var d = t.slice(s + 1), f = d.indexOf("]");
                    if (f < 0) throw new Error("Invalid argument type tag: an open array type tag ('[') was found without a matching close array tag ('[]'). Type tag was: " + r);
                    var l = d.slice(0, f);
                    u = i.readArgumentsIntoArray([], l, r, n, a, o), s += f + 2;
                } else u = i.readArgument(c, r, n, a, o), s++;
                e.push(u);
            }
            return e;
        }, i.writeArguments = function(e, t) {
            var r = i.collectArguments(e, t);
            return i.joinParts(r);
        }, i.joinParts = function(e) {
            for (var t = new Uint8Array(e.byteLength), r = e.parts, n = 0, a = 0; a < r.length; a++) {
                var o = r[a];
                i.copyByteArray(o, t, n), n += o.length;
            }
            return t;
        }, i.addDataPart = function(e, t) {
            t.parts.push(e), t.byteLength += e.length;
        }, i.writeArrayArguments = function(e, t) {
            for (var r = "[", n = 0; n < e.length; n++) {
                var a = e[n];
                r += i.writeArgument(a, t);
            }
            return r += "]";
        }, i.writeArgument = function(e, t) {
            if (i.isArray(e)) return i.writeArrayArguments(e, t);
            var r = e.type, n = i.argumentTypes[r].writer;
            if (n) {
                var a = i[n](e.value);
                i.addDataPart(a, t);
            }
            return e.type;
        }, i.collectArguments = function(e, t, r) {
            i.isArray(e) || (e = void 0 === e ? [] : [ e ]), r = r || {
                byteLength: 0,
                parts: []
            }, t.metadata || (e = i.annotateArguments(e));
            for (var n = ",", a = r.parts.length, o = 0; o < e.length; o++) {
                var s = e[o];
                n += i.writeArgument(s, r);
            }
            var u = i.writeString(n);
            return r.byteLength += u.byteLength, r.parts.splice(a, 0, u), r;
        }, i.readMessage = function(e, t, r) {
            t = t || i.defaults;
            var n = i.dataView(e, e.byteOffset, e.byteLength);
            r = r || {
                idx: 0
            };
            var a = i.readString(n, r);
            return i.readMessageContents(a, n, t, r);
        }, i.readMessageContents = function(e, t, r, n) {
            if (0 !== e.indexOf("/")) throw new Error("A malformed OSC address was found while reading an OSC message. String was: " + e);
            var a = i.readArguments(t, r, n);
            return {
                address: e,
                args: 1 === a.length && r.unpackSingleArgs ? a[0] : a
            };
        }, i.collectMessageParts = function(e, t, r) {
            return r = r || {
                byteLength: 0,
                parts: []
            }, i.addDataPart(i.writeString(e.address), r), i.collectArguments(e.args, t, r);
        }, i.writeMessage = function(e, t) {
            if (t = t || i.defaults, !i.isValidMessage(e)) throw new Error("An OSC message must contain a valid address. Message was: " + JSON.stringify(e, null, 2));
            var r = i.collectMessageParts(e, t);
            return i.joinParts(r);
        }, i.isValidMessage = function(e) {
            return e.address && 0 === e.address.indexOf("/");
        }, i.readBundle = function(e, t, r) {
            return i.readPacket(e, t, r);
        }, i.collectBundlePackets = function(e, t, r) {
            r = r || {
                byteLength: 0,
                parts: []
            }, i.addDataPart(i.writeString("#bundle"), r), i.addDataPart(i.writeTimeTag(e.timeTag), r);
            for (var n = 0; n < e.packets.length; n++) {
                var a = e.packets[n], o = (a.address ? i.collectMessageParts : i.collectBundlePackets)(a, t);
                r.byteLength += o.byteLength, i.addDataPart(i.writeInt32(o.byteLength), r), r.parts = r.parts.concat(o.parts);
            }
            return r;
        }, i.writeBundle = function(e, t) {
            if (!i.isValidBundle(e)) throw new Error("An OSC bundle must contain 'timeTag' and 'packets' properties. Bundle was: " + JSON.stringify(e, null, 2));
            t = t || i.defaults;
            var r = i.collectBundlePackets(e, t);
            return i.joinParts(r);
        }, i.isValidBundle = function(e) {
            return void 0 !== e.timeTag && void 0 !== e.packets;
        }, i.readBundleContents = function(e, t, r, n) {
            for (var a = i.readTimeTag(e, r), o = []; r.idx < n; ) {
                var s = i.readInt32(e, r), u = r.idx + s, c = i.readPacket(e, t, r, u);
                o.push(c);
            }
            return {
                timeTag: a,
                packets: o
            };
        }, i.readPacket = function(e, t, r, n) {
            var a = i.dataView(e, e.byteOffset, e.byteLength);
            n = void 0 === n ? a.byteLength : n, r = r || {
                idx: 0
            };
            var o = i.readString(a, r), s = o[0];
            if ("#" === s) return i.readBundleContents(a, t, r, n);
            if ("/" === s) return i.readMessageContents(o, a, t, r);
            throw new Error("The header of an OSC packet didn't contain an OSC address or a #bundle string. Header was: " + o);
        }, i.writePacket = function(e, t) {
            if (i.isValidMessage(e)) return i.writeMessage(e, t);
            if (i.isValidBundle(e)) return i.writeBundle(e, t);
            throw new Error("The specified packet was not recognized as a valid OSC message or bundle. Packet was: " + JSON.stringify(e, null, 2));
        }, i.argumentTypes = {
            i: {
                reader: "readInt32",
                writer: "writeInt32"
            },
            h: {
                reader: "readInt64",
                writer: "writeInt64"
            },
            f: {
                reader: "readFloat32",
                writer: "writeFloat32"
            },
            s: {
                reader: "readString",
                writer: "writeString"
            },
            S: {
                reader: "readString",
                writer: "writeString"
            },
            b: {
                reader: "readBlob",
                writer: "writeBlob"
            },
            t: {
                reader: "readTimeTag",
                writer: "writeTimeTag"
            },
            T: {
                reader: "readTrue"
            },
            F: {
                reader: "readFalse"
            },
            N: {
                reader: "readNull"
            },
            I: {
                reader: "readImpulse"
            },
            d: {
                reader: "readFloat64",
                writer: "writeFloat64"
            },
            c: {
                reader: "readChar32",
                writer: "writeChar32"
            },
            r: {
                reader: "readColor",
                writer: "writeColor"
            },
            m: {
                reader: "readMIDIBytes",
                writer: "writeMIDIBytes"
            }
        }, i.inferTypeForArgument = function(e) {
            switch (typeof e) {
              case "boolean":
                return e ? "T" : "F";

              case "string":
                return "s";

              case "number":
                return "f";

              case "undefined":
                return "N";

              case "object":
                if (null === e) return "N";
                if (e instanceof Uint8Array || e instanceof ArrayBuffer) return "b";
                if ("number" == typeof e.high && "number" == typeof e.low) return "h";
            }
            throw new Error("Can't infer OSC argument type for value: " + JSON.stringify(e, null, 2));
        }, i.annotateArguments = function(e) {
            for (var t = [], r = 0; r < e.length; r++) {
                var n, a = e[r];
                if ("object" == typeof a && a.type && void 0 !== a.value) n = a; else if (i.isArray(a)) n = i.annotateArguments(a); else {
                    n = {
                        type: i.inferTypeForArgument(a),
                        value: a
                    };
                }
                t.push(n);
            }
            return t;
        }, i.isCommonJS && (module.exports = i);
    }();
    i = i || require("./osc.js"), t = t || require("slip"), r = r || require("events").EventEmitter;
    !function() {
        "use strict";
        i.firePacketEvents = function(e, t, r, n) {
            t.address ? e.emit("message", t, r, n) : i.fireBundleEvents(e, t, r, n);
        }, i.fireBundleEvents = function(e, t, r, n) {
            e.emit("bundle", t, r, n);
            for (var a = 0; a < t.packets.length; a++) {
                var o = t.packets[a];
                i.firePacketEvents(e, o, t.timeTag, n);
            }
        }, i.fireClosedPortSendError = function(e, t) {
            t = t || "Can't send packets on a closed osc.Port object. Please open (or reopen) this Port by calling open().", 
            e.emit("error", t);
        }, i.Port = function(e) {
            this.options = e || {}, this.on("data", this.decodeOSC.bind(this));
        };
        var e = i.Port.prototype = Object.create(r.prototype);
        e.constructor = i.Port, e.send = function(e) {
            var t = Array.prototype.slice.call(arguments), r = this.encodeOSC(e), n = i.nativeBuffer(r);
            t[0] = n, this.sendRaw.apply(this, t);
        }, e.encodeOSC = function(e) {
            var t;
            e = e.buffer ? e.buffer : e;
            try {
                t = i.writePacket(e, this.options);
            } catch (e) {
                this.emit("error", e);
            }
            return t;
        }, e.decodeOSC = function(e, t) {
            e = i.byteArray(e), this.emit("raw", e, t);
            try {
                var r = i.readPacket(e, this.options);
                this.emit("osc", r, t), i.firePacketEvents(this, r, void 0, t);
            } catch (e) {
                this.emit("error", e);
            }
        }, i.SLIPPort = function(e) {
            var r = this, n = this.options = e || {};
            n.useSLIP = void 0 === n.useSLIP || n.useSLIP, this.decoder = new t.Decoder({
                onMessage: this.decodeOSC.bind(this),
                onError: function(e) {
                    r.emit("error", e);
                }
            });
            var i = n.useSLIP ? this.decodeSLIPData : this.decodeOSC;
            this.on("data", i.bind(this));
        }, (e = i.SLIPPort.prototype = Object.create(i.Port.prototype)).constructor = i.SLIPPort, 
        e.encodeOSC = function(e) {
            var r;
            e = e.buffer ? e.buffer : e;
            try {
                var n = i.writePacket(e, this.options);
                r = t.encode(n);
            } catch (e) {
                this.emit("error", e);
            }
            return r;
        }, e.decodeSLIPData = function(e, t) {
            this.decoder.decode(e, t);
        }, i.relay = function(e, t, r, n, i, a) {
            r = r || "message", n = n || "send", i = i || function() {}, a = a ? [ null ].concat(a) : [];
            var o = function(e) {
                a[0] = e, e = i(e), t[n].apply(t, a);
            };
            return e.on(r, o), {
                eventName: r,
                listener: o
            };
        }, i.relayPorts = function(e, t, r) {
            var n = r.raw ? "raw" : "osc", a = r.raw ? "sendRaw" : "send";
            return i.relay(e, t, n, a, r.transform);
        }, i.stopRelaying = function(e, t) {
            e.removeListener(t.eventName, t.listener);
        }, i.Relay = function(e, t, r) {
            (this.options = r || {}).raw = !1, this.port1 = e, this.port2 = t, this.listen();
        }, (e = i.Relay.prototype = Object.create(r.prototype)).constructor = i.Relay, e.open = function() {
            this.port1.open(), this.port2.open();
        }, e.listen = function() {
            this.port1Spec && this.port2Spec && this.close(), this.port1Spec = i.relayPorts(this.port1, this.port2, this.options), 
            this.port2Spec = i.relayPorts(this.port2, this.port1, this.options);
            var e = this.close.bind(this);
            this.port1.on("close", e), this.port2.on("close", e);
        }, e.close = function() {
            i.stopRelaying(this.port1, this.port1Spec), i.stopRelaying(this.port2, this.port2Spec), 
            this.emit("close", this.port1, this.port2);
        }, "undefined" != typeof module && module.exports && (module.exports = i);
    }();
    i = i || require("../osc.js");
    return function() {
        "use strict";
        i.WebSocket = "undefined" != typeof WebSocket ? WebSocket : require("ws"), i.WebSocketPort = function(e) {
            i.Port.call(this, e), this.on("open", this.listen.bind(this)), this.socket = e.socket, 
            this.socket && (1 === this.socket.readyState ? (i.WebSocketPort.setupSocketForBinary(this.socket), 
            this.emit("open", this.socket)) : this.open());
        };
        var e = i.WebSocketPort.prototype = Object.create(i.Port.prototype);
        e.constructor = i.WebSocketPort, e.open = function() {
            (!this.socket || this.socket.readyState > 1) && (this.socket = new i.WebSocket(this.options.url)), 
            i.WebSocketPort.setupSocketForBinary(this.socket);
            var e = this;
            this.socket.onopen = function() {
                e.emit("open", e.socket);
            };
        }, e.listen = function() {
            var e = this;
            this.socket.onmessage = function(t) {
                e.emit("data", t.data, t);
            }, this.socket.onerror = function(t) {
                e.emit("error", t);
            }, this.socket.onclose = function(t) {
                e.emit("close", t);
            }, e.emit("ready");
        }, e.sendRaw = function(e) {
            this.socket && 1 === this.socket.readyState ? this.socket.send(e) : i.fireClosedPortSendError(this);
        }, e.close = function(e, t) {
            this.socket.close(e, t);
        }, i.WebSocketPort.setupSocketForBinary = function(e) {
            e.binaryType = i.isNode ? "nodebuffer" : "arraybuffer";
        };
    }(), i;
});