/* Smalltalk from Squeak4.5 with VMMaker 4.13.6 translated as JS source on 3 November 2014 1:52:23 pm */
/* Automatically generated by
	JSPluginCodeGenerator VMMakerJS-bf.15 uuid: fd4e10f2-3773-4e80-8bb5-c4b471a014e5
   from
	MiscPrimitivePlugin VMMaker-bf.353 uuid: 8ae25e7e-8d2c-451e-8277-598b30e9c002
 */

module("users.bert.SqueakJS.plugins.MiscPrimitivePlugin").requires("users.bert.SqueakJS.vm").toRun(function() {
"use strict";

var VM_PROXY_MAJOR = 1;
var VM_PROXY_MINOR = 11;

/*** Functions ***/
function CLASSOF(obj) { return typeof obj === "number" ? interpreterProxy.classSmallInteger() : obj.sqClass }
function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : 0 }
function BYTESIZEOF(obj) { return obj.bytes ? obj.bytes.length : obj.words ? obj.words.length * 4 : 0 }
function DIV(a, b) { return Math.floor(a / b) | 0; }   // integer division
function MOD(a, b) { return a - DIV(a, b) * b | 0; }   // signed modulus
function SHL(a, b) { return b > 31 ? 0 : a << b; }     // fix JS shift
function SHR(a, b) { return b > 31 ? 0 : a >>> b; }    // fix JS shift
function SHIFT(a, b) { return b < 0 ? (b < -31 ? 0 : a >>> (0-b) ) : (b > 31 ? 0 : a << b); }

/*** Variables ***/
var interpreterProxy = null;
var moduleName = "MiscPrimitivePlugin 3 November 2014 (e)";



/*	Copy the integer anInt into byteArray ba at index i, and return the next index */

function encodeBytesOfinat(anInt, ba, i) {
	var j;

	for (j = 0; j <= 3; j++) {
		ba[(i + j) - 1] = ((SHR(anInt, ((3 - j) * 8))) & 255);
	}
	return i + 4;
}


/*	Encode the integer anInt in byteArray ba at index i, and return the next index.
	The encoding is as follows...
		0-223	0-223
		224-254	(0-30)*256 + next byte (0-7935)
		255		next 4 bytes */

function encodeIntinat(anInt, ba, i) {
	if (anInt <= 223) {
		ba[i - 1] = anInt;
		return i + 1;
	}
	if (anInt <= 7935) {
		ba[i - 1] = ((anInt >> 8) + 224);
		ba[i] = (MOD(anInt, 256));
		return i + 2;
	}
	ba[i - 1] = 255;
	return encodeBytesOfinat(anInt, ba, i + 1);
}


/*	Note: This is coded so that plugins can be run from Squeak. */

function getInterpreter() {
	return interpreterProxy;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

function getModuleName() {
	return moduleName;
}

function halt() {
	;
}

function msg(s) {
	console.log(moduleName + ": " + s);
}


/*	Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array. */

function primitiveCompareString() {
	var rcvr;
	var string1;
	var string2;
	var order;
	var c1;
	var c2;
	var i;
	var len1;
	var len2;

	rcvr = interpreterProxy.stackValue(3);
	string1 = interpreterProxy.stackBytes(2);
	string2 = interpreterProxy.stackBytes(1);
	order = interpreterProxy.stackBytes(0);
	if (interpreterProxy.failed()) {
		return null;
	}
	len1 = string1.length;
	len2 = string2.length;
	for (i = 1; i <= Math.min(len1, len2); i++) {
		c1 = order[string1[i - 1]];
		c2 = order[string2[i - 1]];
		if (c1 !== c2) {
			if (c1 < c2) {
				if (interpreterProxy.failed()) {
					return null;
				}
				interpreterProxy.popthenPush(4, 1);
				return null;
			} else {
				if (interpreterProxy.failed()) {
					return null;
				}
				interpreterProxy.popthenPush(4, 3);
				return null;
			}
		}
	}
	if (len1 === len2) {
		if (interpreterProxy.failed()) {
			return null;
		}
		interpreterProxy.popthenPush(4, 2);
		return null;
	}
	if (len1 < len2) {
		if (interpreterProxy.failed()) {
			return null;
		}
		interpreterProxy.popthenPush(4, 1);
		return null;
	} else {
		if (interpreterProxy.failed()) {
			return null;
		}
		interpreterProxy.popthenPush(4, 3);
		return null;
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(3);
}


/*	Store a run-coded compression of the receiver into the byteArray ba,
	and return the last index stored into. ba is assumed to be large enough.
	The encoding is as follows...
		S {N D}*.
		S is the size of the original bitmap, followed by run-coded pairs.
		N is a run-length * 4 + data code.
		D, the data, depends on the data code...
			0	skip N words, D is absent
			1	N words with all 4 bytes = D (1 byte)
			2	N words all = D (4 bytes)
			3	N words follow in D (4N bytes)
		S and N are encoded as follows...
			0-223	0-223
			224-254	(0-30)*256 + next byte (0-7935)
			255		next 4 bytes */

function primitiveCompressToByteArray() {
	var rcvr;
	var bm;
	var ba;
	var eqBytes;
	var i;
	var j;
	var k;
	var lowByte;
	var m;
	var size;
	var word;

	rcvr = interpreterProxy.stackValue(2);
	bm = interpreterProxy.stackInt32Array(1);
	ba = interpreterProxy.stackBytes(0);
	if (interpreterProxy.failed()) {
		return null;
	}
	size = bm.length;
	i = encodeIntinat(size, ba, 1);
	k = 1;
	while (k <= size) {
		word = bm[k - 1];
		lowByte = word & 255;
		eqBytes = (((word >>> 8) & 255) === lowByte) && ((((word >>> 16) & 255) === lowByte) && (((word >>> 24) & 255) === lowByte));
		j = k;
		while ((j < size) && (word === bm[j])) {
			++j;
		}
		if (j > k) {

			/* We have two or more = words, ending at j */

			if (eqBytes) {

				/* Actually words of = bytes */

				i = encodeIntinat((((j - k) + 1) * 4) + 1, ba, i);
				ba[i - 1] = lowByte;
				++i;
			} else {
				i = encodeIntinat((((j - k) + 1) * 4) + 2, ba, i);
				i = encodeBytesOfinat(word, ba, i);
			}
			k = j + 1;
		} else {

			/* Check for word of 4 = bytes */

			if (eqBytes) {

				/* Note 1 word of 4 = bytes */

				i = encodeIntinat((1 * 4) + 1, ba, i);
				ba[i - 1] = lowByte;
				++i;
				++k;
			} else {

				/* Finally, check for junk */

				while ((j < size) && (bm[j - 1] !== bm[j])) {
					++j;
				}
				if (j === size) {
					++j;
				}
				i = encodeIntinat(((j - k) * 4) + 3, ba, i);
				for (m = k; m <= (j - 1); m++) {
					i = encodeBytesOfinat(bm[m - 1], ba, i);
				}
				k = j;
			}
		}
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.popthenPush(3, i - 1);
	return null;
}


/*	Copy the contents of the given array of signed 8-bit samples into the given array of 16-bit signed samples. */

function primitiveConvert8BitSigned() {
	var rcvr;
	var aByteArray;
	var aSoundBuffer;
	var i;
	var n;
	var s;

	rcvr = interpreterProxy.stackValue(2);
	aByteArray = interpreterProxy.stackBytes(1);
	aSoundBuffer = interpreterProxy.stackUint16Array(0);
	if (interpreterProxy.failed()) {
		return null;
	}
	n = aByteArray.length;
	for (i = 1; i <= n; i++) {
		s = aByteArray[i - 1];
		if (s > 127) {
			aSoundBuffer[i - 1] = ((s - 256) << 8);
		} else {
			aSoundBuffer[i - 1] = (s << 8);
		}
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(2);
}


/*	Decompress the body of a byteArray encoded by compressToByteArray (qv)...
	The format is simply a sequence of run-coded pairs, {N D}*.
		N is a run-length * 4 + data code.
		D, the data, depends on the data code...
			0	skip N words, D is absent
				(could be used to skip from one raster line to the next)
			1	N words with all 4 bytes = D (1 byte)
			2	N words all = D (4 bytes)
			3	N words follow in D (4N bytes)
		S and N are encoded as follows (see decodeIntFrom:)...
			0-223	0-223
			224-254	(0-30)*256 + next byte (0-7935)
			255		next 4 bytes */
/*	NOTE:  If fed with garbage, this routine could read past the end of ba, but it should fail before writing past the ned of bm. */

function primitiveDecompressFromByteArray() {
	var rcvr;
	var bm;
	var ba;
	var index;
	var anInt;
	var code;
	var data;
	var end;
	var i;
	var j;
	var k;
	var m;
	var n;
	var pastEnd;

	rcvr = interpreterProxy.stackValue(3);
	bm = interpreterProxy.stackInt32Array(2);
	ba = interpreterProxy.stackBytes(1);
	index = interpreterProxy.stackIntegerValue(0);
	if (interpreterProxy.failed()) {
		return null;
	}

	/* byteArray read index */

	i = index;
	end = ba.length;

	/* bitmap write index */

	k = 1;
	pastEnd = bm.length + 1;
	while (i <= end) {

		/* Decode next run start N */

		anInt = ba[i - 1];
		++i;
		if (!(anInt <= 223)) {
			if (anInt <= 254) {
				anInt = ((anInt - 224) * 256) + ba[i - 1];
				++i;
			} else {
				anInt = 0;
				for (j = 1; j <= 4; j++) {
					anInt = (anInt << 8) + ba[i - 1];
					++i;
				}
			}
		}
		n = anInt >>> 2;
		if ((k + n) > pastEnd) {
			interpreterProxy.primitiveFail();
			return null;
		}
		code = anInt & 3;
		if (code === 0) {

			/* skip */

			null;
		}
		if (code === 1) {

			/* n consecutive words of 4 bytes = the following byte */

			data = ba[i - 1];
			++i;
			data = data | (data << 8);
			data = data | (data << 16);
			for (j = 1; j <= n; j++) {
				bm[k - 1] = data;
				++k;
			}
		}
		if (code === 2) {

			/* n consecutive words = 4 following bytes */

			data = 0;
			for (j = 1; j <= 4; j++) {
				data = (data << 8) | ba[i - 1];
				++i;
			}
			for (j = 1; j <= n; j++) {
				bm[k - 1] = data;
				++k;
			}
		}
		if (code === 3) {

			/* n consecutive words from the data... */

			for (m = 1; m <= n; m++) {
				data = 0;
				for (j = 1; j <= 4; j++) {
					data = (data << 8) | ba[i - 1];
					++i;
				}
				bm[k - 1] = data;
				++k;
			}
		}
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(3);
}

function primitiveFindFirstInString() {
	var rcvr;
	var aString;
	var inclusionMap;
	var start;
	var i;
	var stringSize;

	rcvr = interpreterProxy.stackValue(3);
	aString = interpreterProxy.stackBytes(2);
	inclusionMap = interpreterProxy.stackBytes(1);
	start = interpreterProxy.stackIntegerValue(0);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (inclusionMap.length !== 256) {
		if (interpreterProxy.failed()) {
			return null;
		}
		interpreterProxy.popthenPush(4, 0);
		return null;
	}
	i = start;
	stringSize = aString.length;
	while ((i <= stringSize) && (inclusionMap[aString[i - 1]] === 0)) {
		++i;
	}
	if (i > stringSize) {
		if (interpreterProxy.failed()) {
			return null;
		}
		interpreterProxy.popthenPush(4, 0);
		return null;
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.popthenPush(4, i);
	return null;
}


/*	Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned.

	The algorithm below is not optimum -- it is intended to be translated to C which will go so fast that it wont matter. */

function primitiveFindSubstring() {
	var rcvr;
	var key;
	var body;
	var start;
	var matchTable;
	var index;
	var startIndex;

	rcvr = interpreterProxy.stackValue(4);
	key = interpreterProxy.stackBytes(3);
	body = interpreterProxy.stackBytes(2);
	start = interpreterProxy.stackIntegerValue(1);
	matchTable = interpreterProxy.stackBytes(0);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (key.length === 0) {
		if (interpreterProxy.failed()) {
			return null;
		}
		interpreterProxy.popthenPush(5, 0);
		return null;
	}
	for (startIndex = start; startIndex <= ((body.length - key.length) + 1); startIndex++) {
		index = 1;
		while (matchTable[body[((startIndex + index) - 1) - 1]] === matchTable[key[index - 1]]) {
			if (index === key.length) {
				if (interpreterProxy.failed()) {
					return null;
				}
				interpreterProxy.popthenPush(5, startIndex);
				return null;
			}
			++index;
		}
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.popthenPush(5, 0);
	return null;
}

function primitiveIndexOfAsciiInString() {
	var rcvr;
	var anInteger;
	var aString;
	var start;
	var pos;
	var stringSize;

	rcvr = interpreterProxy.stackValue(3);
	anInteger = interpreterProxy.stackIntegerValue(2);
	aString = interpreterProxy.stackBytes(1);
	start = interpreterProxy.stackIntegerValue(0);
	if (interpreterProxy.failed()) {
		return null;
	}
	stringSize = aString.length;
	for (pos = start; pos <= stringSize; pos++) {
		if (aString[pos - 1] === anInteger) {
			if (interpreterProxy.failed()) {
				return null;
			}
			interpreterProxy.popthenPush(4, pos);
			return null;
		}
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.popthenPush(4, 0);
	return null;
}


/*	Answer the hash of a byte-indexed collection,
	using speciesHash as the initial value.
	See SmallInteger>>hashMultiply.

	The primitive should be renamed at a
	suitable point in the future */

function primitiveStringHash() {
	var rcvr;
	var aByteArray;
	var speciesHash;
	var byteArraySize;
	var hash;
	var low;
	var pos;

	rcvr = interpreterProxy.stackValue(2);
	aByteArray = interpreterProxy.stackBytes(1);
	speciesHash = interpreterProxy.stackIntegerValue(0);
	if (interpreterProxy.failed()) {
		return null;
	}
	byteArraySize = aByteArray.length;
	hash = speciesHash & 268435455;
	for (pos = 1; pos <= byteArraySize; pos++) {

		/* Begin hashMultiply */

		hash += aByteArray[pos - 1];
		low = hash & 16383;
		hash = ((9741 * low) + ((((9741 * (hash >>> 14)) + (101 * low)) & 16383) * 16384)) & 268435455;
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.popthenPush(3, hash);
	return null;
}


/*	translate the characters in the string by the given table, in place */

function primitiveTranslateStringWithTable() {
	var rcvr;
	var aString;
	var start;
	var stop;
	var table;
	var i;

	rcvr = interpreterProxy.stackValue(4);
	aString = interpreterProxy.stackBytes(3);
	start = interpreterProxy.stackIntegerValue(2);
	stop = interpreterProxy.stackIntegerValue(1);
	table = interpreterProxy.stackBytes(0);
	if (interpreterProxy.failed()) {
		return null;
	}
	for (i = start; i <= stop; i++) {
		aString[i - 1] = table[aString[i - 1]];
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(4);
}


/*	Note: This is coded so that is can be run from Squeak. */

function setInterpreter(anInterpreter) {
	var ok;

	interpreterProxy = anInterpreter;
	ok = interpreterProxy.majorVersion() == VM_PROXY_MAJOR;
	if (ok === false) {
		return false;
	}
	ok = interpreterProxy.minorVersion() >= VM_PROXY_MINOR;
	return ok;
}


Squeak.registerExternalModule("MiscPrimitivePlugin", {
	primitiveConvert8BitSigned: primitiveConvert8BitSigned,
	primitiveCompareString: primitiveCompareString,
	primitiveTranslateStringWithTable: primitiveTranslateStringWithTable,
	primitiveStringHash: primitiveStringHash,
	primitiveCompressToByteArray: primitiveCompressToByteArray,
	primitiveFindSubstring: primitiveFindSubstring,
	primitiveIndexOfAsciiInString: primitiveIndexOfAsciiInString,
	setInterpreter: setInterpreter,
	primitiveDecompressFromByteArray: primitiveDecompressFromByteArray,
	getModuleName: getModuleName,
	primitiveFindFirstInString: primitiveFindFirstInString,
});

}); // end of module
